file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\pixxiLCD-39P4CT.fnc

000001  000001  #platform "pixxiLCD-39P4CT"
000002  000001  #platform "pixxiLCD-39P4CT"
000003  000008  */
000004  000009      #constant pixxiLCD_39P4CT
000005  000009      #constant pixxiLCD_39P4CT
000006  000010        
000007  000011      #IFNOT EXISTS PIXXI44_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PIXXI44functions.fnc

000008  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000009  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PIXXI44_FUNCTIONS
000014  000004  #constant PIXXI44_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000019  #END
000019  000020        
000020  000021  #CONST
000021  000027  #END
000022  000028        
000023  000029        
000024  000030  #CONST
000025  000044  #END
000026  000045        
000027  000046        
000028  000047  #CONST
000029  000212  #END
000030  000213        
000031  000214        
000032  000215  // baud divisor rates for setbaud(n);
000033  000216  #CONST
000034  000238  #END
000035  000239        
000036  000240        
000037  000241        
000038  000242        
000039  000247  */
000040  000248        
000041  000249        
000042  000250  //==============================================//
000043  000251  // EVE bios functions                           //
000044  000252  //==============================================//
000045  000253                                                  //
000046  000254  func serin(), 1;                // read a byte from COM0
000047  000255  // Syntax: serin();
000048  000256  // Usage : char := serin();
000049  000257  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000258  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000259  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000260  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000261  //     : Returns: -1 if no character is available
000054  000262  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000263  //     : Returns: positive value 0 to 255 for a valid character received
000056  000264        
000057  000265  func putch("char"), 0;                // write single char to current output device
000058  000266  // Syntax: putch("char");
000059  000267  // Usage : putch("A");
000060  000268  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000269  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000270  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000271  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000272  //     : The arguments can be a variable, array element, expression or constant
000065  000273        
000066  000274  func serout("char"), 0;                // write a byte to COM0
000067  000275  // Syntax: serout1("char");
000068  000276  // Usage : serout1(ch);
000069  000277  // Notes : send character to COM1
000070  000278        
000071  000279  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000280  // Syntax: setbaud(baud_number);
000073  000281  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000282  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000283  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000284  //       : this is used as a table pointer to get the baud rate divisor
000077  000285  //       : value for one of the 20 selected baud rates, control is then
000078  000286  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000287  //       : The pre-defined constants equate to a value of 0-19.
000080  000288  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000289  //       : will occur.
000082  000290        
000083  000291  func to("device"), 1;                // output device redirection
000084  000292  // Syntax: to(outstream);
000085  000293  // Usage : to(APPEND); putstr("TWO ");
000086  000294  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000295  //     :
000088  000296  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000297  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000298  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000299  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000300  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000301  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000302  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000303  //     : sequential data to a media stream.
000096  000304  //     :
000097  000305  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000306  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000307  //     :                            appended to user memory if previous redirection was to an array.
000100  000308  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000309  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000310  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000311  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000312  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000313        
000106  000314        
000107  000315  func pause("milliseconds"), 0;            // blocking delay
000108  000316  // Syntax: pause(milliseconds);
000109  000317  // Usage : pause(1000);                //pause for 1 second
000110  000318  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000319        
000112  000320  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000321  // Syntax: putnum(format, value);
000114  000322  // Usage : var := putnum(HEX, val);
000115  000323  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000324  //     : Format: A constant that specifies the number format
000117  000325  //     : Value : The number to be printed
000118  000326  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000327  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000328  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000329  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000330  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000331  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000332  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000333  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000334  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000335  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000336  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000337  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000338  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000339  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000340  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000341  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000342  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000343  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000344  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000345  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000346  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000347  //     : | | | | V V V
000140  000348  //     : | | | | | | |
000141  000349  //     : | | | | | |
000142  000350  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000351  //     : | | | | digit count |
000144  000352  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000353  //     : | | | |
000146  000354  //     : | | | |
000147  000355  //     : | | | |
000148  000356  //     : | | | |
000149  000357  //     : | | | |
000150  000358  //     : | | | |______ 1 = leading zeros included
000151  000359  //     : | | | 0 = leading zeros suppressed
000152  000360  //     : | | |
000153  000361  //     : | | |
000154  000362  //     : | | |_______ 1 = leading zero blanking
000155  000363  //     : | |
000156  000364  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000365  //     : |
000158  000366  //     : |______ 1 = space before unsigned number
000159  000367        
000160  000368        
000161  000369  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000370        
000163  000371  func putstr("string"), 1;                       // print string to current output device
000164  000372  // Syntax: putstr(pointer);
000165  000373  // Usage : putstr("HELLO\n");
000166  000374  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000375  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000376  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000377  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000378  //       : using the to(...); function.
000171  000379  //       : A string constant is automatically terminated with a zero.
000172  000380  //       : A string in a data statement is not automatically terminated with a zero.
000173  000381  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000382  //       : element packs 1 or 2 characters.
000175  000383        
000176  000384        
000177  000385  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000386  // Syntax: strlen("varAddress);
000179  000387  // Usage : strlen("HELLO\n");
000180  000388  // Notes : gives the length of a string that is packed into regular var array
000181  000389  //       : Use str_Length(ptr)  for string pointer mode
000182  000390        
000183  000391        
000184  000392  //==============================================//
000185  000393  // Memory Access Function Prototypes            //
000186  000394  //==============================================//
000187  000395                                                  //
000188  000396  func peekW("address"), 1;                       // read a word from system memory
000189  000397  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000398  // refer to address map of internal variables   //
000191  000399  //==============================================//
000192  000400  // Math Functions                               //
000193  000401  //==============================================//
000194  000402                                                  //
000195  000403  func ABS("value"), 1;                           // return a positive number
000196  000404  // Syntax: ABS(value);
000197  000405  // Usage : var := ABS(arg);
000198  000406  // Notes : Returns the absolute value of an argument
000199  000407        
000200  000408  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000409  // Syntax: MIN(value1, value2);
000202  000410  // Usage : var := MIN(arg1, arg2);
000203  000411  // Notes : Returns the minimum of 2 arguments
000204  000412        
000205  000413  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000414  // Syntax: MAX(value1, value2);
000207  000415  // Usage : var := MAX(arg1, arg2);
000208  000416  // Notes : Returns the maximum of 2 arguments
000209  000417        
000210  000418  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000419  // Syntax: SWAP(&var1, &var2);
000212  000420  // Usage : SWAP(&var1, &var2);
000213  000421  // Notes : Swaps the contents of 2 variables or memory locations
000214  000422        
000215  000423  func SIN("angle"), 1;                           // return SIN of angle
000216  000424  // Syntax: SIN(angle);
000217  000425  // Usage : var := SIN(arg);
000218  000426  // Notes : Returns the sine in radians of an argument in degrees
000219  000427  //       : the returned value range is from 127 to -127. The real
000220  000428  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000429  //       : scaling must be done in user code.
000222  000430        
000223  000431  func COS("angle"), 1;                           // return COS of angle
000224  000432  // Syntax: COS(angle);
000225  000433  // Usage : var := COS(arg);
000226  000434  // Notes : Returns the cosine in radians of an argument in degrees
000227  000435  //       : the returned value range is from 127 to -127. The real
000228  000436  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000437  //       : scaling must be done in user code.
000230  000438        
000231  000439  func RAND(), 1;                                 // return a pseudo random number
000232  000440  // Syntax: RAND();
000233  000441  // Usage : var := RAND();
000234  000442  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000443  //       : The random number generator must first be seeded
000236  000444  //       : by using the SEED(number) function.
000237  000445        
000238  000446  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000447  // Syntax: SEED(number);
000240  000448  // Usage : SEED(arg);
000241  000449  // Notes : Seeds the random number generator.
000242  000450        
000243  000451  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000452  // Syntax: OVF();
000245  000453  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000454  //       : hiWord := OVF();
000247  000455  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000456        
000249  000457  func SQRT("number"), 1;                         // return square root of a number
000250  000458  // Syntax: SQRT(number);
000251  000459  // Usage : SQRT(arg);
000252  000460  // Notes : Returns the integer square root of a number.
000253  000461  //------------------------------------------------------------------//
000254  000462  //          Text Related Function Prototypes
000255  000463  //------------------------------------------------------------------//
000256  000464        
000257  000465  func txt_MoveCursor("line", "column"), 0;
000258  000466  // Syntax: txt_SetCursor(line, column);
000259  000467  // Usage : txt_SetCursor(arg1, arg2);
000260  000468  // Notes : Moves the text Cursor to a new screen position set by
000261  000469  //       : line,column parameters.
000262  000470        
000263  000471  func txt_Set("mode", "value"), 0;
000264  000472  // Syntax: txt_Set(mode, value);
000265  000473  // Usage : txt_Set(arg1, arg2);
000266  000474  // Returns : Original value before the change
000267  000475  // Notes : Sets various text related parameters used by other functions
000268  000476  //       : This allows the features to be set programatically with a
000269  000477  //       : single function call.It is strongly recommended to use the
000270  000478  //       : pre-defined constants rather than the mode numbers.
000271  000479  //       : NB:- Although it is often required to be able to set text
000272  000480  //       : functions with a single function call for graphics engine
000273  000481  //       : related functions, there is a complete set of single parameter
000274  000482  //       : shortcut functions that have exactly the same function as
000275  000483  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000484  //       :
000277  000485  //       : mode = TEXT_COLOUR (mode 0)
000278  000486  //       : txt_Set(TEXT_COLOUR, value);
000279  000487  //       : value = 0 to 0xFFFF, Black to White
000280  000488  //       : Sets the Text colour for the display
000281  000489  //       : Default = LIME.
000282  000490  //       :
000283  000491  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000492  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000493  //       : value = 0 to 0xFFFF, Black to White
000286  000494  //       : Sets the Text background colour for the display. Effective
000287  000495  //       : when text mode is Opaque.
000288  000496  //       : Default = BLACK.
000289  000497  //       :
000290  000498  //       : mode = FONT_ID (mode 2)
000291  000499  //       : txt_Set(FONT_ID, value);
000292  000500  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000501  //       : else this value is the name of a font included
000294  000502  //       : in a users program in a data statement.
000295  000503  //       : Default = FONT SIZE 3.
000296  000504  //       :
000297  000505  //       : mode = TEXT_WIDTH  (mode 3)
000298  000506  //       : txt_Set(TEXT_WIDTH, value);
000299  000507  //       : value = 1 to 16
000300  000508  //       : Sets the Text Width multiplier
000301  000509  //       : text will be printed magnified horizontally
000302  000510  //       : by this factor, Default = 1.
000303  000511  //       :
000304  000512  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000513  //       : txt_Set(TEXT_HEIGHT, value);
000306  000514  //       : value = 1 to 16
000307  000515  //       : Sets the Text Height multiplier
000308  000516  //       : text will be printed magnified vertically
000309  000517  //       : by this factor, Default = 1.
000310  000518  //       :
000311  000519  //       : mode = TEXT_XGAP  (mode 5)
000312  000520  //       : txt_Set(TEXT_XGAP, value);
000313  000521  //       : value = 1 to 32
000314  000522  //       : Sets the horizontal gap between characters
000315  000523  //       : The gap is in pixel units, Default = 0
000316  000524  //       :
000317  000525  //       : mode = TEXT_YGAP  (mode 6)
000318  000526  //       : txt_Set(TEXT_YGAP, value);
000319  000527  //       : value = 1 to 32
000320  000528  //       : Sets the vertical gap below characters
000321  000529  //       : The gap is in pixel units, Default = 0
000322  000530  //       :
000323  000531  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000532  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000533  //       : value = 0 to 255
000326  000534  //       : Sets the delay time (in ms) during character
000327  000535  //       : printing to give a 'teletype' like effect.
000328  000536  //       : Often used to attract attention to a string
000329  000537  //       : being printed which can often be missed if
000330  000538  //       : just suddenly appearing or changing.
000331  000539  //       : Default = 0 ms.
000332  000540  //       :
000333  000541  //       : mode = TEXT_OPACITY (mode 8)
000334  000542  //       : txt_Set(TEXT_OPACITY, value);
000335  000543  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000544  //       : value = OPAQUE (1) = Text Opaque
000337  000545  //       : Sets the Opacity/Transparency of the text
000338  000546  //       : Default = 0 or TRANSPARENT
000339  000547  //       :
000340  000548  //       : mode = TEXT_BOLD (mode 9)
000341  000549  //       : txt_Set(TEXT_BOLD, value);
000342  000550  //       : value = dont care
000343  000551  //       : Sets Bold Text mode for the next string or char
000344  000552  //       : The feature automatically resets after printing
000345  000553  //       : using putstr or print has completed
000346  000554  //       :
000347  000555  //       : mode = TEXT_ITALIC (mode 10)
000348  000556  //       : txt_Set(TEXT_ITALIC, value);
000349  000557  //       : value = dont care
000350  000558  //       : Sets Italic Text mode for the next string or char
000351  000559  //       : The feature automatically resets after printing
000352  000560  //       : using putstr or print has completed
000353  000561        
000354  000562  //       : mode = TEXT_INVERSE (mode 11)
000355  000563  //       : txt_Set(TEXT_INVERSE, value);
000356  000564  //       : value = dont care
000357  000565  //       : Sets Inverse Text mode for the next string or char
000358  000566  //       : The feature automatically resets after printing
000359  000567  //       : using putstr or print has completed
000360  000568  //       :
000361  000569  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000570  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000571  //       : value = dont care
000364  000572  //       : Sets Underlined Text mode for the next string or char
000365  000573  //       : The feature automatically resets after printing
000366  000574  //       : using putstr or print has completed
000367  000575  //       :
000368  000576  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000577  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000578  //       : value = bits are defined as:
000371  000579  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000580  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000581  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000582  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000583  //       : Allows a combination of text attributes to be defined together
000376  000584  //       : by 'or'ing the bits together.
000377  000585  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000586  //       : The feature automatically resets after printing
000379  000587  //       : using putstr or print has completed.
000380  000588  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000589  //       :
000382  000590  //       : mode = TEXT_WRAP (mode 14)
000383  000591  //       : txt_Set(TEXT_WRAP , value);
000384  000592  //       : Sets the position where text wrap will occur
000385  000593  //       : The feature automatically resets when screen
000386  000594  //       : mode is changed. If the value is set to 0,
000387  000595  //       : text wrap is turned off.
000388  000596  //       : of the current screen. Default value is 0
000389  000597  // Notes : The value is in pixel units.
000390  000598  //       :
000391  000599        
000392  000600  //       : txt_Set mode 15 reserved for future use
000393  000601  //       :
000394  000602        
000395  000603        
000396  000604        
000397  000605  //=====================================================//
000398  000606  // Single parameter short-cuts                         //
000399  000607  // for the txt_Set functions                           //
000400  000608  // These functions return the existing value before    //
000401  000609  // the change is made.                                 //
000402  000610  //=====================================================//
000403  000611  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000612  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000613  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000614  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000615  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000616  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000617  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000618  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000619  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000620  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000621  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000622  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000623  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000624  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000625  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000626  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000627        
000420  000628        
000421  000629  //------------------------------------------------------------------//
000422  000630  //                 Hardware Function Prototypes
000423  000631  //------------------------------------------------------------------//
000424  000632        
000425  000633  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000426  000634  // Syntax: pin_Set(mode, pin);
000427  000635  // Usage : pin_Set(arg1, arg2);
000428  000636  // Notes : Sets the appropriate pins to Inputs or Outputs
000429  000637  //       : returns true if the pin number is legal (usually ignored)
000430  000638  //       :
000431  000639  //       : "mode" is either INPUT or OUTPUT
000432  000640  //       :
000433  000641  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000434  000642  //       : of your PiXXi-44 processor.
000435  000643        
000436  000644  func pin_HI("pin"), 1;                    // set pin to logic '1'
000437  000645  // Syntax: pin_HI(pin);
000438  000646  // Usage : pin_HI(arg);
000439  000647  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000440  000648  //       : pin that was previously selected as an Output.
000441  000649  //       : returns true if the pin number is legal (usually ignored)
000442  000650  //       :
000443  000651  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000444  000652  //       : of your PiXXi-44 processor.
000445  000653        
000446  000654  func pin_LO("pin"), 1;                    // set pin to logic '0'
000447  000655  // Syntax: pin_LO(pin);
000448  000656  // Usage : pin_LO(arg);
000449  000657  // Notes : Outputs a logic "Low" (0V) on the appropriate
000450  000658  //       : pin that was previously selected as an Output.
000451  000659  //       : returns true if the pin number is legal (usually ignored)
000452  000660  //       :
000453  000661  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000454  000662  //       : of your PiXXi-44 processor.
000455  000663        
000456  000664  func pin_Read("pin"), 1;                // read pin, logic or analogue
000457  000665  // Syntax	: pin_Read(pin);
000458  000666  // Usage	: arg1 := pin_Read(arg2);
000459  000667  // Notes	: Reads the logic state of the appropriate
000460  000668  // 	: pin that was previously selected as an Input.
000461  000669  // 	:
000462  000670  // 	: "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000463  000671  // 	: of your PiXXi-44 processor.
000464  000672  // 	: Returns 0 or 1 for a digital input
000465  000673  // 	: Returns 0..4095 for an analogue input
000466  000674        
000467  000675  //------------------------------------------------------------------//
000468  000676  //                 P1 module BUS I/O control
000469  000677  //------------------------------------------------------------------//
000470  000678        
000471  000679  func bus_In(), 1;
000472  000680  // Syntax: bus_In();
000473  000681  // Usage : arg1 := bus_In();
000474  000682  // Notes : Read the 7bit wide bus into the lower 7 bits of arg1.
000475  000683  //       : The upper 9 bits of arg1 are set to 0.
000476  000684  //       : Only available in Mode 2 (4-Wire SPI)
000477  000685  //       : 
000478  000686  //       : BUS_0 is IO12_PIN
000479  000687  //       : BUS_1 is IO13_PIN
000480  000688  //       : BUS_2 is IO14_PIN
000481  000689  //       : BUS_3 is IO15_PIN
000482  000690  //       : BUS_4 is IO16_PIN
000483  000691  //       : BUS_5 is IO17_PIN
000484  000692  //       : BUS_6 is IO18_PIN
000485  000693  //       : BUS_7 is N/A
000486  000694        
000487  000695  func bus_Out("var"), 0;
000488  000696  // Syntax: bus_Out(var);
000489  000697  // Usage : bus_Out(arg1);
000490  000698  // Notes : The lower 7 bits of arg1 are placed on the 7bit wide bus.
000491  000699  //       : The upper 9 bits of arg1 are ignored.
000492  000700  //       : NB:- any BUS pins that are set to inputs are not affected.
000493  000701  //       : Only available in Mode 2 (4-Wire SPI)
000494  000702  //       :
000495  000703  //       : BUS_0 is pin 27 of J1
000496  000704  //       : BUS_1 is pin 25 of J1
000497  000705  //       : BUS_2 is pin 23 of J1
000498  000706  //       : BUS_3 is pin 21 of J1
000499  000707  //       : BUS_4 is pin 19 of J1
000500  000708  //       : BUS_5 is pin 17 of J1
000501  000709  //       : BUS_6 is pin 13 of J2
000502  000710  //       : BUS_7 is pin 11 of J2
000503  000711        
000504  000712  func bus_Set("var"), 0;
000505  000713  // Syntax: bus_Set(var);
000506  000714  // Usage : bus_Set(arg1);
000507  000715  // Notes : Not available on the Pixxi Chips
000508  000716        
000509  000717  func bus_Write("var"), 0;
000510  000718  // Syntax: bus_Write(var);
000511  000719  // Usage : bus_Write(arg1);
000512  000720  // Notes : Not available on the Pixxi Chips
000513  000721        
000514  000722  func bus_Read(), 1;
000515  000723  // Syntax: bus_Read();
000516  000724  // Usage : arg1 := bus_Read();
000517  000725  // Notes : Not available on the Pixxi Chips
000518  000726        
000519  000727        
000520  000728  //------------------------------------------------------------------//
000521  000729  //   Graphics Functions
000522  000730  //------------------------------------------------------------------//
000523  000731  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000524  000732  // Syntax: gfx_Set(mode, value);
000525  000733  // Usage : gfx_Set(arg1, arg2);
000526  000734  // Notes : Sets various graphics parameters used by other functions
000527  000735  //       : This allows the features to be set programatically with a
000528  000736  //       : single function call.It is strongly recommended to use the
000529  000737  //       : pre-defined constants rather than the mode numbers.
000530  000738  //       : NB:- Although it is often required to be able to set graphics
000531  000739  //       : functions with a single function call for graphics engine
000532  000740  //       : related functions, there is a complete set of single parameter
000533  000741  //       : shortcut functions that have exactly the same function as
000534  000742  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000535  000743  //       :
000536  000744  //       : mode = PEN_SIZE (mode 16)
000537  000745  //       : gfx_Set(PEN_SIZE, value);
000538  000746  //       : value = SOLID (value 0) rectangle and circle objects are solid
000539  000747  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000540  000748  //       : Sets the mode of the Pen used by most graphics objects
000541  000749  //       :
000542  000750  //       : mode = BACKGROUND_COLOUR (mode 17)
000543  000751  //       : gfx_Set(BACKGROUND_COLOUR, value);
000544  000752  //       : value = 0 to 0xFFFF, Black to White
000545  000753  //       : Sets the Background colour of the screen
000546  000754  //       :
000547  000755  //       : mode = OBJECT_COLOUR (mode 18)
000548  000756  //       : gfx_Set(OBJECT_COLOUR, value);
000549  000757  //       : value = 0 to 0xFFFF, Black to White
000550  000758  //       : Sets the Object colour used in various functions
000551  000759  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000552  000760  //       :
000553  000761  //       : mode = CLIPPING (mode 19)
000554  000762  //       : gfx_Set(CLIPPING, value);
000555  000763  //       : value = OFF (value 0) Clipping disabled
000556  000764  //       : value = ON (value 1) Clipping enabled
000557  000765  //       : Enables/Disables the Clipping feature
000558  000766  //       :
000559  000767  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000560  000768  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000561  000769  //       : value = 0 to 0xFFFF Black to White
000562  000770  //       : Sets Bitmap, Image or Animation Transparency Colour.
000563  000771  //       : NB not implemented
000564  000772  //       :
000565  000773  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000566  000774  //       : gfx_Set(5, value);
000567  000775  //       : value = OFF (value 0) Transparency disabled
000568  000776  //       : value = ON (value 1) Transparency enabled
000569  000777  //       : Enables/Disables the Transparency feature
000570  000778  //       : NB not implemented
000571  000779  //       :
000572  000780  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000573  000781  //       : gfx_Set(FRAME_DELAY, value);
000574  000782  //       : value = 0 to 65535 ms
000575  000783  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000576  000784  //       : over-ride the embedded frame delay of the clip. After the event,
000577  000785  //       : the setting will auto disable and if further inter-frame delays need
000578  000786  //       : overriding the setting must be re-issued.
000579  000787  //       :
000580  000788  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000581  000789  //       : gfx_Set(SCREEN_MODE, value);
000582  000790  //       : value = LANDSCAPE   (value 0)
000583  000791  //       : value = LANDSCAPE_R (value 1)
000584  000792  //       : value = PORTRAIT    (value 2)
000585  000793  //       : value = PORTRAIT_R  (value 3)
000586  000794  //       :
000587  000795  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000588  000796  //       : gfx_Set(OUTLINE_COLOUR, value);
000589  000797  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000590  000798  //       : Sets the filled Rectangle or Circle objects outline colour
000591  000799  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000592  000800  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000593  000801  //       :
000594  000802  //       : Only supports variable contrast for uOLED Modules
000595  000803  //       : mode = CONTRAST (mode 25) : Contrast
000596  000804  //       : gfx_Set(CONTRAST, value);
000597  000805  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000598  000806  //       : when contrast=0, display is placed in low power mode.
000599  000807  //       : This function should be called with contrast=0 when
000600  000808  //       : powering down the module.
000601  000809  //       :
000602  000810  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000603  000811  //       : gfx_Set(LINE_PATTERN, value);
000604  000812  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000605  000813  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000606  000814  //       : a value of 0 turns the feature off
000607  000815  //       :
000608  000816  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000609  000817  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000610  000818  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000611  000819  //       : NB not implemented, default is COLOUR16
000612  000820  //       :
000613  000821  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000614  000822  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000615  000823  //       : sets the button and slider objects bevel width
000616  000824  //       :
000617  000825  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000618  000826  //       : gfx_Set(BEVEL_SHADOW , 5);
000619  000827  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000620  000828  //       :
000621  000829  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000622  000830  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000623  000831  //       : sets the origin of drawn objects to a position other than 0,0
000624  000832  //       :
000625  000833  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000626  000834  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000627  000835  //       : sets the origin of drawn objects to a position other than 0,0
000628  000836        
000629  000837        
000630  000838  func gfx_Cls(), 0;                    // clear the screen
000631  000839  // Syntax: gfx_Cls();
000632  000840  // Usage : gfx_Cls();
000633  000841  // Notes : Clears the screen with current background colour
000634  000842        
000635  000843  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000636  000844  // Syntax: gfx_MoveTo(x, y);
000637  000845  // Usage : gfx_MoveTo(arg1, arg2);
000638  000846  // Notes : Moves the origin to a new x,y position
000639  000847        
000640  000848  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000641  000849  // Syntax: gfx_MoveRel(x, y);
000642  000850  // Usage : gfx_MoveRel(arg1, arg2);
000643  000851  // Notes : Moves the origin to a new x,y position
000644  000852  //       : relative to the current origing
000645  000853        
000646  000854  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000647  000855  // Syntax: gfx_LineTo(x1, y1);
000648  000856  // Usage : gfx_LineTo(arg1, arg2);
000649  000857  // Notes : Draws a Line from the origin x,y to x1,y1.
000650  000858  //       : The new origin is then set to x1, y1. Line colour needs
000651  000859  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000652  000860        
000653  000861  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000654  000862  // Syntax: gfx_LineRel(x1, y1);
000655  000863  // Usage : gfx_LineRel(arg1, arg2);
000656  000864  // Notes : Draws a Line from the origin x,y to x1,y1.
000657  000865  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000658  000866  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000659  000867        
000660  000868  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000661  000869  // Syntax: gfx_Line(x1, x2, y2, colr);
000662  000870  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000663  000871  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000664  000872        
000665  000873  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000666  000874  // Syntax: gfx_Line(x1, x2, y, colr);
000667  000875  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000668  000876  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000669  000877        
000670  000878  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000671  000879  // Syntax: gfx_Line(y1, y2, x, colr);
000672  000880  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000673  000881  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000674  000882        
000675  000883  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000676  000884  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000677  000885  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000678  000886  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000679  000887  //       : bottom corner (x2,y2) on the screen.
000680  000888        
000681  000889  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000682  000890  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000683  000891  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000684  000892  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000685  000893  //       : bottom corner (x2,y2) on the screen.
000686  000894        
000687  000895  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000688  000896  // Syntax: gfx_Circle(x, y, rad, colr);
000689  000897  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000690  000898  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000691  000899        
000692  000900  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000693  000901  // Syntax: gfx_Circle(x, y, rad, colr);
000694  000902  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000695  000903  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000696  000904        
000697  000905  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000698  000906  // Syntax: gfx_PutPixel(x, y, colr);
000699  000907  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000700  000908  // Notes : Plots a coloured pixel on the screen at x,y location
000701  000909        
000702  000910  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000703  000911  // Syntax: gfx_GetPixel(x, y);
000704  000912  // Usage : var := gfx_GetPixel(arg1, arg2);
000705  000913  // Notes : Reads and returns the colour value of a pixel at location x,y
000706  000914        
000707  000915  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000708  000916  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000709  000917  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000710  000918  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000711  000919  //       : Vertices must be specified in an anti-clockwise fashion
000712  000920        
000713  000921  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000714  000922  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000715  000923  // Usage : gfx_OrbitInit(&arg1, &arg2);
000716  000924  // Notes : Sets up the Orbit function parameters.
000717  000925  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000718  000926  //       : variables that get updated after calling gfx_Orbit(,,) function.
000719  000927  //       : The coordiantaes are calculated relative to the origin
000720  000928  //       : obtained by using the gfx_MoveTo(x, y) function.
000721  000929        
000722  000930  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000723  000931  // Syntax: gfx_Orbit(angle, distance);
000724  000932  // Usage : gfx_Orbit(arg1, arg2);
000725  000933  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000726  000934  //       : only known parameters are the angle and the distance from the current origin.
000727  000935        
000728  000936  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000729  000937  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000730  000938  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000731  000939  // Notes : This function is very similar to the Ploygon function
000732  000940  //       : with the exception of the 1st and the last vertices not joined.
000733  000941        
000734  000942  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000735  000943  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000736  000944  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000737  000945  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000738  000946  //       : Vertices must be minimum of 3 and can be specified in any fashion
000739  000947        
000740  000948  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000741  000949  // Syntax: gfx_Dot();
000742  000950  // Usage : gfx_Dot();
000743  000951  // Notes : Places a coloured dot at the origin
000744  000952        
000745  000953        
000746  000954  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000747  000955  // Syntax: gfx_Bullet();
000748  000956  // Usage : gfx_Bullet();
000749  000957  // Notes : Places a coloured circle at the origin
000750  000958  //       : filled or unfilled state is controlled by PenSize
000751  000959        
000752  000960  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000753  000961  // Syntax: gfx_IncX();
000754  000962  // Usage : var := gfx_IncX();
000755  000963  // Notes : Increments the x coordinate of the origin
000756  000964        
000757  000965  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000758  000966  // Syntax: gfx_IncY();
000759  000967  // Usage : var := gfx_IncY();
000760  000968  // Notes : Increments the y coordinate of the origin
000761  000969        
000762  000970  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000763  000971  // Syntax: gfx_BoxTo(x1, y1);
000764  000972  // Usage : gfx_BoxTo(arg1, arg2);
000765  000973  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000766  000974  //       : The new origin is then set to x1,y1. Rectangle colour needs
000767  000975  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000768  000976  //       : and the PenSize setting determines if Box is solid or outline.
000769  000977        
000770  000978  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000771  000979  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000772  000980  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000773  000981  // Notes : Specifies a clipping window region on the screen such that any objects
000774  000982  //       : and text placed onto the screen will be clipped and displayed only
000775  000983  //       : within that region. For the clipping window to take effect, "Clipping"
000776  000984  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000777  000985        
000778  000986        
000779  000987  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000780  000988  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000781  000989  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000782  000990  // *Notes:
000783  000991        
000784  000992  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000785  000993  // Syntax: gfx_SetClipRegion();
000786  000994  // Usage : var := gfx_SetClipRegion();
000787  000995  // *Notes:
000788  000996        
000789  000997  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000790  000998  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000791  000999  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000792  001000  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000793  001001  //       : with xradius = xrad and yradius = yrad.
000794  001002  //       : if PenSize = 0 Ellipse is Solid
000795  001003  //       : if PenSize = 1 Ellipse is Outline
000796  001004        
000797  001005        
000798  001006  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000799  001007  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000800  001008  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000801  001009  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000802  001010  //       : with xradius = xrad and yradius = yrad.
000803  001011        
000804  001012  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000805  001013  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000806  001014  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000807  001015  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000808  001016  //       : x,y arguments (top left corner). The size of the button depends on
000809  001017  //       : the font, width, height and length of the text.
000810  001018  //       : The button appearance will depend on the state parameter setting:
000811  001019  //       :         state = 0 : Button Pressed
000812  001020  //       :         state = 1 : Button Raised
000813  001021        
000814  001022  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000815  001023  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000816  001024  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000817  001025  // Notes : Draws a panel (groupbox) at screen location defined by
000818  001026  //       : x, y, width and height with colour "colour".
000819  001027  //       :         state = 0 : recessed
000820  001028  //       :         state = 1 : raised
000821  001029        
000822  001030  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000823  001031  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000824  001032  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000825  001033  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000826  001034  //       : Slider parameters are as follows:
000827  001035  //       :         mode = 0 : Slider recessed
000828  001036  //       :         mode = 1 : Slider raised
000829  001037  //       :         x1, y1 = top left corner
000830  001038  //       :         x2, y2 = bottom right corner
000831  001039  //       :         scale = n : sets the full scale range from 0 to n
000832  001040  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000833  001041  //       : returns:-
000834  001042        
000835  001043        
000836  001044  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000837  001045  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000838  001046  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000839  001047  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000840  001048  //       : and pastes it to another location determined by xd, yd.
000841  001049        
000842  001050  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000843  001051  // Syntax: gfx_RGBto565(red, green, blue);
000844  001052  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000845  001053  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000846  001054        
000847  001055  func gfx_332to565("COLOUR8BIT"), 1;
000848  001056  // Syntax: gfx_332to565(colour);
000849  001057  // Usage : gfx_332to565(arg);
000850  001058  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000851  001059        
000852  001060  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000853  001061  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000854  001062  // Usage : gfx_Selection(1, RED, YELLOW);
000855  001063  // Notes : Called prior to drawing a button, this function
000856  001064  //       : hilites the required text line on a multiline button.
000857  001065        
000858  001066  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000859  001067  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000860  001068  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000861  001069  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000862  001070  //       : Vertices must be specified in an anti-clockwise fashion
000863  001071        
000864  001072        
000865  001073  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000866  001074  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000867  001075  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
000868  001076  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000869  001077  //       : Vertices must be minimum of 3 and can be specified in any fashion
000870  001078        
000871  001079        
000872  001080  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
000873  001081  // Syntax: gfx_Offset(x, y);
000874  001082  // Usage : gfx_Offset(arg1, arg2);
000875  001083  // Notes : Set the screen offset
000876  001084        
000877  001085        
000878  001086        
000879  001087  func gfx_Get("mode"), 1;
000880  001088  // Syntax: gfx_Get(mode);
000881  001089  // Usage : arg1 := gfx_Get(arg);
000882  001090  // Notes : Returns various parameters to caller
000883  001091  //       :
000884  001092  //       : mode = X_MAX (mode 0) : current orientations maximum X value
000885  001093  //       : var := gfx_Get(X_MAX);
000886  001094  //       : Returns the maximum horizontal value of the display
000887  001095  //       :
000888  001096  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
000889  001097  //       : var := gfx_Get(Y_MAX);
000890  001098  //       : Returns the maximum vertical value of the display
000891  001099  //       :
000892  001100  //       : mode = LEFT_POS (mode 2) : Left location of last Object
000893  001101  //       : var := gfx_Get(LEFT_POS);
000894  001102  //       : Returns the left location of the last drawn object
000895  001103  //       : such as a slider or button or an image/video
000896  001104  //       :
000897  001105  //       : mode = TOP_POS (mode 3) : Top location of Object
000898  001106  //       : var := gfx_Get(TOP_POS);
000899  001107  //       : Returns the top location of the last drawn object
000900  001108  //       : such as a slider or button or an image/video
000901  001109  //       :
000902  001110  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
000903  001111  //       : var := gfx_Get(RIGHT_POS);
000904  001112  //       : Returns the right location of the last drawn object
000905  001113  //       : such as a slider or button or an image/video
000906  001114  //       :
000907  001115  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
000908  001116  //       : var := gfx_Get(BOTTOM_POS );
000909  001117  //       : Returns the bottom location of the last drawn object
000910  001118  //       : such as a slider or button or an image/video
000911  001119  //       :
000912  001120        
000913  001121        
000914  001122  //==================================================//
000915  001123  // Single parameter short-cuts                      //
000916  001124  // for the gfx_Set functions                        //
000917  001125  // These functions return the existing value before //
000918  001126  // the change is made.                              //
000919  001127  //==================================================//
000920  001128  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
000921  001129  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
000922  001130  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
000923  001131  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
000924  001132  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
000925  001133  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
000926  001134  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
000927  001135  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
000928  001136  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
000929  001137  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
000930  001138  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
000931  001139  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
000932  001140  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
000933  001141  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
000934  001142  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
000935  001143  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
000936  001144        
000937  001145        
000938  001146  //==================================================//
000939  001147  // uSD/FLASH Function Prototypes                    //
000940  001148  //==================================================//
000941  001149  func media_Video("x", "y"), 0;                      // display movie at position x y
000942  001150  // Syntax: media_Video(x, y);
000943  001151  // Usage : media_Video(arg1, arg2);
000944  001152  // Notes : Play a Video/Animation clip from the uSD card at screen location
000945  001153  //       : specified by x,y (top left corner). The location of the clip in the
000946  001154  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
000947  001155        
000948  001156  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
000949  001157  // Syntax: media_VideoFrame(Frame_number);
000950  001158  // Usage : arg1 := media_VideoFrame();
000951  001159  // Notes : After a pointer to a valid video has been set with media_SetSector,
000952  001160  //       : calling this function shows each fram sequentially, returning
000953  001161  //       : the number of frames remaining. The position of the image is
000954  001162  //     : at the current origin as set with gfx_MoveTo(...);
000955  001163        
000956  001164  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
000957  001165  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
000958  001166  // Usage : media_SetAdd(arg1, arg2);
000959  001167  // Notes : Set uSD internal Address pointer for bytewise access
000960  001168        
000961  001169  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
000962  001170  // Syntax: media_SetSector(SectHiWord, SectLoWord);
000963  001171  // Usage : media_SetSector(arg1, arg2);
000964  001172  // Notes : Set uSD internal Sector pointer for sector block access
000965  001173        
000966  001174  func media_RdSector("*destination"), 1;
000967  001175  // Syntax: media_RdSector(*destination);
000968  001176  // Usage : media_RdSector(rdblock);
000969  001177  // Notes : Reads and Returns 512 bytes (256 words) into a destination
000970  001178  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
000971  001179  //       : After the read the Sector pointer is automatically incremented by 1.
000972  001180  //       : Returns TRUE if uSD response was TRUE
000973  001181        
000974  001182  func media_WrSector("*source"), 1;
000975  001183  // Syntax: media_WrSector(*source);
000976  001184  // Usage : media_WrSector(wrblock);
000977  001185  // Notes : Writes 512 bytes (256 words) from a source memory block
000978  001186  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
000979  001187  //       : pointer is automatically incremented by 1.
000980  001188  //       : Returns TRUE if uSD response was TRUE
000981  001189        
000982  001190  func media_ReadByte(), 1;                // read a byte at the current stream position
000983  001191  // Syntax: media_RdByte();
000984  001192  // Usage : var := media_RdByte();
000985  001193  // Notes : Reads and Returns a single byte of data from the
000986  001194  //       : uSD card pointed to by the internal Address pointer.
000987  001195  //       : After the read the Address pointer is automatically
000988  001196  //       : incremented by 1.
000989  001197        
000990  001198  func media_ReadWord(), 1;                // read a word at the current stream position
000991  001199  // Syntax: media_ReadWord();
000992  001200  // Usage : var := media_ReadWord();
000993  001201  // *Notes : Reads and Returns a single word of data from the
000994  001202  //       : uSD card pointed to by the internal Address pointer.
000995  001203  //       : After the read the Address pointer is automatically
000996  001204  //       : incremented by 2.
000997  001205        
000998  001206  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
000999  001207  // Syntax: media_WriteByte(arg1);
001000  001208  // Usage : var := media_WriteByte(arg1);
001001  001209  // *Notes : Writes and Returns xxxxx
001002  001210  //       : After the write the Address pointer is automatically
001003  001211  //       : incremented by 1.
001004  001212        
001005  001213  func media_WriteWord("word"), 1;            // write a word to the current stream position
001006  001214  // Syntax: media_WriteWord(arg1);
001007  001215  // Usage : var := media_WriteWord(arg1);
001008  001216  // *Notes : Writes and Returns xxxxx
001009  001217  //       : After the write the Address pointer is automatically
001010  001218  //       : incremented by 2.
001011  001219        
001012  001220  func media_Image("x", "y"), 0;            // display image at position x y
001013  001221  // Syntax: media_Image(x, y);
001014  001222  // Usage : media_Image(arg1, arg2);
001015  001223  // Notes : Display an image from the uSD card at screen location
001016  001224  //       : specified by x,y (top left corner). The location of the
001017  001225  //       : Image in the uSD card must be specified by
001018  001226  //       : media_setSector(Image_Sector_Add) function.
001019  001227        
001020  001228  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001021  001229  // Syntax: media_Flush();
001022  001230  // Usage : var := media_Flush();
001023  001231  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001024  001232  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001025  001233        
001026  001234  func media_Init(), 1;                    // initialize uSD card
001027  001235  // Usage	: media_Init();
001028  001236  // Notes	: Initialise uSD CARD
001029  001237  // 	: Response: 0 = No Card
001030  001238  // 	:           1 = Card Initialised
001031  001239  // 	: Do not use this for systems with SPI Flash, use media_InitFlash() instead
001032  001240  // 	: init the Media.
001033  001241        
001034  001242        
001035  001243  //==============================================//
001036  001244  // Communications Function Prototypes           //
001037  001245  //==============================================//
001038  001246  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001039  001247  // Syntax: com_Init(buffer, bufsize, qualifier);
001040  001248  // Usage1: com_Init(mybuf, 20, 0);
001041  001249  // Usage2: com_Init(mybuf, 20, ':');
001042  001250  // Notes : initialize a serial capture buffer for the comms input
001043  001251  //       : The program must declare a var array as a circular buffer.
001044  001252  //       : Usage1 declares a circular buffer which will continually
001045  001253  //       : buffer characters.
001046  001254  //       : Usage2 must receive ':' before any characters will
001047  001255  //       : accumulate in the buffer.
001048  001256        
001049  001257  func com_Reset(), 0;                 // reset the comms receiver
001050  001258  // Syntax: com_Reset();
001051  001259  // Usage : com_Reset();
001052  001260  // Notes : reset comms to default polled mode
001053  001261        
001054  001262  func com_Count(), 1;                // return count of characters in receive buffer
001055  001263  // Syntax: com_Count();
001056  001264  // Usage : arg := com_Count();
001057  001265  // Notes : return count of buffered characters in buffer attachment
001058  001266        
001059  001267  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001060  001268  // Syntax: com_Full();
001061  001269  // Usage : if (com_Full() ,,,, go read buffer;
001062  001270  // Notes : return true if buffer full (not necessarily an error if
001063  001271  //       : buffer is sized to a packet size)
001064  001272        
001065  001273  func com_Error(), 1;                // return comms errors comms error occurred
001066  001274  // Syntax: com_Error();
001067  001275  // Usage : if (com_Error() ) ...... take recovery action;
001068  001276  // Notes : return non zero if any errors low level comms errors occured
001069  001277  // returns :
001070  001278  // bit0 = Receiver Overflow Error
001071  001279  // bit1 = Receiver Framing Error
001072  001280  // bit2 = Transmit Buffer Overflow
001073  001281        
001074  001282  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001075  001283  // Syntax: com_Sync();
001076  001284  // Usage : com_Sync();
001077  001285  // return true if sync character has been received in com_Init("...") mode
001078  001286        
001079  001287        
001080  001288  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001081  001289  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001082  001290  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001083  001291  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001084  001292  // Notes : initialize a serial buffer for the COM0 output.
001085  001293  //       : The program must declare a var array as a circular buffer.
001086  001294  //       : When a TX buffer is declared for comms, the transmission
001087  001295  //       : of characters becomes non blocking. The only time
001088  001296  //       : blocking will occur is if the buffer has insufficient space
001089  001297  //       : to accept the next character, in which case the function
001090  001298  //       : will wait for buffer space to become available. If the
001091  001299  //       : TX buffer is no longer required, just set the buffer pointer
001092  001300  //       : to zero, the size in this case doesnt matter and is ignored.
001093  001301  //       : The function can resize or reallocated to another buffer at
001094  001302  //       : any time. The buffer is flushed before any changes are made.
001095  001303  //       : "pin" designates an IO pin to control a bi-directional 
001096  001304  //       : control device for half duplex mode. "pin" will go HI at the
001097  001305  //       : start of a transmission, and will return low after the final
001098  001306  //       : byte is transmitted. If not required, just set "pin" to zero.
001099  001307        
001100  001308        
001101  001309  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001102  001310  // Syntax: com_TXcount();
001103  001311  // Usage : arg := com_Count();
001104  001312  // Notes : return count of characters remaining in COM0 transmit buffer
001105  001313  //       : that was previously allocated with com_TXbuffer(...);
001106  001314        
001107  001315        
001108  001316  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001109  001317  // Syntax: com_TXemptyEvent(function);
001110  001318  // Usage : arg := com_TXemptyEvent();
001111  001319  // Notes : If a comms TX buffer that was previously allocated with
001112  001320  //       : com_TXbuffer(...);, this function can be used to set up
001113  001321  //       : a function to be called when the COM0 TX buffer is empty.
001114  001322  //       : This is useful for either reloading the TX buffer, setting
001115  001323  //       : or clearing a pin to change the direction of eg a RS485
001116  001324  //       : line driver, or any other form of traffic control.
001117  001325  //       : The event function must not have any parameters.
001118  001326  //       : To disable the event, simply call com_TXemptyEvent(0).
001119  001327  //       : com_TXbuffer(...); also resets any active event.
001120  001328  //       : com_TXemptyEvent returns any previous event function
001121  001329  //       : address, or zero if there was no previous function.
001122  001330        
001123  001331        
001124  001332  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001125  001333  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001126  001334  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001127  001335  // Notes : Expecting that a comms TX buffer that was previously allocated with
001128  001336  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001129  001337  //       : the buffer being sent wile it is being loaded. Mormally, when
001130  001338  //       : using buffered comms, the transmit process will begin
001131  001339  //       : immediately. This is often undesirable for 2 reasons,
001132  001340  //       : 1] you may wish to build a packet then send it later
001133  001341  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001134  001342  //       : as the FIFO buffer is constantly trying to empty while
001135  001343  //       : you are busy tring to fill it.
001136  001344  // return -1 if function is called illegally when TX comms is not buffered.
001137  001345  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001138  001346  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001139  001347        
001140  001348        
001141  001349  //=============================================================//
001142  001350  // Auxilliary Communications Function Prototypes
001143  001351  //=============================================================//
001144  001352  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001145  001353  // Syntax: com_Init(buffer, bufsize, qualifier);
001146  001354  // Usage1: com_Init(mybuf, 20, 0);
001147  001355  // Usage2: com_Init(mybuf, 20, ':');
001148  001356  // Notes : initialize a serial capture buffer for the comms input
001149  001357  //       : The program must declare a var array as a circular buffer.
001150  001358  //       : Usage1 declares a circular buffer which will continually
001151  001359  //       : buffer characters.
001152  001360  //       : Usage2 must receive ':' before any characters will
001153  001361  //       : accumulate in the buffer.
001154  001362        
001155  001363  func com1_Reset(), 0;
001156  001364  // Syntax: com_Reset();
001157  001365  // Usage : com_Reset();
001158  001366  // Notes : reset comms receiver to default polled mode
001159  001367        
001160  001368  func com1_Count(), 1;
001161  001369  // Syntax: com_Count();
001162  001370  // Usage : arg := com_Count();
001163  001371  // Notes : return count of characters in receive buffer
001164  001372        
001165  001373  func com1_Full(), 1;
001166  001374  // Syntax: com_Full();
001167  001375  // Usage : if (com_Full() ,,,, go read buffer;
001168  001376  // Notes : return true if receive buffer full
001169  001377        
001170  001378  func com1_Error(), 1;
001171  001379  // Syntax: com_Error();
001172  001380  // Usage : if (com_Error() ) ...... take recovery action;
001173  001381  // Notes : return non zero if any level comms errors occured
001174  001382  // returns :
001175  001383  // bit0 = Receiver Overflow Error
001176  001384  // bit1 = Receiver Framing Error
001177  001385  // bit2 = Transmit Buffer Overflow
001178  001386        
001179  001387  func com1_Sync(), 1;
001180  001388  // Syntax: com_Sync();
001181  001389  // Usage : com_Sync();
001182  001390  // Notes : return true if sync character has been received in com_Init("...") mode
001183  001391        
001184  001392        
001185  001393  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001186  001394  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001187  001395  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001188  001396  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001189  001397  // Notes : initialize a serial buffer for the COM1 output.
001190  001398  //       : The program must declare a var array as a circular buffer.
001191  001399  //       : When a TX buffer is declared for comms, the transmission
001192  001400  //       : of characters becomes non blocking. The only time
001193  001401  //       : blocking will occur is if the buffer has insufficient space
001194  001402  //       : to accept the next character, in which case the function
001195  001403  //       : will wait for buffer space to become available. If the
001196  001404  //       : TX buffer is no longer required, just set the buffer pointer
001197  001405  //       : to zero, the size in this case doesnt matter and is ignored.
001198  001406  //       : The function can resize or reallocated to another buffer at
001199  001407  //       : any time. The buffer is flushed before any changes are made.
001200  001408  //       : "pin" designates an IO pin to control a bi-directional 
001201  001409  //       : control device for half duplex mode. "pin" will go HI at the
001202  001410  //       : start of a transmission, and will return low after the final
001203  001411  //       : byte is transmitted. If not required, just set "pin" to zero.
001204  001412        
001205  001413        
001206  001414  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001207  001415  // Syntax: com1_TXcount();
001208  001416  // Usage : arg := com1_Count();
001209  001417  // Notes : return count of characters remaining in COM1 transmit buffer
001210  001418  //       : that was previously allocated with com1_TXbuffer(...);
001211  001419        
001212  001420        
001213  001421  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001214  001422  // Syntax: com1_TXemptyEvent(function);
001215  001423  // Usage : arg := com1_TXemptyEvent();
001216  001424  // Notes : If a comms TX buffer that was previously allocated with
001217  001425  //       : com1_TXbuffer(...);, this function can be used to set up
001218  001426  //       : a function to be called when the COM1 TX buffer is empty.
001219  001427  //       : This is useful for either reloading the TX buffer, setting
001220  001428  //       : or clearing a pin to change the direction of eg a RS485
001221  001429  //       : line driver, or any other form of traffic control.
001222  001430  //       : The event function must not have any parameters.
001223  001431  //       : To disable the event, simply call com1_TXemptyEvent(0).
001224  001432  //       : com1_TXbuffer(...); also resets any active event.
001225  001433  //       : com1_TXemptyEvent returns any previous event function
001226  001434  //       : address, or zero if there was no previous function.
001227  001435        
001228  001436        
001229  001437  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001230  001438  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001231  001439  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001232  001440  // Notes : Expecting that a comms TX buffer that was previously allocated with
001233  001441  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001234  001442  //       : the buffer being sent wile it is being loaded. Mormally, when
001235  001443  //       : using buffered comms, the transmit process will begin
001236  001444  //       : immediately. This is often undesirable for 2 reasons,
001237  001445  //       : 1] you may wish to build a packet then send it later
001238  001446  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001239  001447  //       : as the FIFO buffer is constantly trying to empty while
001240  001448  //       : you are busy tring to fill it.
001241  001449  // return -1 if function is called illegally when TX comms is not buffered.
001242  001450  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001243  001451  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001244  001452        
001245  001453  func serin1(), 1;
001246  001454  // Syntax: serin1();
001247  001455  // Usage : char := serin1();
001248  001456  // Notes : return the next available character from COM1
001249  001457        
001250  001458  func serout1("char"), 0;
001251  001459  // Syntax: serout1("char");
001252  001460  // Usage : serout1(ch);
001253  001461  // Notes : send character to COM1
001254  001462        
001255  001463  func com_SetBaud("comport","baudrate/10"), 1;
001256  001464  // Syntax: com_SetBaud("comport","baudrate/10");
001257  001465  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001258  001466  // Notes : sets to any viable baud rate from 160 to 655350
001259  001467  // return true if baud rate was acceptable
001260  001468        
001261  001469        
001262  001470        
001263  001471  //==============================================//
001264  001472  // Display Access                               //
001265  001473  //==============================================//
001266  001474  func disp_Init(), 0;                            // initialize display with required tables
001267  001475  // Syntax: disp_Init();
001268  001476  // Usage : disp_Init();
001269  001477  // Notes : Initialises or reinitialises the display.
001270  001478  //       : Normally used after restoration of peripheral power
001271  001479  //       : and after DeepSleep.
001272  001480        
001273  001481  func disp_SetReg("register", "data"), 0;
001274  001482  // Syntax: display_SetReg(register, data);
001275  001483  // Usage : display_SetReg(arg1, arg2);
001276  001484  // Notes : Sets uLCD specific display driver registers. Refer
001277  001485  //       : to appropriate display driver data sheet.
001278  001486        
001279  001487  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001280  001488  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001281  001489  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001282  001490  // Notes : Prepares the GRAM area for user access.
001283  001491  //       : Data can now be written with disp_GRAM.
001284  001492  //       : GRAM will be set accordingly for the correct screen mode.
001285  001493  //       : the LO word of the 32 bit pixel count is returned. This is
001286  001494  //       : usually all that is needed unlse GRAM area exceeds 256^2
001287  001495  //       : A copy of the 32bit value can be found in
001288  001496  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001289  001497        
001290  001498  func disp_WrGRAM("colour"), 0;
001291  001499  // Syntax: display_WrGRAM(colour);
001292  001500  // Usage : display_WrGRAM(arg);
001293  001501  // Notes : Data can be written to the GRAM consecutively using
001294  001502  //       : this function once the GRAM access window has been setup.
001295  001503        
001296  001504  func disp_WriteControl("value"), 0;             // write a control byte to the display
001297  001505  func disp_WriteWord("value"), 0;                // write a word to the display
001298  001506        
001299  001507        
001300  001508  func disp_ReadWord("Command", "dummy"), 1;                        // read a word from the display
001301  001509  // Syntax	: disp_ReadWord(command, 1);
001302  001510  // Usage	: x:=disp_ReadWord(command, 1);
001303  001511  // Notes	: Read a word from the controller
001304  001512  // Eg: 	: print(disp_ReadWord(0), 0);        // select Ilitek ID register, read using 0 dummy reads, print ID
001305  001513  // 	: (Many displays are write only)
001306  001514  // 	: Some SPI displays required the command be given as part of the read sequence.
001307  001515  // 	: For displays that do not require this the value will be ignored.
001308  001516        
001309  001517                                                  //
001310  001518  //==============================================//
001311  001519  // unadorned SPI functions                      //
001312  001520  //==============================================//
001313  001521  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001314  001522  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001315  001523  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001316  001524  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001317  001525                                                  //
001318  001526  //==============================================//
001319  001527  // flash device specific functions              //
001320  001528  //==============================================//
001321  001529  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001322  001530  // Syntax: flash_SIG();
001323  001531  // Usage : flash_SIG();
001324  001532  // Notes	: Returns the Flash Signature returned from the 'FLASH WAKEUP RETURN SIG'
001325  001533  // 	: (0xAB) command.
001326  001534        
001327  001535  func flash_ID(), 1;                             // read ID code from FLASH device
001328  001536  // Syntax: flash_ID();
001329  001537  // Usage : flash_ID();
001330  001538  // Notes	: Returns the second(memory type) and third(memory capacity) bytes returned from the 
001331  001539  // 	: 'FLASH READ ID REG' (0x9F) command.
001332  001540        
001333  001541  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001334  001542        
001335  001543  func flash_Block64Erase(), 1;            // erase the required 64k flash block
001336  001544  // Syntax: flash_Block64Erase();
001337  001545  // Usage : flash_Block64Erase();
001338  001546  // Notes	: Erase the 64KB flash block including the currently set address
001339  001547  // 	: This uses the 0xD8 command.
001340  001548                                                  //
001341  001549                                                  //
001342  001550  //==============================================//
001343  001551  // string and character size function           //
001344  001552  //==============================================//
001345  001553  func charwidth("char"), 1;                      // return width of a character in pixel units
001346  001554  func charheight("char"), 1;                     // return height of a character in pixel units
001347  001555  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001348  001556  func strheight(), 1;                            // return height of a string in pixel units
001349  001557        
001350  001558        
001351  001559  //------------------------------------------------------------------//
001352  001560  //        I2C Function Prototypes
001353  001561  //------------------------------------------------------------------//
001354  001562  func I2C1_Open("speed"), 0;
001355  001563  // Syntax: I2C1_Open(speed),
001356  001564  // Usage : I2C1_Open(I2C_MED);
001357  001565  // Notes : configures the I2C1 module
001358  001566  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001359  001567        
001360  001568  func I2C1_Close(), 0;
001361  001569  // Syntax: I2C1_Close();
001362  001570  // Usage : I2C1_Close();
001363  001571  // Notes : disables the I2C1 module.
001364  001572        
001365  001573  func I2C1_Start(), 1;
001366  001574  // Syntax: I2C1_Start();
001367  001575  // Usage : I2C1_Start();
001368  001576  // Notes : generates a Start condition.
001369  001577  //       : returns true if successful (usually ignored)
001370  001578        
001371  001579  func I2C1_Stop(), 1;
001372  001580  // Syntax: I2C1_Stop();
001373  001581  // Usage : I2C1_Stop();
001374  001582  // Notes : generates a Stop condition.
001375  001583  //       : returns true if successful (usually ignored)
001376  001584        
001377  001585  func I2C1_Restart(), 1;
001378  001586  // Syntax: I2C1_Restart();
001379  001587  // Usage : I2C1_Restart();
001380  001588  // Notes : generates a Restart condition.
001381  001589  //       : returns true if successful (usually ignored)
001382  001590        
001383  001591  func I2C1_Read(), 1;
001384  001592  // Syntax: I2C1_Read();
001385  001593  // Usage : ch := I2C1_Read();
001386  001594  // Notes : reads a single byte from the I2C Bus.
001387  001595        
001388  001596  func I2C1_Write("byte"), 1;
001389  001597  // Syntax: I2C1_Write(byte);
001390  001598  // Usage : r := I2C1_Write(ch);
001391  001599  // Notes : is used to write a byte to the I2C bus.
001392  001600  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001393  001601        
001394  001602  func I2C1_Ack(), 0;
001395  001603  // Syntax: I2C1_Ack();
001396  001604  // Usage : I2C1_Ack();
001397  001605  // Notes : generates the acknowledge condition.
001398  001606        
001399  001607  func I2C1_Nack(), 0;
001400  001608  // Syntax: I2C1_Nack();
001401  001609  // Usage : I2C1_Nack();
001402  001610  // Notes : generates the negative acknowledge condition.
001403  001611        
001404  001612  func I2C1_AckStatus(), 0;
001405  001613  // Syntax: I2C1_AckStatus();
001406  001614  // Usage : r := I2C1_AckStatus();
001407  001615  // Notes : returns the ACK status from the device.
001408  001616        
001409  001617  func I2C1_AckPoll("control"), 1;
001410  001618  // Syntax: I2C1_AckPoll();
001411  001619  // Usage : r := I2C1_AckPoll(0xA0);
001412  001620  // Notes : waits for a device to return from ACK polling.
001413  001621        
001414  001622  func I2C1_Idle(), 0;
001415  001623  // Syntax: I2C1_Idle();
001416  001624  // Usage : I2C1_Idle();
001417  001625  // Notes : waits until the I2C Bus is Inactive.
001418  001626        
001419  001627  func I2C1_Gets("buffer", "size"), 1;
001420  001628  // Syntax: I2C1_Gets("buffer", "size");
001421  001629  // Usage : r := I2C1_Gets(mybuf, 16);
001422  001630  // Notes : only reads up to "size" characters into "buffer"
001423  001631  //       : Reads up to asciiz terminator including terminator
001424  001632        
001425  001633  func I2C1_Getn("buffer", "size"), 1;
001426  001634  // Syntax: I2C1_Gets("buffer", "size");
001427  001635  // Usage : r := I2C1_Gets(mybuf, 16);
001428  001636  // Notes : reads "size" bytes into "buffer"
001429  001637  //       :
001430  001638        
001431  001639  func I2C1_Puts("buffer"), 1;
001432  001640  // Syntax: I2C1_Puts("buffer");
001433  001641  // Usage : r := I2C1_Puts(mybuf);
001434  001642  // Notes : writes an asciiz string to the I2C device
001435  001643  //       : returns count of characters written
001436  001644        
001437  001645  func I2C1_Putn("buffer", "count"), 1;
001438  001646  // Syntax: I2C1_Putn("buffer","count");
001439  001647  // Usage : r := I2C1_Puts(mybuf,10);
001440  001648  // Notes : writes up to "size" bytes to the I2C device
001441  001649  //       : returns number of bytes written
001442  001650        
001443  001651        
001444  001652  //------------------------------------------------------------------//
001445  001653  //        Image Control Function Prototypes
001446  001654  //------------------------------------------------------------------//
001447  001655  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001448  001656  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001449  001657  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001450  001658  // Notes : set the position where the image will be displayed
001451  001659  //       : returns true if index was ok and function was successful.
001452  001660  //       : you may turn off an image so when img_Refresh is called,
001453  001661  //       : the image will not be shown
001454  001662        
001455  001663  func img_Enable("handle", "index"), 1;
001456  001664  // Syntax: img_Enable(handle, index);
001457  001665  // Usage : r := img_Enable(hImageList, imagenum);
001458  001666  // Notes : enable image in a image list
001459  001667  //       : returns true if index was ok and function was successful.
001460  001668  //       : this is the default state so when img_Refresh is called,
001461  001669  //       : all the images in the list will be shown
001462  001670  //       : if index is set to -1, all of the images are enabled
001463  001671        
001464  001672  func img_Disable("handle", "index"), 1;
001465  001673  // Syntax: img_Disable(handle, index);
001466  001674  // Usage : r := img_Disable(hImageList, imagenum);
001467  001675  // Notes : disable image in a image list
001468  001676  //       : returns true if index was ok and function was successful.
001469  001677  //       : you must turn off an image so when img_Refresh is called,
001470  001678  //       : the image will not be shown.
001471  001679  //       : if index is set to -1, all of the images are disabled
001472  001680        
001473  001681        
001474  001682  func img_Darken("handle", "index"), 1;
001475  001683  // Syntax: img_Darken(handle, index);
001476  001684  // Usage : r := img_Darken(hImageList, imagenum);
001477  001685  // Notes : darken image in a image list
001478  001686  //       : returns true if index was ok and function was successful.
001479  001687  //       : if index is set to -1, all of the images are darkened
001480  001688  //       : NB:- this feature will only work for the next refresh, then
001481  001689  //       : the image reverts back to normal when displayed again.
001482  001690        
001483  001691        
001484  001692  func img_Lighten("handle", "index"), 1;
001485  001693  // Syntax: img_Lighten(handle, index);
001486  001694  // Usage : r := img_Lighten(hImageList, imagenum);
001487  001695  // Notes : lighten image in a image list
001488  001696  //       : returns true if index was ok and function was successful.
001489  001697  //       : if index is set to -1, all of the images are lightened
001490  001698  //       : NB:- this feature will only work for the next refresh, then
001491  001699  //       : the image reverts back to normal when displayed again.
001492  001700        
001493  001701  func img_SetWord("handle", "index", "offset", "word"), 1;
001494  001702  // Syntax: img_SetWord(handle, index, offset, word);
001495  001703  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001496  001704  // Notes : set specified word (0-7) in a image entry
001497  001705  //       : returns TRUE if successful, return value usually ignored.
001498  001706        
001499  001707  func img_GetWord("handle", "index", "offset"), 1;
001500  001708  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001501  001709  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001502  001710  // Notes : returns specified word (0-14) from an image entry
001503  001711  //       : refer to image control entry offsets.
001504  001712        
001505  001713  func img_Show("handle", "index"), 1;
001506  001714  // Syntax: img_Show(handle, index);
001507  001715  // Usage : display image entry (regardless of enable/disable)
001508  001716  //       : returns TRUE if successful, return value usually ignored.
001509  001717        
001510  001718  func img_SetAttributes("handle", "index","value"), 1;
001511  001719  // Syntax: img_SetAttributes("handle", "index","offset");
001512  001720  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001513  001721  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001514  001722  //       : of an image control entry. "value" refers to various bits in
001515  001723  //       : the image control entry (see image attribute flags).
001516  001724  //       : A '1' bit in the "value" field SETS the respective bit
001517  001725  //       : in the IMAGE_FLAGS field of the image control entry.
001518  001726  //       : returns TRUE if successful, return value usually ignored.
001519  001727        
001520  001728  func img_ClearAttributes("handle", "index","value"), 1;
001521  001729  // Syntax: img_ClearAttributes("handle", "index","offset");
001522  001730  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001523  001731  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001524  001732  //       : of an image control entry. "value" refers to various bits in
001525  001733  //       : the image control entry (see image attribute flags)
001526  001734  //       : a '1' bit in the "value" field CLEARS the respective bit
001527  001735  //       : in the IMAGE_FLAGS field of the image control entry.
001528  001736  //       : returns TRUE if successful, return value usually ignored.
001529  001737        
001530  001738  func img_Touched("handle", "index"), 1;
001531  001739  // Syntax: r := img_Touched(handle, index);
001532  001740  // Usage : img_Touched(hndl, 17);
001533  001741  //       : returns -1 if image not touched, or returns index
001534  001742  // Notes : if index is passed as -1, function tests all images,
001535  001743  //       : and returns -1 if image not touched, or returns index.
001536  001744        
001537  001745        
001538  001746        
001539  001747        
001540  001748  //------------------------------------------------------------------//
001541  001749  //        Timer Function Prototypes
001542  001750  //------------------------------------------------------------------//
001543  001751  func sys_T(), 1;
001544  001752  // Syntax: sys_T();
001545  001753  // Usage : t := sys_T();
001546  001754  // Notes : return the current value of the rolling system timer (1msec) LO word
001547  001755        
001548  001756  func sys_T_HI(), 1;
001549  001757  // Syntax: sys_T_HI();
001550  001758  // Usage : t := sys_T_HI();
001551  001759  // Notes : return the current value of the rolling system timer (1msec) HI word
001552  001760        
001553  001761  func sys_SetTimer("timernum","value"), 0;
001554  001762  // Syntax: sys_SetTimer("timernum", "value");
001555  001763  // Usage : sys_SetTimer(TIMER5, 10000);
001556  001764  // Notes : set a countdown on the selected timer, or 'top up' if required.
001557  001765  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001558  001766  //       : Maximum timeout period is 65.535 seconds
001559  001767  //       : A timer can be read with the sys_GetTimer("timernum") function
001560  001768        
001561  001769  func sys_GetTimer("timernum"), 1;
001562  001770  // Syntax: t := sys_GetTimer("timernum");
001563  001771  // Usage : t := sys_GetTimer(TIMER3);
001564  001772  // Notes : returns 0 if timer has expired, or the current countdown value.
001565  001773  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001566  001774  //       : Maximum timeout period is 65.535 seconds
001567  001775  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001568  001776        
001569  001777  func sys_SetTimerEvent("timernum","function"), 1;
001570  001778  // Syntax: sys_SetTimerFunction("timernum", "function");
001571  001779  // Usage : sys_SetTimer(TIMER5, myfunc);
001572  001780  // Notes : set a function to be called for selected timer.
001573  001781  //       : When the timer reaches zero, the function is called.
001574  001782  //       : The called function must not have any parameters
001575  001783  //       : sys_SetTimerEvent returns any previous event function
001576  001784  //       : address, or zero if there was no previous function.
001577  001785        
001578  001786  func sys_EventQueue(), 1;
001579  001787  // Syntax: sys_EventQueue();
001580  001788  // Usage : tasks := sys_EventQueue();
001581  001789  // Notes : returns the max number of events that were pending
001582  001790  //       : in the timer queue since the last call to this function.
001583  001791  //       : This can be used to assess timer event overhead burden,
001584  001792  //       : especially after or during a sys_EventsPostpone action.
001585  001793        
001586  001794  func sys_EventsPostpone(), 0;
001587  001795  // Syntax: sys_EventPostpone();
001588  001796  // Usage : sys_EventPostpone();   // postpone the event queue
001589  001797  // Notes : postpone any events until the sys_EventResume function is executed
001590  001798  //       : The timer event queue will continue to queue events, but no action
001591  001799  //       : will take place untill a sys_EventResume function is encountered.
001592  001800  //       : The queue will continue to receive up to 32 events before discarding
001593  001801  //       : any further events. This function is required to allow a sequence of
001594  001802  //       : instructions or functions to occur that would otherwise be corrupted
001595  001803  //       : by an event occuring during the sequence of instructions or functions.
001596  001804  //       : A good example of this is when you set a position to print, if there
001597  001805  //       : was no way of locking the current sequence, an event may occur which
001598  001806  //       : does a similar thing, and a contention would occur - printing to
001599  001807  //       : the wrong position. This function should be used wisely, if any action
001600  001808  //       : that is required would take considerable time, it is better to disable
001601  001809  //       : any conflicting event functions with a bypass flag, then restart the
001602  001810  //       : conflicting event by re-issuing a timer value.
001603  001811        
001604  001812  func sys_EventsResume(), 0;
001605  001813  // Syntax: sys_EventsResume();
001606  001814  // Usage : sys_EventsResume();   // resume the event queue
001607  001815  // Notes : resume any postponed events. The queue will try to execute any timer
001608  001816  //       : events that were incurred during the postponed period.
001609  001817        
001610  001818        
001611  001819  func sys_Sleep("units"), 1;
001612  001820  // Syntax: t := sys_Sleep("units");
001613  001821  // Usage : t := sys_Sleep(10);
001614  001822  // Notes : sets the display into low power mode for a period of time.
001615  001823  //       : Touching the touch screen will also wake from sleep.
001616  001824  //       : Returns remaining sleep units.
001617  001825        
001618  001826  func iterator("offset"), 0;
001619  001827  // Syntax: t :=  iterator("offset");
001620  001828  // Usage : t :=  iterator(10);
001621  001829  // Notes : set the iterator size for ++/--
001622  001830  //       : The next postinc,postdec,preinc of predec will alter
001623  001831  //       : by the specified value.
001624  001832  //       : The offset will return to 1 after the next operation.
001625  001833        
001626  001834        
001627  001835        
001628  001836        
001629  001837  //------------------------------------------------------------------//
001630  001838  //         Touch Screen Function Prototypes
001631  001839  //------------------------------------------------------------------//
001632  001840        
001633  001841  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001634  001842  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001635  001843  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001636  001844  // Notes : Specifies a new touch detect region on the screen
001637  001845  //       : such that only touch activity in that region will
001638  001846  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001639  001847        
001640  001848  func touch_Set("mode"), 0;
001641  001849  // Syntax: touch_Set(mode);
001642  001850  // Usage : touch_Set(arg);
001643  001851  // Notes : Sets various Touch Screen related parameters
001644  001852  //       :
001645  001853  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001646  001854  //       : touch_Set(TOUCH_ENABLE);
001647  001855  //       : Enables and initialises Touch Screen hardware
001648  001856  //       :
001649  001857  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001650  001858  //       : touch_Set(TOUCH_DISABLE );
001651  001859  //       : Disables the Touch Screen
001652  001860  //       : Note: Touch Screen runs in the background and disabling
001653  001861  //       : it when not in use will free up extra resources
001654  001862  //       : such as 4DVM CPU cycles.
001655  001863  //       :
001656  001864  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001657  001865  //       : touch_Set(TOUCH_REGIONDEFAULT);
001658  001866  //       : This will reset the current active region to default
001659  001867  //       : to the full screen without the application having to
001660  001868  //       : set a new active region for the full screen.
001661  001869  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001662  001870  //       : that requre to be interfaced with an external pointing
001663  001871  //       : device, values that are poked into TOUCH_DRIVE will be
001664  001872  //       : read with the touch_Get() function)
001665  001873        
001666  001874        
001667  001875  func touch_Get("mode"), 1;
001668  001876  // Syntax: touch_Get(mode);
001669  001877  // Usage : arg1 := touch_Get(arg);
001670  001878  // Notes : Returns various Touch Screen parameters to caller
001671  001879  //       :
001672  001880  //       : mode = TOUCH_STATUS  (mode 0)
001673  001881  //       : var := touch_Get(TOUCH_STATUS);
001674  001882  //       : Returns the various states of the touch screen
001675  001883  //       : 0 = NOTOUCH
001676  001884  //       : 1 = TOUCH_PRESSED
001677  001885  //       : 2 = TOUCH_RELEASED
001678  001886  //       : 3 = TOUCH_MOVING
001679  001887  //       :
001680  001888  //       : mode = TOUCH_GETX   (mode 1)
001681  001889  //       : var := touch_Get(TOUCH_GETX);
001682  001890  //       : Returns the X coordinates of the touch
001683  001891  //       :
001684  001892  //       : mode = TOUCH_GETY   (mode 2)
001685  001893  //       : var := touch_Get(TOUCH_GETY);
001686  001894  //       : Returns the Y coordinates of the touch
001687  001895        
001688  001896  //------------------------------------------------------------------//
001689  001897  //        CTYPE Function Prototypes
001690  001898  //------------------------------------------------------------------//
001691  001899        
001692  001900  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001693  001901  // Syntax: isdigit("char");
001694  001902  // Usage : Var := isdigit(ch);
001695  001903  // Notes : char specifies the ascii character for the test
001696  001904  //     : 0 : char is not an ascii digit.
001697  001905  //     : 1 : char is an ascii digit..
001698  001906  //     : Valid range is "0123456789"
001699  001907        
001700  001908  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001701  001909  // Syntax: isxdigit("char");
001702  001910  // Usage : Var := isxdigit(ch);
001703  001911  // Notes : char specifies the ascii character for the test
001704  001912  //     : 0 : char is not an ascii hexadecimal digit.
001705  001913  //     : 1 : char is an ascii hexadecimal digit..
001706  001914  //     : Valid range is "0123456789ABCDEF"
001707  001915        
001708  001916  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001709  001917  // Syntax: isupper("char");
001710  001918  // Usage : Var := isupper(ch);
001711  001919  // Notes : char specifies the ascii character for the test
001712  001920  //     : 0 : char is not an ascii upper-case letter.
001713  001921  //     : 1 : char is an ascii upper-case letter.
001714  001922  //     : Valid range is "ABCD....WXYZ"
001715  001923        
001716  001924  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001717  001925  // Syntax: islower("char");
001718  001926  // Usage : Var := islower(ch);
001719  001927  // Notes : char specifies the ascii character for the test
001720  001928  //     : 0 : char is not an ascii lower-case letter.
001721  001929  //     : 1 : char is an ascii lower-case letter.
001722  001930  //     : Valid range is "abcd....wxyz"
001723  001931        
001724  001932  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001725  001933  // Syntax: isalpha("char");
001726  001934  // Usage : Var := isalpha(ch);
001727  001935  // Notes : char specifies the ascii character for the test
001728  001936  //     : 0 : char is not an ascii lower or upper case letter.
001729  001937  //     : 1 : char is an ascii lower or upper case letter.
001730  001938  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001731  001939        
001732  001940  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001733  001941  // Syntax: isalnum("char");
001734  001942  // Usage : Var := isalnum(ch);
001735  001943  // Notes : char specifies the ascii character for the test
001736  001944  //     : 0 : char is not an ascii alphanumeric character.
001737  001945  //     : 1 : char is an ascii alphanumeric character.
001738  001946  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001739  001947        
001740  001948  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001741  001949  // Syntax: isprint("char");
001742  001950  // Usage : Var := isprint(ch);
001743  001951  // Notes : char specifies the ascii character for the test
001744  001952  //     : 0 : char is not a printable ascii character.
001745  001953  //     : 1 : char is a printable ascii character.
001746  001954  //     : Valid range is "0x20...0x7F"
001747  001955        
001748  001956  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001749  001957  // Syntax: isspace("char");
001750  001958  // Usage : Var := isspace(ch);
001751  001959  // Notes : char specifies the ascii character for the test
001752  001960  //     : 0 : char is not a space type character.
001753  001961  //     : 1 : char is a space type character.
001754  001962  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001755  001963        
001756  001964  //unformatted
001757  001965  func iswhite("char"), 1;    //
001758  001966  // Syntax: iswhite("char");
001759  001967  // Usage : Var := iswhite(ch);
001760  001968  // Notes : char specifies the ascii character for the test
001761  001969  //     : 0 : char is not a space or tab character.
001762  001970  //     : 1 : char is not a space or tab character.
001763  001971  //     : Valid range is space or tab
001764  001972        
001765  001973  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001766  001974  // Syntax: toupper("char");
001767  001975  // Usage : Var := toupper(ch);
001768  001976  // Notes : char specifies the ascii character for the test
001769  001977  //     : "ABCD....XYZ" : if character is a lower case letter.
001770  001978  //     : char : if character is not a lower case letter.
001771  001979  //     : Valid range is "abcd....wxyz"
001772  001980        
001773  001981  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001774  001982  // Syntax: tolower("char");
001775  001983  // Usage : Var := tolower(ch);
001776  001984  // Notes : char specifies the ascii character for the test
001777  001985  //     : "abcd....xyz" : if character is an upper case letter.
001778  001986  //     : char : if character is not an upper case letter.
001779  001987  //     : Valid range is "ABCD....WXYZ"
001780  001988        
001781  001989  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001782  001990  // Syntax: LObyte(var);
001783  001991  // Usage : myVar := LObyte(myvar2);
001784  001992  // Notes : var specifies the user variable
001785  001993  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001786  001994        
001787  001995  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001788  001996  // Syntax: HIbyte(var);
001789  001997  // Usage : myVar := HIbyte(myvar2);
001790  001998  // Notes : var specifies the user variable
001791  001999  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001792  002000        
001793  002001        
001794  002002  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001795  002003  // Syntax: ByteSwap(var);
001796  002004  // Usage : myVar := ByteSwap(myvar2);
001797  002005  // Notes : var specifies the user variable
001798  002006  //     : Returns the endian swapped value of a 16 bit variable
001799  002007        
001800  002008        
001801  002009  //------------------------------------------------------------------//
001802  002010  //        Memory Allocation Function Prototypes
001803  002011  //------------------------------------------------------------------//
001804  002012        
001805  002013  func mem_Alloc("size"), 1;
001806  002014  // Syntax: mem_Alloc(bytesize);
001807  002015  // Usage : myvar := mem_Alloc(100);
001808  002016  // Notes : Allocate a block of memory to pointer myvar
001809  002017  //       : The allocated memory contains garbage but is a fast allocation.
001810  002018  //       : The block must later be released with mem_Free();
001811  002019  //       : returns 0 if function fails
001812  002020        
001813  002021  func mem_AllocV("size"), 1;
001814  002022  // Syntax: mem_AllocV(bytesize);
001815  002023  // Usage : myvar := mem_AllocV(100);
001816  002024  // Notes : Allocate a block of memory to pointer myvar
001817  002025  //       : The block of memory is filled with signature values
001818  002026  //       : the block starts with A5,5A then fills with incrementing
001819  002027  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001820  002028  //       : This can be helpful when debugging
001821  002029  //       : The block must later be released with mem_Free();
001822  002030  //       : returns 0 if function fails
001823  002031        
001824  002032  func mem_AllocZ("size"), 1;
001825  002033  // Syntax: mem_AllocZ(bytesize);
001826  002034  // Usage : myvar := mem_AllocC(100);
001827  002035  // Notes : Allocate a zeroed block of memory to pointer myvar
001828  002036  //       : The block of memory is filled with zeroes
001829  002037  //       : The block must later be released with mem_Free();
001830  002038  //       : returns 0 if function fails
001831  002039        
001832  002040  func mem_Realloc("ptr", "size"), 1;
001833  002041  // Syntax: myvar := mem_Realloc("ptr", "size");
001834  002042  // Usage : myvar := mem_Realloc(ptr, size);
001835  002043  // Notes : The function may move the memory block to a new location,
001836  002044  //       : in which case the new location is returned.
001837  002045  //       : The content of the memory block is preserved up to the lesser
001838  002046  //       : of the new and old sizes, even if the block is moved.
001839  002047  //       : If the new size is larger, the value of the newly allocated
001840  002048  //       : portion is indeterminate. In case that ptr is NULL,
001841  002049  //       : the function behaves exactly as mem_Alloc, assigning a new block
001842  002050  //       : of size bytes and returning a pointer to the beginning of it.
001843  002051  //       : In case that the size is 0, the memory previously allocated in
001844  002052  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001845  002053  //       : pointer is returned.
001846  002054        
001847  002055  func mem_Free("allocation"), 1;
001848  002056  // Syntax: myvar := mem_Free(allocation);
001849  002057  // Usage : myvar := mem_Free(myvar);
001850  002058  // Notes : De-allocate a block of memory previously created with
001851  002059  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001852  002060  //       : returns 0 if function fails
001853  002061        
001854  002062  func mem_Heap(), 1;
001855  002063  // Syntax: myvar := mem_Heap();
001856  002064  // Usage : myvar := mem_Heap();
001857  002065  // Notes : returns bytecount available in heap
001858  002066  //       :
001859  002067        
001860  002068  func mem_Set("ptr","char","size"), 1;
001861  002069  // Syntax: mem_Set(ptr,char,bytesize);
001862  002070  // Usage : mem_Set(p, 'A', 100);
001863  002071  // Notes : fill a block of memory with a byte value
001864  002072  //       : returns ptr
001865  002073        
001866  002074  func mem_Copy("src", "dest", "bytecount"), 1;
001867  002075  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001868  002076  // Usage : myvar := mem_Copy(p1, p2, 100);
001869  002077  // Notes : copy a word aligned block of memory from src to dest
001870  002078  //       : Note that count is a byte count, this facilitates
001871  002079  //       : copying word aligned byte arrays when using word
001872  002080  //       : aliggned packed strings.
001873  002081  //       : returns src
001874  002082        
001875  002083  func mem_Compare("ptr1","ptr2","count"), 1;
001876  002084  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001877  002085  // Usage : myvar := mem_Compare(p1, p2, 100);
001878  002086  // Notes : compare blocks of memory at src, dest
001879  002087  //       : returns 0 if we have a match
001880  002088        
001881  002089  //------------------------------------------------------------------//
001882  002090  //        FAT16 Function Prototypes
001883  002091  //------------------------------------------------------------------//
001884  002092        
001885  002093  func file_Error(), 1;
001886  002094  // Syntax: myvar := file_Error();
001887  002095  // Usage : e := file_Error();
001888  002096  // Notes : return the most recent file error.
001889  002097  //       :
001890  002098        
001891  002099  func file_Count("filename"), 1;
001892  002100  // Syntax: count := file_Count("filename");
001893  002101  // Usage : count := file_Count("*.4dg");
001894  002102  // Notes : returns number of files found that match the criteria
001895  002103        
001896  002104  func file_Dir("filename"), 1;
001897  002105  // Syntax: count := file_Dir("filename");
001898  002106  // Usage : count := file_Dir("*.4dg");
001899  002107  // Notes : streams a string of filenames that agree with the search key
001900  002108  //       : returns number of files found that match the criteria
001901  002109        
001902  002110  func file_FindFirst("fname"), 1;
001903  002111  // Syntax: res := file_FindFirst("fname");
001904  002112  // Usage : if (file_FindFirst("*.4xe") ....
001905  002113  // Notes : returns true if at least 1 file exists
001906  002114  //       : that satisfies the file argument.
001907  002115  //       : Wildcards are usually used so if
001908  002116  //       : file_FindFirst returns true, further
001909  002117  //       : tests can be made using file_FindNext();
001910  002118  //       : to find all the files that match the
001911  002119  //       : wildcard class. Note that the stream behaviour
001912  002120  //       : is the same as file_Dir.
001913  002121  //       :
001914  002122        
001915  002123  func file_FindNext(), 1;
001916  002124  // Syntax: res := file_FindNext();
001917  002125  // Usage : while ((file_FindNext()) ....
001918  002126  // Notes : returns true if more file exists
001919  002127  //       : that satisfies the file argument
001920  002128  //       : that was given for  file_FindFirst.
001921  002129  //       : Wildcards must be used for
001922  002130  //       : file_FindFirst, else this function will
001923  002131  //       : always return zero as the only occurence
001924  002132  //       : will have already been found.
001925  002133  //       : Note that the stream behaviour
001926  002134  //       : is the same as file_Dir.
001927  002135  //       :
001928  002136        
001929  002137  func file_Exists("fname"), 1;
001930  002138  // Syntax: res := file_Exists("fname"),
001931  002139  // Usage : if(file_Exists("myfile") ....
001932  002140  // Notes : returns true if file exists
001933  002141  //       :
001934  002142        
001935  002143  func file_Open("fname", "mode"), 1;
001936  002144  // Syntax: handle := file_Open("fname","mode"),
001937  002145  // Usage : handle := file_Open("myfile.txt", 'r');
001938  002146  // Notes : returns handle if file exists
001939  002147  //       :
001940  002148        
001941  002149  func file_Close("handle"), 1;
001942  002150  // Syntax: res := file_Close("handle");
001943  002151  // Usage : res := file_Close(hnd1);
001944  002152  // Notes : returns true if file closed ok
001945  002153  //       :
001946  002154        
001947  002155  func file_Read("*dest", "size", "handle"), 1;
001948  002156  // Syntax: res := file_Read("*dest", "size", "handle"),
001949  002157  // Usage : res := file_Read(memblock,20,hnd1);
001950  002158  // Notes : returns number of characters read
001951  002159  //       : if "dest" is zero, data is read direct to GRAM window
001952  002160  //       :
001953  002161        
001954  002162        
001955  002163  func file_Seek("handle", "HiWord", "LoWord"), 1;
001956  002164  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
001957  002165  // Usage : res := file_Seek(hSource, 0, 0x1234);
001958  002166  // Notes : set file position to 0x00001234 (byte position 4660)
001959  002167  //       : for the file handle so subsequent data may be read
001960  002168  //       : from that position onwards with file_GetC(...),
001961  002169  //       : file_GetW(...) or file_GetS(...), or an image
001962  002170  //       : can be displayed with file_Image(...)
001963  002171  // Notes : returns true if ok, usually ignored
001964  002172        
001965  002173  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001966  002174  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001967  002175  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
001968  002176  // Notes : set file seek position to 123000
001969  002177  //       : for the file handle so subsequent data may be read
001970  002178  //       : from that record position onwards with file_GetC(...),
001971  002179  //       : file_GetW(...) or file_GetS(...), or an image
001972  002180  //       : can be displayed with file_Image(...)
001973  002181  // Notes : returns true if ok, usually ignored
001974  002182        
001975  002183  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
001976  002184  // Syntax: file_Tell("handle", &HiWord, &LoWord);
001977  002185  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
001978  002186  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
001979  002187  //       : returns true if function succeeded
001980  002188        
001981  002189  func file_Write("*source", "size", "handle"), 1;
001982  002190  // Syntax: res := fwrite("*source", "size", "handle"),
001983  002191  // Usage : res := fwrite(memblock, 20, hnd1);
001984  002192  // Notes : returns number of bytes written
001985  002193  //       :
001986  002194        
001987  002195  func file_Size("handle", "&HiWord", "&LoWord"), 1;
001988  002196  // Syntax: file_Size("handle", &HiWord, &LoWord);
001989  002197  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
001990  002198  // Notes : Reads the 32 bit file size and stores it into 2 variables.
001991  002199  //       : returns true if function succeeded
001992  002200        
001993  002201  func file_Image("x", "y", "handle"), 1;
001994  002202  // Syntax: file_Image(x, y, handle);
001995  002203  // Usage : file_Image(10, 10, hnd1);
001996  002204  // Notes : Display an image from a file at the current file position.
001997  002205  //       : The image is displayed at x,y (with respect to top left corner).
001998  002206  //       : If there is more than 1 image in the file, it can be
001999  002207  //       : accessed with file_Seek(...)
002000  002208        
002001  002209  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002002  002210  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002003  002211  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002004  002212  // Notes : Save a image from screen to file at the current file position.
002005  002213  //       : The image can later be displayed with file_Image(...);
002006  002214  //       : The file may be opened in append mode to accumulate multiple
002007  002215  //       : images. Later, the images can be accessed with file_Seek(...);
002008  002216  //       : Note that the image will be sector aligned.
002009  002217  //       : All image headers must start on a sector boundary.
002010  002218  //       : The image is saved from x, y (with respect to top left corner)
002011  002219  //       : and the capture area is determined by "width" and "height".
002012  002220  //       : returns 0 if function succeeded
002013  002221        
002014  002222  func file_PutC("char","handle"), 1;
002015  002223  // Syntax: file_PutC("char", "handle");
002016  002224  // Usage : file_PutC('x', hndl);
002017  002225  // Notes : returns true if function succeeded
002018  002226        
002019  002227  func file_GetC("handle"), 1;
002020  002228  // Syntax: file_GetC("handle");
002021  002229  // Usage : mychar := fgetC("handle");
002022  002230  // Notes : returns next char from file
002023  002231        
002024  002232  func file_PutW("word","handle"), 1;
002025  002233  // Syntax: file_PutW("word","handle");
002026  002234  // Usage : file_PutW(0x1234, hndl);
002027  002235  // Notes : returns true if function succeeded
002028  002236        
002029  002237  func file_GetW("handle"), 1;
002030  002238  // Syntax: file_GetW("handle");
002031  002239  // Usage : myword := fgetW("handle");
002032  002240  // Notes : returns next word in file
002033  002241        
002034  002242  func file_PutS("*source", "handle"), 1;
002035  002243  // Syntax: res := file_Puts("*source", "handle"),
002036  002244  // Usage : res := file_Puts(mystring, hnd1);
002037  002245  // Notes : returns number of characters written
002038  002246  //       :
002039  002247        
002040  002248  func file_GetS("*string", "size", "handle"), 1;
002041  002249  // Syntax: res := file_Gets("*string", "size", "handle");
002042  002250  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002043  002251  // Notes : get a string from a file
002044  002252  //       : returns pointer to string or null if failed.
002045  002253  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002046  002254  //       : NB:- only reads up to "size-1" characters into "string"
002047  002255  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002048  002256  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002049  002257  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002050  002258  //       : C] It reaches the end of file
002051  002259  //       : D] A read error occurs.
002052  002260        
002053  002261        
002054  002262  func file_Erase("fname"), 1;
002055  002263  // Syntax: res := file_Erase("fname");
002056  002264  // Usage : res := file_Erase("myfile.txt");
002057  002265  // Notes : returns true if successful
002058  002266  //       :
002059  002267        
002060  002268  func file_Rewind("handle"), 1;
002061  002269  // Syntax: res := file_Rewind("handle");
002062  002270  // Usage : res := file_Rewind(hnd1);
002063  002271  // Notes : returns true if file rewound ok (usually ignored)
002064  002272  //       : resets the file pointer the the beginning of the open file.
002065  002273        
002066  002274  func file_LoadFunction("fname.4xe"), 1;
002067  002275  // Syntax: res := file_LoadFunction("fname.4fn");
002068  002276  // Usage : myfunc := file_LoadFunction(myfuncname);
002069  002277  // Notes : Load a function or program from disk and
002070  002278  //       : return a function pointer to the allocation.
002071  002279  //       : The function can then be invoked just like any other
002072  002280  //       : function would be called via a function pointer.
002073  002281  //       : Parameters may be passed to it in a conventional way.
002074  002282  //       : The function may be discarded at any time when no
002075  002283  //       : longer required, thus freeing its memory resources.
002076  002284  //       : The loaded function can be discarded with mem_Free(..)
002077  002285  //       : eg:
002078  002286  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002079  002287  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002080  002288  //       : then elsewhere in your program:-
002081  002289  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002082  002290  //       : if(res == QUIT_APPLICATION) goto exitApp;
002083  002291  //       : Later in your program, when popupWindow is no longer
002084  002292  //       : required for the application:-
002085  002293  //       : res := mem_Free(popupWindow);
002086  002294  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002087  002295  //       : The callers stack is shared by the loaded function,
002088  002296  //       : however any global variables in the loaded function
002089  002297  //       : are private to that function.
002090  002298  //
002091  002299        
002092  002300  func file_Run("fname.4xe", "arglistptr"), 1;
002093  002301  // Syntax: res := file_Run("fname.4xe","arglistptr");
002094  002302  // Usage : res := file_Run(fname, argptr);
002095  002303  // Notes : current program releases any allocated memory but
002096  002304  //       : retains the stack and global memory.
002097  002305  //       : If arglistptr is 0, no arguments are passed, else
002098  002306  //       : arglist points to an array, the first element being
002099  002307  //       : the number of elements in the array.
002100  002308  //       : func 'main' in the called program accepts
002101  002309  //       : the arguments, if any. THe arguments can only
002102  002310  //       : be passed by value, no pointers or references can be
002103  002311  //       : used as all memory is cleared before the file
002104  002312  //       : is loaded. Refer to file_Exec and file_LoadFunction
002105  002313  //       : for functions that can pass by reference.
002106  002314        
002107  002315  func file_Exec("fname.4xe", "arglistptr"), 1;
002108  002316  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002109  002317  // Usage : res := file_Exec("fname.4xe","arglistptr");
002110  002318  // Notes : returns like a function, current program
002111  002319  //       : calling program is kept active and control returns to it.
002112  002320  //       : If arglistptr is 0, no arguments are passed, else
002113  002321  //       : arglist points to an array, the first element being
002114  002322  //       : the number of elements in the array.
002115  002323  //       : func 'main' in the called program accepts the arguments.
002116  002324  //       : This function is similar to file_LoadFunction(...), however,
002117  002325  //       : the function argument list is passed by pointer, and
002118  002326  //       : the memory consumed by the function is released as
002119  002327  //       : soon as the function completes.
002120  002328        
002121  002329  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002122  002330  // Syntax	: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002123  002331  // Usage	: hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002124  002332  // Notes	: Reads a control file to create an image list.
002125  002333  // 	: Returns NULL if function fails.
002126  002334  // 	: Returns a handle (pointer to the memory allocation) to the
002127  002335  // 	: image control list that has been created.
002128  002336  // 	: "fname1" is the control list filename "*.dat"
002129  002337  // 	: "fname2" is the image filename "*.gci"
002130  002338  // 	: "mode" is 0 for FAT based GCI and DAT with quick load and slower for each display
002131  002339  // 	: "mode" is 1 for FAT based GCI and DAT with slower load and faster for each display
002132  002340  // 	: "mode" is 2 for FAT based DAT with RAW GCI
002133  002341  // 	: "mode" is 3 for Flash based 'file system' GCI (GCIF) with itegerated DAT and other file types
002134  002342  // 	: "fname1" and "fname2" are then the Flash high and low words of the GFIC start location.
002135  002343        
002136  002344  // Notes : This function Calculates the size of a chunk of memory required for
002137  002345  //       : a image list and populates it from the image control file ("*.dat")
002138  002346  //       : therefore, when imagelist is no longer required, you must de-allocate
002139  002347  //       : the image list memory by using eg:- mem_Free(hImagelist);
002140  002348  //       : to restore the heap.
002141  002349  //       :
002142  002350  //       : mode 0:- it is assumed that there is a graphics file with the
002143  002351  //       : file extension "fname2.gci". In this case, the images have been stored
002144  002352  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002145  002353  //       : "fname1.dat" file are saved in the image control so that the image control
002146  002354  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002147  002355  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002148  002356  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002149  002357  //       : for the file offsets and save them in the relevant entries in the image control.
002150  002358  //       : The penalty is that images take longer to find when displayed due to file_Seek
002151  002359  //       : overheads.
002152  002360  //
002153  002361  //       : mode 1:- it is assumed that there is a graphics file with the
002154  002362  //       : file extension "fname2.gci". In this case, the images have been stored
002155  002363  //       : in a FAT16 file concurrently, and the offset of the images are saved
002156  002364  //       : in the image control so that image file (*.gci) can be mapped to directly.
002157  002365  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002158  002366  //       : internally. This means that there is no seek time penalty, however, the
002159  002367  //       : image list takes a lot longer to build, as all the seeking is done at control
002160  002368  //       : build time.
002161  002369        
002162  002370  //       : mode 2:- the graphics file with the is placed in a partitioned area
002163  002371  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002164  002372  //       : disk, and the absolute address of the images are saved in the DAT file
002165  002373  //       : This is the fastest operation of the image control as there is no seeking
002166  002374  //       : or other disk activity taking place.
002167  002375        
002168  002376  func file_Mount(), 1;
002169  002377  // Syntax: r := file_Mount();
002170  002378  // Usage : r := file_Mount();
002171  002379  // Notes : Create a control block for FAT16 and mount the File System
002172  002380        
002173  002381  func file_Unmount(), 0;
002174  002382  // Syntax: file_Unmount();
002175  002383  // Usage : file_Unmount();
002176  002384  // Notes : release any control block and buffers for FAT16
002177  002385  //       : and unmount the File System
002178  002386        
002179  002387  func file_PlayWAV("fname1"), 1;
002180  002388  // Syntax: file_PlayWAV("fname1");
002181  002389  // Usage : file_PlayWAV("ding.wav");
002182  002390  // Notes : Play a wave file with filename "fname1"
002183  002391  //       : This function automatically grabs a chunk
002184  002392  //       : of memory for a file buffer, and a wave
002185  002393  //       : buffer. The minimum memory requirement is
002186  002394  //       : about 580 bytes for the disk io service and
002187  002395  //       : a minimum wave buffer size of 1024. The siz
002188  002396  //       : of the wave buffer allocation
002189  002397  //       : can be increased by the snd_BufSize function.
002190  002398  //       : The default size 1024 bytes.
002191  002399  //       : NB the memory is only required during the
002192  002400  //       : duration of play, and is automatically
002193  002401  //       : released while not in use.
002194  002402  //       : See the Sound Class services for other associated controls.
002195  002403  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002196  002404  //       : If errors occured, the folling is returned
002197  002405  //       : -7  : Insufficient memory available for WAV buffer and file
002198  002406  //       : -6  : cant play this rate
002199  002407  //       : -5  : no data chunk found in first rsector
002200  002408  //       : -4  : no format data
002201  002409  //       : -3  : no wave chunk signature
002202  002410  //       : -2  : bad wave file format
002203  002411  //       : -1  : file not found
002204  002412        
002205  002413        
002206  002414        
002207  002415  //------------------------------------------------------------------//
002208  002416  //        Sound Class Services
002209  002417  //------------------------------------------------------------------//
002210  002418        
002211  002419  func snd_Volume("var"), 0;
002212  002420  // Syntax: snd_Volume("var");
002213  002421  // Usage : snd_Volume(30);
002214  002422  // Notes : set sound playback volume.  Var must
002215  002423  //       : be in the range from 8 (min volume)
002216  002424  //       : to 127 (max volume). If var is less
002217  002425  //       : than 8 volume is set to 8, and if
002218  002426  //       : var > 127 it is set to 127.
002219  002427        
002220  002428  func snd_Pitch("pitch"), 1;
002221  002429  // func snd_Pitch("freq"), 1;
002222  002430  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002223  002431  // Notes : sets the samples playback rate to a different frequency
002224  002432  //       : The minimum value is 4khz
002225  002433  //       : Setting the pitch to zero restores the original sample rate
002226  002434  //       : Return value is the samples original sample rate.
002227  002435        
002228  002436  func snd_BufSize("var"), 0;
002229  002437  // Syntax: snd_BufSize("var");
002230  002438  // Usage : snd_BufSize(2);
002231  002439  // Notes : specify the a memory chunk size for the wavefile buffer.
002232  002440  //       : default size 1024 bytes.
002233  002441  //       : 0 = 1024 bytes (default)
002234  002442  //       : 1 = 2048 bytes
002235  002443  //       : 2 = 4096 bytes
002236  002444  //       : 3 = 8192 bytes
002237  002445        
002238  002446  func snd_Stop(), 0;
002239  002447  // Syntax: snd_Stop();
002240  002448  // Usage : snd_Stop();
002241  002449  // Notes : stop any sound that is playing, releasing
002242  002450  //       : buffers and closes any open wav file.
002243  002451        
002244  002452  func snd_Pause(), 0;
002245  002453  // Syntax: snd_Pause();
002246  002454  // Usage : snd_Pause();
002247  002455  // Notes : pauses any sound that is playing, does nothing
002248  002456  //       : until sound is resumed with snd_Continue().
002249  002457  //       : The sample cam be terminated with snd_Stop.
002250  002458  //       : buffers and closes any open wav file.
002251  002459        
002252  002460  func snd_Continue(), 0;
002253  002461  // Syntax: snd_Continue();
002254  002462  // Usage : snd_Continue();
002255  002463  // Notes : resume any sound that is paused by snd_Pause.
002256  002464        
002257  002465  func snd_Playing(), 1;
002258  002466  // Syntax: snd_Playing();
002259  002467  // Usage : r := snd_Playing();
002260  002468  // Notes : returns 0 if sound has finished playing,
002261  002469  //       : else return number of 512 byte blocks to go.
002262  002470        
002263  002471        
002264  002472        
002265  002473  //------------------------------------------------------------------//
002266  002474  //        String Class Services
002267  002475  //------------------------------------------------------------------//
002268  002476        
002269  002477  func str_Ptr("&var"), 1;
002270  002478  // Syntax: str_Ptr(&var);
002271  002479  // Usage : p := str_Ptr(&var);
002272  002480  // Notes : return a byte pointer to a word region
002273  002481        
002274  002482  func str_GetD("&ptr", "&var"), 1;
002275  002483  // Syntax: str_GetD(&ptr, &var);
002276  002484  // Usage : ok := str_GetD(&ptr, &var);
002277  002485  // Notes : convert number in a string to DWORD ( myvar[2] )
002278  002486  //       : returns true if function succeeds, advancing ptr
002279  002487        
002280  002488  func str_GetW("&ptr", "&var"), 1;
002281  002489  // Syntax: str_GetW(&ptr, &var);
002282  002490  // Usage : ok := str_GetW(&ptr, &var);
002283  002491  // Notes : convert number in a string to WORD ( myvar )
002284  002492  //       : returns true if function succeeds, advancing ptr
002285  002493        
002286  002494  func str_GetHexW("&ptr", "&var"), 1;
002287  002495  // Syntax: str_GetHexW(&ptr, &var);
002288  002496  // Usage : ok := str_GetHexW(&ptr, &var);
002289  002497  // Notes : convert HEX number in a string to WORD ( myvar )
002290  002498  //       : returns true if function succeeds, advancing ptr
002291  002499        
002292  002500  func str_GetC("&ptr", "&var"), 1;
002293  002501  // Syntax: str_GetC(&ptr, &var);
002294  002502  // Usage : ok := str_GetC(&ptr, &var);
002295  002503  // Notes : get a valid ascii char in a string to WORD ( myvar )
002296  002504  //       : returns true if function succeeds, advancing ptr
002297  002505        
002298  002506  func str_GetByte("ptr"), 1;
002299  002507  // Syntax: str_GetByte(ptr);
002300  002508  // Usage : myvar := str_GetByte(ptr);
002301  002509  // Notes : get a byte to myvar
002302  002510  //       : returns value
002303  002511        
002304  002512  func str_GetWord("ptr"), 1;
002305  002513  // Syntax: GetWord(ptr);
002306  002514  // Usage : GetWord(ptr);
002307  002515  // Notes : get a word to myvar
002308  002516  //       : returns value
002309  002517        
002310  002518  func str_PutByte("ptr","val"), 0;
002311  002519  // Syntax: str_PutByte(ptr);
002312  002520  // Usage : myvar := str_PutByte(ptr);
002313  002521  // Notes : put a byte at ptr
002314  002522  //       : returns value
002315  002523        
002316  002524  func str_PutWord("ptr","val"), 0;
002317  002525  // Syntax: str_PutWord("ptr","val");
002318  002526  // Usage : str_PutWord(p,100);
002319  002527  // Notes : put word 100 at current pointer location
002320  002528  //       : returns value
002321  002529        
002322  002530  func str_Match("&ptr", "*str"), 1;
002323  002531  // Syntax: str_Match(&ptr, *str);
002324  002532  // Usage : r := str_Match(&p, "hello");
002325  002533  // Notes : Case sensitive match
002326  002534  //       : returns true if function succeded, andvancing pointer to position past
002327  002535  //       : the matched item. Note that any whitespace characters are skipped
002328  002536  //       : in the source string prior to the test.
002329  002537        
002330  002538  func str_MatchI("&ptr", "*str"), 1;
002331  002539  // Syntax: str_MatchI(&ptr, *str);
002332  002540  // Usage : r := str_MatchI(&p, "hello");
002333  002541  // Notes : Case insensitive match
002334  002542  //       : returns true if function succeded, andvancing pointer to position past
002335  002543  //       : the matched item. Note that any whitespace characters are skipped
002336  002544  //       : in the source string prior to the test.
002337  002545        
002338  002546  func str_Find("&ptr", "*str"), 1;
002339  002547  // Syntax: str_Find(&ptr, *str);
002340  002548  // Usage : n := str_Find(&p, "hello");
002341  002549  // Notes : given the address of a pointer to a source string as the
002342  002550  //       : first argument, and a pointer to a test string as the second
002343  002551  //       : argument, attempt to find the position of the matching string
002344  002552  //       : in the source string. The test is performed with case sensitivity.
002345  002553  //       : return 0 if not found, else returns the address of the first
002346  002554  //       : character of the match. NB:- The source pointer is not altered.
002347  002555        
002348  002556  func str_FindI("&ptr", "*str"), 1;
002349  002557  // Syntax: str_Find(&ptr, *str);
002350  002558  // Usage : n := str_Find(&p, "hello");
002351  002559  // Notes : given the address of a pointer to a source string as the
002352  002560  //       : first argument, and a pointer to a test string as the second
002353  002561  //       : argument, attempt to find the position of the matching string
002354  002562  //       : in the source string. The test is performed with no case
002355  002563  //       : sensitivity, eg upper and lower case chars are accepted.
002356  002564  //       : return 0 if not found, else returns the address of the first
002357  002565  //       : character of the match. NB:- The source pointer is not altered.
002358  002566        
002359  002567  func str_Length("ptr"), 1;
002360  002568  // Syntax: str_Length(ptr);
002361  002569  // Usage : len := str_Ptr(mystring);
002362  002570  // Notes : return the length of a byte aligned string excluding terminator
002363  002571        
002364  002572  func str_Printf("&ptr", "*format"), 1;
002365  002573  // Syntax: str_Printf("&ptr", "*format");
002366  002574  // Usage : r := str_Printf(&p, "%8s");
002367  002575  // Notes : refer to documentation
002368  002576  //       :
002369  002577        
002370  002578  func str_Cat("dest","src"), 1;
002371  002579  // Syntax: str_Append("&dest","&src");
002372  002580  // Usage : str_Append(&buf,"Hello");
002373  002581  // Notes : Appends a copy of the source string to the destination string.
002374  002582  //       : The terminating null character in destination is overwritten by
002375  002583  //       : the first character of source, and a new null-character is appended
002376  002584  //       : at the end of the new string formed by the concatenation of both in destination.
002377  002585  //       : returns destination.
002378  002586        
002379  002587  func str_CatN("dest","src","count"), 1;
002380  002588  // Syntax: str_Append("&dest","&src","count");
002381  002589  // Usage : str_Append(&buf,"Monday",3);
002382  002590  // Notes : Appends a copy of the source string to the destination string.
002383  002591  //       : The number of characters copied is limited by "count".
002384  002592  //       : The terminating null character in destination is overwritten by
002385  002593  //       : the first character of source, and a new null-character is appended
002386  002594  //       : at the end of the new string formed by the concatenation of both in destination.
002387  002595  //       : returns destination.
002388  002596        
002389  002597        
002390  002598  func sys_StoreTouchCalibration(), 1;
002391  002599  // Syntax: sys_StoreTouchCalibration();
002392  002600  // Usage : r := sys_StoreTouchCalibration();
002393  002601  // Notes : Store the touch calibration values in non-volatile memory.
002394  002602  //       : Returns true if the values have been accepted and stored,
002395  002603  //       : else returns false if write could not be performed, or
002396  002604  //       : touch calibration values are improbable.
002397  002605  //       : The values that are stored are obtained from:-
002398  002606  //     : TOUCH_XMINCAL             78  // touch calibration value
002399  002607  //     : TOUCH_YMINCAL             79  // touch calibration value
002400  002608  //       : TOUCH_XMAXCAL             80  // touch calibration value
002401  002609  //       : TOUCH_YMAXCAL             81  // touch calibration value
002402  002610  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002403  002611  //       : This function is not supported on uVGA, Capicitive touch
002404  002612  //       : and 4.3" resistive touch modules.
002405  002613        
002406  002614        
002407  002615  func unicode_page("charbeg","charend","charoffset"), 1;
002408  002616  // Syntax: unicode_page("charbeg","charend","charoffset");
002409  002617  // Usage : eg:  F_Traditional_0x20_0xFF
002410  002618  // Notes : After selecting a unicode image control with txt_FontID,
002411  002619  //       : this function is called to set the required font within the
002412  002620  //       : unicode set. The file "Unicode.inc" contains wrappers for
002413  002621  //       : this function, and it is not normally called directly.
002414  002622  //       : Returns count of characters in the set.
002415  002623  //       : Refer to "Unicode.inc" for further information.
002416  002624        
002417  002625        
002418  002626  func EVE_SP(), 1;
002419  002627  // Syntax: EVE_SP();
002420  002628  // Usage : eg:  print(EVE_SP());
002421  002629  // Notes : Used for debugging to assess the current stack level,
002422  002630  //       : mainly for checking stack leaks
002423  002631        
002424  002632  func EVE_SSIZE(), 1;
002425  002633  // Syntax: EVE_SSIZE();
002426  002634  // Usage : eg:  print(EVE_SSIZE());
002427  002635  // Notes : Used to get the stack size,
002428  002636  //       : mainly for debugging purposes
002429  002637        
002430  002638        
002431  002639  // uVGAII extended functions
002432  002640  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002433  002641  // Syntax: disp_Sync(line);
002434  002642  // Usage : disp_Sync(480);
002435  002643  // Notes : Waits till the hardware gets to a certain line.
002436  002644  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002437  002645  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002438  002646  //       : depending on the graphics operation. The higher the value, the slower
002439  002647  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002440  002648  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002441  002649  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002442  002650  //       : be slowest (as its actually right at the end of the blanking period) and 508
002443  002651  //       : will cause a hangup situation as it is above the highes scanline value.
002444  002652  //       : Currently, this function is only supported on displays with SSD1963 driver.
002445  002653        
002446  002654        
002447  002655  // New functions added to PmmC v2.8
002448  002656  //================================================================
002449  002657  func CY(), 1;
002450  002658  // Syntax: CY();
002451  002659  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002452  002660  //       : print(myvar," "CY(),"\n");           // carry = 1
002453  002661  // Notes : This function returns the carry status of an
002454  002662  // unsigned overflow from any 16 or 32bit additions or sutractions.
002455  002663  //================================================================
002456  002664        
002457  002665        
002458  002666  //================================================================
002459  002667  func str_ByteMove("src", "dest", "count"), 1;
002460  002668  // func str_ByteMove("src", "dest", "count"), 1;
002461  002669  // Syntax   : str_ByteMove(src, dest, bytecount);
002462  002670  // Input    : STR *source points to byte aligned source.
002463  002671  //          : STR *dest   points to byte aligned destination.
002464  002672  //          : VAR count   number of bytes to transfer.
002465  002673  // Usage    : nextpos := str_ByteMove(s, d, 100);
002466  002674  // Notes    : copy bytes from "src" to "dest", stopping only
002467  002675  //          : when "count" is exhausted.
002468  002676  //          : No terminator is appended, it is purely a
002469  002677  //          : byte copy, and any zeroes encountered will
002470  002678  //          : also be copied.
002471  002679  // Returns  : returns a pointer to the end of the destination
002472  002680  //          : (which is "dest" + "count")
002473  002681  //================================================================
002474  002682        
002475  002683        
002476  002684  //================================================================
002477  002685  func str_Copy("dest", "src"), 1;
002478  002686  // Syntax   : str_Copy(dest, src);
002479  002687  // Input    : STR *dest   points to byte aligned destination.
002480  002688  //          : STR *source points to byte aligned source.
002481  002689  // Usage    : nextplace := str_Copy(d, s);
002482  002690  // Notes    : copy a string from "src" to "dest", stopping only
002483  002691  //          : when the end of source string "src" is encountered
002484  002692  //          : (0x00 terminator).
002485  002693  //          : The terminator is always appended, even if "src" is
002486  002694  //          : an empty string.
002487  002695  // Returns  : returns a pointer to the 0x00 string terminator at
002488  002696  //          : end of "dest" (which is "dest" + str_Length(src); )
002489  002697  //================================================================
002490  002698        
002491  002699  //================================================================
002492  002700  func str_CopyN("dest", "src", "count"), 1;
002493  002701  // Syntax   : str_CopyN(dest, src, bytecount);
002494  002702  // Input    : STR *dest   points to byte aligned destination.
002495  002703  //          : STR *source points to byte aligned source.
002496  002704  //          : VAR count   max number of chars to copy.
002497  002705  // Usage    : nextplace := str_CopyN(d, s, 100);
002498  002706  // Notes    : copy a string from "src" to "dest", stopping only
002499  002707  //          : when "count" is exhausted, or end of source
002500  002708  //          : string "str" is encountered (0x00 string terminator).
002501  002709  //          : The terminator is always appended, even if
002502  002710  //          : "count" is zero, or "src" is a null string.
002503  002711  // Returns  : returns a pointer to the 0x00 string terminator
002504  002712  //          : (which is "dest" + whatever was copied)
002505  002713  //================================================================
002506  002714        
002507  002715  //================================================================
002508  002716  func umul_1616("&res32", "val1", "val2"), 1;
002509  002717  // Syntax   : umul_1616(&res32, varA, varB);
002510  002718  // Input    : DWORD *result   points to 32bit result register.
002511  002719  //          : VAR   val1  16bit register or constant
002512  002720  //          : VAR   val2  16bit register or constant
002513  002721  // Usage    : var res32[2];
002514  002722  //          : umul_1616(&res32, myvar, 50000);
002515  002723  // Notes    : performs an unsigned multiply of 2 x 16bit values
002516  002724  //          : placing the 32bit result in a 2 word array.
002517  002725  // Returns  : the pointer to the 32bit result.
002518  002726  //          : carry and overflow are not affected.
002519  002727  //================================================================
002520  002728        
002521  002729  //================================================================
002522  002730  func uadd_3232("&res32", "&val1", "&val2"), 1;
002523  002731  // Syntax   : cmp_3232(&res32, &varA, &varB);
002524  002732  // Input    : DWORD *res32 points to optional result (or zero for compare)
002525  002733  //          : DWORD *val1 points to 32bit augend
002526  002734  //          : DWORD *val2 points to 32bit addend
002527  002735  // Usage    : var res32[2];
002528  002736  //          : res := cmp_3232(res32, val1, val2);
002529  002737  // Notes    : performs an unsigned addition of 2 x 32bit values
002530  002738  //          : placing the 32bit result in a 2 word array.
002531  002739  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002532  002740  //          ; carry flag is also set on 32bit unsigned overflow
002533  002741  //          ; and can be read with the CY() function.
002534  002742  //================================================================
002535  002743        
002536  002744  //================================================================
002537  002745  func usub_3232("&res32", "&val1", "&val2"), 1;
002538  002746  // Syntax   : cmp_3232(&res32, &varA, &varB);
002539  002747  // Input    : DWORD *res32 points to optional result (or zero for compare)
002540  002748  //          : DWORD *val1 points to first 32bit minuend
002541  002749  //          : DWORD *val2 points to 32bit subtrahend
002542  002750  // Usage    : var res32[2];
002543  002751  //          : res := cmp_3232(res32, val1, val2);
002544  002752  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002545  002753  //          : placing the 32bit result in a 2 word array.
002546  002754  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002547  002755  //          ; carry flag is also set on 32bit unsigned underflow
002548  002756  //          ; and can be read with the CY() function.
002549  002757  //================================================================
002550  002758        
002551  002759  //================================================================
002552  002760  func ucmp_3232("&val1", "&val2"), 1;
002553  002761  // Syntax   : cmp_3232(&varA, &varB);
002554  002762  // Input    : DWORD *val1 points to 32bit minuend
002555  002763  //          : DWORD *val2 points to 32bit sutrahend
002556  002764  // Usage    : res := cmp_3232(val1, val2);
002557  002765  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002558  002766  //          : The result of the subtraction is returned.
002559  002767  // Returns  : 0  if equal
002560  002768  //          : 1  if val1 > val2
002561  002769  //          : -1 if val1 < val2
002562  002770  //          : This function does not affect the carry flag.
002563  002771  //================================================================
002564  002772        
002565  002773  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002566  002774  // Syntax: disp_Disconnect();                  New in v3.8
002567  002775  // Usage : disp_Disconnect();
002568  002776  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002569  002777  //       : its lowest possible power consumption. Use after disabling peripheral power
002570  002778  //       : to ensure the minimal power usage by the display.
002571  002779  //       : disp_Init() should be used to reinitialise the display.
002572  002780        
002573  002781  func reserved(), 0;                            
002574  002782        
002575  002783  func sys_DeepSleep("units"), 1;
002576  002784  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002577  002785  // Usage : t := sys_DeepSleep(10);
002578  002786  // Notes : sets the display and processor into lowest power mode for a period of time.
002579  002787  //       : When returning from DeepSleep the display should be reinitialised
002580  002788  //       : with disp_Init().
002581  002789  //       : Touching the touch screen will also wake from sleep.
002582  002790  //       : Returns remaining sleep units.
002583  002791        
002584  002792  func sys_PmmC(), 1;
002585  002793  // Syntax: sys_PmmC();
002586  002794  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer, new in v4.6
002587  002795  // Notes : print the system PmmC name and revision eg "Picaso\n4.6"
002588  002796  //       : Can be captured to a buffer using the to( function
002589  002797  //       : Returns PmmC version as a hex number, eg 0x46
002590  002798        
002591  002799  func sys_Driver(), 0;
002592  002800  // Syntax: sys_Driver();
002593  002801  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer, new in v4.6
002594  002802  // Notes : print the system PmmC name and revision eg "uLCD-32PTU"
002595  002803  //       : Can be captured to a buffer using the to( function
002596  002804  //       : Returns nothing.
002597  002805        
002598  002806  func OW_Reset("pin"), 1;                             // issue 1wire reset command
002599  002807  // Syntax   : OW_Reset(PA0);
002600  002808  // Usage    : OW_Reset(PA0);
002601  002809  // Notes    : Only available on PA0 to PA13
002602  002810  //          : Resets  ONEWIRE device
002603  002811  //          : Returns the status, 0 = ACK.
002604  002812  //          :
002605  002813        
002606  002814  func OW_Read("pin"), 1;                              // read data from 1wire bus
002607  002815  // Syntax   : OW_Read(PA0);
002608  002816  // Usage    : arg1 := OW_Read(PA0);
002609  002817  // Notes    : Only available on PA0 to PA13
002610  002818  //          : Reads value of the ONEWIRE pin
002611  002819  //          : that was previously selected for ONEWIRE comms.
002612  002820  //          :
002613  002821  //          : pin = 0 : the next byte from the ONEWIRE bus
002614  002822        
002615  002823  func OW_Read9("pin"), 1;                             // read data from 1wire bus, 9bit mode
002616  002824  // Syntax   : OW_Read9(PA0);
002617  002825  // Usage    : OW_Read9(PA0);
002618  002826  // Notes    : Only available on PA0 to PA13
002619  002827  //          : Reads 9 bit value of the appropriate ONEWIRE pin
002620  002828  //          : that was previously selected for ONEWIRE comms.
002621  002829  //          :
002622  002830  //          : read the 9 bits from the ONEWIRE bus
002623  002831        
002624  002832  func OW_Write("pin", "value"), 0;                      // write value to 1wire device
002625  002833  // Syntax   : OW_Write(PA0, arg);
002626  002834  // Usage    : OW_Write(PA0, arg);
002627  002835  // Notes    : Only available on PA0 to PA13
002628  002836  //          : Sends ONEWIRE data on the appropriate
002629  002837  //          : pin that was previously  selected as ONEWIRE comms.
002630  002838  //          :
002631  002839  //          : write arg to the ONEWIRE bus
002632  002840        
002633  002841  func snd_Freq("Freq", "Duration"), 1;
002634  002842  // Syntax	: snd_Freq("Freq", "Duration");
002635  002843  // Usage	: r := snd_Freq(1000, 2000);
002636  002844  // Notes	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002637  002845  // 	: else return True.
002638  002846  // 	: Minimum Freq is 20
002639  002847  // 	: This will produce a pure Square wave and is designed for driving
002640  002848  // 	: Piezo transducers which require this sort of drive. It can be used
002641  002849  // 	: directly with high impedience speakers.
002642  002850        
002643  002851  func gfx_SpriteSet("bitmaps", "colours", "palette"), 0;
002644  002852  // Syntax   : gfx_SpriteSet("bitmaps", "colours", "palette");
002645  002853  // Usage    : gfx_SpriteSet(mysprites, mycolours, mypalette);
002646  002854  // Notes    : 3 sets of data are required by the sprite generator,
002647  002855  //          : this function sets the internal pointers for the 3 parts.
002648  002856  //          : 1] the bitmaps for the sprites,
002649  002857  //          : 2] the colour lookup table (CLUT),
002650  002858  //          : 3] the 4 colour palettes.
002651  002859        
002652  002860        
002653  002861  func gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage"), 0;
002654  002862  // Syntax 	: gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage");
002655  002863  // Usage 	: gfx_BlitSprite(1,2,10,10,SOUTH,0);  // example show a cherry upside down using the third palette of mypalette
002656  002864  // Notes 	: Places the required sprite bitmap at the origin xpos, ypos using the required 4 colour palette.
002657  002865  //  	: orientation determines in which direction the sprite will be displayed.
002658  002866  //    	: if preimage exists it should be large enough to hold the entire image 'underneath' the sprite.
002659  002867        
002660  002868  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
002661  002869  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
002662  002870  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
002663  002871  // Notes   : reads an arbitrary rectangular area from the display to an array.
002664  002872  //         : If "ptr" is 0, the correctly sized array is created, in which case
002665  002873  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
002666  002874  //         : is expected to point to a correctly sized array.
002667  002875  //         : NB if an array is supplied, its size must be large enough, and may
002668  002876  //         : be calculated:-
002669  002877  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
002670  002878  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
002671  002879  // Returns : A pointer to the created aray, or the users array.
002672  002880  //         : In the case of ptr=0, if there is insufficient
002673  002881  //         : memory to create the array, zero is returned
002674  002882        
002675  002883        
002676  002884  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
002677  002885  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
002678  002886  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
002679  002887  // Notes   : "ptr" points to the array to be written.
002680  002888  // Returns : nothing
002681  002889        
002682  002890  func rect_Intersect("&rect1", "&rect2"), 1;
002683  002891  // Syntax   : rect_Intersect(&rect1, &rect2);
002684  002892  // Usage    : rect_Intersect(box1, box2);
002685  002893  // Notes    : return true if any part of rect1 is within rect2
002686  002894  //          : each rectangle is an array of 4 words in the format:-
002687  002895  //	    : element 0 = RECT_LEFT			
002688  002896  //	    : element 1 = RECT_TOP			
002689  002897  //	    : element 2 = RECT_WIDTH 		
002690  002898  //	    : element 3 = RECT_HEIGHT 
002691  002899  //          : This function is ideal for use as a collision detector.		
002692  002900        
002693  002901  func rect_Within("&rect1", "&rect2"), 1;
002694  002902  // Syntax   : rect_Within(&rect1, &rect2);
002695  002903  // Usage    : rect_Within(box1, box2);
002696  002904  // Notes    : return true if rect1 is fully within rect2
002697  002905  //          : each rectangle is an array of 4 words in the format:-
002698  002906  //	    : element 0 = RECT_LEFT			
002699  002907  //	    : element 1 = RECT_TOP			
002700  002908  //	    : element 2 = RECT_WIDTH
002701  002909  //	    : element 3 = RECT_HEIGHT 
002702  002910        
002703  002911  func snd_RTTTL("TunePtr",), 1;                           // play a RTTTL tune string
002704  002912  // Syntax	: snd_RTTTL(TunePtr);
002705  002913  // Usage	: snd_RTTTL("...notes...");
002706  002914  // Notes	: Play an RTTTL tune string from a data statement or a direct string
002707  002915  // 	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002708  002916        
002709  002917  func joystick("Pin"), 1;                                     // read the joystick value
002710  002918  // Syntax   : Joystick("Pin");
002711  002919  // Usage    : var := Joystick(IO1_PIN);
002712  002920  // *Notes   : Returned values are:-
002713  002921  //          :    JOY_RELEASED 0
002714  002922  //          :    JOY_UP       1
002715  002923  //          :    JOY_LEFT     2
002716  002924  //          :    JOY_DOWN     3
002717  002925  //          :    JOY_RIGHT    4
002718  002926  //          :    JOY_BTNB     5
002719  002927  //          :    JOY_BTNA     6
002720  002928        
002721  002929  func gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour"), 0;         // display an Annular ring segment
002722  002930  // Syntax 	: gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour") ;
002723  002931  // Usage 	: gfx_RingSegment(x, y, starta, enda, rx, w, colour) ;
002724  002932  // Notes 	: Draw a Segment of a ring at x, y from rad1 to rad2 starting at starta to enda
002725  002933  // 	: in colour.
002726  002934  //
002727  002935        
002728  002936  func gfx_AngularMeter("value", "&MeterRam", "&MeterDef"), 0;                           // draw an angular meter scale and value
002729  002937  // Syntax 	: gfx_AngularMeter("value", "&MeterRam", "&MeterDef") ;
002730  002938  // Usage 	: gfx_AngularMeter(value, MeterRam, MeterDef) ;
002731  002939  // Notes 	: Draw an Angular Meter as defined by MeterDef (if required), using MeterRam positioning at
002732  002940  // 	: position value. See the reference for the MeterDef values
002733  002941  //
002734  002942        
002735  002943  // AngularMeter constants
002736  002944  #CONST
002737  002995  #END
002738  002996        
002739  002997  #constant PANEL2_FILLED 0x8000
002740  002997  #constant PANEL2_FILLED 0x8000
002741  002998        
002742  002999  func gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf"), 0;                           // draw a windows style 3D panel
002743  003000  // Syntax 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002744  003001  // Usage 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002745  003002  // Notes	: Draws a panel2 (groupbox) at screen location defined by
002746  003003  // 	: x, y, width and height with left colour "cl", right colour "cr" and option fill colour "cf".
002747  003004  // 	:  w1 and w2 define the width of the outer and inner borders.
002748  003005  // 	:         state = 0 : recessed
002749  003006  // 	:         state = 1 : raised
002750  003007  // 	: 	  or state with PANEL2_FILLED to draw the fill
002751  003008        
002752  003009  func gfx_Needle("value", "&NeedleRam", "&NeedleDef"), 0;                           // draw a needle on a meter base
002753  003010  // Syntax 	: gfx_Needle("value", "&NeedleRam", "&NeedleDef") ;
002754  003011  // Usage 	: gfx_Needle(value, NeedleRam, NeedleDef) ;
002755  003012  // Notes 	: Draw a Needle as defined by NeedleDef (if required), using NeedleRam positioning at
002756  003013  // 	: position value. See the reference for the NeedleDef values
002757  003014  //
002758  003015        
002759  003016  #CONST
002760  003038  #END
002761  003039        
002762  003040  #CONST
002763  003047  #END
002764  003048        
002765  003049  func gfx_Dial("value", "&DialRam", "&DialDef"), 0;                           // draw a Dial / knob
002766  003050  // Syntax 	: gfx_Dial("value", "&DialRam", "&DialDef") ;
002767  003051  // Usage 	: gfx_Dial(value, DialRam, DialDef) ;
002768  003052  // Notes 	: Draw a Dial as defined by DialDef (if required), using DialRam positioning at
002769  003053  // 	: position value. See the reference for the DialDef values
002770  003054  //
002771  003055        
002772  003056  #CONST
002773  003114  #END
002774  003115        
002775  003116  func gfx_Gauge("value", "&GaugeRam", "&GaugeDef"), 0;                           // draw a gauge
002776  003117  // Syntax 	: gfx_Gauge("value", "&GaugeRam", "&GaugeDef") ;
002777  003118  // Usage 	: gfx_Gauge(value, GaugeRam, GaugeDef) ;
002778  003119  // Notes 	: Draw a Gauge as defined by GaugeDef (if required), using GaugeRam positioning at
002779  003120  // 	: position value. See the reference for the GaugeDef values
002780  003121  //
002781  003122        
002782  003123  #CONST
002783  003148  #END
002784  003149        
002785  003150  // widget_* functions
002786  003151  //
002787  003152  #CONST
002788  003185  #END
002789  003186        
002790  003187  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
002791  003188  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
002792  003189  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
002793  003190  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
002794  003191  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
002795  003192  //         : to be used for rounded panels, rounded buttons, circular buttons.
002796  003193  //         : "style" specifies the drawing mode
002797  003194  //         :     GRAD_DOWN         // gradient changes in the vertical direction
002798  003195  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
002799  003196  //         :     GRAD_UP           // gradient changes in the vertical direction
002800  003197  //         :     GRAD_LEFT         // gradient change in the horizontal direction
002801  003198  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
002802  003199  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
002803  003200  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
002804  003201  // Returns : nothing.
002805  003202        
002806  003203        
002807  003204  //------------------------------------------------------------------//
002808  003205  //     gradient control constants                                   //
002809  003206  //------------------------------------------------------------------//
002810  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002811  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002812  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002813  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002814  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002815  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002816  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002817  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002818  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002819  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002820  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002821  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002822  003213        
002823  003214  #CONST
002824  003217  #END
002825  003218        
002826  003219  #CONST
002827  003251  #END
002828  003252        
002829  003253  func gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef"), 0;                           // draw a value to a series of 7 segment led Digits
002830  003254  // Syntax 	: gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef");
002831  003255  // Usage 	: gfx_LedDigits(value, LedDigitRam, LedDigitDef);
002832  003256  // Notes 	: Draw a series of 7 segment Led Digits as defined by LedDigitDef, using LedDigitRam positioning at
002833  003257  // 	: position value. See the reference for LedDigitDef values.
002834  003258  //
002835  003259        
002836  003260  func gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value"), 0;                           // draw a single 7 segment led digit
002837  003261  // Syntax 	: gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value");
002838  003262  // Usage 	: gfx_LedDigit(x, y, digitsize, oncolour, offcolour, value);
002839  003263  // Notes 	: Draws a single 7 segment led Digit at x, y of size digitsize using oncolour and offcolour.
002840  003264  // 	: The value can be 0-9 (0-9), A-F (0x0a-0x0f), blank(0x10) and - (0x11).
002841  003265  //      : Or value with LEDDIGIT_F_SHOW_DP to show a decimal point, LEDDIGIT_F_DP_COMMA to make the Decimal
002842  003266  // 	: point a comma and LEDDIGIT_F_DP_ON to turn the decimal point on
002843  003267  // 	:
002844  003268  // 	: LEDDIGIT_F_SET_SEGMENTS can be used to turn value into a series of bits to turn on individual segments
002845  003269  //      : eg LEDDIGIT_F_SET_SEGMENTS + 9 will turn on the top and bottom segments. Again LEDDIGIT_F_SHOW_DP and
002846  003270  // 	: LEDDIGIT_F_DP_COMMA can be used, but in this case the DP is the 8th segment. 
002847  003271  // Returns : nothing.
002848  003272        
002849  003273  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
002850  003274  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
002851  003275  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
002852  003276  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
002853  003277  //         : determined by "radius". 
002854  003278  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
002855  003279  // Returns : nothing.
002856  003280        
002857  003281  func putstrCentred("xc", "yc", "string"), 0;
002858  003282  // Syntax  : putstrCentred(x, y, "string"),
002859  003283  // Usage   : putstrCentred(100, 100, "HELLO");
002860  003284  // Notes   : Print a string centred at position x, y
002861  003285  //         : "String" may be a string constant, or pointer to a word aligned string.
002862  003286  // Returns : nothing.
002863  003287        
002864  003288  func widget_Create("count"), 1;
002865  003289  // Syntax 	: widget_Create("count"),
002866  003290  // Usage  	: widget_Create(count);
002867  003291  // Notes  	: Creates a widget Control capable of hoolding count elements and returns
002868  003292  //        	: a handle for the control.
002869  003293  // Returns	: Widget control handle.
002870  003294        
002871  003295  func widget_Add("hndl", "index", "widget"), 1;
002872  003296  // Syntax 	: widget_Add("hndl", "index", "widget"),
002873  003297  // Usage  	: widget_Add(hndl, index, widget);
002874  003298  // Notes  	: Add a widget ram entry "widget" into index "index" of the widget control referenced
002875  003299  //        	: by "hndl".
002876  003300  // Returns	: ssnothing.
002877  003301        
002878  003302  func widget_Delete("hndl", "index"), 1;
002879  003303  // Syntax 	: widget_Delete("hndl", "index"),
002880  003304  // Usage  	: widget_Delete(hndl, index);
002881  003305  // Notes  	: Delete widget ram entry "index" from the widget control referenced by "hndl".
002882  003306  // Returns	: sssnothing.
002883  003307        
002884  003308  func widget_Show("hndl", "index"), 1;
002885  003309  // Syntax	: widget_Show(handle, index);
002886  003310  // Usage	: display a flash resident image entry.
002887  003311  // Returns	: TRUE if successful, return value usually ignored.
002888  003312        
002889  003313  func widget_LoadFlash("Extra"), 1;
002890  003314  // Syntax	: hImagelist := widget_LoadFlash("Extra") ;
002891  003315  // Usage 	: hImagelist := widget_LoadFlash(0);
002892  003316  // Notes	: Reads the flash control file to create an widget list.
002893  003317  //      	: Returns NULL if function fails.
002894  003318  //      	: Returns a handle (pointer to the memory allocation) to the
002895  003319  //      	: widget control list that has been created.
002896  003320  //      	: "Extra" is the number of extra widget controls to be created
002897  003321  //      	: beyond the count in flash memory
002898  003322  // Returns 	: pointer to Widget control, or null if failed.
002899  003323        
002900  003324  func widget_Realloc("handle", "n"), 1;
002901  003325  // Syntax	: widget_Realloc(handle, n);
002902  003326  // Usage 	: Resizes a widget control to contain n entries, allowing it to be expanded or
002903  003327  //      	: condensed. Doing this unnecessarily can lead to RAM fragmentation. It is
002904  003328  //             	: much better to allocate widget controls once with the desired number of entries.
002905  003329  // Returns	: new handle to widget control.
002906  003330        
002907  003331  func widget_GetWord("hndl", "index", "offset"), 1;
002908  003332  // Syntax	: myvar := widget_GetWord("handle", "index", "offset");
002909  003333  // Usage 	: myvar := widget_GetWord(hndl, 5, WIDGET_YPOS);
002910  003334  // Notes 	: returns specified word (0-14) from a widget entry
002911  003335  //       	: refer to widget control entry offsets.
002912  003336        
002913  003337  func widget_Setposition("hndl", "index", "xpos", "ypos"), 1;
002914  003338  // Syntax	: widget_SetPosition(handle, index, xpos, ypos);
002915  003339  // Usage 	: r := widget_SetPosition(hImageList, imagenum, x, y);
002916  003340  // Notes 	: set the position of the widget control
002917  003341  //       	: returns true if index was ok and function was successful.
002918  003342        
002919  003343  func widget_Enable("hndl", "index"), 1;
002920  003344  // Syntax	: widget_Enable(handle, index);
002921  003345  // Usage 	: r := widget_Enable(hImageList, imagenum);
002922  003346  // Notes 	: enable an item in a widget control.
002923  003347  // Returns     	: true if index was ok and function was successful.
002924  003348        
002925  003349  func widget_Disable("hndl", "index"), 1;
002926  003350  // Syntax	: widget_Disable(handle, index);
002927  003351  // Usage 	: r := widget_Disable(hImageList, imagenum);
002928  003352  // Notes 	: disable an inetm in a widget control.
002929  003353  // Returns      : true if index was ok and function was successful.
002930  003354        
002931  003355  func widget_SetWord("hndl", "index", "offset", "value"), 1;
002932  003356  // Syntax: widget_SetWord(handle, index, offset, word);
002933  003357  // Usage : widget_SetWord(hndl, 5, IMAGE_XPOS, 10);
002934  003358  // Notes : set specified word (0-7) in a image entry
002935  003359  //       : returns TRUE if successful, return value usually ignored.
002936  003360        
002937  003361  func widget_SetAttributes("hndl", "index", "value"), 1;
002938  003362  // Syntax: widget_SetAttributes("handle", "index","offset");
002939  003363  // Usage : widget_SetAttributes(hndl, 5, I_TOPMOST);
002940  003364  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
002941  003365  //       : of an image control entry. "value" refers to various bits in
002942  003366  //       : the image control entry (see image attribute flags).
002943  003367  //       : A '1' bit in the "value" field SETS the respective bit
002944  003368  //       : in the IMAGE_FLAGS field of the image control entry.
002945  003369  //       : returns TRUE if successful, return value usually ignored.
002946  003370        
002947  003371  func widget_ClearAttributes("hndl", "index", "value"), 1;
002948  003372  // Syntax: widget_ClearAttributes("handle", "index","offset");
002949  003373  // Usage : widget_ClearAttributes(hndl, 5, I_TOPMOST);
002950  003374  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
002951  003375  //       : of an image control entry. "value" refers to various bits in
002952  003376  //       : the image control entry (see image attribute flags)
002953  003377  //       : a '1' bit in the "value" field CLEARS the respective bit
002954  003378  //       : in the IMAGE_FLAGS field of the image control entry.
002955  003379  //       : returns TRUE if successful, return value usually ignored.
002956  003380        
002957  003381  func widget_Touched("hndl", "index"), 1;
002958  003382  // Syntax: r := widget_Touched(handle, index);
002959  003383  // Usage : widget_Touched(hndl, 17);
002960  003384  //       : returns -1 if image not touched, or returns index
002961  003385  // Notes : if index is passed as -1, function tests all images,
002962  003386  //       : and returns -1 if image not touched, or returns index.
002963  003387        
002964  003388  func widget_FontID("id"), 1;                   // text font ID for flash based font
002965  003389  // Syntax: widget_FontID(id);
002966  003390  // Usage : widget_FontID(0);
002967  003391  //       : returns id of previous font
002968  003392        
002969  003393  #CONST
002970  003431  #END
002971  003432        
002972  003433  func gfx_Slider5("value", "&SliderRam", "&SliderDef"), 0;                           // draw a slider
002973  003434  // Syntax 	: gfx_Slider5("value", "&SliderRam", "&SliderDef") ;
002974  003435  // Usage 	: gfx_Slider5(value, SliderRam, SliderDef) ;
002975  003436  // Notes 	: Draw a Slider as defined by SliderDef (if required), using SliderRam positioning at
002976  003437  // 	: position value. See the reference for the SliderDef values
002977  003438  //
002978  003439        
002979  003440  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
002980  003441  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
002981  003442  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
002982  003443  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
002983  003444  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
002984  003445  //         : If "radius1" is zero, the inner rectangle will have square corners.
002985  003446  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
002986  003447  // Returns : nothing.
002987  003448        
002988  003449  /////////////////////
002989  003450  #CONST
002990  003469  #END
002991  003470        
002992  003471  func gfx_Switch("state", "&SwitchRam", "&SwitchDef"), 0;                           // draw a switch
002993  003472  // Syntax 	: gfx_Switch("state", "&SwitchRam", "&SwitchDef") ;
002994  003473  // Usage 	: gfx_Switch(state, SwitchRam, SwitchDef) ;
002995  003474  // Notes 	: Draw a Switch as defined by SwitchDef (if required), using SwitchRam positioning at
002996  003475  // 	: position value. See the reference for the SwitchDef values
002997  003476  //
002998  003477        
002999  003478  #CONST
003000  003507  #END
003001  003508        
003002  003509  func gfx_Button4("state", "&gfx_ButtonRam", "&gfx_ButtonDef"), 0;                           // draw a button
003003  003510  // Syntax 	: gfx_Button4("state", "&ButtonRam", "&ButtonDef") ;
003004  003511  // Usage 	: gfx_Button4(state, ButtonRam, ButtonDef) ;
003005  003512  // Notes 	: Draw a Button as defined by ButtonDef (if required), using ButtonRam positioning at
003006  003513  // 	: position value. See the reference for the ButtonDef values
003007  003514  //
003008  003515        
003009  003516  #CONST
003010  003531  #END
003011  003532        
003012  003533  func gfx_Led("state", "&LedRam", "&LedDef"), 0;                           // draw an LED
003013  003534  // Syntax 	: gfx_Led("state", "&LedRam", "&LedDef") ;
003014  003535  // Usage 	: gfx_Led(state, LedRam, LedDef) ;
003015  003536  // Notes 	: Draw a Led as defined by LedDef (if required), using LedRam positioning in
003016  003537  // 	: state state. See the reference for the LedDef values
003017  003538  //
003018  003539        
003019  003540  #CONST
003020  003558  #END
003021  003559  #CONST
003022  003577  #END
003023  003578        
003024  003579  func gfx_Scale("&ScaleRam", "&ScaleDef"), 0;                           // draw a Scale
003025  003580  // Syntax 	: gfx_Scale("&ScaleRam", "&ScaleDef") ;
003026  003581  // Usage 	: gfx_Scale(ScaleRam, ScaleDef) ;
003027  003582  // Notes 	: Draw a Scale as defined by ScaleDef, setting LedRam for use in touch processing.
003028  003583  // 	: See the reference for the ScaleDef values. If touch processing is not required 0 may be used as the SclaleRam parameter.
003029  003584  //
003030  003585        
003031  003586  #CONST
003032  003590  #END
003033  003591        
003034  003592  #CONST
003035  003612  #END
003036  003613        
003037  003614  func gfx_RulerGauge("state", "&RulerGaugeRam", "&RulerGaugeDef"), 0;                           // draw a Ruler Gauge
003038  003615  // Syntax 	: gfx_Led("position", "&RulerGaugeRam", "&RulerGaugeDef") ;
003039  003616  // Usage 	: gfx_Led(position, RulerGaugeRam, RulerGaugeDef) ;
003040  003617  // Notes 	: Draw a RulerGauge as defined by RulerGaugeDef (if required), using RulerGaugeRam positioning at
003041  003618  // 	: position value. See the reference for the RulerGaugeDef values
003042  003619  //
003043  003620        
003044  003621  #CONST
003045  003631  #END
003046  003632        
003047  003633  func file_CheckUpdate("Filename", "Options"), 1;                           // check and/or update the program running in Flash
003048  003634  // Syntax 	: file_CheckUpdate("Filename", "Options") ;
003049  003635  // Usage 	: file_CheckUpdate("thisfile.4xe", CheckUpdate_Check) ;
003050  003636  // Notes 	: Check and/or update the program running in flash using the specified file on uSD.
003051  003637  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003052  003638  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003053  003639  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003054  003640  //
003055  003641  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003056  003642  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003057  003643  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003058  003644  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003059  003645  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003060  003646  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003061  003647        
003062  003648  func udiv_3232("res32", "val1", "val2"), 1;
003063  003649  // Syntax   : udiv_1616(res32, varA, varB);
003064  003650  // Input    : DWORD *result   points to 32bit result register.
003065  003651  //          : DWORD   val1  pointer to 32bit value (dividend)
003066  003652  //          : DWORD   val2  pointer to 32bit value (divisor)
003067  003653  // Usage    : var res32[2];
003068  003654  //          : umul_1616(res32, myvar, 50000);
003069  003655  // Notes    : performs an unsigned division of 2 x 32bit values
003070  003656  //          : placing the 32bit result in a 2 word array.
003071  003657  // Returns  : the pointer to the 32bit result.
003072  003658  //          : carry and overflow are not affected.
003073  003659        
003074  003660  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
003075  003661  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
003076  003662  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
003077  003663  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
003078  003664  //         : "style" specifies the drawing mode
003079  003665  //         :     GRAD_DOWN         // gradient changes in the vertical direction
003080  003666  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
003081  003667  //         :     GRAD_UP           // gradient changes in the vertical direction
003082  003668  //         :     GRAD_LEFT         // gradient change in the horizontal direction
003083  003669  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
003084  003670  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
003085  003671  // Returns : nothing.
003086  003672        
003087  003673  func I2C2_Open("speed"), 1;
003088  003674  // Syntax : I2C2_Openx(speed),
003089  003675  // Usage  : I2C2_Open(I2C_MED);
003090  003676  // Notes : configures the I2C1 module
003091  003677  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003092  003678  // Returns: True if successful
003093  003679        
003094  003680        
003095  003681  func I2C3_Open("speed"), 1;
003096  003682  // Syntax : I2C3_Openx(speed),
003097  003683  // Usage  : I2C3_Open(I2C_MED);
003098  003684  // Notes : configures the I2C1 module
003099  003685  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003100  003686  // Returns: True if successful
003101  003687        
003102  003688  func I2C2_Close(), 0;
003103  003689  // Usage : I2C2_Close();
003104  003690  // Notes : disables the I2C2 module.
003105  003691        
003106  003692  func I2C3_Close(), 0;
003107  003693  // Usage : I2C3_Close();
003108  003694  // Notes : disables the I2C3 module.
003109  003695        
003110  003696  func I2C2_Start(), 1;
003111  003697  // Syntax: I2C2_Start();
003112  003698  // Usage : I2C2_Start();
003113  003699  // Notes : generates a Start condition.
003114  003700  //       : returns true if successful (usually ignored)
003115  003701        
003116  003702  func I2C3_Start(), 1;
003117  003703  // Syntax: I2C3_Start();
003118  003704  // Usage : I2C3_Start();
003119  003705  // Notes : generates a Start condition.
003120  003706  //       : returns true if successful (usually ignored)
003121  003707        
003122  003708  func I2C2_Stop(), 1;
003123  003709  // Syntax: I2C2_Stop();
003124  003710  // Usage : I2C2_Stop();
003125  003711  // Notes : generates a Stop condition.
003126  003712  //       : returns true if successful (usually ignored)
003127  003713        
003128  003714  func I2C3_Stop(), 1;
003129  003715  // Syntax: I2C3_Stop();
003130  003716  // Usage : I2C3_Stop();
003131  003717  // Notes : generates a Stop condition.
003132  003718  //       : returns true if successful (usually ignored)
003133  003719        
003134  003720  func I2C2_Restart(), 1;
003135  003721  // Syntax: I2C2_Restart();
003136  003722  // Usage : I2C2_Restart();
003137  003723  // Notes : generates a Restart condition.
003138  003724  //       : returns true if successful (usually ignored)
003139  003725        
003140  003726  func I2C3_Restart(), 1;
003141  003727  // Syntax: I2C3_Restart();
003142  003728  // Usage : I2C3_Restart();
003143  003729  // Notes : generates a Restart condition.
003144  003730  //       : returns true if successful (usually ignored)
003145  003731        
003146  003732  func I2C2_Read(), 1;
003147  003733  // Syntax: I2C2_Read();
003148  003734  // Usage : ch := I2C2_Read();
003149  003735  // Notes : reads a single byte from the I2C Bus.
003150  003736        
003151  003737  func I2C3_Read(), 1;
003152  003738  // Syntax: I2C3_Read();
003153  003739  // Usage : ch := I2C3_Read();
003154  003740  // Notes : reads a single byte from the I2C Bus.
003155  003741        
003156  003742  func I2C2_Write("byte"), 1;
003157  003743  // Syntax: I2C2_Write(byte);
003158  003744  // Usage : r := I2C2_Write(ch);
003159  003745  // Notes : is used to write a byte to the I2C bus.
003160  003746  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003161  003747        
003162  003748  func I2C3_Write("byte"), 1;
003163  003749  // Syntax: I2C3_Write(byte);
003164  003750  // Usage : r := I2C3_Write(ch);
003165  003751  // Notes : is used to write a byte to the I2C bus.
003166  003752  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003167  003753        
003168  003754  func I2C2_Ack(), 0;
003169  003755  // Syntax: I2C2_Ack();
003170  003756  // Usage : I2C2_Ack();
003171  003757  // Notes : generates the acknowledge condition.
003172  003758        
003173  003759  func I2C3_Ack(), 0;
003174  003760  // Syntax: I2C3_Ack();
003175  003761  // Usage : I2C3_Ack();
003176  003762  // Notes : generates the acknowledge condition.
003177  003763        
003178  003764  func I2C2_Nack(), 0;
003179  003765  // Syntax: I2C2_Nack();
003180  003766  // Usage : I2C2_Nack();
003181  003767  // Notes : generates the negative acknowledge condition.
003182  003768        
003183  003769  func I2C3_Nack(), 0;
003184  003770  // Syntax: I2C3_Nack();
003185  003771  // Usage : I2C3_Nack();
003186  003772  // Notes : generates the negative acknowledge condition.
003187  003773        
003188  003774  func I2C2_AckStatus(), 1;
003189  003775  // Syntax: I2C2_AckStatus();
003190  003776  // Usage : r := I2C2_AckStatus();
003191  003777  // Notes : returns the ACK status from the device.
003192  003778        
003193  003779  func I2C3_AckStatus(), 1;
003194  003780  // Syntax: I2C3_AckStatus();
003195  003781  // Usage : r := I2C3_AckStatus();
003196  003782  // Notes : returns the ACK status from the device.
003197  003783        
003198  003784  func I2C2_AckPoll("control"), 1;
003199  003785  // Syntax: I2C2_AckPoll();
003200  003786  // Usage : r := I2C2_AckPoll(0xA0);
003201  003787  // Notes : waits for a device to return from ACK polling.
003202  003788        
003203  003789  func I2C3_AckPoll("control"), 1;
003204  003790  // Syntax: I2C3_AckPoll();
003205  003791  // Usage : r := I2C3_AckPoll(0xA0);
003206  003792  // Notes : waits for a device to return from ACK polling.
003207  003793        
003208  003794  func I2C2_Idle(), 1;
003209  003795  // Syntax : I2C2_Idle();
003210  003796  // Usage  : r := I2C2_Idle();
003211  003797  // Notes  : waits until the I2C Bus is Inactive.
003212  003798  //        : Times out if bus not idle within 1 second
003213  003799  // Returns: TRUE if successful, else failed (timed out)
003214  003800        
003215  003801  func I2C3_Idle(), 1;
003216  003802  // Syntax : I2C3_Idle();
003217  003803  // Usage  : r := I2C3_Idle();
003218  003804  // Notes  : waits until the I2C Bus is Inactive.
003219  003805  //        : Times out if bus not idle within 1 second
003220  003806  // Returns: TRUE if successful, else failed (timed out)
003221  003807        
003222  003808  func I2C2_Gets("buffer", "size"), 1;
003223  003809  // Syntax: I2C2_Gets("buffer", "size");
003224  003810  // Usage : r := I2C2_Gets(mybuf, 16);
003225  003811  // Notes : only reads up to "size" characters into "buffer"
003226  003812  //       : Reads up to asciiz terminator including terminator
003227  003813        
003228  003814  func I2C3_Gets("buffer", "size"), 1;
003229  003815  // Syntax: I2C3_Gets("buffer", "size");
003230  003816  // Usage : r := I2C3_Gets(mybuf, 16);
003231  003817  // Notes : only reads up to "size" characters into "buffer"
003232  003818  //       : Reads up to asciiz terminator including terminator
003233  003819        
003234  003820  func I2C2_Getn("buffer", "size"), 1;
003235  003821  // Syntax: I2C2_Gets("buffer", "size");
003236  003822  // Usage : r := I2C2_Gets(mybuf, 16);
003237  003823  // Notes : reads "size" bytes into "buffer"
003238  003824  //       :
003239  003825        
003240  003826  func I2C3_Getn("buffer", "size"), 1;
003241  003827  // Syntax: I2C3_Gets("buffer", "size");
003242  003828  // Usage : r := I2C3_Gets(mybuf, 16);
003243  003829  // Notes : reads "size" bytes into "buffer"
003244  003830  //       :
003245  003831        
003246  003832  func I2C2_Puts("buffer"), 1;
003247  003833  // Syntax: I2C2_Puts("buffer");
003248  003834  // Usage : r := I2C2_Puts(mybuf);
003249  003835  // Notes : writes an asciiz string to the I2C device
003250  003836  //       : returns count of characters written
003251  003837        
003252  003838  func I2C3_Puts("buffer"), 1;
003253  003839  // Syntax: I2C3_Puts("buffer");
003254  003840  // Usage : r := I2C3_Puts(mybuf);
003255  003841  // Notes : writes an asciiz string to the I2C device
003256  003842  //       : returns count of characters written
003257  003843        
003258  003844  func I2C2_Putn("buffer", "count"), 1;
003259  003845  // Syntax: I2C2_Putn("buffer","count");
003260  003846  // Usage : r := I2C2_Puts(mybuf,10);
003261  003847  // Notes : writes up to "size" bytes to the I2C device
003262  003848  //       : returns number of bytes written
003263  003849        
003264  003850  func I2C3_Putn("buffer", "count"), 1;
003265  003851  // Syntax: I2C3_Putn("buffer","count");
003266  003852  // Usage : r := I2C3_Puts(mybuf,10);
003267  003853  // Notes : writes up to "size" bytes to the I2C device
003268  003854  //       : returns number of bytes written
003269  003855        
003270  003856  func gfx_XYrotToVal("x","y","base","mina","maxa","minv","maxv"), 1;         // convert a rotational x/y postion to a value
003271  003857  // Usage	: gfx_XYrotToVal(x,y,XYROT_EAST,starta,enda,minv,maxv)
003272  003858  // Notes	: Convert a rotational angle into a value
003273  003859  // 	: Calculates a position for a rotary input starting at mina and continuing to maxa. both angles must be greater than 0.
003274  003860  // 	: Base can be XYROT_EAST, used for internal widgets, or XYROT_SOUTH, used for GCI widgets.
003275  003861  // 	: Returns a value from minv to maxv
003276  003862        
003277  003863  func gfx_XYlinToVal("x","y","base","minpos","maxpos","minv","maxv"), 1;         // convert a linear x/y postion to a value
003278  003864  // Usage	: gfx_XYrotToVal(x,y,XYLIN_X,startp,endp,minv,maxv)
003279  003865  // Notes	: Convert a linear position into a value
003280  003866  // 	: Calculates a position for a linear input starting at minpos and continuing to maxpos. 
003281  003867  // 	: Base can be XYLIN_X, to use the x value for calculations, or XYLIN_Y, to use the y value.
003282  003868  // 	: Returns a value from minv to maxv
003283  003869        
003284  003870  func media_InitSpeed("Speed"), 1;                     // initialize uSD card at a given speed
003285  003871  // Usage	: media_Init(SPI_SPEED15);
003286  003872  // Notes	: Initialise uSD CARD at a specified speed
003287  003873  // 	: Response: 0 = No Card
003288  003874  // 	:           1 = Card Initialised
003289  003875  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003290  003876        
003291  003877  func file_MountSpeed("Speed"), 1;                     // mount a uSD card at a given speed
003292  003878  // Syntax	: r := file_Mount(SPI_SPEED15);
003293  003879  // Usage	: r := file_Mount(SPI_SPEED15);
003294  003880  // Notes	: Create a control block for FAT16 and mount the File System at the specified speed
003295  003881  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003296  003882        
003297  003883  func img_FileRead("*dest", "size", "handle", "index"), 1;
003298  003884  // Syntax: res := img_FileRead("*dest", "size", "handle", "index"),
003299  003885  // Usage : res := img_FileRead(memblock,20,hnd1);
003300  003886  // Notes : returns number of characters read
003301  003887  //       : if "dest" is zero, data is read direct to GRAM window
003302  003888  //       :
003303  003889        
003304  003890  func img_FileSeek("handle", "index", "HiWord", "LoWord"), 1;
003305  003891  // Syntax: res := img_FileSeek("handle", "index", "HiWord", "LoWord")
003306  003892  // Usage : res := img_FileSeek(hSource, 0, 0x1234);
003307  003893  // Notes : set file position to 0x00001234 (byte position 4660)
003308  003894  //       : for the file handle so subsequent data may be read
003309  003895  //       : from that position onwards with img_FileGetC(...),
003310  003896  //       : img_FileGetW(...) or img_FileGetS(...)
003311  003897  // Notes : returns true if ok, usually ignored
003312  003898        
003313  003899  func img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003314  003900  // Syntax: img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003315  003901  // Usage : res := img_FileIndex(hsource, 0, 1000, 123), 1;
003316  003902  // Notes : set file seek position to 123000
003317  003903  //       : for the file handle so subsequent data may be read
003318  003904  //       : from that record position onwards with img_FileGetC(...),
003319  003905  //       : img_FileGetW(...) or img_FileGetS(...)
003320  003906  // Notes : returns true if ok, usually ignored
003321  003907        
003322  003908  func img_FileTell("handle", "index", "&HiWord", "&LoWord"), 1;
003323  003909  // Syntax: img_FileTell("handle", "index", &HiWord, &LoWord);
003324  003910  // Usage : img_FileTell(fhndl, &SizeHi, &SizeLo);
003325  003911  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003326  003912  //       : returns true if function succeeded
003327  003913        
003328  003914  func img_FileSize("handle", "index", "&HiWord", "&LoWord"), 1;
003329  003915  // Syntax: img_FileSize("handle", "index", &HiWord, &LoWord);
003330  003916  // Usage : img_FileSize(fhndl, &SizeHi, &SizeLo);
003331  003917  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003332  003918  //       : returns true if function succeeded
003333  003919        
003334  003920  func img_FileGetC("handle", "index"), 1;
003335  003921  // Syntax: img_FileGetC("handle", "index");
003336  003922  // Usage : mychar := fgetC("handle", "index");
003337  003923  // Notes : returns next char from file
003338  003924        
003339  003925  func img_FileGetW("handle", "index"), 1;
003340  003926  // Syntax: img_FileGetW("handle", "index");
003341  003927  // Usage : myword := fgetW("handle", "index");
003342  003928  // Notes : returns next word in file
003343  003929        
003344  003930  func img_FileGetS("*string", "size", "handle", "index"), 1;
003345  003931  // Syntax: res := img_FileGets("*string", "size", "handle", "index");
003346  003932  // Usage : res := img_FileGets(mystr , 81, hnd1); // read up to 80 chars
003347  003933  // Notes : get a string from a file
003348  003934  //       : returns pointer to string or null if failed.
003349  003935  //       : img_FileGetS(...) automatically appends a null-terminator to the data read.
003350  003936  //       : NB:- only reads up to "size-1" characters into "string"
003351  003937  //       : img_FileGetS(...) will stop reading when any of the following conditions are true:
003352  003938  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003353  003939  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003354  003940  //       : C] It reaches the end of file
003355  003941  //       : D] A read error occurs.
003356  003942        
003357  003943  func img_FileRewind("handle", "index"), 1;
003358  003944  // Syntax: res := img_FileRewind("handle", "index");
003359  003945  // Usage : res := img_FileRewind(hnd1);
003360  003946  // Notes : returns true if file rewound ok (usually ignored)
003361  003947  //       : resets the file pointer the the beginning of the open file.
003362  003948        
003363  003949  func img_FileLoadFunction("handle", "index"), 1;
003364  003950  // Syntax: res := img_FileLoadFunction("handle", "index");
003365  003951  // Usage : myfunc := img_FileLoadFunction("handle", "index");
003366  003952  // Notes : Load a function or program from disk and
003367  003953  //       : return a function pointer to the allocation.
003368  003954  //       : The function can then be invoked just like any other
003369  003955  //       : function would be called via a function pointer.
003370  003956  //       : Parameters may be passed to it in a conventional way.
003371  003957  //       : The function may be discarded at any time when no
003372  003958  //       : longer required, thus freeing its memory resources.
003373  003959  //       : The loaded function can be discarded with mem_Free(..)
003374  003960  //       : eg:
003375  003961  //       : popupWindow := img_FileLoadFunction("handle", "index");
003376  003962  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003377  003963  //       : then elsewhere in your program:-
003378  003964  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003379  003965  //       : if(res == QUIT_APPLICATION) goto exitApp;
003380  003966  //       : Later in your program, when popupWindow is no longer
003381  003967  //       : required for the application:-
003382  003968  //       : res := mem_Free(popupWindow);
003383  003969  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003384  003970  //       : The callers stack is shared by the loaded function,
003385  003971  //       : however any global variables in the loaded function
003386  003972  //       : are private to that function.
003387  003973  //
003388  003974        
003389  003975  func img_FileRun("handle", "index", "arglistptr"), 1;
003390  003976  // Syntax: res := img_FileRun("handle", "index","arglistptr");
003391  003977  // Usage : res := img_FileRun("handle", "index", argptr);
003392  003978  // Notes : current program releases any allocated memory but
003393  003979  //       : retains the stack and global memory.
003394  003980  //       : If arglistptr is 0, no arguments are passed, else
003395  003981  //       : arglist points to an array, the first element being
003396  003982  //       : the number of elements in the array.
003397  003983  //       : func 'main' in the called program accepts
003398  003984  //       : the arguments, if any. THe arguments can only
003399  003985  //       : be passed by value, no pointers or references can be
003400  003986  //       : used as all memory is cleared before the file
003401  003987  //       : is loaded. Refer to img_FileExec and img_FileLoadFunction
003402  003988  //       : for functions that can pass by reference.
003403  003989        
003404  003990  func img_FileExec("handle", "index", "arglistptr"), 1;
003405  003991  // Syntax: res := img_FileExec("handle", "index","arglistptr");
003406  003992  // Usage : res := img_FileExec("handle", "index","arglistptr");
003407  003993  // Notes : returns like a function, current program
003408  003994  //       : calling program is kept active and control returns to it.
003409  003995  //       : If arglistptr is 0, no arguments are passed, else
003410  003996  //       : arglist points to an array, the first element being
003411  003997  //       : the number of elements in the array.
003412  003998  //       : func 'main' in the called program accepts the arguments.
003413  003999  //       : This function is similar to img_FileLoadFunction(...), however,
003414  004000  //       : the function argument list is passed by pointer, and
003415  004001  //       : the memory consumed by the function is released as
003416  004002  //       : soon as the function completes.
003417  004003        
003418  004004  func img_FilePlayWAV("handle", "index"), 1;
003419  004005  // Syntax: img_FilePlayWAV("handle", "index");
003420  004006  // Usage : img_FilePlayWAV("handle", "index");
003421  004007  // Notes : Play a wave file at index "index" in the filesystem "handle"
003422  004008  //       : This function automatically grabs a chunk
003423  004009  //       : of memory for a file buffer, and a wave
003424  004010  //       : buffer. The minimum memory requirement is
003425  004011  //       : about 580 bytes for the disk io service and
003426  004012  //       : a minimum wave buffer size of 1024. The siz
003427  004013  //       : of the wave buffer allocation
003428  004014  //       : can be increased by the snd_BufSize function.
003429  004015  //       : The default size 1024 bytes.
003430  004016  //       : NB the memory is only required during the
003431  004017  //       : duration of play, and is automatically
003432  004018  //       : released while not in use.
003433  004019  //       : See the Sound Class services for other associated controls.
003434  004020  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003435  004021  //       : If errors occured, the folling is returned
003436  004022  //       : -7  : Insufficient memory available for WAV buffer and file
003437  004023  //       : -6  : cant play this rate
003438  004024  //       : -5  : no data chunk found in first rsector
003439  004025  //       : -4  : no format data
003440  004026  //       : -3  : no wave chunk signature
003441  004027  //       : -2  : bad wave file format
003442  004028  //       : -1  : file not found
003443  004029        
003444  004030  func img_TxtFontID("handle", "index"), 1;                   // 2  text font ID (0 = system font)
003445  004031  // Syntax: img_TxtFontID("handle", "index");
003446  004032  // Usage : img_TxtFontID("handle", "index");
003447  004033  // Notes : Set the font to a font held in the image file system
003448  004034        
003449  004035  func img_FileCheckUpdate("handle", "index", "Options"), 1;                           // check and/or update the program running in Flash
003450  004036  // Syntax 	: img_FileCheckUpdate("handle", "index", "Options") ;
003451  004037  // Usage 	: img_FileCheckUpdate("handle", "index", CheckUpdate_Check) ;
003452  004038  // Notes 	: Check and/or update the program running in flash using the specified file in Flash memory.
003453  004039  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003454  004040  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003455  004041  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003456  004042  //
003457  004043  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003458  004044  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003459  004045  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003460  004046  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003461  004047  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003462  004048  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003463  004049        
003464  004050  func flash_Block32Erase(), 1;            // erase the required 32k flash block
003465  004051  // Syntax	: flash_Block32Erase();
003466  004052  // Usage	: flash_Block32Erase();
003467  004053  // Notes	: Erase the 32KB flash block including the currently set address
003468  004054  // 	: This uses the 0x52 command.
003469  004055        
003470  004056  func flash_Sector4Erase(), 1;            // erase the required 4k flash sector
003471  004057  // Syntax: flash_Sector4Erase();
003472  004058  // Usage : flash_Sector4Erase();
003473  004059  // Notes	: Erase the 4KB flash sector including the currently set address
003474  004060  // 	: This uses the 0x20 command.
003475  004061        
003476  004062  func com_Mode("8" ,"N", "1", "comport"), 1 ;
003477  004063  // Syntax	: comx_Mode("databits", "parity", "Stopbits", "comport");
003478  004064  // Usage	: comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
003479  004065  // *Notes	: Data Bits must be 8
003480  004066  // 	: Parity may be 'N', 'O' or 'E'.
003481  004067  // 	: Stop Bits may be 1 or 2.
003482  004068  // 	: returns true if mode was acceptable
003483  004069        
003484  004070  func img_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in a Flash GCI
003485  004071  // Syntax: img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003486  004072  // Usage : img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003487  004073  // Notes	: Load and call the Function found at index "idx" in the Flash GCI identified by "Hndl". 
003488  004074  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003489  004075  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003490  004076  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003491  004077  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003492  004078  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003493  004079  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003494  004080  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003495  004081  // 	: Returns 0 if successful.
003496  004082        
003497  004083  func img_FunctionFreeCache("handle"), 0 ;                                 // Free all cached Flash GCI Functions 
003498  004084  // Syntax: img_FunctionFreeCache(hndl);
003499  004085  // Usage : img_FunctionFreeCache(hndl);
003500  004086  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003501  004087  // 	: Flash GCI.
003502  004088        
003503  004089  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
003504  004090  // *Notes   : (if you calculate all of the incoming data
003505  004091  //          : INCLUDING the CRC, the result should be 0x00
003506  004092  //          : This is equivalent to simple addition of all bytes
003507  004093  //          : and returning the negated sum an 8 bit value.
003508  004094  //          : For the standard test string "123456789",
003509  004095  //          : crc_CSUM_8 will return 0x0023.
003510  004096        
003511  004097  func gfx_GradientShape("GradientRAM", "HorzVert", "OuterWidth", "X", "Y", "W", "H", "TLrad", "TRrad", "BLrad", "BRrad", "Darken", "OuterColor", "OuterType", "OuterLevel", "InnerColor", "InnerType", "InnerLevel", "Split"), 0 ;
003512  004098  // Syntax 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003513  004099  // Usage 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003514  004100  // Notes 	: Produce a shaped color gradient using the supplied parameters.0
003515  004101  // 	: GradientRAM	This Function requires a quantity or RAM to work. It also needs to be initialised and it's size varies accoring to the largest corner radius. Multiple gradient shape calls can
003516  004102  // 	: 	share the same GradientRAM. eg gradientRAM[29+91*2] := [-1,-1,-9999,0,0,91] ;  Would support a maximum radius of 90 degrees, note the 91 in two places.
003517  004103  // 	: HorzVert	Horizontal or Vertical -- 0 or 1
003518  004104  // 	: OuterWidth	Outer gradient width 0 to ...
003519  004105  // 	: X	x co-ordinate
003520  004106  // 	: Y	y co-ordinate
003521  004107  // 	: W	width
003522  004108  // 	: H	height
003523  004109  // 	: LTrad	Top left corner radius
003524  004110  // 	: TRrad	Top right corner radius
003525  004111  // 	: BLrad	Bottom left radius
003526  004112  // 	: BRrad	Bottom right radius
003527  004113  // 	: Darken	Darken both colours by a value. Can be a -ve value to lighten
003528  004114  // 	: OuterCol	Outer Gradient colour
003529  004115  // 	: OuterType	Outer Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003530  004116  // 	: OuterLevel	Outer Gradient level 0 - 63
003531  004117  // 	: InnerCol	Inner Gradient colour
003532  004118  // 	: InnerType	Inner Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003533  004119  // 	: InnerLevel	Inner Gradient level 0 - 63
003534  004120  // 	: Split	Split gradient, 0 - no split, 1 - top, 2 - bottom 
003535  004121  // 
003536  004122  // Returns	: nothing
003537  004123        
003538  004124        
003539  004125  func gfx_GradientColor("Type", "Darken", "Level", "H", "Pos", "Color"), 1 ;
003540  004126  // Syntax 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003541  004127  // Usage 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003542  004128  // Notes 	: Given the parameters, adjust the input color to produce the output color.
003543  004129  // 	: Type	Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003544  004130  // 	: Darken	Darken colour by a value. Can be a -ve value to lighten
003545  004131  // 	: Level	Gradient level 0 - 63
003546  004132  // 	: H	Height of the object that gradient is applied
003547  004133  // 	: Pos	Position in the height that gradient is calculated
003548  004134  // 	: Color	Source colour that gradient is applied to
003549  004135  // 
003550  004136  // Returns	: Color after Adjustment.
003551  004137        
003552  004138  func gfx_GradTriangleFilled("X0", "Y0", "X1", "Y1", "X2", "Y2", "SolidCol", "GradientCol", "GradientHeight", "GradientY", "GradientLevel", "Type"), 0;
003553  004139  // Syntax 	: gfx_GradTriangleFilled(X0, Y0, X1, Y1, X2, Y2, SolidCol, GradientCol, GradientHeight, GradientY, GradientLevel, Type);
003554  004140  // Usage 	: gfx_GradTriangleFilled(10, 10, 10, 100, 100, 100 ,YELLOW, DARKKHAKI, 100, 10, 30, 1);
003555  004141  // Notes 	: Produce a triangle with or without a gradient.
003556  004142  // 	: X0	First triangle point x coordinate
003557  004143  // 	: Y0	First triangle point y coordinate
003558  004144  // 	: X1	Second triangle point x coordinate
003559  004145  // 	: Y1	Second triangle point y coordinate
003560  004146  // 	: X2	Third triangle point x coordinate
003561  004147  // 	: Y2	Third triangle point y coordinate
003562  004148  // 	: SolidCol	Colour that will be used if the Solid or Gradient parameter is set to 0
003563  004149  // 	: GradientCol	Colour that will be used if the Solid or Gradient parameter is set to 1
003564  004150  // 	: GradientHeight	Height of the area that the gradient will be calculated. Can be larger than the triangle
003565  004151  // 	: GradientY	Position on the Y axis that the gradient will be calculated from with respect to triangle position
003566  004152  // 	: GradientLevel	Level of gradient applied
003567  004153  // 	: Type	Select wether solid triangle or gardient triangle is drawn. 
003568  004154        
003569  004155  func media_InitFlash("Command"), 1;                    // initialize Flash Memory
003570  004156  // Usage	: media_InitFlash();
003571  004157  // Notes	: Initialise Flash Memory 
003572  004158  // 	: Response: 0 = Normally ignored, but should be 0
003573  004159  // 	:           1 = a uSD Card has been Initialised, you should not use this command for uSD cards
003574  004160  // 	: Note that for systems with SPI Flash the response will be 0, however, this function needs to be called to 
003575  004161  // 	: init the Flash memory chip.
003576  004162  // 	: Command	The command used to set the flash memory into 4 byte addressing mode
003577  004163  // 	: FLASH_ADDR_DEF_COMMAND	The default command will be used (0xB7)
003578  004164  // 	: FLASH_ADDR_ALWAYS_4BYTE	No command will be sent (for chips permantly in 4 byte mode)
003579  004165  // 	: else this command will be sent to enter 4 Byte Addressing mode, if the capacity of the chip appears to
003580  004166  // 	: be greater than 16MB. Requires the JEDEC approved response to the 'FLASH READ ID' (0x9F) command.
003581  004167        
003582  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003583  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003584  004169        
003585  004170  func file_RunSpeed("Speed", "fname.4xe", "arglistptr"), 1;
003586  004171  // Syntax	: res := file_Run(SPI_SPEED15, "fname.4xe","arglistptr");
003587  004172  // Usage	: res := file_Run(SPI_SPEED15, fname, argptr);
003588  004173  // Notes	: current program releases any allocated memory but
003589  004174  // 	: retains the stack and global memory.
003590  004175  // 	: If arglistptr is 0, no arguments are passed, else
003591  004176  // 	: arglist points to an array, the first element being
003592  004177  // 	: the number of elements in the array.
003593  004178  // 	: func 'main' in the called program accepts
003594  004179  // 	: the arguments, if any. The arguments can only
003595  004180  // 	: be passed by value, no pointers or references can be
003596  004181  // 	: used as all memory is cleared before the file
003597  004182  // 	: is loaded. Refer to file_Exec and file_LoadFunction
003598  004183  // 	: for functions that can pass by reference.
003599  004184  // 	: Speed specifies the File System is mounted at the specified speed
003600  004185  // 	: can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003601  004186        
003602  004187  func I2CS_Open("Addr", "RdBuf", "RdBufSize", "WrBuf", "WrBufSize", "WaitOption"), 0;  // Open I2C Slave
003603  004188  // Usage	: I2CS_Open(Addr, RdBuf, RdBufS, WrBuf, WrBufs, 0xaa);
003604  004189  // Notes	: Initialize and open the I2C Slave 
003605  004190  // 	: The slave ACKs any transmissions from the master until the read buffer fills
003606  004191  // 	: The slave NAKs any receives by the master until the write buffer is released, or is empty
003607  004192  // 	: Addr	The I2C Address for this Slave
003608  004193  // 	: RdBuf	The buffer for receiving 'commands' from the master
003609  004194  // 	: RdBufSize	The size of the receive buffer 
003610  004195  // 	: WrBuf	The buffer for sending 'responses' to the master
003611  004196  // 	: WrBufSize	The size of the write buffer
003612  004197  // 	: WaitOption	The character to send when no data is available, or all sent, or with I2C_CLOCK_STRETCHING to use clock stretching 
003613  004198  // 	: Response: None
003614  004199        
003615  004200  func I2CS_Close(), 0;          // Close I2C Slave
003616  004201  // Usage	: I2CS_Close();
003617  004202  // Notes	: Closes the I2C Slave 
003618  004203  // 	: Response: None
003619  004204        
003620  004205  func I2CS_Write("Byte"), 0;      // Write byte to output buffer
003621  004206  // Usage	: I2CS_Write("Byte");
003622  004207  // Notes	: Writes a byte to the I2C Slave Write Buffer
003623  004208  // 	: When everything to be written to the Master is in the write buffer, the buffer should be released
003624  004209  // 	: with I2CS_Release()
003625  004210  // 	: Response: None
003626  004211        
003627  004212  func I2CS_Count(), 1;          // Count of bytes in input buffer
003628  004213  // Usage	: I2CS_Count();
003629  004214  // Notes	: Retrieve the number of bytes available in the I2C Slave's read buffer
003630  004215  // 	: Response: Number of bytes in the buffer
003631  004216        
003632  004217  func I2CS_Read(), 1;           // Read byte from Read Buffer
003633  004218  // Usage	: I2CS_Read();
003634  004219  // Notes	: Read a byte from the I2C Slave's read buffer
003635  004220  // 	: Response: byte read from buffer
003636  004221        
003637  004222  func I2CS_Release(), 0;        // Release output buffer to enable Master to read
003638  004223  // Usage	: I2CS_Release();
003639  004224  // Notes	: Release an accumulated I2C Slave write buffer for sending to the master
003640  004225  // 	: Response: None
003641  004226        
003642  004227  func I2CS_Overflow(), 1;        // Check for any overflow in the read or write processes
003643  004228  // Usage	: I2CS_Overflow();
003644  004229  // Notes	: Check for any overflow in the read or write processes, the error is automatically
003645  004230  // 	: Reset at the start of the next I2CS_Write() or the last I2CS_Read() for the current buffer.
003646  004231  // 	: Response: Overflow flags
003647  004232  // 	: 0x01 : The host has sent more data than the I2CS_Read() buffer can hold
003648  004233  // 	: 0x02 : The host has read all the data the I2CS_Write() buffer contained
003649  004234  // 	: 0x04 : The host has read more data than the I2CS_Write() buffer contained
003650  004235        
003651  004236  func com_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003652  004237  // Usage	: com_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003653  004238  // Usage	: com_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003654  004239  // Notes	: initialize a serial buffer for the COM0 output.
003655  004240  // 	: The program must declare a var array as a circular buffer.
003656  004241  // 	: When a TX buffer is declared for comms, the transmission
003657  004242  // 	: of characters becomes non blocking. If the buffer has
003658  004243  // 	: insufficient space to accept the next character from a
003659  004244  // 	: serout_x() function, the excess characters will be ignored,
003660  004245  // 	: and the com_Full_x() error will be asserted.   If the
003661  004246  // 	: TX buffer is no longer required, just set the buffer pointer
003662  004247  // 	: to zero, the size in this case doesnt matter and is ignored.
003663  004248  // 	: The function can resize or reallocated to another buffer at
003664  004249  // 	: any time. The buffer is flushed before any changes are made.
003665  004250  // 	: "pin" designates an IO pin to control a bi-directional
003666  004251  // 	: control device for half duplex mode. "pin" will go HI at the
003667  004252  // 	: start of a transmission, and will return low after the final
003668  004253  // 	: byte is transmitted. If not required, just set "pin" to zero.
003669  004254        
003670  004255  func com_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003671  004256  // Syntax	: com_InitBrk(buffer, bufsize, qualifier);
003672  004257  // Usage1	: com_InitBrk(mybuf, 20, 0);
003673  004258  // Usage2	: com_InitBrk(mybuf, 20, ':');
003674  004259  // Notes	: initialize a serial capture buffer for the comms input
003675  004260  // 	: The program must declare a var array as a circular buffer.
003676  004261  // 	: Usage1 declares a circular buffer which will continually
003677  004262  // 	: buffer characters.
003678  004263  // 	: Usage2 must receive ':' before any characters will
003679  004264  // 	: accumulate in the buffer.
003680  004265        
003681  004266  //------------------------------------------------------------------//
003682  004267  //     break control constant                                       //
003683  004268  //------------------------------------------------------------------//
003684  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003685  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003686  004270        
003687  004271  func disp_Refresh(), 0;  // Refresh an ePaper display
003688  004272  // Syntax	: disp_Refresh();
003689  004273  // Usage	: disp_Refresh();
003690  004274  // Notes	: This command is only applicable to ePaper displays.
003691  004275  // 	: Refresh an ePaper display
003692  004276  // 	: After updating the RAM in an ePaper display thuis commmand is used
003693  004277  // 	: to place the contents of the RAM onto the ePaper.
003694  004278        
003695  004279  func disp_Busy(), 1;  // Check the busy status of an ePaper display
003696  004280  // Syntax	: disp_Busy();
003697  004281  // Usage	: disp_Busy();
003698  004282  // Notes	: This command is only applicable to ePaper displays.
003699  004283  // 	: Return the busy status of an ePaper display
003700  004284  // 
003701  004285  // Returns	: 1 if the display is busy, 0 otherwise
003702  004286        
003703  004287  //=========================================================================================================
003704  004288  // Internal FLASH memory functions
003705  004289  //=========================================================================================================
003706  004290  func intflash_GetByte("ptr"), 1;
003707  004291  // Syntax   : intflash_GetByte(ptr);
003708  004292  // Usage    : myvar := intflash_GetByte(1); // read the first byte from internal flash
003709  004293  // Notes    : Reads a single byte from internal flash.
003710  004294  // Returns  : the byte value from the location
003711  004295        
003712  004296        
003713  004297  func intflash_GetWord("ptr"), 1;
003714  004298  // Syntax   : intflash_GetWord(ptr);
003715  004299  // Usage    : myvar := intflash_GetWord(0x0000); // read first word from internal flash
003716  004300  // Notes    : Reads a single word from any internal flash location.
003717  004301  //          : The pointer is byte aligned.
003718  004302  // Returns  : the byte value from the location
003719  004303        
003720  004304        
003721  004305  func intflash_Copy("ptr", "dest", "count"), 1;
003722  004306  // Syntax   : intflash_Copy(ptr, dest, count);
003723  004307  // Usage    : myvar := intflash_Copy(0x123, mybuf, 20); // read 20 bytes from internal flash starting from 0x123
003724  004308  // Notes    : Copies bytes from any internal flash locations to a user buffer.
003725  004309  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
003726  004310  // Returns  : the count of bytes transferred.
003727  004311        
003728  004312  func intflash_WriteBlock("sourceptr", "Size"), 1;
003729  004313  // Syntax   : intflash_WriteBlock(pbuf);
003730  004314  // Usage    : result := intflash_WriteBlock(buffer); // store the 2k buffer 
003731  004315  // Notes    : Copies a buffer to NVM. Size bytes are written. A maximum of 2048 bytes can be written.
003732  004316  // Returns  : returns true if the function succeeded.
003733  004317        
003734  004318  func intflash_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in internal flash
003735  004319  // Syntax: intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003736  004320  // Usage : intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003737  004321  // Notes	: Load and call the Function found at index "idx" in the internal flash widget identified by "Hndl". 
003738  004322  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003739  004323  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003740  004324  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003741  004325  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003742  004326  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003743  004327  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003744  004328  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003745  004329  // 	: Returns 0 if successful.
003746  004330        
003747  004331  func intflash_FunctionFreeCache("handle"), 0 ;                                 // Free all cached internal Flash Functions 
003748  004332  // Syntax: img_FunctionFreeCache(hndl);
003749  004333  // Usage : img_FunctionFreeCache(hndl);
003750  004334  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003751  004335  // 	: widget handle.
003752  004336        
003753  004337  func com1_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003754  004338  // Usage	: com1_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003755  004339  // Usage	: com1_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003756  004340  // Notes	: initialize a serial buffer for the COM1 output.
003757  004341  // 	: The program must declare a var array as a circular buffer.
003758  004342  // 	: When a TX buffer is declared for comms, the transmission
003759  004343  // 	: of characters becomes non blocking. If the buffer has
003760  004344  // 	: insufficient space to accept the next character from a
003761  004345  // 	: serout_x() function, the excess characters will be ignored,
003762  004346  // 	: and the com_Full_x() error will be asserted.   If the
003763  004347  // 	: TX buffer is no longer required, just set the buffer pointer
003764  004348  // 	: to zero, the size in this case doesnt matter and is ignored.
003765  004349  // 	: The function can resize or reallocated to another buffer at
003766  004350  // 	: any time. The buffer is flushed before any changes are made.
003767  004351  // 	: "pin" designates an IO pin to control a bi-directional
003768  004352  // 	: control device for half duplex mode. "pin" will go HI at the
003769  004353  // 	: start of a transmission, and will return low after the final
003770  004354  // 	: byte is transmitted. If not required, just set "pin" to zero.
003771  004355        
003772  004356  func com1_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003773  004357  // Syntax	: com1_InitBrk(buffer, bufsize, qualifier);
003774  004358  // Usage1	: com1_InitBrk(mybuf, 20, 0);
003775  004359  // Usage2	: com1_InitBrk(mybuf, 20, ':');
003776  004360  // Notes	: initialize a serial capture buffer for the comms input
003777  004361  // 	: The program must declare a var array as a circular buffer.
003778  004362  // 	: Usage1 declares a circular buffer which will continually
003779  004363  // 	: buffer characters.
003780  004364  // 	: Usage2 must receive ':' before any characters will
003781  004365  // 	: accumulate in the buffer.
003782  004366        
003783  004367  //------------------------------------------------------------------//
003784  004368  // CONSTANTS
003785  004369  //------------------------------------------------------------------//
003786  004370        
003787  004371  #CONST
003788  004500  #END
003789  004501        
003790  004502  // generic constants
003791  004503  #CONST
003792  004514  #END
003793  004515        
003794  004516  // other constants
003795  004517  #CONST
003796  004520  #END
003797  004521        
003798  004522  //------------------------------------------------------------------------------
003799  004523  // Pin related constants
003800  004524  //------------------------------------------------------------------------------
003801  004525  #CONST
003802  004547  #END
003803  004548        
003804  004549  //------------------------------------------------------------------------------
003805  004550  //gfx_Set() related constants
003806  004551  //------------------------------------------------------------------------------
003807  004552  #CONST
003808  004569  #END
003809  004570        
003810  004571        
003811  004572  //gfx_Get() related constants
003812  004573  #CONST
003813  004582  #END
003814  004583        
003815  004584        
003816  004585        
003817  004586        
003818  004587  #CONST
003819  004600  #END
003820  004601        
003821  004602        
003822  004603  #CONST
003823  004625  #END
003824  004626        
003825  004627  //------------------------------------------------------------------------------
003826  004628  //txt_Set() related constants
003827  004629  //------------------------------------------------------------------------------
003828  004630  #CONST
003829  004649  #END
003830  004650        
003831  004651        
003832  004652        
003833  004653  //------------------------------------------------------------------------------
003834  004654  //txt_Set() related arguments
003835  004655  // NB:- FONT4 must be inherited if required,
003836  004656  // eg #inherit "FONT4.fnt"
003837  004657  //------------------------------------------------------------------------------
003838  004658  #CONST
003839  004670  #END
003840  004671        
003841  004672        
003842  004673        
003843  004674  //touch_Set() related constants
003844  004675  #CONST
003845  004679  #END
003846  004680        
003847  004681  //touch_Get() related constants
003848  004682  #CONST
003849  004690  #END
003850  004691        
003851  004692  // image control offset related constants
003852  004693  #CONST
003853  004700  #END
003854  004701        
003855  004702  // image attribute flags
003856  004703  // for img_SetAttributes(...) and img_ClearAttributes(...)
003857  004704  #CONST
003858  004718  #END
003859  004719        
003860  004720        
003861  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003862  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003863  004722        
003864  004723  // image control entry offsets
003865  004724  #CONST
003866  004739  #END
003867  004740        
003868  004741  #CONST
003869  004759  #END
003870  004760        
003871  004761        
003872  004762        
003873  004763        
003874  004764  #CONST
003875  004784  #END
003876  004785        
003877  004786        
003878  004787        
003879  004788  // timer control  related constants
003880  004789  #CONST
003881  004798  #END
003882  004799        
003883  004800  // I2C timing related constants
003884  004801  #CONST
003885  004805  #END
003886  004806        
003887  004807        
003888  004808  // spi_Init(...)  mode arguments
003889  004809  #CONST
003890  004832  #END
003891  004833        
003892  004834  //------------------------------------------------------------------------------
003893  004835  // system WORD variables accesible with peekW and pokeW or pointer access
003894  004836  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
003895  004837  // can also be accessed with peekW and pokeW
003896  004838  //------------------------------------------------------------------------------
003897  004839        
003898  004840  #CONST
003899  004934  #END
003900  004935        
003901  004936  //------------------------------------------------------------------------------
003902  004937  // FILEIO Error Code Constants
003903  004938  //------------------------------------------------------------------------------
003904  004939  #CONST
003905  004965  #END
003906  004966        
003907  004967  //==================================================================================================
003908  004968        
003909  004969        
003910  004970        
003911  000013      #ENDIF
003912  000014        
003913  000015        
003914  000016  //===========================================================================================
003915  000017        
003916  000018        
003917  000002        
003918  000003  //#constant OLDCOMPILE
003919  000004        
003920  000005        
003921  000006        
003922  000007        
003923  000008        
003924  000009  // generated 12/10/2022 5:48:32 PM
003925  000010  // uSDRequired:- 1   InternalRequired:- 1   InherentsInProgFlash:- 0   GciFlashFS:- 1   InherentWidgets:- 0   InternalObjects:- 9   GciFlashFiles:- 1
003926  000011        
003927  000012  #MODE RUNFLASH
003928  000013        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

003929  000014  #inherit "4DGL_16bitColours.fnc"
003930  000014  #inherit "4DGL_16bitColours.fnc"
003931  000004  */
003932  000005        
003933  000006        
003934  000007        
003935  000008  #CONST
003936  000149  #END
003937  000150        
003938  000015        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

003939  000016  #inherit "VisualConst.inc"
003940  000016  #inherit "VisualConst.inc"
003941  000001  // Line Patterns
003942  000002  #constant  LPCOARSE    0xF0F0
003943  000002  #constant  LPCOARSE    0xF0F0
003944  000003  #constant  LPMEDIUM    0x3333
003945  000003  #constant  LPMEDIUM    0x3333
003946  000004  #constant  LPFINE      0xAAAA
003947  000004  #constant  LPFINE      0xAAAA
003948  000005  #constant  LPDASHDOT   0x03CF
003949  000005  #constant  LPDASHDOT   0x03CF
003950  000006  #constant  LPDASHDOTDOT 0x0333
003951  000006  #constant  LPDASHDOTDOT 0x0333
003952  000007  #constant  LPSOLID     0x0000
003953  000007  #constant  LPSOLID     0x0000
003954  000017        
003955  000018        
file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGaugeConst.inc

003956  000019  #inherit "SprinterGaugeConst.inc"
003957  000019  #inherit "SprinterGaugeConst.inc"
003958  000001  // File generated 12/10/2022 5:48:28 PM
003959  000002  // Warning! This is a generated file, any manual changes will be
003960  000003  // lost during the next generation.
003961  000004        
003962  000005  #constant  IFONT_OFFSET     0
003963  000005  #constant  IFONT_OFFSET     0
003964  000006  // object indexes into WIDGET pointer
003965  000007  #CONST
003966  000017  #END
003967  000018        
003968  000019  // object indexes into ImageControl
003969  000020  #CONST
003970  000029  #END
003971  000030        
003972  000031        
003973  000032        
003974  000033  #constant  ffsEndUnits4k    0x0049  // First unused 4k Sector on Flash
003975  000033  #constant  ffsEndUnits4k    0x0049  // First unused 4k Sector on Flash
003976  000034  #constant  ffsEnd4kH        0x0004  // Address of first unused 4k Sector on Flash, High
003977  000034  #constant  ffsEnd4kH        0x0004  // Address of first unused 4k Sector on Flash, High
003978  000035  #constant  ffsEnd4kL        0x9000  // Address of first unused 4k Sector on Flash, Low
003979  000035  #constant  ffsEnd4kL        0x9000  // Address of first unused 4k Sector on Flash, Low
003980  000036  #constant  ffsEndUnits32k   0x000A  // First unused 32k Block on Flash
003981  000036  #constant  ffsEndUnits32k   0x000A  // First unused 32k Block on Flash
003982  000037  #constant  ffsEnd32kH       0x0005  // Address of first unused 32k Block on Flash, High
003983  000037  #constant  ffsEnd32kH       0x0005  // Address of first unused 32k Block on Flash, High
003984  000038  #constant  ffsEnd32kL       0x0000  // Address of first unused 32k Block on Flash, Low
003985  000038  #constant  ffsEnd32kL       0x0000  // Address of first unused 32k Block on Flash, Low
003986  000039  #constant  ffsEndUnits64k   0x0005  // First unused 64k Block on Flash
003987  000039  #constant  ffsEndUnits64k   0x0005  // First unused 64k Block on Flash
003988  000040  #constant  ffsEnd64kH       0x0005  // Address of first unused 64k Block on Flash, High
003989  000040  #constant  ffsEnd64kH       0x0005  // Address of first unused 64k Block on Flash, High
003990  000041  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
003991  000041  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
003992  000042        
003993  000043  #IFNOT EXISTS NOGLOBALS
003994  000044  var hndl ;
003995  000045  #ENDIF
003996  000020        
003997  000021        
003998  000022  #constant IPDatasize 22
003999  000022  #constant IPDatasize 22
004000  000023        
004001  000024  #CONST
004002  000028  #END
004003  000029        
004004  000030        
004005  000031        
004006  000032  #CONST
004007  000174  #END
004008  000175        
004009  000227  #END
4010  0397
4011  0398
4012  0399
4013  039A
4014  039B
4015  039C
4016  039D
4017  039E
4018  039F
4019  03A0
4020  03A1
4021  03A2
4022  03A3
4023  03A4
4024  03A5
4025  03A6
4026  03A7
4027  03A8
4028  03A9
4029  03AA
4030  03AB
4031  03AC
4032  03AD
4033  03AE
4034  03AF
4035  03B0
4036  03B1
4037  03B2
4038  03B3
4039  03B4
4040  03B5
4041  03B6
4042  03B7
4043  03B8
4044  03B9
4045  03BA
4046  03BB
4047  03BC
4048  03BD
4049  03BE
4050  03BF
4051  03C0
4052  03C1
4053  03C2
4054  03C3
4055  03C4
4056  03C5
4057  03C6
4058  03C7
4059  03C8
4060  03C9
4061  03CA
4062  03CB
4063  03CC
4064  03CD
4065  03CE
4066  03CF
4067  03D0
4068  03D1
4069  03D2
4070  03D3
4071  03D4
4072  03D5
4073  03D6
4074  03D7
4075  03D8
4076  03D9
4077  03DA
4078  03DB
4079  03DC
4080  03DD
4081  03DE
4082  03DF
4083  03E0
4084  03E1
4085  03E2
4086  03E3
4087  03E4
4088  03E5
4089  03E6
4090  03E7
4091  03E8
4092  03E9
4093  03EA
4094  03EB
4095  03EC
4096  03ED
4097  03EE
4098  03EF
4099  03F0
4100  03F1
4101  03F2
4102  03F3
4103  03F4
4104  03F5
4105  03F6
4106  03F7
4107  03F8
4108  03F9
4109  03FA
4110  03FB
4111  03FC
4112  03FD
4113  03FE
4114  03FF
4115  0400
4116  0401
4117  0402
4118  0403
4119  0404
4120  0405
4121  0406
4122  0407
4123  0408
4124  0409
4125  040A
4126  040B
4127  040C
4128  040D
4129  040E
4130  040F
4131  0410
4132  0411
4133  0412
4134  0413
4135  0414
4136  0415
4137  0416
4138  0417
4139  0418
4140  0419
4141  041A
4142  041B
4143  041C
4144  041D
4145  041E
4146  041F
4147  0420
4148  0421
4149  0422
4150  0423
4151  0424
4152  0425
4153  0426
4154  0427
4155  0428
4156  0429
4157  042A
4158  042B
4159  042C
4160  042D
4161  042E
4162  042F
4163  0430
4164  0431
4165  0432
4166  0433
4167  0434
4168  0435
4169  0436
4170  0437
4171  0438
4172  0439
4173  043A
4174  043B
4175  043C
4176  043D
4177  043E
4178  043F
4179  0440
4180  0441
4181  0442
4182  0443
4183  0444
4184  0445
4185  0446
4186  0447
4187  0448
4188  0449
4189  044A
4190  044B
4191  044C
4192  044D
4193  044E
4194  044F
4195  0450
4196  0451
4197  0452
4198  0453
4199  0454
4200  0455
4201  0456
4202  0457
4203  0458
4204  0459
4205  045A
4206  045B
4207  045C
4208  045D
4209  045E
4210  045F
4211  0460
4212  0461
4213  0462
4214  0463
4215  0464
4216  0465
4217  0466
4218  0467
4219  0468
4220  0469
4221  046A
4222  046B
4223  046C
4224  046D
4225  046E
4226  046F
4227  0470
4228  0471
4229  0472
4230  0473
4231  0474
4232  0475
4233  0476
4234  0477
4235  0478
4236  0479
4237  047A
4238  047B
4239  047C
4240  047D
4241  047E
4242  047F
4243  0480
4244  0481
4245  0482
4246  0483
4247  0484
4248  0485
4249  0486
4250  0487
4251  0488
4252  0489
4253  048A
4254  048B
4255  048C
4256  048D
4257  048E
4258  048F
4259  0490
4260  0491
4261  0492
4262  0493
4263  0494
4264  0495
4265  0496
4266  0497
4267  0498
4268  0499
4269  049A
4270  049B
4271  049C
4272  049D
4273  049E
4274  049F
4275  04A0
4276  04A1
4277  04A2
4278  04A3
4279  04A4
4280  04A5
4281  04A6
4282  04A7
4283  04A8
4284  04A9
4285  04AA
4286  04AB
4287  04AC
4288  04AD
4289  04AE
4290  04AF
4291  04B0
4292  04B1
4293  04B2
4294  04B3
4295  04B4
4296  04B5
4297  04B6
4298  04B7
4299  04B8
4300  04B9
4301  04BA
4302  04BB
4303  04BC
4304  04BD
4305  04BE
4306  04BF
4307  04C0
4308  04C1
4309  04C2
4310  04C3
4311  04C4
4312  04C5
4313  04C6
4314  04C7
4315  04C8
4316  04C9
4317  04CA
4318  04CB
4319  04CC
4320  04CD
4321  04CE
4322  04CF
4323  04D0
4324  04D1
4325  04D2
4326  04D3
4327  04D4
4328  04D5
4329  04D6
4330  04D7
4331  04D8
4332  04D9
4333  04DA
4334  04DB
4335  04DC
4336  04DD
4337  04DE
4338  04DF
4339  04E0
4340  04E1
4341  04E2
4342  04E3
4343  04E4
4344  04E5
4345  04E6
4346  04E7
4347  04E8
4348  04E9
4349  04EA
4350  04EB
4351  04EC
4352  04ED
4353  04EE
4354  04EF
4355  04F0
4356  04F1
4357  04F2
4358  04F3
4359  04F4
4360  04F5
4361  04F6
4362  04F7
4363  04F8
4364  04F9
4365  04FA
4366  04FB
4367  04FC
4368  04FD
4369  04FE
4370  04FF
4371  0500
4372  0501
4373  0502
4374  0503
4375  0504
4376  0505
4377  0506
4378  0507
4379  0508
4380  0509
4381  050A
4382  050B
4383  050C
4384  050D
4385  050E
4386  050F
4387  0510
4388  0511
4389  0512
4390  0513
4391  0514
4392  0515
4393  0516
4394  0517
4395  0518
4396  0519
4397  051A
4398  051B
4399  051C
4400  051D
4401  051E
4402  051F
4403  0520
4404  0521
4405  0522
4406  0523
4407  0524
4408  0525
4409  0526
4410  0527
4411  0528
4412  0529
4413  052A
4414  052B
4415  052C
4416  052D
4417  052E
4418  052F
4419  0530
4420  0531
4421  0532
4422  0533
4423  0534
4424  0535
4425  0536
4426  0537
4427  0538
4428  0539
4429  053A
4430  053B
4431  053C
4432  053D
4433  053E
4434  053F
4435  0540
4436  0541
4437  0542
4438  0543
4439  0544
4440  0545
4441  0546
4442  0547
4443  0548
4444  0549
4445  054A
4446  054B
4447  054C
4448  054D
4449  054E
4450  054F
4451  0550
4452  0551
4453  0552
4454  0553
4455  0554
4456  0555
4457  0556
4458  0557
4459  0558
4460  0559
4461  055A
4462  055B
4463  055C
4464  055D
4465  055E
4466  055F
4467  0560
4468  0561
4469  0562
4470  0563
4471  0564
4472  0565
4473  0566
4474  0567
4475  0568
4476  0569
4477  056A
4478  056B
4479  056C
4480  056D
4481  056E
4482  056F
4483  0570
4484  0571
4485  0572
4486  0573
4487  0574
4488  0575
4489  0576
4490  0577
4491  0578
4492  0579
4493  057A
4494  057B
4495  057C
4496  057D
4497  057E
4498  057F
4499  0580
4500  0581
4501  0582
4502  0583
4503  0584
4504  0585
4505  0586
4506  0587
4507  0588
4508  0589
4509  058A
4510  058B
4511  058C
4512  058D
4513  058E
4514  058F
4515  0590
4516  0591
4517  0592
4518  0593
4519  0594
4520  0595
4521  0596
4522  0597
4523  0598
4524  0599
4525  059A
4526  059B
4527  059C
4528  059D
4529  059E
4530  059F
4531  05A0
4532  05A1
4533  05A2
4534  05A3
4535  05A4
4536  05A5
4537  05A6
4538  05A7
4539  05A8
4540  05A9
4541  05AA
4542  05AB
4543  05AC
4544  05AD
4545  05AE
4546  05AF
4547  05B0
4548  05B1
4549  05B2
4550  05B3
4551  05B4
4552  05B5
4553  05B6
4554  05B7
4555  05B8
4556  05B9
4557  05BA
4558  05BB
4559  05BC
4560  05BD
4561  05BE
4562  05BF
4563  05C0
4564  05C1
4565  05C2
4566  05C3
4567  05C4
4568  05C5
4569  05C6
4570  05C7
4571  05C8
4572  05C9
4573  05CA
4574  05CB
4575  05CC
4576  05CD
4577  05CE
4578  05CF
4579  05D0
4580  05D1
4581  05D2
4582  05D3
4583  05D4
4584  05D5
4585  05D6
4586  05D7
4587  05D8
4588  05D9
4589  05DA
4590  05DB
4591  05DC
4592  05DD
4593  05DE
4594  05DF
4595  05E0
4596  05E1
4597  05E2
4598  05E3
4599  05E4
4600  05E5
4601  05E6
4602  05E7
4603  05E8
4604  05E9
4605  05EA
4606  05EB
4607  05EC
4608  05ED
4609  05EE
4610  05EF
4611  05F0
4612  05F1
4613  05F2
4614  05F3
4615  05F4
4616  05F5
4617  05F6
4618  05F7
4619  05F8
4620  05F9
4621  05FA
4622  05FB
4623  05FC
4624  05FD
4625  05FE
4626  05FF
4627  0600
4628  0601
4629  0602
4630  0603
4631  0604
4632  0605
4633  0606
4634  0607
4635  0608
4636  0609
4637  060A
4638  060B
4639  060C
4640  060D
4641  060E
4642  060F
4643  0610
4644  0611
4645  0612
4646  0613
4647  0614
4648  0615
4649  0616
4650  0617
4651  0618
4652  0619
4653  061A
4654  061B
4655  061C
4656  061D
4657  061E
4658  061F
4659  0620
4660  0621
4661  0622
4662  0623
4663  0624
4664  0625
4665  0626
4666  0627
4667  0628
4668  0629
4669  062A
4670  062B
4671  062C
4672  062D
4673  062E
4674  062F
4675  0630
4676  0631
4677  0632
4678  0633
4679  0634
4680  0635
4681  0636
4682  0637
4683  0638
4684  0639
4685  063A
4686  063B
4687  063C
4688  063D
4689  063E
4690  063F
4691  0640
4692  0641
4693  0642
4694  0643
4695  0644
4696  0645
4697  0646
4698  0647
4699  0648
4700  0649
4701  064A
4702  064B
4703  064C
4704  064D
4705  064E
4706  064F
4707  0650
4708  0651
4709  0652
4710  0653
4711  0654
4712  0655
4713  0656
4714  0657
4715  0658
4716  0659
4717  065A
4718  065B
4719  065C
4720  065D
4721  065E
4722  065F
4723  0660
4724  0661
4725  0662
4726  0663
4727  0664
4728  0665
4729  0666
4730  0667
4731  0668
4732  0669
4733  066A
4734  066B
4735  066C
4736  066D
4737  066E
4738  066F
4739  0670
4740  0671
4741  0672
4742  0673
4743  0674
4744  0675
4745  0676
4746  0677
4747  0678
4748  0679
4749  067A
4750  067B
4751  067C
4752  067D
4753  067E
4754  067F
4755  0680
4756  0681
4757  0682
4758  0683
4759  0684
4760  0685
4761  0686
4762  0687
4763  0688
4764  0689
4765  068A
4766  068B
4767  068C
4768  068D
4769  068E
4770  068F
4771  0690
4772  0691
4773  0692
4774  0693
4775  0694
4776  0695
4777  0696
4778  0697
4779  0698
4780  0699
4781  069A
4782  069B
4783  069C
4784  069D
4785  069E
4786  069F
4787  06A0
4788  06A1
4789  06A2
4790  06A3
4791  06A4
4792  06A5
4793  06A6
4794  06A7
4795  06A8
4796  06A9
4797  06AA
4798  06AB
4799  06AC
4800  06AD
4801  06AE
4802  06AF
4803  06B0
4804  06B1
4805  06B2
4806  06B3
4807  06B4
4808  06B5
4809  06B6
4810  06B7
4811  06B8
4812  06B9
4813  06BA
4814  06BB
4815  06BC
4816  06BD
4817  06BE
4818  06BF
4819  06C0
4820  06C1
4821  06C2
4822  06C3
4823  06C4
4824  06C5
4825  06C6
4826  06C7
4827  06C8
4828  06C9
4829  06CA
4830  06CB
4831  06CC
4832  06CD
4833  06CE
4834  06CF
4835  06D0
4836  06D1
4837  06D2
4838  06D3
4839  06D4
4840  06D5
4841  06D6
4842  06D7
4843  06D8
4844  06D9
4845  06DA
4846  06DB
4847  06DC
4848  06DD
4849  06DE
4850  06DF
4851  06E0
4852  06E1
4853  06E2
4854  06E3
4855  06E4
4856  06E5
4857  06E6
4858  06E7
4859  06E8
4860  06E9
4861  06EA
4862  06EB
4863  06EC
4864  06ED
4865  06EE
4866  06EF
4867  06F0
4868  06F1
4869  06F2
4870  06F3
4871  06F4
4872  06F5
4873  06F6
4874  06F7
4875  06F8
4876  06F9
4877  06FA
4878  06FB
4879  06FC
4880  06FD
4881  06FE
4882  06FF
4883  0700
4884  0701
4885  0702
4886  0703
4887  0704
4888  0705
4889  0706
4890  0707
4891  0708
4892  0709
4893  070A
4894  070B
4895  070C
4896  070D
4897  070E
4898  070F
4899  0710
4900  0711
4901  0712
4902  0713
4903  0714
4904  0715
4905  0716
4906  0717
4907  0718
4908  0719
4909  071A
4910  071B
4911  071C
4912  071D
4913  071E
4914  071F
4915  0720
4916  0721
4917  0722
4918  0723
4919  0724
4920  0725
4921  0726
4922  0727
004923  000228        
004924  000229      var vIAngularMeter0[WIDGET_RAM_SPACE] ;
004925  000230      var vIAngularMeter1[WIDGET_RAM_SPACE] ;
004926  000231      var vILedDigits0[WIDGET_RAM_SPACE+2] ;
004927  000232      var vIAngularMeter3[WIDGET_RAM_SPACE] ;
004928  000233      var vILedDigits1[WIDGET_RAM_SPACE+2] ;
004929  000234      var vILedDigits2[WIDGET_RAM_SPACE+2] ;
004930  000235      var vILedDigits3[WIDGET_RAM_SPACE+2] ;
004931  000236      var vIAngularMeter2[WIDGET_RAM_SPACE] ;
004932  000237      var vILedDigits4[WIDGET_RAM_SPACE+2] ;
004933  000238  // Start P2.inc
004934  000239  var vObjects[MaxIntObjects+1] ;              // address of RAM objects
004935  000240  var GObjectIdx, GObjectFunc, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings ;
004936  000241  var oObjects[MaxTotObjects+1] ;                 // address of objects
004937  000242  var CurrentForm, oldn, ImageTouched ;
004938  000243  var TouchXpos, TouchYpos ;
004939  000244  var GObjectType, TouchState, CurInputData, pInputIndex ;
004940  000245  var comRX[40], cmd[CMDLenMAX] ;
004941  000246        
004942  000247  var InputCS, OutputCS ;
004943  000248        
004944  000249  // > ? Constant/Global/Data ? <
004945  000250        
004946  000251  func addressInternalWidget(var idx var iponly)
004947  000252      var i, j ;
004948  000253  //to(COM0) ; print("Address Int ", idx, " ") ; pause(2) ;
004949  000254      GObjectIdx := xobj2iobj[idx] ;
004950  000255      GObjectType := (GObjectIdx>>8) ;                          // extract object type
004951  000256      i := oObjects[GObjectType] ;                              // i is address of list of all objects of this type
004952  000257      GObjectIdx &= 0xff ;
004953  000258      //GObjectIdx *= 2 ;
004954  000259      j := GObjectIdx * 2 ;
004955  000260      GObjectDATA := i[j + 2] ;                                 // address of this object
004956  000261      i := vObjects[GObjectType-tiAngularMeter] ;               // i is address of list of all ram objects of his type
004957  000262      GObjectRAM := i[j] ;                                      // address of this objects' ram
004958  000263      i := GObjectType-tiAngularMeter ;
004959  000264      GObjectFunc := gfxInternals[i] ; // address function
004960  000265      GObjectParms := gfxIntParms[i] ;
004961  000266      GObjectStrings := gfxIntStrings[i] ;
004962  000267  //to(COM0) ; print([HEX4] GObjectFunc, " ", [HEX4] GObjectRAM, " ", [HEX4] GObjectDATA, " ", GObjectType, " ", GObjectIdx, "\r\n") ;
004963  000268  //    GObjectFunc(0, GObjectRAM, GObjectDATA) ;
004964  000269  endfunc
004965  000270        
004966  000271  func seroutCS(var op)
004967  000272      serout(op) ;
004968  000273      OutputCS ^= op ;
004969  000274  endfunc
004970  000275        
004971  000276  func nak0()
004972  000277      serout(NAK) ;
004973  000278      InputCS := 0 ;
004974  000279  endfunc
004975  000280        
004976  000281  func seroutOcs()
004977  000282      serout(OutputCS) ;
004978  000283      OutputCS := 0 ;
004979  000284  endfunc
004980  000285        
004981  000286  func SendReport(var id, var objt, var objn, var val)
004982  000287      seroutCS(id) ;
004983  000288      seroutCS(objt) ;
004984  000289      seroutCS(objn) ;
004985  000290      seroutCS(val >> 8) ; // first 8 bits
004986  000291      seroutCS(val) ;
004987  000292      seroutOcs() ;
004988  000293  endfunc
004989  000294        
004990  000295        
004991  000296  func ReadObject(var ObjectType, var ObjectIdx)
004992  000297      var j, k, Objects ;
004993  000298      if ((ObjectType >= tiLedDigitsH) && (ObjectType <= tiLinearInput))
004994  000299          j := ObjectIdx *2 ;
004995  000300          k := vObjects[ObjectType-tiAngularMeter] ;               // k is address of list of all ram objects of his type
004996  000301          k := k[j] ;                                              // k is address of this objects' ram
004997  000302          if (ObjectType == tiLedDigit)
004998  000303              k := k[0] ;
004999  000304          else 
005000  000305              k := k[WIDGET_VAL1] ;
005001  000306          endif
005002  000307  //gfx_MoveTo(0,0); txt_Opacity(OPAQUE) ; print(ObjectType, " ", ObjectIdx, " ", k," ") ;
005003  000308      else
005004  000309      Objects := *(oObjects+ObjectType) ;
005005  000310        
005006  000311      j := 2 + ObjectIdx * 2 + Objects ;
005007  000312       if (ObjectType == tForm)
005008  000313          k := CurrentForm ;
005009  000314          else
005010  000315          k := img_GetWord(hndl, *j, IMAGE_INDEX);
005011  000316          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
005012  000317                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
005013  000318      endif
005014  000319      endif
005015  000320      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
005016  000321  endfunc
005017  000322        
005018  000323  var wp ;
005019  000324        
005020  000325        
005021  000326  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
005022  000327      var i, j, k, Objects ;
005023  000328  //    ObjectType &= 0x3f ; Why was his there? Anibuttons? Complex cascades?
005024  000329      if (ObjectType == tForm)
005025  000330          ActivateForm(ObjectIdx) ;
005026  000331          return ;
005027  000332      endif
005028  000333      Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
005029  000334      i := *(Objects) ;
005030  000335      if ((ObjectType >= tiAngularMeter) && (ObjectType <= tiLinearInput))
005031  000336          i := oObjects[ObjectType] ;                              // f is address of list of all objects of this type
005032  000337          j := ObjectIdx *2 ;
005033  000338          i := i[j + 2] ;                         // f is address of this object
005034  000339          k := vObjects[ObjectType-tiAngularMeter] ;               // a is address of list of all ram objects of his type
005035  000340          k := k[j] ;                             // a is address of this objects' ram
005036  000341              j := ObjectType-tiAngularMeter ;
005037  000342              Objects := gfxInternals[j] ;           // locate function address   
005038  000343              Objects(NewVal, k, i) ; 
005039  000344          return ;
005040  000345      endif
005041  000346      switch (ObjectType)
005042  000347          case tWinButton :
005043  000348              j := InputControls[oWinButtons[ObjectIdx+1]] ;
005044  000349              break ;
005045  000350          default : j := -1 ;
005046  000351      endswitch
005047  000352        
005048  000353      if (j != -1)
005049  000354          k := img_GetWord(hndl, i , IMAGE_INDEX) ;
005050  000355              NewVal := NewVal << 1 ;
005051  000356              if (OVF())      // button group index change
005052  000357                  if (*(j+InputData+Ofs_IPD_P1))
005053  000358                      k &= 1 ;    // mask off old group index for momentary
005054  000359                  else
005055  000360                      k &= 3 ;    // mask off old group index for toggle
005056  000361                  endif
005057  000362              else            // normal set
005058  000363                  if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
005059  000364                  k &= 0xfffc ;    // retain only group index for state set
005060  000365              endif
005061  000366              NewVal |= k ;
005062  000367  //        endif
005063  000368          endif
005064  000369        
005065  000370      img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
005066  000371      img_Show(hndl, i) ; // will only display if form is current
005067  000372      return ; // compiler bug circumvention!
005068  000373  endfunc
005069  000374        
005070  000375  func TurnOffButtons(var group)
005071  000376      var j, k, l, m, n, o, p;
005072  000377      m := GObjectIdx ;     // save as will be clobbered
005073  000378      n := GObjectType ;     // save as will be clobbered
005074  000379      for (j := 0; j < nInputs; j++)
005075  000380          k := j*IPDatasize ;
005076  000381          if (*(InputData+k+Ofs_IPD_P2) == group)
005077  000382              l := -1 ;
005078  000383               if (*(InputData+k) == tWinButton)
005079  000384                  l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
005080  000385                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
005081  000386                  img_Show(hndl, l);      // only shows on current form
005082  000387        
005083  000388              endif
005084  000389          endif
005085  000390      next
005086  000391      GObjectIdx := m ;     // Restore
005087  000392      GObjectType := n ;    // Restore
005088  000393  endfunc
005089  000394        
005090  000395        
005091  000396        
005092  000397        
005093  000398  func ActivateForm(var newform)
005094  000399      var i, j, *p ;
005095  000400        
005096  000401          widget_Disable(wp, ALL) ;
005097  000402      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
005098  000403          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
005099  000404              if (img_GetWord(hndl, i, IMAGE_TAG))
005100  000405                  img_Disable(hndl,i) ;
005101  000406              endif
005102  000407          next
005103  000408      endif
005104  000409      CurrentForm := newform ;
005105  000410      // display newform image or clear to image color
005106  000411      if (FormBGcolors[CurrentForm] != ColorBGimage)
005107  000412          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
005108  000413          gfx_Cls() ;
005109  000414          DoGFXObjects() ;                                    // display GFX 'widgets'
005110  000415      endif
005111  000416        
005112  000417      // enable inputs
005113  000418      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
005114  000419          j := img_GetWord(hndl, i, IMAGE_TAG) ;
005115  000420          if (j)
005116  000421              j-- ;
005117  000422              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
005118  000423              //if (j != tKeyboard)
005119  000424              if (((j <= tWinButton) || (j >= t4Dbutton)) && (j != tSmartGauge) )               // enable inputs
005120  000425                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
005121  000426              endif
005122  000427              img_Show(hndl,i) ; // show initialy, if required
005123  000428              if (j == tForm)
005124  000429                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
005125  000430              endif
005126  000431          endif
005127  000432      next
005128  000433        
005129  000434      // enable inputs
005130  000435         var a, f ; 
005131  000446  */
005132  000447      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
005133  000448          addressInternalWidget(i, 0) ;
005134  000449          widget_Enable(wp,i) ;
005135  000450          if (GObjectType != tiLabelB) widget_ClearAttributes(wp,i,WIDGET_F_INITIALISED) ; // don't clear initialised for tiLabelB
005136  000451                  j := GObjectRAM[WIDGET_VAL1] ;
005137  000452                  GObjectFunc(j, GObjectRAM, GObjectDATA) ; 
005138  000453      next
005139  000454      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
005140  000455          if (InternalInputControls[i] != -1)
005141  000456              widget_SetAttributes(wp,i,WIDGET_F_TOUCH_ENABLE) ;
005142  000457          endif
005143  000458      next
005144  000459        
005145  000460        
005146  000461  endfunc
005147  000462        
005148  000463  func UpdateObjects(var newval)
005149  000464      var IPidx, otherOBJ, oldvalue ;
005150  000465      if (GObjectType < tiLedDigitsH)
005151  000466          oldvalue := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ;
005152  000467      else
005153  000468          oldvalue := GObjectRAM[WIDGET_VAL1] ;
005154  000469      endif
005155  000470      if ( ( oldvalue != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
005156  000471        
005157  000472      if (GObjectType < tiLedDigitsH)
005158  000473          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
005159  000474              img_Show(hndl, *(pInputIndex));      // only shows on current form
005160  000475      else
005161  000476          WriteObject(GObjectType, GObjectIdx, newval) ;
005162  000477      endif
005163  000478          if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
005164  000479              if (*(CurInputData+Ofs_IPD_P1))
005165  000480                  newval &= 1;
005166  000481              else
005167  000482                  newval &= 3;
005168  000483              endif
005169  000484              if (newval > 1) newval := 1;
005170  000485          endif
005171  000486          IPidx := *(CurInputData+TouchState) ;
005172  000487          while(IPidx != 0)
005173  000488              otherOBJ := IPidx + InputData;
005174  000489              if (*(otherOBJ) == OT_REPORT)
005175  000490                  SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
005176  000491              else if (*(otherOBJ) == OT_MAGIC)
005177  000492                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
005178  000493                  IPidx(newval) ;
005179  000494  //            else if (TouchState == *(otherOBJ+Ofs_IPD_P4))  // test prior to Workshop 6.5.0.0
005180  000495              else if ((TouchState == *(otherOBJ+Ofs_IPD_P4)) || (*(CurInputData+Ofs_IPD_P1) && ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))))
005181  000496                  if (*(otherOBJ) == OT_ACTIVATE)
005182  000497                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
005183  000498                      GObjectType := tForm ;
005184  000499                  else if (*(otherOBJ) == OT_SETCONST)
005185  000500                      newval := *(otherOBJ+Ofs_IPD_P3) ;
005186  000501                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
005187  000502                  else if (*(otherOBJ) == OT_SETANOTHER)
005188  000503                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
005189  000504                  else if (*(otherOBJ) == OT_PREVFRAME)
005190  000505                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
005191  000506                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
005192  000507                      endif
005193  000508                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
005194  000509                  else if (*(otherOBJ) == OT_NEXTFRAME)
005195  000510                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
005196  000511                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
005197  000512                      endif
005198  000513                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
005199  000514                  endif
005200  000515              endif
005201  000516              IPidx := *(otherOBJ+TouchState) ;
005202  000517          wend
005203  000518      endif
005204  000519  endfunc
005205  000520        
005206  000521  // End P2.inc
005207  000522  func DoGFXObjects()
005208  000523  endfunc
005209  000524        
005210  000525  // Start P3.inc
005211  000526  func main()
005212  000527      var comTX[50], cmdi, i, j, TouchStatus ;
005213  000528        
005214  000529        
005215  000530      gfx_ScreenMode(LANDSCAPE) ;
005216  000531        
005217  000532      media_InitFlash(FLASH_ADDR_DEF_COMMAND) ;
005218  000533        
005219  000534        
005220  000535  //    gfx_MoveTo(0, 0);
005221  000536  //    print(mem_Heap()," ") ;
005222  000537  //    gfx_TransparentColour(0x0020);
005223  000538  //    gfx_Transparency(ON);
005224  000539        
005225  000540        
005226  000541      // open image control
005227  000542      hndl := file_LoadImageControl(0, 0, 3);
005228  000543        
005229  000544      // init 'constants'
005230  000545  // End P3.inc
005231  000546        
005232  000547      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
005233  000548      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
005234  000549      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
005235  000550      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
005236  000551      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
005237  000552      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
005238  000553      oObjects[tWinButton] := oWinButtons ;
005239  000554      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
005240  000555      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
005241  000556      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
005242  000557      oObjects[tForm] := oForms ;
005243  000558      oObjects[tGauge] := oGauges ;
005244  000559      oObjects[tImage] := oImages ;
005245  000560      oObjects[tKeyboard] := oDipSwitchs ; // dummy as no object there
005246  000561      oObjects[tLed] := oDipSwitchs ; // dummy as no object there
005247  000562      oObjects[tLeddigits] := oDipSwitchs ; // dummy as no object there
005248  000563      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
005249  000564      oObjects[tStrings] := oDipSwitchs ; // dummy as no object there
005250  000565      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
005251  000566      oObjects[tUserled] := oDipSwitchs ; // dummy as no object there
005252  000567      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
005253  000568      oObjects[tStaticText] := oDipSwitchs ; // dummy as no object there
005254  000569      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
005255  000570      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
005256  000571      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
005257  000572      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
005258  000573      oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
005259  000574      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
005260  000575      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
005261  000576      oObjects[t4Dbutton] := oDipSwitchs ; // dummy as no object there
005262  000577      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
005263  000578      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
005264  000579      oObjects[tUserButton] := oDipSwitchs ; // dummy as no object there
005265  000580      oObjects[tMagicObject] := oDipSwitchs ; // dummy as no object there
005266  000581      oObjects[tSmartGauge] := oDipSwitchs ; // dummy as no object there
005267  000582      oObjects[tSmartSlider] := oDipSwitchs ; // dummy as no object there
005268  000583      oObjects[tSmartKnob] := oDipSwitchs ; // dummy as no object there
005269  000584      oObjects[tiLedDigitsH] := oDipSwitchs ; // dummy as no object there
005270  000585      oObjects[tiAngularMeter] := oiAngularMeters ;
005271  000586      oObjects[tiGauge] := oDipSwitchs ; // dummy as no object there
005272  000587      oObjects[tiLabelB] := oDipSwitchs ; // dummy as no object there
005273  000588      oObjects[tiUserGauge] := oDipSwitchs ; // dummy as no object there
005274  000589      oObjects[tiMediaGauge] := oDipSwitchs ; // dummy as no object there
005275  000590      oObjects[tiMediaThermometer] := oDipSwitchs ; // dummy as no object there
005276  000591      oObjects[tiLed] := oDipSwitchs ; // dummy as no object there
005277  000592      oObjects[tiMediaLed] := oDipSwitchs ; // dummy as no object there
005278  000593      oObjects[tiLedDigits] := oiLedDigitss ;
005279  000594      oObjects[tiNeedle] := oDipSwitchs ; // dummy as no object there
005280  000595      oObjects[tiRuler] := oDipSwitchs ; // dummy as no object there
005281  000596      oObjects[tiLedDigit] := oDipSwitchs ; // dummy as no object there
005282  000597      oObjects[tiButtonD] := oDipSwitchs ; // dummy as no object there
005283  000598      oObjects[tiButtonE] := oDipSwitchs ; // dummy as no object there
005284  000599      oObjects[tiMediaButton] := oDipSwitchs ; // dummy as no object there
005285  000600      oObjects[tiToggleInput] := oDipSwitchs ; // dummy as no object there
005286  000601      oObjects[tiDial] := oDipSwitchs ; // dummy as no object there
005287  000602      oObjects[tiMediaRotary] := oDipSwitchs ; // dummy as no object there
005288  000603      oObjects[tiRotaryInput] := oDipSwitchs ; // dummy as no object there
005289  000604      oObjects[tiSwitch] := oDipSwitchs ; // dummy as no object there
005290  000605      oObjects[tiSwitchB] := oDipSwitchs ; // dummy as no object there
005291  000606      oObjects[tiSliderE] := oDipSwitchs ; // dummy as no object there
005292  000607      oObjects[tiMediaSlider] := oDipSwitchs ; // dummy as no object there
005293  000608      oObjects[tiSliderH] := oDipSwitchs ; // dummy as no object there
005294  000609      oObjects[tiSliderG] := oDipSwitchs ; // dummy as no object there
005295  000610      oObjects[tiSliderF] := oDipSwitchs ; // dummy as no object there
005296  000611      oObjects[tiSliderD] := oDipSwitchs ; // dummy as no object there
005297  000612      oObjects[tiSliderC] := oDipSwitchs ; // dummy as no object there
005298  000613      oObjects[tiLinearInput] := oDipSwitchs ; // dummy as no object there
005299  000614      vObjects[0] := oiviAngularMeter ;
005300  000615      vObjects[8] := oiviLedDigits ;
005301  000616  // Start P4.inc
005302  000617      wp := widget_Create(9) ;
005303  000618      for (i := 0; i < 9; i++)
005304  000619  	addressInternalWidget(i, 0) ;
005305  000620          if (GObjectType != tiLedDigit) widget_Add(wp, i, GObjectRAM) ;    // don't add tiLedDigit objects as they are only 1 word long
005306  000621      next
005307  000622        
005308  000623      // init comms
005309  000624      com_Init(comRX,CMDLenMAX,0);
005310  000625      com_SetBaud(COM0,960);
005311  000626      com_TXbuffer(comTX, 100, 0);
005312  000627      // tag 'real' objects
005313  000628      for (i := 0; i <= MaxTotObjects; i++)
005314  000629          if (   (i != tSounds)
005315  000630              && (i != tTimer)
005316  000631              && (i != tPinOutput)
005317  000632              && (i != tMagicObject)
005318  000633              && (i != tPinInput) )
005319  000634              TouchXpos := oObjects[i] ;
005320  000635              TouchYpos := *(TouchXpos) ;
005321  000636              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
005322  000637                  oldn := *(TouchXpos+ImageTouched*2) ;
005323  000638                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
005324  000639                  if (oldn != -1)
005325  000640                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
005326  000641                      img_Disable(hndl, oldn) ;
005327  000642                  endif
005328  000643              next
005329  000644          endif
005330  000645      next
005331  000646        
005332  000647      // display initial form
005333  000648      CurrentForm := -1 ;
005334  000649  // End P4.inc
005335  000650  // Start P5.inc
005336  000651      ActivateForm(0) ; // need to change this according to first actual form
005337  000652        
005338  000653  // End P5.inc
005339  000654  // Start P6.inc px44
005340  000655      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
005341  000656      oldn := -1 ;
005342  000657      repeat
005343  000658        
005344  000659          // check comms for command, how to NAK invalid command
005345  000660          if (com_Count() != 0)
005346  000661              i := serin() ;
005347  000662              InputCS ^= i ;               // update checksum
005348  000663                  cmd[cmdi++] := i ;
005349  000664                   if (   (cmd[0] == READ_OBJ)
005350  000665                           && (cmdi == 4)         )
005351  000666                      if (InputCS)
005352  000667                          nak0() ;
005353  000668                      else
005354  000669                          ReadObject(cmd[1], cmd[2]) ;
005355  000670                      endif
005356  000671                      cmdi := 0 ;
005357  000672                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
005358  000673                           && (cmdi == 6)          )
005359  000674                      if (InputCS)
005360  000675                          nak0() ;
005361  000676                      else
005362  000677                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
005363  000678                          serout(ACK) ;
005364  000679                      endif
005365  000680                      cmdi := 0 ;
005366  000681                  else if (   (cmd[0] == WRITE_CONTRAST)
005367  000682                           && (cmdi == 3)         )
005368  000683                      if (InputCS)
005369  000684                          nak0() ;
005370  000685                      else
005371  000686                          gfx_Contrast(cmd[1]) ;
005372  000687                          serout(ACK) ;
005373  000688                      endif
005374  000689                      cmdi := 0 ;
005375  000690                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
005376  000691                      nak0() ;
005377  000692                      cmdi := 0 ;
005378  000693                  endif
005379  000694          endif   // a character is available
005380  000695        
005381  000696        
005382  000697      // touch code processing
005383  000698        
005384  000699          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
005385  000700          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
005386  000701              ImageTouched := img_Touched(hndl,-1) ;
005387  000702              if (ImageTouched == -1)
005388  000703                  ImageTouched := widget_Touched(wp, ALL) ;
005389  000704                  if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
005390  000705              endif
005391  000706              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
005392  000707                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
005393  000708              endif
005394  000709              if (TouchStatus != TOUCH_RELEASED)        // if not released
005395  000710                  if (oldn != -1)
005396  000711                      ImageTouched := oldn ;
005397  000712                  else
005398  000713                      if (oldn != ImageTouched)
005399  000714                  oldn := ImageTouched ;
005400  000715                          TouchStatus := TOUCH_PRESSED ;
005401  000716                      endif
005402  000717                  endif
005403  000718                  TouchXpos  := touch_Get(TOUCH_GETX);
005404  000719                  TouchYpos  := touch_Get(TOUCH_GETY);
005405  000720                  TouchState := Ofs_IPD_DOWN ;
005406  000721              else
005407  000722                  ImageTouched := oldn ;                     // simulate release of what we touched
005408  000723                  oldn := -1 ;                    // prevent double release
005409  000724                  TouchState := Ofs_IPD_RELEASE ;
005410  000725              endif
005411  000726              if (ImageTouched >= 0)
005412  000727                          CurInputData := InputControls[ImageTouched] + InputData;
005413  000728                          GObjectType := *(CurInputData) ;
005414  000729                          if (GObjectType == tSmartSlider)
005415  000730                              i := tTrackbar ; // GSlider ;
005416  000731                          else if (GObjectType == tSmartKnob)
005417  000732                              i := tKnob ;
005418  000733                          else if (GObjectType >= t4Dbutton) 
005419  000734                              i := GObjectType - 23 ; // adjust to ensure next in gosub
005420  000735                          else 
005421  000736                              i := GObjectType ;
005422  000737                          endif
005423  000738                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
005424  000739                          ImageTouched := -1 ; // show processed here
005425  000740              endif
005426  000741              if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
005427  000742              if (ImageTouched >= 0)
005428  000743  //print(ImageTouched," ") ;
005429  000744  //                        CurInputData := InternalInputControls[ImageTouched] + InternalInputData;
005430  000745                          CurInputData := InternalInputControls[ImageTouched] + InputData;
005431  000746  //                        GObjectType := *(CurInputData) ;
005432  000747  //                        i := GObjectType ;
005433  000748  //                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
005434  000749  //                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
005435  000750                          addressInternalWidget(ImageTouched, 0) ;
005436  000751  //                        i := xobj2iiobj[ImageTouched] ;                            // address object type and hash from ram index
005437  000752  //                        GObjectIdx := i & 0xff ;
005438  000753  //                        GObjectType := (i>>8) ;                                   // extract object type
005439  000754                          if (GObjectType <= tiToggleInput) 
005440  000755                              i := 0 ;
005441  000756                          else if (GObjectType <= tiRotaryInput) 
005442  000757                              i := 1 ;
005443  000758                          else if (GObjectType <= tiSwitchB) 
005444  000759                              i := 2 ;
005445  000760                          else 
005446  000761                              i := 3 ;
005447  000762                          endif
005448  000763  //to(COM0) ; print(i, "\r\n") ;  
005449  000764        
005450  000765                          gosub (i), (ciButton, ciDial, ciSwitch, ciSlider) ;
005451  000766        
005452  000767        
005453  000768  //            ImageTouched := widget_Touched(wp, ALL) ;
005454  000769              endif
005455  000770          endif
005456  000771   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
005457  000772        
005458  000773          sys_EventsResume() ;
005459  000774      forever
005460  000775        
005461  000776  ciSwitch:
005462  000777  cDipswitch:
005463  000778        
005464  000779  cKnob:
005465  000780  ciDial:
005466  000781        
005467  000782  cRockerswitch:
005468  000783        
005469  000784  cRotaryswitch:
005470  000785        
005471  000786  cSlider:
005472  000787  cTrackbar:
005473  000788  ciSlider:
005474  000789        
005475  000790  ciButton:
005476  000791        
005477  000792  c4DButton:
005478  000793  cUserButton:
005479  000794  cWinbutton:
005480  000795      pInputIndex := oObjects[GObjectType]  + *(CurInputData+Ofs_IPD_OBJVIDX) ;
005481  000796      i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
005482  000797  CommonButtons:
005483  000798      if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
005484  000799          if (TouchStatus == TOUCH_RELEASED)
005485  000800              i &= 0xfffe ;
005486  000801              TouchState == Ofs_IPD_DOWN ;
005487  000802          else
005488  000803              i |= 1 ;
005489  000804              TouchState == Ofs_IPD_RELEASE ;
005490  000805          endif
005491  000806      else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
005492  000807          if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
005493  000808              if ((i & 3) == 3)
005494  000809                  i &= 0xfffc ;
005495  000810              else
005496  000811                  i++ ;
005497  000812              endif
005498  000813          else
005499  000814              i |= 1 ;                                      // make down regardless of current state
005500  000815          endif
005501  000816      else                        // group action, up all other buttons on touch press, reports 0 for button down
005502  000817          if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
005503  000818              TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
005504  000819          endif
005505  000820          if (GObjectType < tiLedDigits)
005506  000821              i := (i & 0xfffc) | 2 ;         // uSD button, four, grouping and blocking states
005507  000822          else
005508  000823              i := 1 ;                        // Internal button two states
005509  000824          endif
005510  000825      endif
005511  000826        
005512  000827      UpdateObjects(i) ;
005513  000828  endsub ;
005514  000829        
005515  000830  cAniButton:
005516  000831        
005517  000832  cColorPicker:
005518  000833        
005519  000834  endfunc
005520  000835  // End P6.inc
Notice: local var 'j' in func 'main' is never used (line 527 file:SprinterGauge.4DGenieS)
Notice: variable 'GObjectRAM' is being indexed (line 468 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'IPidx' requires 1 argument (line 493 file:SprinterGauge.4DGenieS)
Notice: variable 'GObjectRAM' is being indexed (line 451 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'GObjectFunc' requires 3 arguments (line 452 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 399 file:SprinterGauge.4DGenieS)
Notice: local var 'a' in func 'ActivateForm' is never used (line 435 file:SprinterGauge.4DGenieS)
Notice: local var 'f' in func 'ActivateForm' is never used (line 435 file:SprinterGauge.4DGenieS)
Notice: local var 'o' in func 'TurnOffButtons' is never used (line 376 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'TurnOffButtons' is never used (line 376 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 338 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 340 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'Objects' requires 3 arguments (line 343 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 301 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 303 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 305 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 260 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 262 file:SprinterGauge.4DGenieS)
Notice: function argument 'iponly' in func 'addressInternalWidget' is never used (line 251 file:SprinterGauge.4DGenieS)


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXFLASH                           128  0x00000080 (const dword)  (not used)
__MAXMEM                           30290  0x00007652 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             4  0x00000004 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 6)
ActivateForm                        3362  0x00000d22 (User func) args[1] r=0  (usage 9)
addressInternalWidget               4652  0x0000122c (User func) args[2] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (usage 6)
ANALOGUE                               2  0x00000002 (const dword)  (not used)
ANGULAR_bgcol                         66  0x00000042 (const dword)  (not used)
ANGULAR_c1                            24  0x00000018 (const dword)  (not used)
ANGULAR_c2                            26  0x0000001a (const dword)  (not used)
ANGULAR_c3                            28  0x0000001c (const dword)  (not used)
ANGULAR_capcol                        46  0x0000002e (const dword)  (not used)
ANGULAR_capfnt                        44  0x0000002c (const dword)  (not used)
ANGULAR_capofsx                       48  0x00000030 (const dword)  (not used)
ANGULAR_capofsy                       50  0x00000032 (const dword)  (not used)
ANGULAR_Caption                       52  0x00000034 (const dword)  (not used)
ANGULAR_cxx                           62  0x0000003e (const dword)  (not used)
ANGULAR_cyx                           64  0x00000040 (const dword)  (not used)
ANGULAR_F_BG_TRANSPARENT             N/A         N/A (macro)   0x0002   (not used)
ANGULAR_F_LABEL_STRINGS              N/A         N/A (macro)   0x0001   (not used)
ANGULAR_F_TEXT_PCT_COLOUR            N/A         N/A (macro)   0x0008   (not used)
ANGULAR_F_TICK_PCT_COLOUR            N/A         N/A (macro)   0x0004   (not used)
ANGULAR_flags                         42  0x0000002a (const dword)  (not used)
ANGULAR_h                             60  0x0000003c (const dword)  (not used)
ANGULAR_incro                         30  0x0000001e (const dword)  (not used)
ANGULAR_labcol                        36  0x00000024 (const dword)  (not used)
ANGULAR_labfnt                        34  0x00000022 (const dword)  (not used)
ANGULAR_labofs                        38  0x00000026 (const dword)  (not used)
ANGULAR_labs                          32  0x00000020 (const dword)  (not used)
ANGULAR_labstr                        40  0x00000028 (const dword)  (not used)
ANGULAR_maxa                          70  0x00000046 (const dword)  (not used)
ANGULAR_maxv                          74  0x0000004a (const dword)  (not used)
ANGULAR_mina                          68  0x00000044 (const dword)  (not used)
ANGULAR_minv                          72  0x00000048 (const dword)  (not used)
ANGULAR_p1                            20  0x00000014 (const dword)  (not used)
ANGULAR_p2                            22  0x00000016 (const dword)  (not used)
ANGULAR_ri                             2  0x00000002 (const dword)  (not used)
ANGULAR_ro                             0  0x00000000 (const dword)  (not used)
ANGULAR_tc                            18  0x00000012 (const dword)  (not used)
ANGULAR_tcks                           4  0x00000004 (const dword)  (not used)
ANGULAR_tiszl                         12  0x0000000c (const dword)  (not used)
ANGULAR_tiszs                         14  0x0000000e (const dword)  (not used)
ANGULAR_tkl                            6  0x00000006 (const dword)  (not used)
ANGULAR_toszl                          8  0x00000008 (const dword)  (not used)
ANGULAR_toszs                         10  0x0000000a (const dword)  (not used)
ANGULAR_tw                            16  0x00000010 (const dword)  (not used)
ANGULAR_w                             58  0x0000003a (const dword)  (not used)
ANGULAR_x                             54  0x00000036 (const dword)  (not used)
ANGULAR_y                             56  0x00000038 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                          24  0x00000018 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 12)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BREAK                              65533  0x0000fffd (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON4_BC0                           12  0x0000000c (const dword)  (not used)
BUTTON4_BC1                           14  0x0000000e (const dword)  (not used)
BUTTON4_BR1                           28  0x0000001c (const dword)  (not used)
BUTTON4_BR2                           30  0x0000001e (const dword)  (not used)
BUTTON4_BRG                           32  0x00000020 (const dword)  (not used)
BUTTON4_CAP                           26  0x0000001a (const dword)  (not used)
BUTTON4_FC0                           28  0x0000001c (const dword)  (not used)
BUTTON4_FC1                           30  0x0000001e (const dword)  (not used)
BUTTON4_FST                           32  0x00000020 (const dword)  (not used)
BUTTON4_FSZ                           34  0x00000022 (const dword)  (not used)
BUTTON4_IB1                           16  0x00000010 (const dword)  (not used)
BUTTON4_IB2                           18  0x00000012 (const dword)  (not used)
BUTTON4_IG0                           20  0x00000014 (const dword)  (not used)
BUTTON4_IG1                           22  0x00000016 (const dword)  (not used)
BUTTON4_OB1                            6  0x00000006 (const dword)  (not used)
BUTTON4_OB2                            8  0x00000008 (const dword)  (not used)
BUTTON4_OBG                           10  0x0000000a (const dword)  (not used)
BUTTON4_rad                            4  0x00000004 (const dword)  (not used)
BUTTON4_TPC                           24  0x00000018 (const dword)  (not used)
BUTTON4_XP                             0  0x00000000 (const dword)  (not used)
BUTTON4_YP                             2  0x00000002 (const dword)  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHECKUPDATE_INVALIDFILE                5  0x00000005 (const dword)  (not used)
CHECKUPDATE_NEWFILE                    1  0x00000001 (const dword)  (not used)
CHECKUPDATE_NOFILE                     4  0x00000004 (const dword)  (not used)
CHECKUPDATE_OLDFILE                    2  0x00000002 (const dword)  (not used)
CHECKUPDATE_QUERY                      1  0x00000001 (const dword)  (not used)
CHECKUPDATE_UPDATEALWAYS               3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATEDONE                 3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATENEWER                2  0x00000002 (const dword)  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
ciButton                          UNRESOLVED  (not used)
ciDial                            UNRESOLVED  (not used)
ciSlider                          UNRESOLVED  (not used)
ciSwitch                          UNRESOLVED  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  504  0x000001f8 (mem) word[80] (global)  (usage 33)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 6)
ColorBGimage                          32  0x00000020 (const dword)  (usage 3)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_InitBrk                        -427  0xfffffe55 (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferBrk                    -426  0xfffffe56 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_InitBrk                         -417  0xfffffe5f (PmmC func) args[3] r=0  (not used)
com_Mode                            -400  0xfffffe70 (PmmC func) args[4] r=1  (not used)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferBrk                     -416  0xfffffe60 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                                424  0x000001a8 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
crc_CSUM_8                          -403  0xfffffe6d (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         420  0x000001a4 (mem) word (global)  (usage 30)
CurrentForm                          406  0x00000196 (mem) word (global)  (usage 42)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIAL_bevColour                        28  0x0000001c (const dword)  (not used)
DIAL_bevColour2                       30  0x0000001e (const dword)  (not used)
DIAL_bevSize                          26  0x0000001a (const dword)  (not used)
DIAL_bgcolour                         22  0x00000016 (const dword)  (not used)
DIAL_capcol                           72  0x00000048 (const dword)  (not used)
DIAL_capfnt                           70  0x00000046 (const dword)  (not used)
DIAL_capofsx                          74  0x0000004a (const dword)  (not used)
DIAL_capofsy                          76  0x0000004c (const dword)  (not used)
DIAL_caption                          78  0x0000004e (const dword)  (not used)
DIAL_colour                           24  0x00000018 (const dword)  (not used)
DIAL_cx                                8  0x00000008 (const dword)  (not used)
DIAL_cy                               10  0x0000000a (const dword)  (not used)
DIAL_F_BG_TRANSPARENT                N/A         N/A (macro)   0x0002   (not used)
DIAL_F_HANDLE_CIRCLE                 N/A         N/A (macro)   0x0000   (not used)
DIAL_F_HANDLE_LINE                   N/A         N/A (macro)   0x0030   (not used)
DIAL_F_HANDLE_RECTANGLE              N/A         N/A (macro)   0x0020   (not used)
DIAL_F_HANDLE_STYLE                  N/A         N/A (macro)   0x00f0   (not used)
DIAL_F_HANDLE_TRIANGLE               N/A         N/A (macro)   0x0010   (not used)
DIAL_F_INDICATOR_CIRCLE              N/A         N/A (macro)   0x0000   (not used)
DIAL_F_INDICATOR_LINE                N/A         N/A (macro)   0x0300   (not used)
DIAL_F_INDICATOR_RECTANGLE           N/A         N/A (macro)   0x0200   (not used)
DIAL_F_INDICATOR_STYLE               N/A         N/A (macro)   0x0f00   (not used)
DIAL_F_INDICATOR_TRIANGLE            N/A         N/A (macro)   0x0100   (not used)
DIAL_F_LABEL_STRINGS                 N/A         N/A (macro)   0x0001   (not used)
DIAL_flags                            80  0x00000050 (const dword)  (not used)
DIAL_h                                 6  0x00000006 (const dword)  (not used)
DIAL_handlecolour                     54  0x00000036 (const dword)  (not used)
DIAL_handlelength                     58  0x0000003a (const dword)  (not used)
DIAL_handlesize                       56  0x00000038 (const dword)  (not used)
DIAL_indc1h                           42  0x0000002a (const dword)  (not used)
DIAL_indc1l                           36  0x00000024 (const dword)  (not used)
DIAL_indc2h                           44  0x0000002c (const dword)  (not used)
DIAL_indc2l                           38  0x00000026 (const dword)  (not used)
DIAL_indc3h                           46  0x0000002e (const dword)  (not used)
DIAL_indc3l                           40  0x00000028 (const dword)  (not used)
DIAL_indlength                        52  0x00000034 (const dword)  (not used)
DIAL_indOffset                        48  0x00000030 (const dword)  (not used)
DIAL_indp1                            32  0x00000020 (const dword)  (not used)
DIAL_indp2                            34  0x00000022 (const dword)  (not used)
DIAL_indsize                          50  0x00000032 (const dword)  (not used)
DIAL_labcolour                        60  0x0000003c (const dword)  (not used)
DIAL_labcount                         66  0x00000042 (const dword)  (not used)
DIAL_labfont                          62  0x0000003e (const dword)  (not used)
DIAL_labofs                           64  0x00000040 (const dword)  (not used)
DIAL_labstr                           68  0x00000044 (const dword)  (not used)
DIAL_maxa                             16  0x00000010 (const dword)  (not used)
DIAL_maxv                             20  0x00000014 (const dword)  (not used)
DIAL_mina                             14  0x0000000e (const dword)  (not used)
DIAL_minv                             18  0x00000012 (const dword)  (not used)
DIAL_rad                              12  0x0000000c (const dword)  (not used)
DIAL_w                                 4  0x00000004 (const dword)  (not used)
DIAL_x                                 0  0x00000000 (const dword)  (not used)
DIAL_y                                 2  0x00000002 (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Busy                           -419  0xfffffe5d (PmmC func) args[0] r=1  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[2] r=1  (not used)
disp_Refresh                        -418  0xfffffe5e (PmmC func) args[0] r=0  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        2747  0x00000abb (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
EAST                                   3  0x00000003 (const dword)  (not used)
EAST_MIRRORED                          7  0x00000007 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
ffsEnd32kH                             5  0x00000005 (const dword)  (not used)
ffsEnd32kL                             0  0x00000000 (const dword)  (not used)
ffsEnd4kH                              4  0x00000004 (const dword)  (not used)
ffsEnd4kL                          36864  0x00009000 (const dword)  (not used)
ffsEnd64kH                             5  0x00000005 (const dword)  (not used)
ffsEnd64kL                             0  0x00000000 (const dword)  (not used)
ffsEndUnits32k                        10  0x0000000a (const dword)  (not used)
ffsEndUnits4k                         73  0x00000049 (const dword)  (not used)
ffsEndUnits64k                         5  0x00000005 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_CheckUpdate                    -344  0xfffffea8 (PmmC func) args[2] r=1  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (not used)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
file_MountSpeed                     -382  0xfffffe82 (PmmC func) args[1] r=1  (not used)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_RunSpeed                       -408  0xfffffe68 (PmmC func) args[3] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
FLASH_ADDR_ALWAYS_4BYTE            65534  0x0000fffe (const dword)  (not used)
FLASH_ADDR_DEF_COMMAND             65535  0x0000ffff (const dword)  (usage 3)
flash_Block32Erase                  -398  0xfffffe72 (PmmC func) args[0] r=1  (not used)
flash_Block64Erase                  -157  0xffffff63 (PmmC func) args[0] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_Sector4Erase                  -399  0xfffffe71 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                         912  0x00000390FormBGcolors                         912  0x00000390 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
FormEndIndex                         726  0x000002d6FormEndIndex                         726  0x000002d6 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
FormStartIndex                       722  0x000002d2FormStartIndex                       722  0x000002d2 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAUGE_COLOR                           18  0x00000012 (const dword)  (not used)
GAUGE_F_HORZ                         N/A         N/A (macro)    0x0002   (not used)
GAUGE_F_TOPRIGHT                     N/A         N/A (macro)    0x0001   (not used)
GAUGE_FLAGS                           36  0x00000024 (const dword)  (not used)
GAUGE_H                                6  0x00000006 (const dword)  (not used)
GAUGE_MAXV                            12  0x0000000c (const dword)  (not used)
GAUGE_MINV                            10  0x0000000a (const dword)  (not used)
GAUGE_P1                              34  0x00000022 (const dword)  (not used)
GAUGE_P1H                             22  0x00000016 (const dword)  (not used)
GAUGE_P1L                             20  0x00000014 (const dword)  (not used)
GAUGE_P2                              32  0x00000020 (const dword)  (not used)
GAUGE_P2H                             26  0x0000001a (const dword)  (not used)
GAUGE_P2L                             24  0x00000018 (const dword)  (not used)
GAUGE_P3H                             30  0x0000001e (const dword)  (not used)
GAUGE_P3L                             28  0x0000001c (const dword)  (not used)
GAUGE_SPACING                         16  0x00000010 (const dword)  (not used)
GAUGE_T                                8  0x00000008 (const dword)  (not used)
GAUGE_TICKH                           14  0x0000000e (const dword)  (not used)
GAUGE_W                                4  0x00000004 (const dword)  (not used)
GAUGE_X                                0  0x00000000 (const dword)  (not used)
GAUGE_Y                                2  0x00000002 (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_AngularMeter                    -312  0xfffffec8 (PmmC func) args[3] r=0  (usage 3)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
gfx_BlitSprite                      -304  0xfffffed0 (PmmC func) args[6] r=0  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
gfx_Button4                         -340  0xfffffeac (PmmC func) args[3] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (not used)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (not used)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 3)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dial                            -315  0xfffffec5 (PmmC func) args[3] r=0  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Gauge                           -316  0xfffffec4 (PmmC func) args[3] r=0  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -346  0xfffffea6 (PmmC func) args[7] r=0  (not used)
gfx_GradientColor                   -405  0xfffffe6b (PmmC func) args[6] r=1  (not used)
gfx_GradientShape                   -404  0xfffffe6c (PmmC func) args[19] r=0  (not used)
gfx_GradTriangleFilled              -406  0xfffffe6a (PmmC func) args[12] r=0  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
gfx_Led                             -341  0xfffffeab (PmmC func) args[3] r=0  (not used)
gfx_LedDigit                        -319  0xfffffec1 (PmmC func) args[6] r=0  (not used)
gfx_LedDigits                       -318  0xfffffec2 (PmmC func) args[3] r=0  (usage 3)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (not used)
gfx_Needle                          -314  0xfffffec6 (PmmC func) args[3] r=0  (not used)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_Panel2                          -313  0xfffffec7 (PmmC func) args[10] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
gfx_ReadGRAMarea                    -305  0xfffffecf (PmmC func) args[5] r=1  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (not used)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_RingSegment                     -311  0xfffffec9 (PmmC func) args[7] r=0  (not used)
gfx_RoundGradient                   -317  0xfffffec3 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -320  0xfffffec0 (PmmC func) args[6] r=0  (not used)
gfx_RulerGauge                      -343  0xfffffea9 (PmmC func) args[3] r=0  (not used)
gfx_Scale                           -342  0xfffffeaa (PmmC func) args[2] r=0  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
gfx_Slider5                         -337  0xfffffeaf (PmmC func) args[3] r=0  (not used)
gfx_SpriteSet                       -303  0xfffffed1 (PmmC func) args[3] r=0  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
gfx_Surround                        -338  0xfffffeae (PmmC func) args[7] r=0  (not used)
gfx_Switch                          -339  0xfffffead (PmmC func) args[3] r=0  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
gfx_WriteGRAMarea                   -306  0xfffffece (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
gfx_XYlinToVal                      -380  0xfffffe84 (PmmC func) args[7] r=1  (not used)
gfx_XYrotToVal                      -379  0xfffffe85 (PmmC func) args[7] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
gfxInternals                           7  0x00000007gfxInternals                           7  0x00000007 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
gfxIntParms                           65  0x00000041gfxIntParms                           65  0x00000041 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
gfxIntStrings                        123  0x0000007bgfxIntStrings                        123  0x0000007b (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectDATA                          264  0x00000108 (mem) word (global)  (usage 6)
GObjectFunc                          260  0x00000104 (mem) word (global)  (usage 6)
GObjectIdx                           258  0x00000102 (mem) word (global)  (usage 21)
GObjectParms                         266  0x0000010a (mem) word (global)  (usage 3)
GObjectRAM                           262  0x00000106 (mem) word (global)  (usage 15)
GObjectStrings                       268  0x0000010c (mem) word (global)  (usage 3)
GObjectType                          416  0x000001a0 (mem) word (global)  (usage 90)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (usage 12)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 81)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C1_Close                          -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C1_Nack                           -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C1_Putn                           -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -361  0xfffffe97 (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -367  0xfffffe91 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -365  0xfffffe93 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -349  0xfffffea3 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -373  0xfffffe8b (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -371  0xfffffe8d (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -369  0xfffffe8f (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -363  0xfffffe95 (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
I2C2_Putn                           -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -375  0xfffffe89 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -357  0xfffffe9b (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -355  0xfffffe9d (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -351  0xfffffea1 (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -359  0xfffffe99 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -362  0xfffffe96 (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -368  0xfffffe90 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -366  0xfffffe92 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -350  0xfffffea2 (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -374  0xfffffe8a (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -372  0xfffffe8c (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -370  0xfffffe8e (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -364  0xfffffe94 (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
I2C3_Putn                           -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -376  0xfffffe88 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -358  0xfffffe9a (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -356  0xfffffe9c (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -360  0xfffffe98 (PmmC func) args[1] r=1  (not used)
I2C_CLOCK_STRETCHING               32768  0x00008000 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2CS_Close                          -410  0xfffffe66 (PmmC func) args[0] r=0  (not used)
I2CS_Count                          -412  0xfffffe64 (PmmC func) args[0] r=1  (not used)
I2CS_Open                           -409  0xfffffe67 (PmmC func) args[6] r=0  (not used)
I2CS_Overflow                       -415  0xfffffe61 (PmmC func) args[0] r=1  (not used)
I2CS_Read                           -413  0xfffffe63 (PmmC func) args[0] r=1  (not used)
I2CS_Release                        -414  0xfffffe62 (PmmC func) args[0] r=0  (not used)
I2CS_Write                          -411  0xfffffe65 (PmmC func) args[1] r=0  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 3)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                           0  0x00000000 (const dword)  (not used)
iFormEndIndex                        734  0x000002deiFormEndIndex                        734  0x000002de (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iFormStartIndex                      730  0x000002daiFormStartIndex                      730  0x000002da (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iGauge0                                2  0x00000002 (const ??? 0)  (usage 3)
iIAngularMeter0                        0  0x00000000 (const ??? 0)  (not used)
IIAngularMeter0                      217  0x000000d9IIAngularMeter0                      217  0x000000d9 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter1                        1  0x00000001 (const ??? 0)  (not used)
IIAngularMeter1                      313  0x00000139IIAngularMeter1                      313  0x00000139 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter2                        7  0x00000007 (const ??? 0)  (not used)
IIAngularMeter2                      600  0x00000258IIAngularMeter2                      600  0x00000258 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter3                        3  0x00000003 (const ??? 0)  (not used)
IIAngularMeter3                      435  0x000001b3IIAngularMeter3                      435  0x000001b3 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits0                           2  0x00000002 (const ??? 0)  (not used)
IILedDigits0                         413  0x0000019dIILedDigits0                         413  0x0000019d (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits1                           4  0x00000004 (const ??? 0)  (not used)
IILedDigits1                         534  0x00000216IILedDigits1                         534  0x00000216 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits2                           5  0x00000005 (const ??? 0)  (not used)
IILedDigits2                         556  0x0000022cIILedDigits2                         556  0x0000022c (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits3                           6  0x00000006 (const ??? 0)  (not used)
IILedDigits3                         578  0x00000242IILedDigits3                         578  0x00000242 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits4                           8  0x00000008 (const ??? 0)  (not used)
IILedDigits4                         700  0x000002bcIILedDigits4                         700  0x000002bc (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iImage0                                0  0x00000000 (const ??? 0)  (usage 3)
iImage1                                3  0x00000003 (const ??? 0)  (usage 3)
iImage2                                4  0x00000004 (const ??? 0)  (usage 3)
iImage3                                5  0x00000005 (const ??? 0)  (usage 3)
iImage4                                6  0x00000006 (const ??? 0)  (usage 3)
ILINEARIP_COLOR1                      12  0x0000000c (const dword)  (not used)
ILINEARIP_COLOR2                      14  0x0000000e (const dword)  (not used)
ILINEARIP_COLOR3                      16  0x00000010 (const dword)  (not used)
ILINEARIP_COLOR4                      18  0x00000012 (const dword)  (not used)
ILINEARIP_COLOR5                      20  0x00000014 (const dword)  (not used)
ILINEARIP_COLOR6                      22  0x00000016 (const dword)  (not used)
ILINEARIP_H                            6  0x00000006 (const dword)  (not used)
ILINEARIP_INDEX                        8  0x00000008 (const dword)  (not used)
ILINEARIP_MAXVAL                      42  0x0000002a (const dword)  (not used)
ILINEARIP_MINVAL                      44  0x0000002c (const dword)  (not used)
ILINEARIP_OFFSET_BR                   46  0x0000002e (const dword)  (not used)
ILINEARIP_OFFSET_TL                   48  0x00000030 (const dword)  (not used)
ILINEARIP_ORIENTATION                 10  0x0000000a (const dword)  (not used)
ILINEARIP_TEXT1                       36  0x00000024 (const dword)  (not used)
ILINEARIP_TEXT2                       38  0x00000026 (const dword)  (not used)
ILINEARIP_TEXT3                       40  0x00000028 (const dword)  (not used)
ILINEARIP_VALUE1                      24  0x00000018 (const dword)  (not used)
ILINEARIP_VALUE2                      26  0x0000001a (const dword)  (not used)
ILINEARIP_VALUE3                      28  0x0000001c (const dword)  (not used)
ILINEARIP_VALUE4                      30  0x0000001e (const dword)  (not used)
ILINEARIP_VALUE5                      32  0x00000020 (const dword)  (not used)
ILINEARIP_VALUE6                      34  0x00000022 (const dword)  (not used)
ILINEARIP_W                            4  0x00000004 (const dword)  (not used)
ILINEARIP_X                            0  0x00000000 (const dword)  (not used)
ILINEARIP_Y                            2  0x00000002 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 39)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
ImageTouched                         410  0x0000019a (mem) word (global)  (usage 72)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
img_FileCheckUpdate                 -397  0xfffffe73 (PmmC func) args[3] r=1  (not used)
img_FileExec                        -394  0xfffffe76 (PmmC func) args[3] r=1  (not used)
img_FileGetC                        -388  0xfffffe7c (PmmC func) args[2] r=1  (not used)
img_FileGetS                        -390  0xfffffe7a (PmmC func) args[4] r=1  (not used)
img_FileGetW                        -389  0xfffffe7b (PmmC func) args[2] r=1  (not used)
img_FileIndex                       -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_FileLoadFunction                -392  0xfffffe78 (PmmC func) args[2] r=1  (not used)
img_FilePlayWAV                     -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
img_FileRead                        -383  0xfffffe81 (PmmC func) args[4] r=1  (not used)
img_FileRewind                      -391  0xfffffe79 (PmmC func) args[2] r=1  (not used)
img_FileRun                         -393  0xfffffe77 (PmmC func) args[3] r=1  (not used)
img_FileSeek                        -384  0xfffffe80 (PmmC func) args[4] r=1  (not used)
img_FileSize                        -387  0xfffffe7d (PmmC func) args[4] r=1  (not used)
img_FileTell                        -386  0xfffffe7e (PmmC func) args[4] r=1  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
img_FunctionCall                    -401  0xfffffe6f (PmmC func) args[7] r=1  (not used)
img_FunctionFreeCache               -402  0xfffffe6e (PmmC func) args[1] r=0  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 36)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 12)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 12)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
img_TxtFontID                       -396  0xfffffe74 (PmmC func) args[2] r=1  (not used)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
InputControls                        738  0x000002e2InputControls                        738  0x000002e2 (mem) word[8] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
InputCS                              664  0x00000298 (mem) word (global)  (usage 15)
InputData                            772  0x00000304InputData                            772  0x00000304 (mem) word[44] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 27)
InternalInputControls                754  0x000002f2InternalInputControls                754  0x000002f2 (mem) word[9] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
intflash_Copy                       -422  0xfffffe5a (PmmC func) args[3] r=1  (not used)
intflash_FunctionCall               -424  0xfffffe58 (PmmC func) args[7] r=1  (not used)
intflash_FunctionFreeCache          -425  0xfffffe57 (PmmC func) args[1] r=0  (not used)
intflash_GetByte                    -420  0xfffffe5c (PmmC func) args[1] r=1  (not used)
intflash_GetWord                    -421  0xfffffe5b (PmmC func) args[1] r=1  (not used)
intflash_WriteBlock                 -423  0xfffffe59 (PmmC func) args[2] r=1  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO10_PIN                              10  0x0000000a (const dword)  (not used)
IO11_PIN                              11  0x0000000b (const dword)  (not used)
IO12_PIN                              12  0x0000000c (const dword)  (not used)
IO13_PIN                              13  0x0000000d (const dword)  (not used)
IO14_PIN                              14  0x0000000e (const dword)  (not used)
IO15_PIN                              15  0x0000000f (const dword)  (not used)
IO16_PIN                              16  0x00000010 (const dword)  (not used)
IO17_PIN                              17  0x00000011 (const dword)  (not used)
IO18_PIN                              18  0x00000012 (const dword)  (not used)
IO19_PIN                              19  0x00000013 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IO6_PIN                                6  0x00000006 (const dword)  (not used)
IO7_PIN                                7  0x00000007 (const dword)  (not used)
IO8_PIN                                8  0x00000008 (const dword)  (not used)
IO9_PIN                                9  0x00000009 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
IROTARYIP_COLOR1                      10  0x0000000a (const dword)  (not used)
IROTARYIP_COLOR2                      12  0x0000000c (const dword)  (not used)
IROTARYIP_COLOR3                      14  0x0000000e (const dword)  (not used)
IROTARYIP_COLOR4                      16  0x00000010 (const dword)  (not used)
IROTARYIP_COLOR5                      18  0x00000012 (const dword)  (not used)
IROTARYIP_COLOR6                      20  0x00000014 (const dword)  (not used)
IROTARYIP_H                            6  0x00000006 (const dword)  (not used)
IROTARYIP_INDEX                        8  0x00000008 (const dword)  (not used)
IROTARYIP_MAXANGLE                    40  0x00000028 (const dword)  (not used)
IROTARYIP_MAXVALUE                    42  0x0000002a (const dword)  (not used)
IROTARYIP_MINANGLE                    44  0x0000002c (const dword)  (not used)
IROTARYIP_MINVALUE                    46  0x0000002e (const dword)  (not used)
IROTARYIP_TEXT1                       34  0x00000022 (const dword)  (not used)
IROTARYIP_TEXT2                       36  0x00000024 (const dword)  (not used)
IROTARYIP_TEXT3                       38  0x00000026 (const dword)  (not used)
IROTARYIP_VALUE1                      22  0x00000016 (const dword)  (not used)
IROTARYIP_VALUE2                      24  0x00000018 (const dword)  (not used)
IROTARYIP_VALUE3                      26  0x0000001a (const dword)  (not used)
IROTARYIP_VALUE4                      28  0x0000001c (const dword)  (not used)
IROTARYIP_VALUE5                      30  0x0000001e (const dword)  (not used)
IROTARYIP_VALUE6                      32  0x00000020 (const dword)  (not used)
IROTARYIP_W                            4  0x00000004 (const dword)  (not used)
IROTARYIP_X                            0  0x00000000 (const dword)  (not used)
IROTARYIP_Y                            2  0x00000002 (const dword)  (not used)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
ITOGGLEIP_COLOR1                      10  0x0000000a (const dword)  (not used)
ITOGGLEIP_COLOR2                      12  0x0000000c (const dword)  (not used)
ITOGGLEIP_COLOR3                      14  0x0000000e (const dword)  (not used)
ITOGGLEIP_COLOR4                      16  0x00000010 (const dword)  (not used)
ITOGGLEIP_COLOR5                      18  0x00000012 (const dword)  (not used)
ITOGGLEIP_COLOR6                      20  0x00000014 (const dword)  (not used)
ITOGGLEIP_H                            6  0x00000006 (const dword)  (not used)
ITOGGLEIP_INDEX                        8  0x00000008 (const dword)  (not used)
ITOGGLEIP_MATRIX                      40  0x00000028 (const dword)  (not used)
ITOGGLEIP_MOMENTARY                   42  0x0000002a (const dword)  (not used)
ITOGGLEIP_TEXT1                       34  0x00000022 (const dword)  (not used)
ITOGGLEIP_TEXT2                       36  0x00000024 (const dword)  (not used)
ITOGGLEIP_TEXT3                       38  0x00000026 (const dword)  (not used)
ITOGGLEIP_VALUE1                      22  0x00000016 (const dword)  (not used)
ITOGGLEIP_VALUE2                      24  0x00000018 (const dword)  (not used)
ITOGGLEIP_VALUE3                      26  0x0000001a (const dword)  (not used)
ITOGGLEIP_VALUE4                      28  0x0000001c (const dword)  (not used)
ITOGGLEIP_VALUE5                      30  0x0000001e (const dword)  (not used)
ITOGGLEIP_VALUE6                      32  0x00000020 (const dword)  (not used)
ITOGGLEIP_W                            4  0x00000004 (const dword)  (not used)
ITOGGLEIP_X                            0  0x00000000 (const dword)  (not used)
ITOGGLEIP_Y                            2  0x00000002 (const dword)  (not used)
IUSERGAUGE_COLOR1                     10  0x0000000a (const dword)  (not used)
IUSERGAUGE_COLOR2                     12  0x0000000c (const dword)  (not used)
IUSERGAUGE_COLOR3                     14  0x0000000e (const dword)  (not used)
IUSERGAUGE_COLOR4                     16  0x00000010 (const dword)  (not used)
IUSERGAUGE_COLOR5                     18  0x00000012 (const dword)  (not used)
IUSERGAUGE_COLOR6                     20  0x00000014 (const dword)  (not used)
IUSERGAUGE_H                           6  0x00000006 (const dword)  (not used)
IUSERGAUGE_INDEX                       8  0x00000008 (const dword)  (not used)
IUSERGAUGE_TEXT1                      34  0x00000022 (const dword)  (not used)
IUSERGAUGE_TEXT2                      36  0x00000024 (const dword)  (not used)
IUSERGAUGE_TEXT3                      38  0x00000026 (const dword)  (not used)
IUSERGAUGE_VALUE1                     22  0x00000016 (const dword)  (not used)
IUSERGAUGE_VALUE2                     24  0x00000018 (const dword)  (not used)
IUSERGAUGE_VALUE3                     26  0x0000001a (const dword)  (not used)
IUSERGAUGE_VALUE4                     28  0x0000001c (const dword)  (not used)
IUSERGAUGE_VALUE5                     30  0x0000001e (const dword)  (not used)
IUSERGAUGE_VALUE6                     32  0x00000020 (const dword)  (not used)
IUSERGAUGE_W                           4  0x00000004 (const dword)  (not used)
IUSERGAUGE_X                           0  0x00000000 (const dword)  (not used)
IUSERGAUGE_Y                           2  0x00000002 (const dword)  (not used)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton0                            1  0x00000001 (const ??? 0)  (usage 3)
iWinbutton1                            7  0x00000007 (const ??? 0)  (usage 3)
JOY_BTNA                               6  0x00000006 (const dword)  (not used)
JOY_BTNB                               5  0x00000005 (const dword)  (not used)
JOY_DOWN                               3  0x00000003 (const dword)  (not used)
JOY_FIRE                               5  0x00000005 (const dword)  (not used)
JOY_LEFT                               2  0x00000002 (const dword)  (not used)
JOY_RELEASED                           0  0x00000000 (const dword)  (not used)
JOY_RIGHT                              4  0x00000004 (const dword)  (not used)
JOY_UP                                 1  0x00000001 (const dword)  (not used)
joystick                            -310  0xfffffeca (PmmC func) args[1] r=1  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                  916  0x00000394kKeyboardKeystrokes                  916  0x00000394 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LED1_cbe                              10  0x0000000a (const dword)  (not used)
LED1_cbs                               8  0x00000008 (const dword)  (not used)
LED1_cOff                             16  0x00000010 (const dword)  (not used)
LED1_cOn                              14  0x0000000e (const dword)  (not used)
LED1_cs                               12  0x0000000c (const dword)  (not used)
LED1_h                                 6  0x00000006 (const dword)  (not used)
LED1_iBr                              18  0x00000012 (const dword)  (not used)
LED1_iLr                              22  0x00000016 (const dword)  (not used)
LED1_oBr                              20  0x00000014 (const dword)  (not used)
LED1_oLr                              24  0x00000018 (const dword)  (not used)
LED1_sh                               26  0x0000001a (const dword)  (not used)
LED1_w                                 4  0x00000004 (const dword)  (not used)
LED1_x                                 0  0x00000000 (const dword)  (not used)
LED1_y                                 2  0x00000002 (const dword)  (not used)
LEDDIGIT_F_DP_COMMA                  N/A         N/A (macro)   0x0400   (not used)
LEDDIGIT_F_DP_ON                     N/A         N/A (macro)   0x0200   (not used)
LEDDIGIT_F_SET_SEGMENTS              N/A         N/A (macro)   0x1000   (not used)
LEDDIGIT_F_SHOW_DP                   N/A         N/A (macro)   0x0800   (not used)
LEDDIGITS_decimals                    10  0x0000000a (const dword)  (not used)
LEDDIGITS_digits                       8  0x00000008 (const dword)  (not used)
LEDDIGITS_digsize                     14  0x0000000e (const dword)  (not used)
LEDDIGITS_F_DP_COMMA                 N/A         N/A (macro)   0x0040   (not used)
LEDDIGITS_F_DP_DOT                   N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_FIXED                    N/A         N/A (macro)   0x0002   (not used)
LEDDIGITS_F_FLOAT                    N/A         N/A (macro)   0x0008   (not used)
LEDDIGITS_F_FLOATFORMATS             N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_GENERAL                  N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_INT16                    N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_INT32                    N/A         N/A (macro)   0x0004   (not used)
LEDDIGITS_F_LEADING0                 N/A         N/A (macro)   0x0020   (not used)
LEDDIGITS_F_LEADINGb                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_SCIENTIFIC               N/A         N/A (macro)   0x0001   (not used)
LEDDIGITS_F_SIGNED                   N/A         N/A (macro)   0x0010   (not used)
LEDDIGITS_F_TYPES                    N/A         N/A (macro)   0x000c   (not used)
LEDDIGITS_F_UNSIGNED                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_flags                       20  0x00000014 (const dword)  (not used)
LEDDIGITS_gap                         12  0x0000000c (const dword)  (not used)
LEDDIGITS_h                            6  0x00000006 (const dword)  (not used)
LEDDIGITS_offcolour                   18  0x00000012 (const dword)  (not used)
LEDDIGITS_oncolour                    16  0x00000010 (const dword)  (not used)
LEDDIGITS_w                            4  0x00000004 (const dword)  (not used)
LEDDIGITS_x                            0  0x00000000 (const dword)  (not used)
LEDDIGITS_y                            2  0x00000002 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIAngularMeter1                      409  0x00000199LIAngularMeter1                      409  0x00000199 (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter1                   UNRESOLVED  (usage 2)
LIAngularMeter2                      696  0x000002b8LIAngularMeter2                      696  0x000002b8 (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter2                   UNRESOLVED  (usage 2)
LIAngularMeter3                      531  0x00000213LIAngularMeter3                      531  0x00000213 (mem) byte[3] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter3                   UNRESOLVED  (usage 2)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                 954  0x000003ba (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxIntObjects                         27  0x0000001b (const dword)  (usage 3)
MaxTotObjects                         67  0x00000043 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_Init4                         -407  0xfffffe69 (const dword)  (not used)
media_InitFlash                     -407  0xfffffe69 (PmmC func) args[1] r=1  (usage 6)
media_InitSpeed                     -381  0xfffffe83 (PmmC func) args[1] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                4617  0x00001209 (User func) args[0] r=0  (usage 12)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NEEDLE_bgcol                          12  0x0000000c (const dword)  (not used)
NEEDLE_ccol                           36  0x00000024 (const dword)  (not used)
NEEDLE_colour                         32  0x00000020 (const dword)  (not used)
NEEDLE_crad                           34  0x00000022 (const dword)  (not used)
NEEDLE_cxx                             8  0x00000008 (const dword)  (not used)
NEEDLE_cyx                            10  0x0000000a (const dword)  (not used)
NEEDLE_extra                          30  0x0000001e (const dword)  (not used)
NEEDLE_F_DOUBLETRIANGLE                4  0x00000004 (const dword)  (not used)
NEEDLE_F_LINE                          0  0x00000000 (const dword)  (not used)
NEEDLE_F_POINTRECTANGLE                2  0x00000002 (const dword)  (not used)
NEEDLE_F_RECTANGLE                     1  0x00000001 (const dword)  (not used)
NEEDLE_F_ROUNDEDRECTANGLE              5  0x00000005 (const dword)  (not used)
NEEDLE_F_TRIANGLE                      3  0x00000003 (const dword)  (not used)
NEEDLE_h                               6  0x00000006 (const dword)  (not used)
NEEDLE_icol                           40  0x00000028 (const dword)  (not used)
NEEDLE_irad                           38  0x00000026 (const dword)  (not used)
NEEDLE_len                            22  0x00000016 (const dword)  (not used)
NEEDLE_maxa                           16  0x00000010 (const dword)  (not used)
NEEDLE_maxv                           20  0x00000014 (const dword)  (not used)
NEEDLE_mina                           14  0x0000000e (const dword)  (not used)
NEEDLE_minv                           18  0x00000012 (const dword)  (not used)
NEEDLE_offs                           26  0x0000001a (const dword)  (not used)
NEEDLE_rad                            28  0x0000001c (const dword)  (not used)
NEEDLE_style                          24  0x00000018 (const dword)  (not used)
NEEDLE_w                               4  0x00000004 (const dword)  (not used)
NEEDLE_x                               0  0x00000000 (const dword)  (not used)
NEEDLE_y                               2  0x00000002 (const dword)  (not used)
nInputs                                4  0x00000004 (const dword)  (usage 3)
nObjects                               8  0x00000008 (const dword)  (not used)
NORTH                                  0  0x00000000 (const dword)  (not used)
NORTH_MIRRORED                         4  0x00000004 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                          860  0x0000035coDipSwitchs                          860  0x0000035c (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 183)
OFF                                    0  0x00000000 (const dword)  (not used)
oForms                               868  0x00000364oForms                               868  0x00000364 (mem) word[3] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (not used)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (not used)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (not used)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (not used)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (not used)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 6)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 9)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 18)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 30)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 6)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 3)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 9)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 18)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 9)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (not used)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (not used)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (not used)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (not used)
Ofs_String_Form                       24  0x00000018 (const dword)  (not used)
Ofs_String_GciFSFontIdx               26  0x0000001a (const dword)  (not used)
Ofs_String_Size                        4  0x00000004 (const dword)  (not used)
Ofs_String_StartH                      0  0x00000000 (const dword)  (not used)
Ofs_String_StartL                      2  0x00000002 (const dword)  (not used)
Ofs_String_Transparent                20  0x00000014 (const dword)  (not used)
Ofs_String_x1                          6  0x00000006 (const dword)  (not used)
Ofs_String_x2                         10  0x0000000a (const dword)  (not used)
Ofs_String_y1                          8  0x00000008 (const dword)  (not used)
Ofs_String_y2                         12  0x0000000c (const dword)  (not used)
oGauges                              874  0x0000036aoGauges                              874  0x0000036a (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiAngularMeters                      890  0x0000037aoiAngularMeters                      890  0x0000037a (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiLedDigitss                         900  0x00000384oiLedDigitss                         900  0x00000384 (mem) word[6] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oImages                              878  0x0000036eoImages                              878  0x0000036e (mem) word[6] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviAngularMeter                     181  0x000000b5oiviAngularMeter                     181  0x000000b5 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviLedDigits                        189  0x000000bdoiviLedDigits                        189  0x000000bd (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 408  0x00000198 (mem) word (global)  (usage 42)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (not used)
oObjects                             270  0x0000010e (mem) word[68] (global)  (usage 219)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 9)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 3)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (not used)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (not used)
OT_REPORT                            100  0x00000064 (const dword)  (usage 3)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 3)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OutputCS                             666  0x0000029a (mem) word (global)  (usage 9)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (usage 3)
OW_Read                             -299  0xfffffed5 (PmmC func) args[1] r=1  (not used)
OW_Read9                            -300  0xfffffed4 (PmmC func) args[1] r=1  (not used)
OW_Reset                            -298  0xfffffed6 (PmmC func) args[1] r=1  (not used)
OW_Write                            -301  0xfffffed3 (PmmC func) args[2] r=0  (not used)
oWinButtons                          862  0x0000035eoWinButtons                          862  0x0000035e (mem) word[3] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL2_FILLED                      32768  0x00008000 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (not used)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
pInputIndex                          422  0x000001a6 (mem) word (global)  (usage 15)
PIXXI                                  4  0x00000004 (const dword)  (usage 3)
PIXXI44_FUNCTIONS                      0  0x00000000 (const ??? 0)  (not used)
PIXXI_44_CHIP                          5  0x00000005 (const ??? 0)  (not used)
pixxiLCD_39P4CT                        0  0x00000000 (const ??? 0)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (not used)
putstrCentred                       -321  0xfffffebf (PmmC func) args[3] r=0  (not used)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          4339  0x000010f3 (User func) args[2] r=0  (usage 3)
RECT_HEIGHT                            3  0x00000003 (const dword)  (not used)
rect_Intersect                      -307  0xfffffecd (PmmC func) args[2] r=1  (not used)
RECT_LEFT                              0  0x00000000 (const dword)  (not used)
RECT_TOP                               1  0x00000001 (const dword)  (not used)
RECT_WIDTH                             2  0x00000002 (const dword)  (not used)
rect_Within                         -308  0xfffffecc (PmmC func) args[2] r=1  (not used)
RED                                63488  0x0000f800 (const dword)  (usage 21)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 3)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                    918  0x00000396rKeyboardRoutines                    918  0x00000396 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RULERGAUGE_F_ORIENT_VERT               2  0x00000002 (const dword)  (not used)
RULERGAUGE_F_TICKS_BOTTOM              0  0x00000000 (const dword)  (not used)
RULERGAUGE_F_TICKS_TOP                 1  0x00000001 (const dword)  (not used)
RULERGAUGE_HC                         24  0x00000018 (const dword)  (not used)
RULERGAUGE_height                      6  0x00000006 (const dword)  (not used)
RULERGAUGE_IC                         30  0x0000001e (const dword)  (not used)
RULERGAUGE_LC                         22  0x00000016 (const dword)  (not used)
RULERGAUGE_majorTickSize              16  0x00000010 (const dword)  (not used)
RULERGAUGE_MC                         26  0x0000001a (const dword)  (not used)
RULERGAUGE_medium                     18  0x00000012 (const dword)  (not used)
RULERGAUGE_minorTicks                 12  0x0000000c (const dword)  (not used)
RULERGAUGE_minorTickSize              14  0x0000000e (const dword)  (not used)
RULERGAUGE_options                    32  0x00000020 (const dword)  (not used)
RULERGAUGE_range                       8  0x00000008 (const dword)  (not used)
RULERGAUGE_TC                         28  0x0000001c (const dword)  (not used)
RULERGAUGE_threshold                  20  0x00000014 (const dword)  (not used)
RULERGAUGE_ticks                      10  0x0000000a (const dword)  (not used)
RULERGAUGE_width                       4  0x00000004 (const dword)  (not used)
RULERGAUGE_XP                          0  0x00000000 (const dword)  (not used)
RULERGAUGE_YP                          2  0x00000002 (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (usage 3)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCALE_BC                              20  0x00000014 (const dword)  (not used)
SCALE_BR                             N/A         N/A (macro)    0x0002   (not used)
SCALE_CenterGap                       26  0x0000001a (const dword)  (not used)
SCALE_CENTRE                         N/A         N/A (macro)    0x0003   (not used)
SCALE_END_ALIGN                      N/A         N/A (macro)    0x0020   (not used)
SCALE_FONT                            24  0x00000018 (const dword)  (not used)
SCALE_HIDE_ZERO                      N/A         N/A (macro)    0x0000   (not used)
SCALE_HORZ                           N/A         N/A (macro)    0x0000   (not used)
SCALE_length                           4  0x00000004 (const dword)  (not used)
SCALE_max                              8  0x00000008 (const dword)  (not used)
SCALE_min                              6  0x00000006 (const dword)  (not used)
SCALE_NO_END_ALIGN                   N/A         N/A (macro)    0x0000   (not used)
SCALE_NONE                           N/A         N/A (macro)    0x0000   (not used)
SCALE_SHOW_ZERO                      N/A         N/A (macro)    0x0040   (not used)
SCALE_TC                              18  0x00000012 (const dword)  (not used)
SCALE_ticklength                      12  0x0000000c (const dword)  (not used)
SCALE_ticklengthMinor                 16  0x00000010 (const dword)  (not used)
SCALE_ticks                           10  0x0000000a (const dword)  (not used)
SCALE_TICKS_BOTH                     N/A         N/A (macro)    0x000c   (not used)
SCALE_TICKS_BR                       N/A         N/A (macro)    0x0008   (not used)
SCALE_TICKS_NONE                     N/A         N/A (macro)    0x0000   (not used)
SCALE_TICKS_TL                       N/A         N/A (macro)    0x0004   (not used)
SCALE_ticksMinor                      14  0x0000000e (const dword)  (not used)
SCALE_TL                             N/A         N/A (macro)    0x0001   (not used)
SCALE_type                            28  0x0000001c (const dword)  (not used)
SCALE_VERT                           N/A         N/A (macro)    0x0010   (not used)
SCALE_XC                              22  0x00000016 (const dword)  (not used)
SCALE_XP                               0  0x00000000 (const dword)  (not used)
SCALE_YP                               2  0x00000002 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
SendReport                          4550  0x000011c6 (User func) args[4] r=0  (usage 6)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 15)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                            4633  0x00001219 (User func) args[1] r=0  (usage 15)
seroutOcs                           4600  0x000011f8 (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (usage 12)
SLIDER5_base_color                    14  0x0000000e (const dword)  (not used)
SLIDER5_F_ORIENT_VERT                N/A         N/A (macro)     0x0001    /* Switch orientation (0 - horizontal, 1 - vertical) */   (not used)
SLIDER5_F_PROGRESSBAR                N/A         N/A (macro)     0x0008    /* Progress Bar mode */   (not used)
SLIDER5_F_TICKS                      N/A         N/A (macro)     0x0002    /* Enable Marker Ticks*/   (not used)
SLIDER5_F_VALUE_IND                  N/A         N/A (macro)     0x0004    /* Enable slider value indicator */   (not used)
SLIDER5_font_c                        38  0x00000026 (const dword)  (not used)
SLIDER5_font_s                        36  0x00000024 (const dword)  (not used)
SLIDER5_knob_f_c_1                    46  0x0000002e (const dword)  (not used)
SLIDER5_knob_f_c_2                    48  0x00000030 (const dword)  (not used)
SLIDER5_knob_f_g                      50  0x00000032 (const dword)  (not used)
SLIDER5_knob_o_c_1                    40  0x00000028 (const dword)  (not used)
SLIDER5_knob_o_c_2                    42  0x0000002a (const dword)  (not used)
SLIDER5_knob_o_g                      44  0x0000002c (const dword)  (not used)
SLIDER5_len                            4  0x00000004 (const dword)  (not used)
SLIDER5_max_val                       12  0x0000000c (const dword)  (not used)
SLIDER5_min_val                       10  0x0000000a (const dword)  (not used)
SLIDER5_num_ticks_L_1                 24  0x00000018 (const dword)  (not used)
SLIDER5_num_ticks_L_2                 26  0x0000001a (const dword)  (not used)
SLIDER5_options                        8  0x00000008 (const dword)  (not used)
SLIDER5_thk                            6  0x00000006 (const dword)  (not used)
SLIDER5_tick_maj_c                    30  0x0000001e (const dword)  (not used)
SLIDER5_tick_maj_l                    28  0x0000001c (const dword)  (not used)
SLIDER5_tick_min_c                    34  0x00000022 (const dword)  (not used)
SLIDER5_tick_min_l                    32  0x00000020 (const dword)  (not used)
SLIDER5_total_tick_B_R                22  0x00000016 (const dword)  (not used)
SLIDER5_total_tick_T_L                20  0x00000014 (const dword)  (not used)
SLIDER5_track_color                   18  0x00000012 (const dword)  (not used)
SLIDER5_track_empty                   16  0x00000010 (const dword)  (not used)
SLIDER5_x_pos                          0  0x00000000 (const dword)  (not used)
SLIDER5_y_pos                          2  0x00000002 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Freq                            -302  0xfffffed2 (PmmC func) args[2] r=1  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_RTTTL                           -309  0xfffffecb (PmmC func) args[1] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SOUND                                  3  0x00000003 (const dword)  (not used)
SOUTH                                  1  0x00000001 (const dword)  (not used)
SOUTH_MIRRORED                         5  0x00000005 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
SWITCH1_cOff                          20  0x00000014 (const dword)  (not used)
SWITCH1_cOn                           18  0x00000012 (const dword)  (not used)
SWITCH1_dshd                          12  0x0000000c (const dword)  (not used)
SWITCH1_F_ORIENT_VERT                N/A         N/A (macro)   0x0001  /* switch orientation (0: Horizontal, 1: Vertical) */   (not used)
SWITCH1_fcOff                         32  0x00000020 (const dword)  (not used)
SWITCH1_fcOn                          30  0x0000001e (const dword)  (not used)
SWITCH1_flg                            8  0x00000008 (const dword)  (not used)
SWITCH1_fnt                           26  0x0000001a (const dword)  (not used)
SWITCH1_fsz                           28  0x0000001c (const dword)  (not used)
SWITCH1_len                            4  0x00000004 (const dword)  (not used)
SWITCH1_lshd                          10  0x0000000a (const dword)  (not used)
SWITCH1_oBz                           14  0x0000000e (const dword)  (not used)
SWITCH1_tBz                           16  0x00000010 (const dword)  (not used)
SWITCH1_thk                            6  0x00000006 (const dword)  (not used)
SWITCH1_tOff                          24  0x00000018 (const dword)  (not used)
SWITCH1_tOn                           22  0x00000016 (const dword)  (not used)
SWITCH1_x                              0  0x00000000 (const dword)  (not used)
SWITCH1_y                              2  0x00000002 (const dword)  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_Driver                          -297  0xfffffed7 (PmmC func) args[0] r=0  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_PmmC                            -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 18)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 3)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tiAngularMeter                        39  0x00000027 (const dword)  (usage 21)
tiButtonD                             51  0x00000033 (const dword)  (usage 3)
tiButtonE                             52  0x00000034 (const dword)  (usage 3)
tiDial                                55  0x00000037 (const dword)  (usage 3)
tiGauge                               40  0x00000028 (const dword)  (usage 3)
tiLabelB                              41  0x00000029 (const dword)  (usage 6)
tiLed                                 45  0x0000002d (const dword)  (usage 3)
tiLedDigit                            50  0x00000032 (const dword)  (usage 9)
tiLedDigits                           47  0x0000002f (const dword)  (usage 6)
tiLedDigitsH                          38  0x00000026 (const dword)  (usage 12)
tiLinearInput                         67  0x00000043 (const dword)  (usage 9)
tImage                                12  0x0000000c (const dword)  (usage 3)
tiMediaButton                         53  0x00000035 (const dword)  (usage 3)
tiMediaGauge                          43  0x0000002b (const dword)  (usage 3)
tiMediaLed                            46  0x0000002e (const dword)  (usage 3)
tiMediaRotary                         56  0x00000038 (const dword)  (usage 3)
tiMediaSlider                         61  0x0000003d (const dword)  (usage 3)
tiMediaThermometer                    44  0x0000002c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tiNeedle                              48  0x00000030 (const dword)  (usage 3)
tiRotaryInput                         57  0x00000039 (const dword)  (usage 6)
tiRuler                               49  0x00000031 (const dword)  (usage 3)
tiSliderC                             66  0x00000042 (const dword)  (usage 3)
tiSliderD                             65  0x00000041 (const dword)  (usage 3)
tiSliderE                             60  0x0000003c (const dword)  (usage 3)
tiSliderF                             64  0x00000040 (const dword)  (usage 3)
tiSliderG                             63  0x0000003f (const dword)  (usage 3)
tiSliderH                             62  0x0000003e (const dword)  (usage 3)
tiSwitch                              58  0x0000003a (const dword)  (usage 3)
tiSwitchB                             59  0x0000003b (const dword)  (usage 6)
tiToggleInput                         54  0x00000036 (const dword)  (usage 6)
tiUserGauge                           42  0x0000002a (const dword)  (usage 3)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 6)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 3)
tMagicObject                          34  0x00000022 (const dword)  (usage 6)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 9)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 18)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           418  0x000001a2 (mem) word (global)  (usage 24)
TouchXpos                            412  0x0000019c (mem) word (global)  (usage 12)
TouchYpos                            414  0x0000019e (mem) word (global)  (usage 9)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSmartGauge                           35  0x00000023 (const dword)  (usage 6)
tSmartKnob                            37  0x00000025 (const dword)  (usage 6)
tSmartSlider                          36  0x00000024 (const dword)  (usage 6)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 3)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 6)
TurnOffButtons                      3825  0x00000ef1 (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 12)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 27)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (not used)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (not used)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                           -345  0xfffffea7 (PmmC func) args[3] r=1  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       2748  0x00000abc (User func) args[1] r=0  (usage 3)
USD_ENABLE                            25  0x00000019 (const dword)  (not used)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
vIAngularMeter0                        2  0x00000002 (mem) word[10] (global)  (usage 3)
vIAngularMeter1                       22  0x00000016 (mem) word[10] (global)  (usage 3)
vIAngularMeter2                      158  0x0000009e (mem) word[10] (global)  (usage 3)
vIAngularMeter3                       66  0x00000042 (mem) word[10] (global)  (usage 3)
vILedDigits0                          42  0x0000002a (mem) word[12] (global)  (usage 3)
vILedDigits1                          86  0x00000056 (mem) word[12] (global)  (usage 3)
vILedDigits2                         110  0x0000006e (mem) word[12] (global)  (usage 3)
vILedDigits3                         134  0x00000086 (mem) word[12] (global)  (usage 3)
vILedDigits4                         178  0x000000b2 (mem) word[12] (global)  (usage 3)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
vObjects                             202  0x000000ca (mem) word[28] (global)  (usage 15)
WEST                                   2  0x00000002 (const dword)  (not used)
WEST_MIRRORED                          6  0x00000006 (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (usage 15)
WHITE                              65535  0x0000ffff (const dword)  (usage 12)
WHITESMOKE                         63422  0x0000f7be (const dword)  (usage 18)
widget_Add                          -323  0xfffffebd (PmmC func) args[3] r=1  (usage 3)
widget_ClearAttributes              -334  0xfffffeb2 (PmmC func) args[3] r=1  (usage 3)
widget_Create                       -322  0xfffffebe (PmmC func) args[1] r=1  (usage 3)
WIDGET_DECIMALS                       11  0x0000000b (const dword)  (not used)
WIDGET_DELAY                          10  0x0000000a (const dword)  (not used)
widget_Delete                       -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
widget_Disable                      -331  0xfffffeb5 (PmmC func) args[2] r=1  (usage 3)
widget_Enable                       -330  0xfffffeb6 (PmmC func) args[2] r=1  (usage 3)
WIDGET_F_DISABLED                   2048  0x00000800 (const dword)  (not used)
WIDGET_F_FLASH                      1024  0x00000400 (const dword)  (not used)
WIDGET_F_INITIALISED                8192  0x00002000 (const dword)  (usage 3)
WIDGET_F_INTERNAL                  16384  0x00004000 (const dword)  (not used)
WIDGET_F_RESERVED                    960  0x000003c0 (const dword)  (not used)
WIDGET_F_TOUCH_ENABLE              32768  0x00008000 (const dword)  (usage 3)
WIDGET_F_UNDRAW_ONLY                4096  0x00001000 (const dword)  (not used)
WIDGET_FLAGS                           6  0x00000006 (const dword)  (not used)
widget_FontID                       -336  0xfffffeb0 (PmmC func) args[1] r=1  (not used)
WIDGET_FRAMES                         11  0x0000000b (const dword)  (not used)
widget_GetWord                      -328  0xfffffeb8 (PmmC func) args[3] r=1  (not used)
WIDGET_HEIGHT                          3  0x00000003 (const dword)  (not used)
WIDGET_HI_WORD                         5  0x00000005 (const dword)  (not used)
WIDGET_LO_WORD                         4  0x00000004 (const dword)  (not used)
widget_LoadFlash                    -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
WIDGET_RAM_SPACE                      10  0x0000000a (const dword)  (usage 27)
widget_Realloc                      -327  0xfffffeb9 (PmmC func) args[2] r=1  (not used)
widget_SetAttributes                -333  0xfffffeb3 (PmmC func) args[3] r=1  (usage 3)
widget_Setposition                  -329  0xfffffeb7 (PmmC func) args[4] r=1  (not used)
widget_SetWord                      -332  0xfffffeb4 (PmmC func) args[4] r=1  (not used)
widget_Show                         -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
WIDGET_TAG                             7  0x00000007 (const dword)  (not used)
WIDGET_TAG2                            8  0x00000008 (const dword)  (not used)
widget_Touched                      -335  0xfffffeb1 (PmmC func) args[2] r=1  (usage 3)
WIDGET_VAL1                            9  0x00000009 (const dword)  (usage 9)
WIDGET_VAL2                           10  0x0000000a (const dword)  (not used)
WIDGET_WIDTH                           2  0x00000002 (const dword)  (not used)
WIDGET_XOTHER                          4  0x00000004 (const dword)  (not used)
WIDGET_XPOS                            0  0x00000000 (const dword)  (not used)
WIDGET_YOTHER                          5  0x00000005 (const dword)  (not used)
WIDGET_YPOS                            1  0x00000001 (const dword)  (not used)
wp                                   668  0x0000029c (mem) word (global)  (usage 21)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_LABEL                           12  0x0000000c (const dword)  (not used)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_STR                              2  0x00000002 (const dword)  (not used)
WRITE_STRU                             3  0x00000003 (const dword)  (not used)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         3974  0x00000f86 (User func) args[3] r=0  (usage 18)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
xobj2iobj                            199  0x000000c7xobj2iobj                            199  0x000000c7 (mem) word[9] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
XYLIN_X                                1  0x00000001 (const dword)  (not used)
XYLIN_Y                                0  0x00000000 (const dword)  (not used)
XYROT_EAST                             0  0x00000000 (const dword)  (not used)
XYROT_SOUTH                            1  0x00000001 (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
