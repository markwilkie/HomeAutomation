file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\pixxiLCD-39P4CT.fnc

000001  000001  #platform "pixxiLCD-39P4CT"
000002  000001  #platform "pixxiLCD-39P4CT"
000003  000008  */
000004  000009      #constant pixxiLCD_39P4CT
000005  000009      #constant pixxiLCD_39P4CT
000006  000010        
000007  000011      #IFNOT EXISTS PIXXI44_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PIXXI44functions.fnc

000008  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000009  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PIXXI44_FUNCTIONS
000014  000004  #constant PIXXI44_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000019  #END
000019  000020        
000020  000021  #CONST
000021  000027  #END
000022  000028        
000023  000029        
000024  000030  #CONST
000025  000044  #END
000026  000045        
000027  000046        
000028  000047  #CONST
000029  000212  #END
000030  000213        
000031  000214        
000032  000215  // baud divisor rates for setbaud(n);
000033  000216  #CONST
000034  000238  #END
000035  000239        
000036  000240        
000037  000241        
000038  000242        
000039  000247  */
000040  000248        
000041  000249        
000042  000250  //==============================================//
000043  000251  // EVE bios functions                           //
000044  000252  //==============================================//
000045  000253                                                  //
000046  000254  func serin(), 1;                // read a byte from COM0
000047  000255  // Syntax: serin();
000048  000256  // Usage : char := serin();
000049  000257  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000258  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000259  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000260  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000261  //     : Returns: -1 if no character is available
000054  000262  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000263  //     : Returns: positive value 0 to 255 for a valid character received
000056  000264        
000057  000265  func putch("char"), 0;                // write single char to current output device
000058  000266  // Syntax: putch("char");
000059  000267  // Usage : putch("A");
000060  000268  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000269  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000270  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000271  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000272  //     : The arguments can be a variable, array element, expression or constant
000065  000273        
000066  000274  func serout("char"), 0;                // write a byte to COM0
000067  000275  // Syntax: serout1("char");
000068  000276  // Usage : serout1(ch);
000069  000277  // Notes : send character to COM1
000070  000278        
000071  000279  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000280  // Syntax: setbaud(baud_number);
000073  000281  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000282  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000283  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000284  //       : this is used as a table pointer to get the baud rate divisor
000077  000285  //       : value for one of the 20 selected baud rates, control is then
000078  000286  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000287  //       : The pre-defined constants equate to a value of 0-19.
000080  000288  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000289  //       : will occur.
000082  000290        
000083  000291  func to("device"), 1;                // output device redirection
000084  000292  // Syntax: to(outstream);
000085  000293  // Usage : to(APPEND); putstr("TWO ");
000086  000294  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000295  //     :
000088  000296  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000297  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000298  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000299  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000300  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000301  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000302  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000303  //     : sequential data to a media stream.
000096  000304  //     :
000097  000305  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000306  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000307  //     :                            appended to user memory if previous redirection was to an array.
000100  000308  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000309  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000310  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000311  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000312  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000313        
000106  000314        
000107  000315  func pause("milliseconds"), 0;            // blocking delay
000108  000316  // Syntax: pause(milliseconds);
000109  000317  // Usage : pause(1000);                //pause for 1 second
000110  000318  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000319        
000112  000320  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000321  // Syntax: putnum(format, value);
000114  000322  // Usage : var := putnum(HEX, val);
000115  000323  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000324  //     : Format: A constant that specifies the number format
000117  000325  //     : Value : The number to be printed
000118  000326  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000327  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000328  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000329  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000330  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000331  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000332  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000333  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000334  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000335  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000336  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000337  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000338  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000339  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000340  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000341  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000342  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000343  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000344  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000345  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000346  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000347  //     : | | | | V V V
000140  000348  //     : | | | | | | |
000141  000349  //     : | | | | | |
000142  000350  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000351  //     : | | | | digit count |
000144  000352  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000353  //     : | | | |
000146  000354  //     : | | | |
000147  000355  //     : | | | |
000148  000356  //     : | | | |
000149  000357  //     : | | | |
000150  000358  //     : | | | |______ 1 = leading zeros included
000151  000359  //     : | | | 0 = leading zeros suppressed
000152  000360  //     : | | |
000153  000361  //     : | | |
000154  000362  //     : | | |_______ 1 = leading zero blanking
000155  000363  //     : | |
000156  000364  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000365  //     : |
000158  000366  //     : |______ 1 = space before unsigned number
000159  000367        
000160  000368        
000161  000369  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000370        
000163  000371  func putstr("string"), 1;                       // print string to current output device
000164  000372  // Syntax: putstr(pointer);
000165  000373  // Usage : putstr("HELLO\n");
000166  000374  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000375  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000376  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000377  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000378  //       : using the to(...); function.
000171  000379  //       : A string constant is automatically terminated with a zero.
000172  000380  //       : A string in a data statement is not automatically terminated with a zero.
000173  000381  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000382  //       : element packs 1 or 2 characters.
000175  000383        
000176  000384        
000177  000385  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000386  // Syntax: strlen("varAddress);
000179  000387  // Usage : strlen("HELLO\n");
000180  000388  // Notes : gives the length of a string that is packed into regular var array
000181  000389  //       : Use str_Length(ptr)  for string pointer mode
000182  000390        
000183  000391        
000184  000392  //==============================================//
000185  000393  // Memory Access Function Prototypes            //
000186  000394  //==============================================//
000187  000395                                                  //
000188  000396  func peekW("address"), 1;                       // read a word from system memory
000189  000397  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000398  // refer to address map of internal variables   //
000191  000399  //==============================================//
000192  000400  // Math Functions                               //
000193  000401  //==============================================//
000194  000402                                                  //
000195  000403  func ABS("value"), 1;                           // return a positive number
000196  000404  // Syntax: ABS(value);
000197  000405  // Usage : var := ABS(arg);
000198  000406  // Notes : Returns the absolute value of an argument
000199  000407        
000200  000408  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000409  // Syntax: MIN(value1, value2);
000202  000410  // Usage : var := MIN(arg1, arg2);
000203  000411  // Notes : Returns the minimum of 2 arguments
000204  000412        
000205  000413  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000414  // Syntax: MAX(value1, value2);
000207  000415  // Usage : var := MAX(arg1, arg2);
000208  000416  // Notes : Returns the maximum of 2 arguments
000209  000417        
000210  000418  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000419  // Syntax: SWAP(&var1, &var2);
000212  000420  // Usage : SWAP(&var1, &var2);
000213  000421  // Notes : Swaps the contents of 2 variables or memory locations
000214  000422        
000215  000423  func SIN("angle"), 1;                           // return SIN of angle
000216  000424  // Syntax: SIN(angle);
000217  000425  // Usage : var := SIN(arg);
000218  000426  // Notes : Returns the sine in radians of an argument in degrees
000219  000427  //       : the returned value range is from 127 to -127. The real
000220  000428  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000429  //       : scaling must be done in user code.
000222  000430        
000223  000431  func COS("angle"), 1;                           // return COS of angle
000224  000432  // Syntax: COS(angle);
000225  000433  // Usage : var := COS(arg);
000226  000434  // Notes : Returns the cosine in radians of an argument in degrees
000227  000435  //       : the returned value range is from 127 to -127. The real
000228  000436  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000437  //       : scaling must be done in user code.
000230  000438        
000231  000439  func RAND(), 1;                                 // return a pseudo random number
000232  000440  // Syntax: RAND();
000233  000441  // Usage : var := RAND();
000234  000442  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000443  //       : The random number generator must first be seeded
000236  000444  //       : by using the SEED(number) function.
000237  000445        
000238  000446  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000447  // Syntax: SEED(number);
000240  000448  // Usage : SEED(arg);
000241  000449  // Notes : Seeds the random number generator.
000242  000450        
000243  000451  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000452  // Syntax: OVF();
000245  000453  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000454  //       : hiWord := OVF();
000247  000455  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000456        
000249  000457  func SQRT("number"), 1;                         // return square root of a number
000250  000458  // Syntax: SQRT(number);
000251  000459  // Usage : SQRT(arg);
000252  000460  // Notes : Returns the integer square root of a number.
000253  000461  //------------------------------------------------------------------//
000254  000462  //          Text Related Function Prototypes
000255  000463  //------------------------------------------------------------------//
000256  000464        
000257  000465  func txt_MoveCursor("line", "column"), 0;
000258  000466  // Syntax: txt_SetCursor(line, column);
000259  000467  // Usage : txt_SetCursor(arg1, arg2);
000260  000468  // Notes : Moves the text Cursor to a new screen position set by
000261  000469  //       : line,column parameters.
000262  000470        
000263  000471  func txt_Set("mode", "value"), 0;
000264  000472  // Syntax: txt_Set(mode, value);
000265  000473  // Usage : txt_Set(arg1, arg2);
000266  000474  // Returns : Original value before the change
000267  000475  // Notes : Sets various text related parameters used by other functions
000268  000476  //       : This allows the features to be set programatically with a
000269  000477  //       : single function call.It is strongly recommended to use the
000270  000478  //       : pre-defined constants rather than the mode numbers.
000271  000479  //       : NB:- Although it is often required to be able to set text
000272  000480  //       : functions with a single function call for graphics engine
000273  000481  //       : related functions, there is a complete set of single parameter
000274  000482  //       : shortcut functions that have exactly the same function as
000275  000483  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000484  //       :
000277  000485  //       : mode = TEXT_COLOUR (mode 0)
000278  000486  //       : txt_Set(TEXT_COLOUR, value);
000279  000487  //       : value = 0 to 0xFFFF, Black to White
000280  000488  //       : Sets the Text colour for the display
000281  000489  //       : Default = LIME.
000282  000490  //       :
000283  000491  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000492  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000493  //       : value = 0 to 0xFFFF, Black to White
000286  000494  //       : Sets the Text background colour for the display. Effective
000287  000495  //       : when text mode is Opaque.
000288  000496  //       : Default = BLACK.
000289  000497  //       :
000290  000498  //       : mode = FONT_ID (mode 2)
000291  000499  //       : txt_Set(FONT_ID, value);
000292  000500  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000501  //       : else this value is the name of a font included
000294  000502  //       : in a users program in a data statement.
000295  000503  //       : Default = FONT SIZE 3.
000296  000504  //       :
000297  000505  //       : mode = TEXT_WIDTH  (mode 3)
000298  000506  //       : txt_Set(TEXT_WIDTH, value);
000299  000507  //       : value = 1 to 16
000300  000508  //       : Sets the Text Width multiplier
000301  000509  //       : text will be printed magnified horizontally
000302  000510  //       : by this factor, Default = 1.
000303  000511  //       :
000304  000512  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000513  //       : txt_Set(TEXT_HEIGHT, value);
000306  000514  //       : value = 1 to 16
000307  000515  //       : Sets the Text Height multiplier
000308  000516  //       : text will be printed magnified vertically
000309  000517  //       : by this factor, Default = 1.
000310  000518  //       :
000311  000519  //       : mode = TEXT_XGAP  (mode 5)
000312  000520  //       : txt_Set(TEXT_XGAP, value);
000313  000521  //       : value = 1 to 32
000314  000522  //       : Sets the horizontal gap between characters
000315  000523  //       : The gap is in pixel units, Default = 0
000316  000524  //       :
000317  000525  //       : mode = TEXT_YGAP  (mode 6)
000318  000526  //       : txt_Set(TEXT_YGAP, value);
000319  000527  //       : value = 1 to 32
000320  000528  //       : Sets the vertical gap below characters
000321  000529  //       : The gap is in pixel units, Default = 0
000322  000530  //       :
000323  000531  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000532  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000533  //       : value = 0 to 255
000326  000534  //       : Sets the delay time (in ms) during character
000327  000535  //       : printing to give a 'teletype' like effect.
000328  000536  //       : Often used to attract attention to a string
000329  000537  //       : being printed which can often be missed if
000330  000538  //       : just suddenly appearing or changing.
000331  000539  //       : Default = 0 ms.
000332  000540  //       :
000333  000541  //       : mode = TEXT_OPACITY (mode 8)
000334  000542  //       : txt_Set(TEXT_OPACITY, value);
000335  000543  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000544  //       : value = OPAQUE (1) = Text Opaque
000337  000545  //       : Sets the Opacity/Transparency of the text
000338  000546  //       : Default = 0 or TRANSPARENT
000339  000547  //       :
000340  000548  //       : mode = TEXT_BOLD (mode 9)
000341  000549  //       : txt_Set(TEXT_BOLD, value);
000342  000550  //       : value = dont care
000343  000551  //       : Sets Bold Text mode for the next string or char
000344  000552  //       : The feature automatically resets after printing
000345  000553  //       : using putstr or print has completed
000346  000554  //       :
000347  000555  //       : mode = TEXT_ITALIC (mode 10)
000348  000556  //       : txt_Set(TEXT_ITALIC, value);
000349  000557  //       : value = dont care
000350  000558  //       : Sets Italic Text mode for the next string or char
000351  000559  //       : The feature automatically resets after printing
000352  000560  //       : using putstr or print has completed
000353  000561        
000354  000562  //       : mode = TEXT_INVERSE (mode 11)
000355  000563  //       : txt_Set(TEXT_INVERSE, value);
000356  000564  //       : value = dont care
000357  000565  //       : Sets Inverse Text mode for the next string or char
000358  000566  //       : The feature automatically resets after printing
000359  000567  //       : using putstr or print has completed
000360  000568  //       :
000361  000569  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000570  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000571  //       : value = dont care
000364  000572  //       : Sets Underlined Text mode for the next string or char
000365  000573  //       : The feature automatically resets after printing
000366  000574  //       : using putstr or print has completed
000367  000575  //       :
000368  000576  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000577  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000578  //       : value = bits are defined as:
000371  000579  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000580  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000581  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000582  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000583  //       : Allows a combination of text attributes to be defined together
000376  000584  //       : by 'or'ing the bits together.
000377  000585  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000586  //       : The feature automatically resets after printing
000379  000587  //       : using putstr or print has completed.
000380  000588  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000589  //       :
000382  000590  //       : mode = TEXT_WRAP (mode 14)
000383  000591  //       : txt_Set(TEXT_WRAP , value);
000384  000592  //       : Sets the position where text wrap will occur
000385  000593  //       : The feature automatically resets when screen
000386  000594  //       : mode is changed. If the value is set to 0,
000387  000595  //       : text wrap is turned off.
000388  000596  //       : of the current screen. Default value is 0
000389  000597  // Notes : The value is in pixel units.
000390  000598  //       :
000391  000599        
000392  000600  //       : txt_Set mode 15 reserved for future use
000393  000601  //       :
000394  000602        
000395  000603        
000396  000604        
000397  000605  //=====================================================//
000398  000606  // Single parameter short-cuts                         //
000399  000607  // for the txt_Set functions                           //
000400  000608  // These functions return the existing value before    //
000401  000609  // the change is made.                                 //
000402  000610  //=====================================================//
000403  000611  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000612  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000613  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000614  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000615  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000616  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000617  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000618  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000619  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000620  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000621  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000622  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000623  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000624  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000625  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000626  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000627        
000420  000628        
000421  000629  //------------------------------------------------------------------//
000422  000630  //                 Hardware Function Prototypes
000423  000631  //------------------------------------------------------------------//
000424  000632        
000425  000633  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000426  000634  // Syntax: pin_Set(mode, pin);
000427  000635  // Usage : pin_Set(arg1, arg2);
000428  000636  // Notes : Sets the appropriate pins to Inputs or Outputs
000429  000637  //       : returns true if the pin number is legal (usually ignored)
000430  000638  //       :
000431  000639  //       : "mode" is either INPUT or OUTPUT
000432  000640  //       :
000433  000641  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000434  000642  //       : of your PiXXi-44 processor.
000435  000643        
000436  000644  func pin_HI("pin"), 1;                    // set pin to logic '1'
000437  000645  // Syntax: pin_HI(pin);
000438  000646  // Usage : pin_HI(arg);
000439  000647  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000440  000648  //       : pin that was previously selected as an Output.
000441  000649  //       : returns true if the pin number is legal (usually ignored)
000442  000650  //       :
000443  000651  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000444  000652  //       : of your PiXXi-44 processor.
000445  000653        
000446  000654  func pin_LO("pin"), 1;                    // set pin to logic '0'
000447  000655  // Syntax: pin_LO(pin);
000448  000656  // Usage : pin_LO(arg);
000449  000657  // Notes : Outputs a logic "Low" (0V) on the appropriate
000450  000658  //       : pin that was previously selected as an Output.
000451  000659  //       : returns true if the pin number is legal (usually ignored)
000452  000660  //       :
000453  000661  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000454  000662  //       : of your PiXXi-44 processor.
000455  000663        
000456  000664  func pin_Read("pin"), 1;                // read pin, logic or analogue
000457  000665  // Syntax	: pin_Read(pin);
000458  000666  // Usage	: arg1 := pin_Read(arg2);
000459  000667  // Notes	: Reads the logic state of the appropriate
000460  000668  // 	: pin that was previously selected as an Input.
000461  000669  // 	:
000462  000670  // 	: "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000463  000671  // 	: of your PiXXi-44 processor.
000464  000672  // 	: Returns 0 or 1 for a digital input
000465  000673  // 	: Returns 0..4095 for an analogue input
000466  000674        
000467  000675  //------------------------------------------------------------------//
000468  000676  //                 P1 module BUS I/O control
000469  000677  //------------------------------------------------------------------//
000470  000678        
000471  000679  func bus_In(), 1;
000472  000680  // Syntax: bus_In();
000473  000681  // Usage : arg1 := bus_In();
000474  000682  // Notes : Read the 7bit wide bus into the lower 7 bits of arg1.
000475  000683  //       : The upper 9 bits of arg1 are set to 0.
000476  000684  //       : Only available in Mode 2 (4-Wire SPI)
000477  000685  //       : 
000478  000686  //       : BUS_0 is IO12_PIN
000479  000687  //       : BUS_1 is IO13_PIN
000480  000688  //       : BUS_2 is IO14_PIN
000481  000689  //       : BUS_3 is IO15_PIN
000482  000690  //       : BUS_4 is IO16_PIN
000483  000691  //       : BUS_5 is IO17_PIN
000484  000692  //       : BUS_6 is IO18_PIN
000485  000693  //       : BUS_7 is N/A
000486  000694        
000487  000695  func bus_Out("var"), 0;
000488  000696  // Syntax: bus_Out(var);
000489  000697  // Usage : bus_Out(arg1);
000490  000698  // Notes : The lower 7 bits of arg1 are placed on the 7bit wide bus.
000491  000699  //       : The upper 9 bits of arg1 are ignored.
000492  000700  //       : NB:- any BUS pins that are set to inputs are not affected.
000493  000701  //       : Only available in Mode 2 (4-Wire SPI)
000494  000702  //       :
000495  000703  //       : BUS_0 is pin 27 of J1
000496  000704  //       : BUS_1 is pin 25 of J1
000497  000705  //       : BUS_2 is pin 23 of J1
000498  000706  //       : BUS_3 is pin 21 of J1
000499  000707  //       : BUS_4 is pin 19 of J1
000500  000708  //       : BUS_5 is pin 17 of J1
000501  000709  //       : BUS_6 is pin 13 of J2
000502  000710  //       : BUS_7 is pin 11 of J2
000503  000711        
000504  000712  func bus_Set("var"), 0;
000505  000713  // Syntax: bus_Set(var);
000506  000714  // Usage : bus_Set(arg1);
000507  000715  // Notes : Not available on the Pixxi Chips
000508  000716        
000509  000717  func bus_Write("var"), 0;
000510  000718  // Syntax: bus_Write(var);
000511  000719  // Usage : bus_Write(arg1);
000512  000720  // Notes : Not available on the Pixxi Chips
000513  000721        
000514  000722  func bus_Read(), 1;
000515  000723  // Syntax: bus_Read();
000516  000724  // Usage : arg1 := bus_Read();
000517  000725  // Notes : Not available on the Pixxi Chips
000518  000726        
000519  000727        
000520  000728  //------------------------------------------------------------------//
000521  000729  //   Graphics Functions
000522  000730  //------------------------------------------------------------------//
000523  000731  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000524  000732  // Syntax: gfx_Set(mode, value);
000525  000733  // Usage : gfx_Set(arg1, arg2);
000526  000734  // Notes : Sets various graphics parameters used by other functions
000527  000735  //       : This allows the features to be set programatically with a
000528  000736  //       : single function call.It is strongly recommended to use the
000529  000737  //       : pre-defined constants rather than the mode numbers.
000530  000738  //       : NB:- Although it is often required to be able to set graphics
000531  000739  //       : functions with a single function call for graphics engine
000532  000740  //       : related functions, there is a complete set of single parameter
000533  000741  //       : shortcut functions that have exactly the same function as
000534  000742  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000535  000743  //       :
000536  000744  //       : mode = PEN_SIZE (mode 16)
000537  000745  //       : gfx_Set(PEN_SIZE, value);
000538  000746  //       : value = SOLID (value 0) rectangle and circle objects are solid
000539  000747  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000540  000748  //       : Sets the mode of the Pen used by most graphics objects
000541  000749  //       :
000542  000750  //       : mode = BACKGROUND_COLOUR (mode 17)
000543  000751  //       : gfx_Set(BACKGROUND_COLOUR, value);
000544  000752  //       : value = 0 to 0xFFFF, Black to White
000545  000753  //       : Sets the Background colour of the screen
000546  000754  //       :
000547  000755  //       : mode = OBJECT_COLOUR (mode 18)
000548  000756  //       : gfx_Set(OBJECT_COLOUR, value);
000549  000757  //       : value = 0 to 0xFFFF, Black to White
000550  000758  //       : Sets the Object colour used in various functions
000551  000759  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000552  000760  //       :
000553  000761  //       : mode = CLIPPING (mode 19)
000554  000762  //       : gfx_Set(CLIPPING, value);
000555  000763  //       : value = OFF (value 0) Clipping disabled
000556  000764  //       : value = ON (value 1) Clipping enabled
000557  000765  //       : Enables/Disables the Clipping feature
000558  000766  //       :
000559  000767  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000560  000768  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000561  000769  //       : value = 0 to 0xFFFF Black to White
000562  000770  //       : Sets Bitmap, Image or Animation Transparency Colour.
000563  000771  //       : NB not implemented
000564  000772  //       :
000565  000773  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000566  000774  //       : gfx_Set(5, value);
000567  000775  //       : value = OFF (value 0) Transparency disabled
000568  000776  //       : value = ON (value 1) Transparency enabled
000569  000777  //       : Enables/Disables the Transparency feature
000570  000778  //       : NB not implemented
000571  000779  //       :
000572  000780  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000573  000781  //       : gfx_Set(FRAME_DELAY, value);
000574  000782  //       : value = 0 to 65535 ms
000575  000783  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000576  000784  //       : over-ride the embedded frame delay of the clip. After the event,
000577  000785  //       : the setting will auto disable and if further inter-frame delays need
000578  000786  //       : overriding the setting must be re-issued.
000579  000787  //       :
000580  000788  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000581  000789  //       : gfx_Set(SCREEN_MODE, value);
000582  000790  //       : value = LANDSCAPE   (value 0)
000583  000791  //       : value = LANDSCAPE_R (value 1)
000584  000792  //       : value = PORTRAIT    (value 2)
000585  000793  //       : value = PORTRAIT_R  (value 3)
000586  000794  //       :
000587  000795  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000588  000796  //       : gfx_Set(OUTLINE_COLOUR, value);
000589  000797  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000590  000798  //       : Sets the filled Rectangle or Circle objects outline colour
000591  000799  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000592  000800  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000593  000801  //       :
000594  000802  //       : Only supports variable contrast for uOLED Modules
000595  000803  //       : mode = CONTRAST (mode 25) : Contrast
000596  000804  //       : gfx_Set(CONTRAST, value);
000597  000805  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000598  000806  //       : when contrast=0, display is placed in low power mode.
000599  000807  //       : This function should be called with contrast=0 when
000600  000808  //       : powering down the module.
000601  000809  //       :
000602  000810  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000603  000811  //       : gfx_Set(LINE_PATTERN, value);
000604  000812  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000605  000813  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000606  000814  //       : a value of 0 turns the feature off
000607  000815  //       :
000608  000816  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000609  000817  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000610  000818  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000611  000819  //       : NB not implemented, default is COLOUR16
000612  000820  //       :
000613  000821  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000614  000822  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000615  000823  //       : sets the button and slider objects bevel width
000616  000824  //       :
000617  000825  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000618  000826  //       : gfx_Set(BEVEL_SHADOW , 5);
000619  000827  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000620  000828  //       :
000621  000829  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000622  000830  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000623  000831  //       : sets the origin of drawn objects to a position other than 0,0
000624  000832  //       :
000625  000833  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000626  000834  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000627  000835  //       : sets the origin of drawn objects to a position other than 0,0
000628  000836        
000629  000837        
000630  000838  func gfx_Cls(), 0;                    // clear the screen
000631  000839  // Syntax: gfx_Cls();
000632  000840  // Usage : gfx_Cls();
000633  000841  // Notes : Clears the screen with current background colour
000634  000842        
000635  000843  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000636  000844  // Syntax: gfx_MoveTo(x, y);
000637  000845  // Usage : gfx_MoveTo(arg1, arg2);
000638  000846  // Notes : Moves the origin to a new x,y position
000639  000847        
000640  000848  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000641  000849  // Syntax: gfx_MoveRel(x, y);
000642  000850  // Usage : gfx_MoveRel(arg1, arg2);
000643  000851  // Notes : Moves the origin to a new x,y position
000644  000852  //       : relative to the current origing
000645  000853        
000646  000854  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000647  000855  // Syntax: gfx_LineTo(x1, y1);
000648  000856  // Usage : gfx_LineTo(arg1, arg2);
000649  000857  // Notes : Draws a Line from the origin x,y to x1,y1.
000650  000858  //       : The new origin is then set to x1, y1. Line colour needs
000651  000859  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000652  000860        
000653  000861  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000654  000862  // Syntax: gfx_LineRel(x1, y1);
000655  000863  // Usage : gfx_LineRel(arg1, arg2);
000656  000864  // Notes : Draws a Line from the origin x,y to x1,y1.
000657  000865  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000658  000866  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000659  000867        
000660  000868  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000661  000869  // Syntax: gfx_Line(x1, x2, y2, colr);
000662  000870  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000663  000871  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000664  000872        
000665  000873  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000666  000874  // Syntax: gfx_Line(x1, x2, y, colr);
000667  000875  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000668  000876  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000669  000877        
000670  000878  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000671  000879  // Syntax: gfx_Line(y1, y2, x, colr);
000672  000880  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000673  000881  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000674  000882        
000675  000883  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000676  000884  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000677  000885  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000678  000886  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000679  000887  //       : bottom corner (x2,y2) on the screen.
000680  000888        
000681  000889  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000682  000890  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000683  000891  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000684  000892  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000685  000893  //       : bottom corner (x2,y2) on the screen.
000686  000894        
000687  000895  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000688  000896  // Syntax: gfx_Circle(x, y, rad, colr);
000689  000897  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000690  000898  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000691  000899        
000692  000900  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000693  000901  // Syntax: gfx_Circle(x, y, rad, colr);
000694  000902  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000695  000903  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000696  000904        
000697  000905  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000698  000906  // Syntax: gfx_PutPixel(x, y, colr);
000699  000907  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000700  000908  // Notes : Plots a coloured pixel on the screen at x,y location
000701  000909        
000702  000910  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000703  000911  // Syntax: gfx_GetPixel(x, y);
000704  000912  // Usage : var := gfx_GetPixel(arg1, arg2);
000705  000913  // Notes : Reads and returns the colour value of a pixel at location x,y
000706  000914        
000707  000915  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000708  000916  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000709  000917  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000710  000918  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000711  000919  //       : Vertices must be specified in an anti-clockwise fashion
000712  000920        
000713  000921  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000714  000922  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000715  000923  // Usage : gfx_OrbitInit(&arg1, &arg2);
000716  000924  // Notes : Sets up the Orbit function parameters.
000717  000925  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000718  000926  //       : variables that get updated after calling gfx_Orbit(,,) function.
000719  000927  //       : The coordiantaes are calculated relative to the origin
000720  000928  //       : obtained by using the gfx_MoveTo(x, y) function.
000721  000929        
000722  000930  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000723  000931  // Syntax: gfx_Orbit(angle, distance);
000724  000932  // Usage : gfx_Orbit(arg1, arg2);
000725  000933  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000726  000934  //       : only known parameters are the angle and the distance from the current origin.
000727  000935        
000728  000936  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000729  000937  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000730  000938  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000731  000939  // Notes : This function is very similar to the Ploygon function
000732  000940  //       : with the exception of the 1st and the last vertices not joined.
000733  000941        
000734  000942  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000735  000943  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000736  000944  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000737  000945  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000738  000946  //       : Vertices must be minimum of 3 and can be specified in any fashion
000739  000947        
000740  000948  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000741  000949  // Syntax: gfx_Dot();
000742  000950  // Usage : gfx_Dot();
000743  000951  // Notes : Places a coloured dot at the origin
000744  000952        
000745  000953        
000746  000954  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000747  000955  // Syntax: gfx_Bullet();
000748  000956  // Usage : gfx_Bullet();
000749  000957  // Notes : Places a coloured circle at the origin
000750  000958  //       : filled or unfilled state is controlled by PenSize
000751  000959        
000752  000960  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000753  000961  // Syntax: gfx_IncX();
000754  000962  // Usage : var := gfx_IncX();
000755  000963  // Notes : Increments the x coordinate of the origin
000756  000964        
000757  000965  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000758  000966  // Syntax: gfx_IncY();
000759  000967  // Usage : var := gfx_IncY();
000760  000968  // Notes : Increments the y coordinate of the origin
000761  000969        
000762  000970  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000763  000971  // Syntax: gfx_BoxTo(x1, y1);
000764  000972  // Usage : gfx_BoxTo(arg1, arg2);
000765  000973  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000766  000974  //       : The new origin is then set to x1,y1. Rectangle colour needs
000767  000975  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000768  000976  //       : and the PenSize setting determines if Box is solid or outline.
000769  000977        
000770  000978  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000771  000979  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000772  000980  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000773  000981  // Notes : Specifies a clipping window region on the screen such that any objects
000774  000982  //       : and text placed onto the screen will be clipped and displayed only
000775  000983  //       : within that region. For the clipping window to take effect, "Clipping"
000776  000984  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000777  000985        
000778  000986        
000779  000987  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000780  000988  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000781  000989  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000782  000990  // *Notes:
000783  000991        
000784  000992  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000785  000993  // Syntax: gfx_SetClipRegion();
000786  000994  // Usage : var := gfx_SetClipRegion();
000787  000995  // *Notes:
000788  000996        
000789  000997  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000790  000998  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000791  000999  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000792  001000  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000793  001001  //       : with xradius = xrad and yradius = yrad.
000794  001002  //       : if PenSize = 0 Ellipse is Solid
000795  001003  //       : if PenSize = 1 Ellipse is Outline
000796  001004        
000797  001005        
000798  001006  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000799  001007  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000800  001008  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000801  001009  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000802  001010  //       : with xradius = xrad and yradius = yrad.
000803  001011        
000804  001012  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000805  001013  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000806  001014  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000807  001015  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000808  001016  //       : x,y arguments (top left corner). The size of the button depends on
000809  001017  //       : the font, width, height and length of the text.
000810  001018  //       : The button appearance will depend on the state parameter setting:
000811  001019  //       :         state = 0 : Button Pressed
000812  001020  //       :         state = 1 : Button Raised
000813  001021        
000814  001022  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000815  001023  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000816  001024  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000817  001025  // Notes : Draws a panel (groupbox) at screen location defined by
000818  001026  //       : x, y, width and height with colour "colour".
000819  001027  //       :         state = 0 : recessed
000820  001028  //       :         state = 1 : raised
000821  001029        
000822  001030  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000823  001031  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000824  001032  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000825  001033  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000826  001034  //       : Slider parameters are as follows:
000827  001035  //       :         mode = 0 : Slider recessed
000828  001036  //       :         mode = 1 : Slider raised
000829  001037  //       :         x1, y1 = top left corner
000830  001038  //       :         x2, y2 = bottom right corner
000831  001039  //       :         scale = n : sets the full scale range from 0 to n
000832  001040  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000833  001041  //       : returns:-
000834  001042        
000835  001043        
000836  001044  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000837  001045  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000838  001046  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000839  001047  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000840  001048  //       : and pastes it to another location determined by xd, yd.
000841  001049        
000842  001050  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000843  001051  // Syntax: gfx_RGBto565(red, green, blue);
000844  001052  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000845  001053  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000846  001054        
000847  001055  func gfx_332to565("COLOUR8BIT"), 1;
000848  001056  // Syntax: gfx_332to565(colour);
000849  001057  // Usage : gfx_332to565(arg);
000850  001058  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000851  001059        
000852  001060  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000853  001061  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000854  001062  // Usage : gfx_Selection(1, RED, YELLOW);
000855  001063  // Notes : Called prior to drawing a button, this function
000856  001064  //       : hilites the required text line on a multiline button.
000857  001065        
000858  001066  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000859  001067  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000860  001068  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000861  001069  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000862  001070  //       : Vertices must be specified in an anti-clockwise fashion
000863  001071        
000864  001072        
000865  001073  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000866  001074  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000867  001075  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
000868  001076  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000869  001077  //       : Vertices must be minimum of 3 and can be specified in any fashion
000870  001078        
000871  001079        
000872  001080  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
000873  001081  // Syntax: gfx_Offset(x, y);
000874  001082  // Usage : gfx_Offset(arg1, arg2);
000875  001083  // Notes : Set the screen offset
000876  001084        
000877  001085        
000878  001086        
000879  001087  func gfx_Get("mode"), 1;
000880  001088  // Syntax: gfx_Get(mode);
000881  001089  // Usage : arg1 := gfx_Get(arg);
000882  001090  // Notes : Returns various parameters to caller
000883  001091  //       :
000884  001092  //       : mode = X_MAX (mode 0) : current orientations maximum X value
000885  001093  //       : var := gfx_Get(X_MAX);
000886  001094  //       : Returns the maximum horizontal value of the display
000887  001095  //       :
000888  001096  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
000889  001097  //       : var := gfx_Get(Y_MAX);
000890  001098  //       : Returns the maximum vertical value of the display
000891  001099  //       :
000892  001100  //       : mode = LEFT_POS (mode 2) : Left location of last Object
000893  001101  //       : var := gfx_Get(LEFT_POS);
000894  001102  //       : Returns the left location of the last drawn object
000895  001103  //       : such as a slider or button or an image/video
000896  001104  //       :
000897  001105  //       : mode = TOP_POS (mode 3) : Top location of Object
000898  001106  //       : var := gfx_Get(TOP_POS);
000899  001107  //       : Returns the top location of the last drawn object
000900  001108  //       : such as a slider or button or an image/video
000901  001109  //       :
000902  001110  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
000903  001111  //       : var := gfx_Get(RIGHT_POS);
000904  001112  //       : Returns the right location of the last drawn object
000905  001113  //       : such as a slider or button or an image/video
000906  001114  //       :
000907  001115  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
000908  001116  //       : var := gfx_Get(BOTTOM_POS );
000909  001117  //       : Returns the bottom location of the last drawn object
000910  001118  //       : such as a slider or button or an image/video
000911  001119  //       :
000912  001120        
000913  001121        
000914  001122  //==================================================//
000915  001123  // Single parameter short-cuts                      //
000916  001124  // for the gfx_Set functions                        //
000917  001125  // These functions return the existing value before //
000918  001126  // the change is made.                              //
000919  001127  //==================================================//
000920  001128  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
000921  001129  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
000922  001130  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
000923  001131  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
000924  001132  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
000925  001133  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
000926  001134  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
000927  001135  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
000928  001136  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
000929  001137  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
000930  001138  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
000931  001139  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
000932  001140  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
000933  001141  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
000934  001142  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
000935  001143  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
000936  001144        
000937  001145        
000938  001146  //==================================================//
000939  001147  // uSD/FLASH Function Prototypes                    //
000940  001148  //==================================================//
000941  001149  func media_Video("x", "y"), 0;                      // display movie at position x y
000942  001150  // Syntax: media_Video(x, y);
000943  001151  // Usage : media_Video(arg1, arg2);
000944  001152  // Notes : Play a Video/Animation clip from the uSD card at screen location
000945  001153  //       : specified by x,y (top left corner). The location of the clip in the
000946  001154  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
000947  001155        
000948  001156  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
000949  001157  // Syntax: media_VideoFrame(Frame_number);
000950  001158  // Usage : arg1 := media_VideoFrame();
000951  001159  // Notes : After a pointer to a valid video has been set with media_SetSector,
000952  001160  //       : calling this function shows each fram sequentially, returning
000953  001161  //       : the number of frames remaining. The position of the image is
000954  001162  //     : at the current origin as set with gfx_MoveTo(...);
000955  001163        
000956  001164  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
000957  001165  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
000958  001166  // Usage : media_SetAdd(arg1, arg2);
000959  001167  // Notes : Set uSD internal Address pointer for bytewise access
000960  001168        
000961  001169  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
000962  001170  // Syntax: media_SetSector(SectHiWord, SectLoWord);
000963  001171  // Usage : media_SetSector(arg1, arg2);
000964  001172  // Notes : Set uSD internal Sector pointer for sector block access
000965  001173        
000966  001174  func media_RdSector("*destination"), 1;
000967  001175  // Syntax: media_RdSector(*destination);
000968  001176  // Usage : media_RdSector(rdblock);
000969  001177  // Notes : Reads and Returns 512 bytes (256 words) into a destination
000970  001178  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
000971  001179  //       : After the read the Sector pointer is automatically incremented by 1.
000972  001180  //       : Returns TRUE if uSD response was TRUE
000973  001181        
000974  001182  func media_WrSector("*source"), 1;
000975  001183  // Syntax: media_WrSector(*source);
000976  001184  // Usage : media_WrSector(wrblock);
000977  001185  // Notes : Writes 512 bytes (256 words) from a source memory block
000978  001186  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
000979  001187  //       : pointer is automatically incremented by 1.
000980  001188  //       : Returns TRUE if uSD response was TRUE
000981  001189        
000982  001190  func media_ReadByte(), 1;                // read a byte at the current stream position
000983  001191  // Syntax: media_RdByte();
000984  001192  // Usage : var := media_RdByte();
000985  001193  // Notes : Reads and Returns a single byte of data from the
000986  001194  //       : uSD card pointed to by the internal Address pointer.
000987  001195  //       : After the read the Address pointer is automatically
000988  001196  //       : incremented by 1.
000989  001197        
000990  001198  func media_ReadWord(), 1;                // read a word at the current stream position
000991  001199  // Syntax: media_ReadWord();
000992  001200  // Usage : var := media_ReadWord();
000993  001201  // *Notes : Reads and Returns a single word of data from the
000994  001202  //       : uSD card pointed to by the internal Address pointer.
000995  001203  //       : After the read the Address pointer is automatically
000996  001204  //       : incremented by 2.
000997  001205        
000998  001206  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
000999  001207  // Syntax: media_WriteByte(arg1);
001000  001208  // Usage : var := media_WriteByte(arg1);
001001  001209  // *Notes : Writes and Returns xxxxx
001002  001210  //       : After the write the Address pointer is automatically
001003  001211  //       : incremented by 1.
001004  001212        
001005  001213  func media_WriteWord("word"), 1;            // write a word to the current stream position
001006  001214  // Syntax: media_WriteWord(arg1);
001007  001215  // Usage : var := media_WriteWord(arg1);
001008  001216  // *Notes : Writes and Returns xxxxx
001009  001217  //       : After the write the Address pointer is automatically
001010  001218  //       : incremented by 2.
001011  001219        
001012  001220  func media_Image("x", "y"), 0;            // display image at position x y
001013  001221  // Syntax: media_Image(x, y);
001014  001222  // Usage : media_Image(arg1, arg2);
001015  001223  // Notes : Display an image from the uSD card at screen location
001016  001224  //       : specified by x,y (top left corner). The location of the
001017  001225  //       : Image in the uSD card must be specified by
001018  001226  //       : media_setSector(Image_Sector_Add) function.
001019  001227        
001020  001228  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001021  001229  // Syntax: media_Flush();
001022  001230  // Usage : var := media_Flush();
001023  001231  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001024  001232  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001025  001233        
001026  001234  func media_Init(), 1;                    // initialize uSD card
001027  001235  // Usage	: media_Init();
001028  001236  // Notes	: Initialise uSD CARD
001029  001237  // 	: Response: 0 = No Card
001030  001238  // 	:           1 = Card Initialised
001031  001239  // 	: Do not use this for systems with SPI Flash, use media_InitFlash() instead
001032  001240  // 	: init the Media.
001033  001241        
001034  001242        
001035  001243  //==============================================//
001036  001244  // Communications Function Prototypes           //
001037  001245  //==============================================//
001038  001246  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001039  001247  // Syntax: com_Init(buffer, bufsize, qualifier);
001040  001248  // Usage1: com_Init(mybuf, 20, 0);
001041  001249  // Usage2: com_Init(mybuf, 20, ':');
001042  001250  // Notes : initialize a serial capture buffer for the comms input
001043  001251  //       : The program must declare a var array as a circular buffer.
001044  001252  //       : Usage1 declares a circular buffer which will continually
001045  001253  //       : buffer characters.
001046  001254  //       : Usage2 must receive ':' before any characters will
001047  001255  //       : accumulate in the buffer.
001048  001256        
001049  001257  func com_Reset(), 0;                 // reset the comms receiver
001050  001258  // Syntax: com_Reset();
001051  001259  // Usage : com_Reset();
001052  001260  // Notes : reset comms to default polled mode
001053  001261        
001054  001262  func com_Count(), 1;                // return count of characters in receive buffer
001055  001263  // Syntax: com_Count();
001056  001264  // Usage : arg := com_Count();
001057  001265  // Notes : return count of buffered characters in buffer attachment
001058  001266        
001059  001267  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001060  001268  // Syntax: com_Full();
001061  001269  // Usage : if (com_Full() ,,,, go read buffer;
001062  001270  // Notes : return true if buffer full (not necessarily an error if
001063  001271  //       : buffer is sized to a packet size)
001064  001272        
001065  001273  func com_Error(), 1;                // return comms errors comms error occurred
001066  001274  // Syntax: com_Error();
001067  001275  // Usage : if (com_Error() ) ...... take recovery action;
001068  001276  // Notes : return non zero if any errors low level comms errors occured
001069  001277  // returns :
001070  001278  // bit0 = Receiver Overflow Error
001071  001279  // bit1 = Receiver Framing Error
001072  001280  // bit2 = Transmit Buffer Overflow
001073  001281        
001074  001282  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001075  001283  // Syntax: com_Sync();
001076  001284  // Usage : com_Sync();
001077  001285  // return true if sync character has been received in com_Init("...") mode
001078  001286        
001079  001287        
001080  001288  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001081  001289  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001082  001290  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001083  001291  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001084  001292  // Notes : initialize a serial buffer for the COM0 output.
001085  001293  //       : The program must declare a var array as a circular buffer.
001086  001294  //       : When a TX buffer is declared for comms, the transmission
001087  001295  //       : of characters becomes non blocking. The only time
001088  001296  //       : blocking will occur is if the buffer has insufficient space
001089  001297  //       : to accept the next character, in which case the function
001090  001298  //       : will wait for buffer space to become available. If the
001091  001299  //       : TX buffer is no longer required, just set the buffer pointer
001092  001300  //       : to zero, the size in this case doesnt matter and is ignored.
001093  001301  //       : The function can resize or reallocated to another buffer at
001094  001302  //       : any time. The buffer is flushed before any changes are made.
001095  001303  //       : "pin" designates an IO pin to control a bi-directional 
001096  001304  //       : control device for half duplex mode. "pin" will go HI at the
001097  001305  //       : start of a transmission, and will return low after the final
001098  001306  //       : byte is transmitted. If not required, just set "pin" to zero.
001099  001307        
001100  001308        
001101  001309  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001102  001310  // Syntax: com_TXcount();
001103  001311  // Usage : arg := com_Count();
001104  001312  // Notes : return count of characters remaining in COM0 transmit buffer
001105  001313  //       : that was previously allocated with com_TXbuffer(...);
001106  001314        
001107  001315        
001108  001316  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001109  001317  // Syntax: com_TXemptyEvent(function);
001110  001318  // Usage : arg := com_TXemptyEvent();
001111  001319  // Notes : If a comms TX buffer that was previously allocated with
001112  001320  //       : com_TXbuffer(...);, this function can be used to set up
001113  001321  //       : a function to be called when the COM0 TX buffer is empty.
001114  001322  //       : This is useful for either reloading the TX buffer, setting
001115  001323  //       : or clearing a pin to change the direction of eg a RS485
001116  001324  //       : line driver, or any other form of traffic control.
001117  001325  //       : The event function must not have any parameters.
001118  001326  //       : To disable the event, simply call com_TXemptyEvent(0).
001119  001327  //       : com_TXbuffer(...); also resets any active event.
001120  001328  //       : com_TXemptyEvent returns any previous event function
001121  001329  //       : address, or zero if there was no previous function.
001122  001330        
001123  001331        
001124  001332  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001125  001333  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001126  001334  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001127  001335  // Notes : Expecting that a comms TX buffer that was previously allocated with
001128  001336  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001129  001337  //       : the buffer being sent wile it is being loaded. Mormally, when
001130  001338  //       : using buffered comms, the transmit process will begin
001131  001339  //       : immediately. This is often undesirable for 2 reasons,
001132  001340  //       : 1] you may wish to build a packet then send it later
001133  001341  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001134  001342  //       : as the FIFO buffer is constantly trying to empty while
001135  001343  //       : you are busy tring to fill it.
001136  001344  // return -1 if function is called illegally when TX comms is not buffered.
001137  001345  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001138  001346  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001139  001347        
001140  001348        
001141  001349  //=============================================================//
001142  001350  // Auxilliary Communications Function Prototypes
001143  001351  //=============================================================//
001144  001352  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001145  001353  // Syntax: com_Init(buffer, bufsize, qualifier);
001146  001354  // Usage1: com_Init(mybuf, 20, 0);
001147  001355  // Usage2: com_Init(mybuf, 20, ':');
001148  001356  // Notes : initialize a serial capture buffer for the comms input
001149  001357  //       : The program must declare a var array as a circular buffer.
001150  001358  //       : Usage1 declares a circular buffer which will continually
001151  001359  //       : buffer characters.
001152  001360  //       : Usage2 must receive ':' before any characters will
001153  001361  //       : accumulate in the buffer.
001154  001362        
001155  001363  func com1_Reset(), 0;
001156  001364  // Syntax: com_Reset();
001157  001365  // Usage : com_Reset();
001158  001366  // Notes : reset comms receiver to default polled mode
001159  001367        
001160  001368  func com1_Count(), 1;
001161  001369  // Syntax: com_Count();
001162  001370  // Usage : arg := com_Count();
001163  001371  // Notes : return count of characters in receive buffer
001164  001372        
001165  001373  func com1_Full(), 1;
001166  001374  // Syntax: com_Full();
001167  001375  // Usage : if (com_Full() ,,,, go read buffer;
001168  001376  // Notes : return true if receive buffer full
001169  001377        
001170  001378  func com1_Error(), 1;
001171  001379  // Syntax: com_Error();
001172  001380  // Usage : if (com_Error() ) ...... take recovery action;
001173  001381  // Notes : return non zero if any level comms errors occured
001174  001382  // returns :
001175  001383  // bit0 = Receiver Overflow Error
001176  001384  // bit1 = Receiver Framing Error
001177  001385  // bit2 = Transmit Buffer Overflow
001178  001386        
001179  001387  func com1_Sync(), 1;
001180  001388  // Syntax: com_Sync();
001181  001389  // Usage : com_Sync();
001182  001390  // Notes : return true if sync character has been received in com_Init("...") mode
001183  001391        
001184  001392        
001185  001393  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001186  001394  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001187  001395  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001188  001396  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001189  001397  // Notes : initialize a serial buffer for the COM1 output.
001190  001398  //       : The program must declare a var array as a circular buffer.
001191  001399  //       : When a TX buffer is declared for comms, the transmission
001192  001400  //       : of characters becomes non blocking. The only time
001193  001401  //       : blocking will occur is if the buffer has insufficient space
001194  001402  //       : to accept the next character, in which case the function
001195  001403  //       : will wait for buffer space to become available. If the
001196  001404  //       : TX buffer is no longer required, just set the buffer pointer
001197  001405  //       : to zero, the size in this case doesnt matter and is ignored.
001198  001406  //       : The function can resize or reallocated to another buffer at
001199  001407  //       : any time. The buffer is flushed before any changes are made.
001200  001408  //       : "pin" designates an IO pin to control a bi-directional 
001201  001409  //       : control device for half duplex mode. "pin" will go HI at the
001202  001410  //       : start of a transmission, and will return low after the final
001203  001411  //       : byte is transmitted. If not required, just set "pin" to zero.
001204  001412        
001205  001413        
001206  001414  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001207  001415  // Syntax: com1_TXcount();
001208  001416  // Usage : arg := com1_Count();
001209  001417  // Notes : return count of characters remaining in COM1 transmit buffer
001210  001418  //       : that was previously allocated with com1_TXbuffer(...);
001211  001419        
001212  001420        
001213  001421  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001214  001422  // Syntax: com1_TXemptyEvent(function);
001215  001423  // Usage : arg := com1_TXemptyEvent();
001216  001424  // Notes : If a comms TX buffer that was previously allocated with
001217  001425  //       : com1_TXbuffer(...);, this function can be used to set up
001218  001426  //       : a function to be called when the COM1 TX buffer is empty.
001219  001427  //       : This is useful for either reloading the TX buffer, setting
001220  001428  //       : or clearing a pin to change the direction of eg a RS485
001221  001429  //       : line driver, or any other form of traffic control.
001222  001430  //       : The event function must not have any parameters.
001223  001431  //       : To disable the event, simply call com1_TXemptyEvent(0).
001224  001432  //       : com1_TXbuffer(...); also resets any active event.
001225  001433  //       : com1_TXemptyEvent returns any previous event function
001226  001434  //       : address, or zero if there was no previous function.
001227  001435        
001228  001436        
001229  001437  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001230  001438  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001231  001439  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001232  001440  // Notes : Expecting that a comms TX buffer that was previously allocated with
001233  001441  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001234  001442  //       : the buffer being sent wile it is being loaded. Mormally, when
001235  001443  //       : using buffered comms, the transmit process will begin
001236  001444  //       : immediately. This is often undesirable for 2 reasons,
001237  001445  //       : 1] you may wish to build a packet then send it later
001238  001446  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001239  001447  //       : as the FIFO buffer is constantly trying to empty while
001240  001448  //       : you are busy tring to fill it.
001241  001449  // return -1 if function is called illegally when TX comms is not buffered.
001242  001450  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001243  001451  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001244  001452        
001245  001453  func serin1(), 1;
001246  001454  // Syntax: serin1();
001247  001455  // Usage : char := serin1();
001248  001456  // Notes : return the next available character from COM1
001249  001457        
001250  001458  func serout1("char"), 0;
001251  001459  // Syntax: serout1("char");
001252  001460  // Usage : serout1(ch);
001253  001461  // Notes : send character to COM1
001254  001462        
001255  001463  func com_SetBaud("comport","baudrate/10"), 1;
001256  001464  // Syntax: com_SetBaud("comport","baudrate/10");
001257  001465  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001258  001466  // Notes : sets to any viable baud rate from 160 to 655350
001259  001467  // return true if baud rate was acceptable
001260  001468        
001261  001469        
001262  001470        
001263  001471  //==============================================//
001264  001472  // Display Access                               //
001265  001473  //==============================================//
001266  001474  func disp_Init(), 0;                            // initialize display with required tables
001267  001475  // Syntax: disp_Init();
001268  001476  // Usage : disp_Init();
001269  001477  // Notes : Initialises or reinitialises the display.
001270  001478  //       : Normally used after restoration of peripheral power
001271  001479  //       : and after DeepSleep.
001272  001480        
001273  001481  func disp_SetReg("register", "data"), 0;
001274  001482  // Syntax: display_SetReg(register, data);
001275  001483  // Usage : display_SetReg(arg1, arg2);
001276  001484  // Notes : Sets uLCD specific display driver registers. Refer
001277  001485  //       : to appropriate display driver data sheet.
001278  001486        
001279  001487  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001280  001488  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001281  001489  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001282  001490  // Notes : Prepares the GRAM area for user access.
001283  001491  //       : Data can now be written with disp_GRAM.
001284  001492  //       : GRAM will be set accordingly for the correct screen mode.
001285  001493  //       : the LO word of the 32 bit pixel count is returned. This is
001286  001494  //       : usually all that is needed unlse GRAM area exceeds 256^2
001287  001495  //       : A copy of the 32bit value can be found in
001288  001496  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001289  001497        
001290  001498  func disp_WrGRAM("colour"), 0;
001291  001499  // Syntax: display_WrGRAM(colour);
001292  001500  // Usage : display_WrGRAM(arg);
001293  001501  // Notes : Data can be written to the GRAM consecutively using
001294  001502  //       : this function once the GRAM access window has been setup.
001295  001503        
001296  001504  func disp_WriteControl("value"), 0;             // write a control byte to the display
001297  001505  func disp_WriteWord("value"), 0;                // write a word to the display
001298  001506        
001299  001507        
001300  001508  func disp_ReadWord("Command", "dummy"), 1;                        // read a word from the display
001301  001509  // Syntax	: disp_ReadWord(command, 1);
001302  001510  // Usage	: x:=disp_ReadWord(command, 1);
001303  001511  // Notes	: Read a word from the controller
001304  001512  // Eg: 	: print(disp_ReadWord(0), 0);        // select Ilitek ID register, read using 0 dummy reads, print ID
001305  001513  // 	: (Many displays are write only)
001306  001514  // 	: Some SPI displays required the command be given as part of the read sequence.
001307  001515  // 	: For displays that do not require this the value will be ignored.
001308  001516        
001309  001517                                                  //
001310  001518  //==============================================//
001311  001519  // unadorned SPI functions                      //
001312  001520  //==============================================//
001313  001521  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001314  001522  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001315  001523  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001316  001524  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001317  001525                                                  //
001318  001526  //==============================================//
001319  001527  // flash device specific functions              //
001320  001528  //==============================================//
001321  001529  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001322  001530  // Syntax: flash_SIG();
001323  001531  // Usage : flash_SIG();
001324  001532  // Notes	: Returns the Flash Signature returned from the 'FLASH WAKEUP RETURN SIG'
001325  001533  // 	: (0xAB) command.
001326  001534        
001327  001535  func flash_ID(), 1;                             // read ID code from FLASH device
001328  001536  // Syntax: flash_ID();
001329  001537  // Usage : flash_ID();
001330  001538  // Notes	: Returns the second(memory type) and third(memory capacity) bytes returned from the 
001331  001539  // 	: 'FLASH READ ID REG' (0x9F) command.
001332  001540        
001333  001541  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001334  001542        
001335  001543  func flash_Block64Erase(), 1;            // erase the required 64k flash block
001336  001544  // Syntax: flash_Block64Erase();
001337  001545  // Usage : flash_Block64Erase();
001338  001546  // Notes	: Erase the 64KB flash block including the currently set address
001339  001547  // 	: This uses the 0xD8 command.
001340  001548                                                  //
001341  001549                                                  //
001342  001550  //==============================================//
001343  001551  // string and character size function           //
001344  001552  //==============================================//
001345  001553  func charwidth("char"), 1;                      // return width of a character in pixel units
001346  001554  func charheight("char"), 1;                     // return height of a character in pixel units
001347  001555  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001348  001556  func strheight(), 1;                            // return height of a string in pixel units
001349  001557        
001350  001558        
001351  001559  //------------------------------------------------------------------//
001352  001560  //        I2C Function Prototypes
001353  001561  //------------------------------------------------------------------//
001354  001562  func I2C1_Open("speed"), 0;
001355  001563  // Syntax: I2C1_Open(speed),
001356  001564  // Usage : I2C1_Open(I2C_MED);
001357  001565  // Notes : configures the I2C1 module
001358  001566  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001359  001567        
001360  001568  func I2C1_Close(), 0;
001361  001569  // Syntax: I2C1_Close();
001362  001570  // Usage : I2C1_Close();
001363  001571  // Notes : disables the I2C1 module.
001364  001572        
001365  001573  func I2C1_Start(), 1;
001366  001574  // Syntax: I2C1_Start();
001367  001575  // Usage : I2C1_Start();
001368  001576  // Notes : generates a Start condition.
001369  001577  //       : returns true if successful (usually ignored)
001370  001578        
001371  001579  func I2C1_Stop(), 1;
001372  001580  // Syntax: I2C1_Stop();
001373  001581  // Usage : I2C1_Stop();
001374  001582  // Notes : generates a Stop condition.
001375  001583  //       : returns true if successful (usually ignored)
001376  001584        
001377  001585  func I2C1_Restart(), 1;
001378  001586  // Syntax: I2C1_Restart();
001379  001587  // Usage : I2C1_Restart();
001380  001588  // Notes : generates a Restart condition.
001381  001589  //       : returns true if successful (usually ignored)
001382  001590        
001383  001591  func I2C1_Read(), 1;
001384  001592  // Syntax: I2C1_Read();
001385  001593  // Usage : ch := I2C1_Read();
001386  001594  // Notes : reads a single byte from the I2C Bus.
001387  001595        
001388  001596  func I2C1_Write("byte"), 1;
001389  001597  // Syntax: I2C1_Write(byte);
001390  001598  // Usage : r := I2C1_Write(ch);
001391  001599  // Notes : is used to write a byte to the I2C bus.
001392  001600  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001393  001601        
001394  001602  func I2C1_Ack(), 0;
001395  001603  // Syntax: I2C1_Ack();
001396  001604  // Usage : I2C1_Ack();
001397  001605  // Notes : generates the acknowledge condition.
001398  001606        
001399  001607  func I2C1_Nack(), 0;
001400  001608  // Syntax: I2C1_Nack();
001401  001609  // Usage : I2C1_Nack();
001402  001610  // Notes : generates the negative acknowledge condition.
001403  001611        
001404  001612  func I2C1_AckStatus(), 0;
001405  001613  // Syntax: I2C1_AckStatus();
001406  001614  // Usage : r := I2C1_AckStatus();
001407  001615  // Notes : returns the ACK status from the device.
001408  001616        
001409  001617  func I2C1_AckPoll("control"), 1;
001410  001618  // Syntax: I2C1_AckPoll();
001411  001619  // Usage : r := I2C1_AckPoll(0xA0);
001412  001620  // Notes : waits for a device to return from ACK polling.
001413  001621        
001414  001622  func I2C1_Idle(), 0;
001415  001623  // Syntax: I2C1_Idle();
001416  001624  // Usage : I2C1_Idle();
001417  001625  // Notes : waits until the I2C Bus is Inactive.
001418  001626        
001419  001627  func I2C1_Gets("buffer", "size"), 1;
001420  001628  // Syntax: I2C1_Gets("buffer", "size");
001421  001629  // Usage : r := I2C1_Gets(mybuf, 16);
001422  001630  // Notes : only reads up to "size" characters into "buffer"
001423  001631  //       : Reads up to asciiz terminator including terminator
001424  001632        
001425  001633  func I2C1_Getn("buffer", "size"), 1;
001426  001634  // Syntax: I2C1_Gets("buffer", "size");
001427  001635  // Usage : r := I2C1_Gets(mybuf, 16);
001428  001636  // Notes : reads "size" bytes into "buffer"
001429  001637  //       :
001430  001638        
001431  001639  func I2C1_Puts("buffer"), 1;
001432  001640  // Syntax: I2C1_Puts("buffer");
001433  001641  // Usage : r := I2C1_Puts(mybuf);
001434  001642  // Notes : writes an asciiz string to the I2C device
001435  001643  //       : returns count of characters written
001436  001644        
001437  001645  func I2C1_Putn("buffer", "count"), 1;
001438  001646  // Syntax: I2C1_Putn("buffer","count");
001439  001647  // Usage : r := I2C1_Puts(mybuf,10);
001440  001648  // Notes : writes up to "size" bytes to the I2C device
001441  001649  //       : returns number of bytes written
001442  001650        
001443  001651        
001444  001652  //------------------------------------------------------------------//
001445  001653  //        Image Control Function Prototypes
001446  001654  //------------------------------------------------------------------//
001447  001655  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001448  001656  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001449  001657  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001450  001658  // Notes : set the position where the image will be displayed
001451  001659  //       : returns true if index was ok and function was successful.
001452  001660  //       : you may turn off an image so when img_Refresh is called,
001453  001661  //       : the image will not be shown
001454  001662        
001455  001663  func img_Enable("handle", "index"), 1;
001456  001664  // Syntax: img_Enable(handle, index);
001457  001665  // Usage : r := img_Enable(hImageList, imagenum);
001458  001666  // Notes : enable image in a image list
001459  001667  //       : returns true if index was ok and function was successful.
001460  001668  //       : this is the default state so when img_Refresh is called,
001461  001669  //       : all the images in the list will be shown
001462  001670  //       : if index is set to -1, all of the images are enabled
001463  001671        
001464  001672  func img_Disable("handle", "index"), 1;
001465  001673  // Syntax: img_Disable(handle, index);
001466  001674  // Usage : r := img_Disable(hImageList, imagenum);
001467  001675  // Notes : disable image in a image list
001468  001676  //       : returns true if index was ok and function was successful.
001469  001677  //       : you must turn off an image so when img_Refresh is called,
001470  001678  //       : the image will not be shown.
001471  001679  //       : if index is set to -1, all of the images are disabled
001472  001680        
001473  001681        
001474  001682  func img_Darken("handle", "index"), 1;
001475  001683  // Syntax: img_Darken(handle, index);
001476  001684  // Usage : r := img_Darken(hImageList, imagenum);
001477  001685  // Notes : darken image in a image list
001478  001686  //       : returns true if index was ok and function was successful.
001479  001687  //       : if index is set to -1, all of the images are darkened
001480  001688  //       : NB:- this feature will only work for the next refresh, then
001481  001689  //       : the image reverts back to normal when displayed again.
001482  001690        
001483  001691        
001484  001692  func img_Lighten("handle", "index"), 1;
001485  001693  // Syntax: img_Lighten(handle, index);
001486  001694  // Usage : r := img_Lighten(hImageList, imagenum);
001487  001695  // Notes : lighten image in a image list
001488  001696  //       : returns true if index was ok and function was successful.
001489  001697  //       : if index is set to -1, all of the images are lightened
001490  001698  //       : NB:- this feature will only work for the next refresh, then
001491  001699  //       : the image reverts back to normal when displayed again.
001492  001700        
001493  001701  func img_SetWord("handle", "index", "offset", "word"), 1;
001494  001702  // Syntax: img_SetWord(handle, index, offset, word);
001495  001703  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001496  001704  // Notes : set specified word (0-7) in a image entry
001497  001705  //       : returns TRUE if successful, return value usually ignored.
001498  001706        
001499  001707  func img_GetWord("handle", "index", "offset"), 1;
001500  001708  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001501  001709  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001502  001710  // Notes : returns specified word (0-14) from an image entry
001503  001711  //       : refer to image control entry offsets.
001504  001712        
001505  001713  func img_Show("handle", "index"), 1;
001506  001714  // Syntax: img_Show(handle, index);
001507  001715  // Usage : display image entry (regardless of enable/disable)
001508  001716  //       : returns TRUE if successful, return value usually ignored.
001509  001717        
001510  001718  func img_SetAttributes("handle", "index","value"), 1;
001511  001719  // Syntax: img_SetAttributes("handle", "index","offset");
001512  001720  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001513  001721  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001514  001722  //       : of an image control entry. "value" refers to various bits in
001515  001723  //       : the image control entry (see image attribute flags).
001516  001724  //       : A '1' bit in the "value" field SETS the respective bit
001517  001725  //       : in the IMAGE_FLAGS field of the image control entry.
001518  001726  //       : returns TRUE if successful, return value usually ignored.
001519  001727        
001520  001728  func img_ClearAttributes("handle", "index","value"), 1;
001521  001729  // Syntax: img_ClearAttributes("handle", "index","offset");
001522  001730  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001523  001731  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001524  001732  //       : of an image control entry. "value" refers to various bits in
001525  001733  //       : the image control entry (see image attribute flags)
001526  001734  //       : a '1' bit in the "value" field CLEARS the respective bit
001527  001735  //       : in the IMAGE_FLAGS field of the image control entry.
001528  001736  //       : returns TRUE if successful, return value usually ignored.
001529  001737        
001530  001738  func img_Touched("handle", "index"), 1;
001531  001739  // Syntax: r := img_Touched(handle, index);
001532  001740  // Usage : img_Touched(hndl, 17);
001533  001741  //       : returns -1 if image not touched, or returns index
001534  001742  // Notes : if index is passed as -1, function tests all images,
001535  001743  //       : and returns -1 if image not touched, or returns index.
001536  001744        
001537  001745        
001538  001746        
001539  001747        
001540  001748  //------------------------------------------------------------------//
001541  001749  //        Timer Function Prototypes
001542  001750  //------------------------------------------------------------------//
001543  001751  func sys_T(), 1;
001544  001752  // Syntax: sys_T();
001545  001753  // Usage : t := sys_T();
001546  001754  // Notes : return the current value of the rolling system timer (1msec) LO word
001547  001755        
001548  001756  func sys_T_HI(), 1;
001549  001757  // Syntax: sys_T_HI();
001550  001758  // Usage : t := sys_T_HI();
001551  001759  // Notes : return the current value of the rolling system timer (1msec) HI word
001552  001760        
001553  001761  func sys_SetTimer("timernum","value"), 0;
001554  001762  // Syntax: sys_SetTimer("timernum", "value");
001555  001763  // Usage : sys_SetTimer(TIMER5, 10000);
001556  001764  // Notes : set a countdown on the selected timer, or 'top up' if required.
001557  001765  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001558  001766  //       : Maximum timeout period is 65.535 seconds
001559  001767  //       : A timer can be read with the sys_GetTimer("timernum") function
001560  001768        
001561  001769  func sys_GetTimer("timernum"), 1;
001562  001770  // Syntax: t := sys_GetTimer("timernum");
001563  001771  // Usage : t := sys_GetTimer(TIMER3);
001564  001772  // Notes : returns 0 if timer has expired, or the current countdown value.
001565  001773  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001566  001774  //       : Maximum timeout period is 65.535 seconds
001567  001775  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001568  001776        
001569  001777  func sys_SetTimerEvent("timernum","function"), 1;
001570  001778  // Syntax: sys_SetTimerFunction("timernum", "function");
001571  001779  // Usage : sys_SetTimer(TIMER5, myfunc);
001572  001780  // Notes : set a function to be called for selected timer.
001573  001781  //       : When the timer reaches zero, the function is called.
001574  001782  //       : The called function must not have any parameters
001575  001783  //       : sys_SetTimerEvent returns any previous event function
001576  001784  //       : address, or zero if there was no previous function.
001577  001785        
001578  001786  func sys_EventQueue(), 1;
001579  001787  // Syntax: sys_EventQueue();
001580  001788  // Usage : tasks := sys_EventQueue();
001581  001789  // Notes : returns the max number of events that were pending
001582  001790  //       : in the timer queue since the last call to this function.
001583  001791  //       : This can be used to assess timer event overhead burden,
001584  001792  //       : especially after or during a sys_EventsPostpone action.
001585  001793        
001586  001794  func sys_EventsPostpone(), 0;
001587  001795  // Syntax: sys_EventPostpone();
001588  001796  // Usage : sys_EventPostpone();   // postpone the event queue
001589  001797  // Notes : postpone any events until the sys_EventResume function is executed
001590  001798  //       : The timer event queue will continue to queue events, but no action
001591  001799  //       : will take place untill a sys_EventResume function is encountered.
001592  001800  //       : The queue will continue to receive up to 32 events before discarding
001593  001801  //       : any further events. This function is required to allow a sequence of
001594  001802  //       : instructions or functions to occur that would otherwise be corrupted
001595  001803  //       : by an event occuring during the sequence of instructions or functions.
001596  001804  //       : A good example of this is when you set a position to print, if there
001597  001805  //       : was no way of locking the current sequence, an event may occur which
001598  001806  //       : does a similar thing, and a contention would occur - printing to
001599  001807  //       : the wrong position. This function should be used wisely, if any action
001600  001808  //       : that is required would take considerable time, it is better to disable
001601  001809  //       : any conflicting event functions with a bypass flag, then restart the
001602  001810  //       : conflicting event by re-issuing a timer value.
001603  001811        
001604  001812  func sys_EventsResume(), 0;
001605  001813  // Syntax: sys_EventsResume();
001606  001814  // Usage : sys_EventsResume();   // resume the event queue
001607  001815  // Notes : resume any postponed events. The queue will try to execute any timer
001608  001816  //       : events that were incurred during the postponed period.
001609  001817        
001610  001818        
001611  001819  func sys_Sleep("units"), 1;
001612  001820  // Syntax: t := sys_Sleep("units");
001613  001821  // Usage : t := sys_Sleep(10);
001614  001822  // Notes : sets the display into low power mode for a period of time.
001615  001823  //       : Touching the touch screen will also wake from sleep.
001616  001824  //       : Returns remaining sleep units.
001617  001825        
001618  001826  func iterator("offset"), 0;
001619  001827  // Syntax: t :=  iterator("offset");
001620  001828  // Usage : t :=  iterator(10);
001621  001829  // Notes : set the iterator size for ++/--
001622  001830  //       : The next postinc,postdec,preinc of predec will alter
001623  001831  //       : by the specified value.
001624  001832  //       : The offset will return to 1 after the next operation.
001625  001833        
001626  001834        
001627  001835        
001628  001836        
001629  001837  //------------------------------------------------------------------//
001630  001838  //         Touch Screen Function Prototypes
001631  001839  //------------------------------------------------------------------//
001632  001840        
001633  001841  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001634  001842  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001635  001843  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001636  001844  // Notes : Specifies a new touch detect region on the screen
001637  001845  //       : such that only touch activity in that region will
001638  001846  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001639  001847        
001640  001848  func touch_Set("mode"), 0;
001641  001849  // Syntax: touch_Set(mode);
001642  001850  // Usage : touch_Set(arg);
001643  001851  // Notes : Sets various Touch Screen related parameters
001644  001852  //       :
001645  001853  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001646  001854  //       : touch_Set(TOUCH_ENABLE);
001647  001855  //       : Enables and initialises Touch Screen hardware
001648  001856  //       :
001649  001857  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001650  001858  //       : touch_Set(TOUCH_DISABLE );
001651  001859  //       : Disables the Touch Screen
001652  001860  //       : Note: Touch Screen runs in the background and disabling
001653  001861  //       : it when not in use will free up extra resources
001654  001862  //       : such as 4DVM CPU cycles.
001655  001863  //       :
001656  001864  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001657  001865  //       : touch_Set(TOUCH_REGIONDEFAULT);
001658  001866  //       : This will reset the current active region to default
001659  001867  //       : to the full screen without the application having to
001660  001868  //       : set a new active region for the full screen.
001661  001869  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001662  001870  //       : that requre to be interfaced with an external pointing
001663  001871  //       : device, values that are poked into TOUCH_DRIVE will be
001664  001872  //       : read with the touch_Get() function)
001665  001873        
001666  001874        
001667  001875  func touch_Get("mode"), 1;
001668  001876  // Syntax: touch_Get(mode);
001669  001877  // Usage : arg1 := touch_Get(arg);
001670  001878  // Notes : Returns various Touch Screen parameters to caller
001671  001879  //       :
001672  001880  //       : mode = TOUCH_STATUS  (mode 0)
001673  001881  //       : var := touch_Get(TOUCH_STATUS);
001674  001882  //       : Returns the various states of the touch screen
001675  001883  //       : 0 = NOTOUCH
001676  001884  //       : 1 = TOUCH_PRESSED
001677  001885  //       : 2 = TOUCH_RELEASED
001678  001886  //       : 3 = TOUCH_MOVING
001679  001887  //       :
001680  001888  //       : mode = TOUCH_GETX   (mode 1)
001681  001889  //       : var := touch_Get(TOUCH_GETX);
001682  001890  //       : Returns the X coordinates of the touch
001683  001891  //       :
001684  001892  //       : mode = TOUCH_GETY   (mode 2)
001685  001893  //       : var := touch_Get(TOUCH_GETY);
001686  001894  //       : Returns the Y coordinates of the touch
001687  001895        
001688  001896  //------------------------------------------------------------------//
001689  001897  //        CTYPE Function Prototypes
001690  001898  //------------------------------------------------------------------//
001691  001899        
001692  001900  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001693  001901  // Syntax: isdigit("char");
001694  001902  // Usage : Var := isdigit(ch);
001695  001903  // Notes : char specifies the ascii character for the test
001696  001904  //     : 0 : char is not an ascii digit.
001697  001905  //     : 1 : char is an ascii digit..
001698  001906  //     : Valid range is "0123456789"
001699  001907        
001700  001908  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001701  001909  // Syntax: isxdigit("char");
001702  001910  // Usage : Var := isxdigit(ch);
001703  001911  // Notes : char specifies the ascii character for the test
001704  001912  //     : 0 : char is not an ascii hexadecimal digit.
001705  001913  //     : 1 : char is an ascii hexadecimal digit..
001706  001914  //     : Valid range is "0123456789ABCDEF"
001707  001915        
001708  001916  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001709  001917  // Syntax: isupper("char");
001710  001918  // Usage : Var := isupper(ch);
001711  001919  // Notes : char specifies the ascii character for the test
001712  001920  //     : 0 : char is not an ascii upper-case letter.
001713  001921  //     : 1 : char is an ascii upper-case letter.
001714  001922  //     : Valid range is "ABCD....WXYZ"
001715  001923        
001716  001924  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001717  001925  // Syntax: islower("char");
001718  001926  // Usage : Var := islower(ch);
001719  001927  // Notes : char specifies the ascii character for the test
001720  001928  //     : 0 : char is not an ascii lower-case letter.
001721  001929  //     : 1 : char is an ascii lower-case letter.
001722  001930  //     : Valid range is "abcd....wxyz"
001723  001931        
001724  001932  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001725  001933  // Syntax: isalpha("char");
001726  001934  // Usage : Var := isalpha(ch);
001727  001935  // Notes : char specifies the ascii character for the test
001728  001936  //     : 0 : char is not an ascii lower or upper case letter.
001729  001937  //     : 1 : char is an ascii lower or upper case letter.
001730  001938  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001731  001939        
001732  001940  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001733  001941  // Syntax: isalnum("char");
001734  001942  // Usage : Var := isalnum(ch);
001735  001943  // Notes : char specifies the ascii character for the test
001736  001944  //     : 0 : char is not an ascii alphanumeric character.
001737  001945  //     : 1 : char is an ascii alphanumeric character.
001738  001946  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001739  001947        
001740  001948  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001741  001949  // Syntax: isprint("char");
001742  001950  // Usage : Var := isprint(ch);
001743  001951  // Notes : char specifies the ascii character for the test
001744  001952  //     : 0 : char is not a printable ascii character.
001745  001953  //     : 1 : char is a printable ascii character.
001746  001954  //     : Valid range is "0x20...0x7F"
001747  001955        
001748  001956  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001749  001957  // Syntax: isspace("char");
001750  001958  // Usage : Var := isspace(ch);
001751  001959  // Notes : char specifies the ascii character for the test
001752  001960  //     : 0 : char is not a space type character.
001753  001961  //     : 1 : char is a space type character.
001754  001962  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001755  001963        
001756  001964  //unformatted
001757  001965  func iswhite("char"), 1;    //
001758  001966  // Syntax: iswhite("char");
001759  001967  // Usage : Var := iswhite(ch);
001760  001968  // Notes : char specifies the ascii character for the test
001761  001969  //     : 0 : char is not a space or tab character.
001762  001970  //     : 1 : char is not a space or tab character.
001763  001971  //     : Valid range is space or tab
001764  001972        
001765  001973  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001766  001974  // Syntax: toupper("char");
001767  001975  // Usage : Var := toupper(ch);
001768  001976  // Notes : char specifies the ascii character for the test
001769  001977  //     : "ABCD....XYZ" : if character is a lower case letter.
001770  001978  //     : char : if character is not a lower case letter.
001771  001979  //     : Valid range is "abcd....wxyz"
001772  001980        
001773  001981  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001774  001982  // Syntax: tolower("char");
001775  001983  // Usage : Var := tolower(ch);
001776  001984  // Notes : char specifies the ascii character for the test
001777  001985  //     : "abcd....xyz" : if character is an upper case letter.
001778  001986  //     : char : if character is not an upper case letter.
001779  001987  //     : Valid range is "ABCD....WXYZ"
001780  001988        
001781  001989  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001782  001990  // Syntax: LObyte(var);
001783  001991  // Usage : myVar := LObyte(myvar2);
001784  001992  // Notes : var specifies the user variable
001785  001993  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001786  001994        
001787  001995  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001788  001996  // Syntax: HIbyte(var);
001789  001997  // Usage : myVar := HIbyte(myvar2);
001790  001998  // Notes : var specifies the user variable
001791  001999  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001792  002000        
001793  002001        
001794  002002  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001795  002003  // Syntax: ByteSwap(var);
001796  002004  // Usage : myVar := ByteSwap(myvar2);
001797  002005  // Notes : var specifies the user variable
001798  002006  //     : Returns the endian swapped value of a 16 bit variable
001799  002007        
001800  002008        
001801  002009  //------------------------------------------------------------------//
001802  002010  //        Memory Allocation Function Prototypes
001803  002011  //------------------------------------------------------------------//
001804  002012        
001805  002013  func mem_Alloc("size"), 1;
001806  002014  // Syntax: mem_Alloc(bytesize);
001807  002015  // Usage : myvar := mem_Alloc(100);
001808  002016  // Notes : Allocate a block of memory to pointer myvar
001809  002017  //       : The allocated memory contains garbage but is a fast allocation.
001810  002018  //       : The block must later be released with mem_Free();
001811  002019  //       : returns 0 if function fails
001812  002020        
001813  002021  func mem_AllocV("size"), 1;
001814  002022  // Syntax: mem_AllocV(bytesize);
001815  002023  // Usage : myvar := mem_AllocV(100);
001816  002024  // Notes : Allocate a block of memory to pointer myvar
001817  002025  //       : The block of memory is filled with signature values
001818  002026  //       : the block starts with A5,5A then fills with incrementing
001819  002027  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001820  002028  //       : This can be helpful when debugging
001821  002029  //       : The block must later be released with mem_Free();
001822  002030  //       : returns 0 if function fails
001823  002031        
001824  002032  func mem_AllocZ("size"), 1;
001825  002033  // Syntax: mem_AllocZ(bytesize);
001826  002034  // Usage : myvar := mem_AllocC(100);
001827  002035  // Notes : Allocate a zeroed block of memory to pointer myvar
001828  002036  //       : The block of memory is filled with zeroes
001829  002037  //       : The block must later be released with mem_Free();
001830  002038  //       : returns 0 if function fails
001831  002039        
001832  002040  func mem_Realloc("ptr", "size"), 1;
001833  002041  // Syntax: myvar := mem_Realloc("ptr", "size");
001834  002042  // Usage : myvar := mem_Realloc(ptr, size);
001835  002043  // Notes : The function may move the memory block to a new location,
001836  002044  //       : in which case the new location is returned.
001837  002045  //       : The content of the memory block is preserved up to the lesser
001838  002046  //       : of the new and old sizes, even if the block is moved.
001839  002047  //       : If the new size is larger, the value of the newly allocated
001840  002048  //       : portion is indeterminate. In case that ptr is NULL,
001841  002049  //       : the function behaves exactly as mem_Alloc, assigning a new block
001842  002050  //       : of size bytes and returning a pointer to the beginning of it.
001843  002051  //       : In case that the size is 0, the memory previously allocated in
001844  002052  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001845  002053  //       : pointer is returned.
001846  002054        
001847  002055  func mem_Free("allocation"), 1;
001848  002056  // Syntax: myvar := mem_Free(allocation);
001849  002057  // Usage : myvar := mem_Free(myvar);
001850  002058  // Notes : De-allocate a block of memory previously created with
001851  002059  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001852  002060  //       : returns 0 if function fails
001853  002061        
001854  002062  func mem_Heap(), 1;
001855  002063  // Syntax: myvar := mem_Heap();
001856  002064  // Usage : myvar := mem_Heap();
001857  002065  // Notes : returns bytecount available in heap
001858  002066  //       :
001859  002067        
001860  002068  func mem_Set("ptr","char","size"), 1;
001861  002069  // Syntax: mem_Set(ptr,char,bytesize);
001862  002070  // Usage : mem_Set(p, 'A', 100);
001863  002071  // Notes : fill a block of memory with a byte value
001864  002072  //       : returns ptr
001865  002073        
001866  002074  func mem_Copy("src", "dest", "bytecount"), 1;
001867  002075  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001868  002076  // Usage : myvar := mem_Copy(p1, p2, 100);
001869  002077  // Notes : copy a word aligned block of memory from src to dest
001870  002078  //       : Note that count is a byte count, this facilitates
001871  002079  //       : copying word aligned byte arrays when using word
001872  002080  //       : aliggned packed strings.
001873  002081  //       : returns src
001874  002082        
001875  002083  func mem_Compare("ptr1","ptr2","count"), 1;
001876  002084  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001877  002085  // Usage : myvar := mem_Compare(p1, p2, 100);
001878  002086  // Notes : compare blocks of memory at src, dest
001879  002087  //       : returns 0 if we have a match
001880  002088        
001881  002089  //------------------------------------------------------------------//
001882  002090  //        FAT16 Function Prototypes
001883  002091  //------------------------------------------------------------------//
001884  002092        
001885  002093  func file_Error(), 1;
001886  002094  // Syntax: myvar := file_Error();
001887  002095  // Usage : e := file_Error();
001888  002096  // Notes : return the most recent file error.
001889  002097  //       :
001890  002098        
001891  002099  func file_Count("filename"), 1;
001892  002100  // Syntax: count := file_Count("filename");
001893  002101  // Usage : count := file_Count("*.4dg");
001894  002102  // Notes : returns number of files found that match the criteria
001895  002103        
001896  002104  func file_Dir("filename"), 1;
001897  002105  // Syntax: count := file_Dir("filename");
001898  002106  // Usage : count := file_Dir("*.4dg");
001899  002107  // Notes : streams a string of filenames that agree with the search key
001900  002108  //       : returns number of files found that match the criteria
001901  002109        
001902  002110  func file_FindFirst("fname"), 1;
001903  002111  // Syntax: res := file_FindFirst("fname");
001904  002112  // Usage : if (file_FindFirst("*.4xe") ....
001905  002113  // Notes : returns true if at least 1 file exists
001906  002114  //       : that satisfies the file argument.
001907  002115  //       : Wildcards are usually used so if
001908  002116  //       : file_FindFirst returns true, further
001909  002117  //       : tests can be made using file_FindNext();
001910  002118  //       : to find all the files that match the
001911  002119  //       : wildcard class. Note that the stream behaviour
001912  002120  //       : is the same as file_Dir.
001913  002121  //       :
001914  002122        
001915  002123  func file_FindNext(), 1;
001916  002124  // Syntax: res := file_FindNext();
001917  002125  // Usage : while ((file_FindNext()) ....
001918  002126  // Notes : returns true if more file exists
001919  002127  //       : that satisfies the file argument
001920  002128  //       : that was given for  file_FindFirst.
001921  002129  //       : Wildcards must be used for
001922  002130  //       : file_FindFirst, else this function will
001923  002131  //       : always return zero as the only occurence
001924  002132  //       : will have already been found.
001925  002133  //       : Note that the stream behaviour
001926  002134  //       : is the same as file_Dir.
001927  002135  //       :
001928  002136        
001929  002137  func file_Exists("fname"), 1;
001930  002138  // Syntax: res := file_Exists("fname"),
001931  002139  // Usage : if(file_Exists("myfile") ....
001932  002140  // Notes : returns true if file exists
001933  002141  //       :
001934  002142        
001935  002143  func file_Open("fname", "mode"), 1;
001936  002144  // Syntax: handle := file_Open("fname","mode"),
001937  002145  // Usage : handle := file_Open("myfile.txt", 'r');
001938  002146  // Notes : returns handle if file exists
001939  002147  //       :
001940  002148        
001941  002149  func file_Close("handle"), 1;
001942  002150  // Syntax: res := file_Close("handle");
001943  002151  // Usage : res := file_Close(hnd1);
001944  002152  // Notes : returns true if file closed ok
001945  002153  //       :
001946  002154        
001947  002155  func file_Read("*dest", "size", "handle"), 1;
001948  002156  // Syntax: res := file_Read("*dest", "size", "handle"),
001949  002157  // Usage : res := file_Read(memblock,20,hnd1);
001950  002158  // Notes : returns number of characters read
001951  002159  //       : if "dest" is zero, data is read direct to GRAM window
001952  002160  //       :
001953  002161        
001954  002162        
001955  002163  func file_Seek("handle", "HiWord", "LoWord"), 1;
001956  002164  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
001957  002165  // Usage : res := file_Seek(hSource, 0, 0x1234);
001958  002166  // Notes : set file position to 0x00001234 (byte position 4660)
001959  002167  //       : for the file handle so subsequent data may be read
001960  002168  //       : from that position onwards with file_GetC(...),
001961  002169  //       : file_GetW(...) or file_GetS(...), or an image
001962  002170  //       : can be displayed with file_Image(...)
001963  002171  // Notes : returns true if ok, usually ignored
001964  002172        
001965  002173  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001966  002174  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001967  002175  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
001968  002176  // Notes : set file seek position to 123000
001969  002177  //       : for the file handle so subsequent data may be read
001970  002178  //       : from that record position onwards with file_GetC(...),
001971  002179  //       : file_GetW(...) or file_GetS(...), or an image
001972  002180  //       : can be displayed with file_Image(...)
001973  002181  // Notes : returns true if ok, usually ignored
001974  002182        
001975  002183  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
001976  002184  // Syntax: file_Tell("handle", &HiWord, &LoWord);
001977  002185  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
001978  002186  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
001979  002187  //       : returns true if function succeeded
001980  002188        
001981  002189  func file_Write("*source", "size", "handle"), 1;
001982  002190  // Syntax: res := fwrite("*source", "size", "handle"),
001983  002191  // Usage : res := fwrite(memblock, 20, hnd1);
001984  002192  // Notes : returns number of bytes written
001985  002193  //       :
001986  002194        
001987  002195  func file_Size("handle", "&HiWord", "&LoWord"), 1;
001988  002196  // Syntax: file_Size("handle", &HiWord, &LoWord);
001989  002197  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
001990  002198  // Notes : Reads the 32 bit file size and stores it into 2 variables.
001991  002199  //       : returns true if function succeeded
001992  002200        
001993  002201  func file_Image("x", "y", "handle"), 1;
001994  002202  // Syntax: file_Image(x, y, handle);
001995  002203  // Usage : file_Image(10, 10, hnd1);
001996  002204  // Notes : Display an image from a file at the current file position.
001997  002205  //       : The image is displayed at x,y (with respect to top left corner).
001998  002206  //       : If there is more than 1 image in the file, it can be
001999  002207  //       : accessed with file_Seek(...)
002000  002208        
002001  002209  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002002  002210  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002003  002211  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002004  002212  // Notes : Save a image from screen to file at the current file position.
002005  002213  //       : The image can later be displayed with file_Image(...);
002006  002214  //       : The file may be opened in append mode to accumulate multiple
002007  002215  //       : images. Later, the images can be accessed with file_Seek(...);
002008  002216  //       : Note that the image will be sector aligned.
002009  002217  //       : All image headers must start on a sector boundary.
002010  002218  //       : The image is saved from x, y (with respect to top left corner)
002011  002219  //       : and the capture area is determined by "width" and "height".
002012  002220  //       : returns 0 if function succeeded
002013  002221        
002014  002222  func file_PutC("char","handle"), 1;
002015  002223  // Syntax: file_PutC("char", "handle");
002016  002224  // Usage : file_PutC('x', hndl);
002017  002225  // Notes : returns true if function succeeded
002018  002226        
002019  002227  func file_GetC("handle"), 1;
002020  002228  // Syntax: file_GetC("handle");
002021  002229  // Usage : mychar := fgetC("handle");
002022  002230  // Notes : returns next char from file
002023  002231        
002024  002232  func file_PutW("word","handle"), 1;
002025  002233  // Syntax: file_PutW("word","handle");
002026  002234  // Usage : file_PutW(0x1234, hndl);
002027  002235  // Notes : returns true if function succeeded
002028  002236        
002029  002237  func file_GetW("handle"), 1;
002030  002238  // Syntax: file_GetW("handle");
002031  002239  // Usage : myword := fgetW("handle");
002032  002240  // Notes : returns next word in file
002033  002241        
002034  002242  func file_PutS("*source", "handle"), 1;
002035  002243  // Syntax: res := file_Puts("*source", "handle"),
002036  002244  // Usage : res := file_Puts(mystring, hnd1);
002037  002245  // Notes : returns number of characters written
002038  002246  //       :
002039  002247        
002040  002248  func file_GetS("*string", "size", "handle"), 1;
002041  002249  // Syntax: res := file_Gets("*string", "size", "handle");
002042  002250  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002043  002251  // Notes : get a string from a file
002044  002252  //       : returns pointer to string or null if failed.
002045  002253  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002046  002254  //       : NB:- only reads up to "size-1" characters into "string"
002047  002255  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002048  002256  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002049  002257  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002050  002258  //       : C] It reaches the end of file
002051  002259  //       : D] A read error occurs.
002052  002260        
002053  002261        
002054  002262  func file_Erase("fname"), 1;
002055  002263  // Syntax: res := file_Erase("fname");
002056  002264  // Usage : res := file_Erase("myfile.txt");
002057  002265  // Notes : returns true if successful
002058  002266  //       :
002059  002267        
002060  002268  func file_Rewind("handle"), 1;
002061  002269  // Syntax: res := file_Rewind("handle");
002062  002270  // Usage : res := file_Rewind(hnd1);
002063  002271  // Notes : returns true if file rewound ok (usually ignored)
002064  002272  //       : resets the file pointer the the beginning of the open file.
002065  002273        
002066  002274  func file_LoadFunction("fname.4xe"), 1;
002067  002275  // Syntax: res := file_LoadFunction("fname.4fn");
002068  002276  // Usage : myfunc := file_LoadFunction(myfuncname);
002069  002277  // Notes : Load a function or program from disk and
002070  002278  //       : return a function pointer to the allocation.
002071  002279  //       : The function can then be invoked just like any other
002072  002280  //       : function would be called via a function pointer.
002073  002281  //       : Parameters may be passed to it in a conventional way.
002074  002282  //       : The function may be discarded at any time when no
002075  002283  //       : longer required, thus freeing its memory resources.
002076  002284  //       : The loaded function can be discarded with mem_Free(..)
002077  002285  //       : eg:
002078  002286  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002079  002287  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002080  002288  //       : then elsewhere in your program:-
002081  002289  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002082  002290  //       : if(res == QUIT_APPLICATION) goto exitApp;
002083  002291  //       : Later in your program, when popupWindow is no longer
002084  002292  //       : required for the application:-
002085  002293  //       : res := mem_Free(popupWindow);
002086  002294  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002087  002295  //       : The callers stack is shared by the loaded function,
002088  002296  //       : however any global variables in the loaded function
002089  002297  //       : are private to that function.
002090  002298  //
002091  002299        
002092  002300  func file_Run("fname.4xe", "arglistptr"), 1;
002093  002301  // Syntax: res := file_Run("fname.4xe","arglistptr");
002094  002302  // Usage : res := file_Run(fname, argptr);
002095  002303  // Notes : current program releases any allocated memory but
002096  002304  //       : retains the stack and global memory.
002097  002305  //       : If arglistptr is 0, no arguments are passed, else
002098  002306  //       : arglist points to an array, the first element being
002099  002307  //       : the number of elements in the array.
002100  002308  //       : func 'main' in the called program accepts
002101  002309  //       : the arguments, if any. THe arguments can only
002102  002310  //       : be passed by value, no pointers or references can be
002103  002311  //       : used as all memory is cleared before the file
002104  002312  //       : is loaded. Refer to file_Exec and file_LoadFunction
002105  002313  //       : for functions that can pass by reference.
002106  002314        
002107  002315  func file_Exec("fname.4xe", "arglistptr"), 1;
002108  002316  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002109  002317  // Usage : res := file_Exec("fname.4xe","arglistptr");
002110  002318  // Notes : returns like a function, current program
002111  002319  //       : calling program is kept active and control returns to it.
002112  002320  //       : If arglistptr is 0, no arguments are passed, else
002113  002321  //       : arglist points to an array, the first element being
002114  002322  //       : the number of elements in the array.
002115  002323  //       : func 'main' in the called program accepts the arguments.
002116  002324  //       : This function is similar to file_LoadFunction(...), however,
002117  002325  //       : the function argument list is passed by pointer, and
002118  002326  //       : the memory consumed by the function is released as
002119  002327  //       : soon as the function completes.
002120  002328        
002121  002329  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002122  002330  // Syntax	: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002123  002331  // Usage	: hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002124  002332  // Notes	: Reads a control file to create an image list.
002125  002333  // 	: Returns NULL if function fails.
002126  002334  // 	: Returns a handle (pointer to the memory allocation) to the
002127  002335  // 	: image control list that has been created.
002128  002336  // 	: "fname1" is the control list filename "*.dat"
002129  002337  // 	: "fname2" is the image filename "*.gci"
002130  002338  // 	: "mode" is 0 for FAT based GCI and DAT with quick load and slower for each display
002131  002339  // 	: "mode" is 1 for FAT based GCI and DAT with slower load and faster for each display
002132  002340  // 	: "mode" is 2 for FAT based DAT with RAW GCI
002133  002341  // 	: "mode" is 3 for Flash based 'file system' GCI (GCIF) with itegerated DAT and other file types
002134  002342  // 	: "fname1" and "fname2" are then the Flash high and low words of the GFIC start location.
002135  002343        
002136  002344  // Notes : This function Calculates the size of a chunk of memory required for
002137  002345  //       : a image list and populates it from the image control file ("*.dat")
002138  002346  //       : therefore, when imagelist is no longer required, you must de-allocate
002139  002347  //       : the image list memory by using eg:- mem_Free(hImagelist);
002140  002348  //       : to restore the heap.
002141  002349  //       :
002142  002350  //       : mode 0:- it is assumed that there is a graphics file with the
002143  002351  //       : file extension "fname2.gci". In this case, the images have been stored
002144  002352  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002145  002353  //       : "fname1.dat" file are saved in the image control so that the image control
002146  002354  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002147  002355  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002148  002356  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002149  002357  //       : for the file offsets and save them in the relevant entries in the image control.
002150  002358  //       : The penalty is that images take longer to find when displayed due to file_Seek
002151  002359  //       : overheads.
002152  002360  //
002153  002361  //       : mode 1:- it is assumed that there is a graphics file with the
002154  002362  //       : file extension "fname2.gci". In this case, the images have been stored
002155  002363  //       : in a FAT16 file concurrently, and the offset of the images are saved
002156  002364  //       : in the image control so that image file (*.gci) can be mapped to directly.
002157  002365  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002158  002366  //       : internally. This means that there is no seek time penalty, however, the
002159  002367  //       : image list takes a lot longer to build, as all the seeking is done at control
002160  002368  //       : build time.
002161  002369        
002162  002370  //       : mode 2:- the graphics file with the is placed in a partitioned area
002163  002371  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002164  002372  //       : disk, and the absolute address of the images are saved in the DAT file
002165  002373  //       : This is the fastest operation of the image control as there is no seeking
002166  002374  //       : or other disk activity taking place.
002167  002375        
002168  002376  func file_Mount(), 1;
002169  002377  // Syntax: r := file_Mount();
002170  002378  // Usage : r := file_Mount();
002171  002379  // Notes : Create a control block for FAT16 and mount the File System
002172  002380        
002173  002381  func file_Unmount(), 0;
002174  002382  // Syntax: file_Unmount();
002175  002383  // Usage : file_Unmount();
002176  002384  // Notes : release any control block and buffers for FAT16
002177  002385  //       : and unmount the File System
002178  002386        
002179  002387  func file_PlayWAV("fname1"), 1;
002180  002388  // Syntax: file_PlayWAV("fname1");
002181  002389  // Usage : file_PlayWAV("ding.wav");
002182  002390  // Notes : Play a wave file with filename "fname1"
002183  002391  //       : This function automatically grabs a chunk
002184  002392  //       : of memory for a file buffer, and a wave
002185  002393  //       : buffer. The minimum memory requirement is
002186  002394  //       : about 580 bytes for the disk io service and
002187  002395  //       : a minimum wave buffer size of 1024. The siz
002188  002396  //       : of the wave buffer allocation
002189  002397  //       : can be increased by the snd_BufSize function.
002190  002398  //       : The default size 1024 bytes.
002191  002399  //       : NB the memory is only required during the
002192  002400  //       : duration of play, and is automatically
002193  002401  //       : released while not in use.
002194  002402  //       : See the Sound Class services for other associated controls.
002195  002403  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002196  002404  //       : If errors occured, the folling is returned
002197  002405  //       : -7  : Insufficient memory available for WAV buffer and file
002198  002406  //       : -6  : cant play this rate
002199  002407  //       : -5  : no data chunk found in first rsector
002200  002408  //       : -4  : no format data
002201  002409  //       : -3  : no wave chunk signature
002202  002410  //       : -2  : bad wave file format
002203  002411  //       : -1  : file not found
002204  002412        
002205  002413        
002206  002414        
002207  002415  //------------------------------------------------------------------//
002208  002416  //        Sound Class Services
002209  002417  //------------------------------------------------------------------//
002210  002418        
002211  002419  func snd_Volume("var"), 0;
002212  002420  // Syntax: snd_Volume("var");
002213  002421  // Usage : snd_Volume(30);
002214  002422  // Notes : set sound playback volume.  Var must
002215  002423  //       : be in the range from 8 (min volume)
002216  002424  //       : to 127 (max volume). If var is less
002217  002425  //       : than 8 volume is set to 8, and if
002218  002426  //       : var > 127 it is set to 127.
002219  002427        
002220  002428  func snd_Pitch("pitch"), 1;
002221  002429  // func snd_Pitch("freq"), 1;
002222  002430  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002223  002431  // Notes : sets the samples playback rate to a different frequency
002224  002432  //       : The minimum value is 4khz
002225  002433  //       : Setting the pitch to zero restores the original sample rate
002226  002434  //       : Return value is the samples original sample rate.
002227  002435        
002228  002436  func snd_BufSize("var"), 0;
002229  002437  // Syntax: snd_BufSize("var");
002230  002438  // Usage : snd_BufSize(2);
002231  002439  // Notes : specify the a memory chunk size for the wavefile buffer.
002232  002440  //       : default size 1024 bytes.
002233  002441  //       : 0 = 1024 bytes (default)
002234  002442  //       : 1 = 2048 bytes
002235  002443  //       : 2 = 4096 bytes
002236  002444  //       : 3 = 8192 bytes
002237  002445        
002238  002446  func snd_Stop(), 0;
002239  002447  // Syntax: snd_Stop();
002240  002448  // Usage : snd_Stop();
002241  002449  // Notes : stop any sound that is playing, releasing
002242  002450  //       : buffers and closes any open wav file.
002243  002451        
002244  002452  func snd_Pause(), 0;
002245  002453  // Syntax: snd_Pause();
002246  002454  // Usage : snd_Pause();
002247  002455  // Notes : pauses any sound that is playing, does nothing
002248  002456  //       : until sound is resumed with snd_Continue().
002249  002457  //       : The sample cam be terminated with snd_Stop.
002250  002458  //       : buffers and closes any open wav file.
002251  002459        
002252  002460  func snd_Continue(), 0;
002253  002461  // Syntax: snd_Continue();
002254  002462  // Usage : snd_Continue();
002255  002463  // Notes : resume any sound that is paused by snd_Pause.
002256  002464        
002257  002465  func snd_Playing(), 1;
002258  002466  // Syntax: snd_Playing();
002259  002467  // Usage : r := snd_Playing();
002260  002468  // Notes : returns 0 if sound has finished playing,
002261  002469  //       : else return number of 512 byte blocks to go.
002262  002470        
002263  002471        
002264  002472        
002265  002473  //------------------------------------------------------------------//
002266  002474  //        String Class Services
002267  002475  //------------------------------------------------------------------//
002268  002476        
002269  002477  func str_Ptr("&var"), 1;
002270  002478  // Syntax: str_Ptr(&var);
002271  002479  // Usage : p := str_Ptr(&var);
002272  002480  // Notes : return a byte pointer to a word region
002273  002481        
002274  002482  func str_GetD("&ptr", "&var"), 1;
002275  002483  // Syntax: str_GetD(&ptr, &var);
002276  002484  // Usage : ok := str_GetD(&ptr, &var);
002277  002485  // Notes : convert number in a string to DWORD ( myvar[2] )
002278  002486  //       : returns true if function succeeds, advancing ptr
002279  002487        
002280  002488  func str_GetW("&ptr", "&var"), 1;
002281  002489  // Syntax: str_GetW(&ptr, &var);
002282  002490  // Usage : ok := str_GetW(&ptr, &var);
002283  002491  // Notes : convert number in a string to WORD ( myvar )
002284  002492  //       : returns true if function succeeds, advancing ptr
002285  002493        
002286  002494  func str_GetHexW("&ptr", "&var"), 1;
002287  002495  // Syntax: str_GetHexW(&ptr, &var);
002288  002496  // Usage : ok := str_GetHexW(&ptr, &var);
002289  002497  // Notes : convert HEX number in a string to WORD ( myvar )
002290  002498  //       : returns true if function succeeds, advancing ptr
002291  002499        
002292  002500  func str_GetC("&ptr", "&var"), 1;
002293  002501  // Syntax: str_GetC(&ptr, &var);
002294  002502  // Usage : ok := str_GetC(&ptr, &var);
002295  002503  // Notes : get a valid ascii char in a string to WORD ( myvar )
002296  002504  //       : returns true if function succeeds, advancing ptr
002297  002505        
002298  002506  func str_GetByte("ptr"), 1;
002299  002507  // Syntax: str_GetByte(ptr);
002300  002508  // Usage : myvar := str_GetByte(ptr);
002301  002509  // Notes : get a byte to myvar
002302  002510  //       : returns value
002303  002511        
002304  002512  func str_GetWord("ptr"), 1;
002305  002513  // Syntax: GetWord(ptr);
002306  002514  // Usage : GetWord(ptr);
002307  002515  // Notes : get a word to myvar
002308  002516  //       : returns value
002309  002517        
002310  002518  func str_PutByte("ptr","val"), 0;
002311  002519  // Syntax: str_PutByte(ptr);
002312  002520  // Usage : myvar := str_PutByte(ptr);
002313  002521  // Notes : put a byte at ptr
002314  002522  //       : returns value
002315  002523        
002316  002524  func str_PutWord("ptr","val"), 0;
002317  002525  // Syntax: str_PutWord("ptr","val");
002318  002526  // Usage : str_PutWord(p,100);
002319  002527  // Notes : put word 100 at current pointer location
002320  002528  //       : returns value
002321  002529        
002322  002530  func str_Match("&ptr", "*str"), 1;
002323  002531  // Syntax: str_Match(&ptr, *str);
002324  002532  // Usage : r := str_Match(&p, "hello");
002325  002533  // Notes : Case sensitive match
002326  002534  //       : returns true if function succeded, andvancing pointer to position past
002327  002535  //       : the matched item. Note that any whitespace characters are skipped
002328  002536  //       : in the source string prior to the test.
002329  002537        
002330  002538  func str_MatchI("&ptr", "*str"), 1;
002331  002539  // Syntax: str_MatchI(&ptr, *str);
002332  002540  // Usage : r := str_MatchI(&p, "hello");
002333  002541  // Notes : Case insensitive match
002334  002542  //       : returns true if function succeded, andvancing pointer to position past
002335  002543  //       : the matched item. Note that any whitespace characters are skipped
002336  002544  //       : in the source string prior to the test.
002337  002545        
002338  002546  func str_Find("&ptr", "*str"), 1;
002339  002547  // Syntax: str_Find(&ptr, *str);
002340  002548  // Usage : n := str_Find(&p, "hello");
002341  002549  // Notes : given the address of a pointer to a source string as the
002342  002550  //       : first argument, and a pointer to a test string as the second
002343  002551  //       : argument, attempt to find the position of the matching string
002344  002552  //       : in the source string. The test is performed with case sensitivity.
002345  002553  //       : return 0 if not found, else returns the address of the first
002346  002554  //       : character of the match. NB:- The source pointer is not altered.
002347  002555        
002348  002556  func str_FindI("&ptr", "*str"), 1;
002349  002557  // Syntax: str_Find(&ptr, *str);
002350  002558  // Usage : n := str_Find(&p, "hello");
002351  002559  // Notes : given the address of a pointer to a source string as the
002352  002560  //       : first argument, and a pointer to a test string as the second
002353  002561  //       : argument, attempt to find the position of the matching string
002354  002562  //       : in the source string. The test is performed with no case
002355  002563  //       : sensitivity, eg upper and lower case chars are accepted.
002356  002564  //       : return 0 if not found, else returns the address of the first
002357  002565  //       : character of the match. NB:- The source pointer is not altered.
002358  002566        
002359  002567  func str_Length("ptr"), 1;
002360  002568  // Syntax: str_Length(ptr);
002361  002569  // Usage : len := str_Ptr(mystring);
002362  002570  // Notes : return the length of a byte aligned string excluding terminator
002363  002571        
002364  002572  func str_Printf("&ptr", "*format"), 1;
002365  002573  // Syntax: str_Printf("&ptr", "*format");
002366  002574  // Usage : r := str_Printf(&p, "%8s");
002367  002575  // Notes : refer to documentation
002368  002576  //       :
002369  002577        
002370  002578  func str_Cat("dest","src"), 1;
002371  002579  // Syntax: str_Append("&dest","&src");
002372  002580  // Usage : str_Append(&buf,"Hello");
002373  002581  // Notes : Appends a copy of the source string to the destination string.
002374  002582  //       : The terminating null character in destination is overwritten by
002375  002583  //       : the first character of source, and a new null-character is appended
002376  002584  //       : at the end of the new string formed by the concatenation of both in destination.
002377  002585  //       : returns destination.
002378  002586        
002379  002587  func str_CatN("dest","src","count"), 1;
002380  002588  // Syntax: str_Append("&dest","&src","count");
002381  002589  // Usage : str_Append(&buf,"Monday",3);
002382  002590  // Notes : Appends a copy of the source string to the destination string.
002383  002591  //       : The number of characters copied is limited by "count".
002384  002592  //       : The terminating null character in destination is overwritten by
002385  002593  //       : the first character of source, and a new null-character is appended
002386  002594  //       : at the end of the new string formed by the concatenation of both in destination.
002387  002595  //       : returns destination.
002388  002596        
002389  002597        
002390  002598  func sys_StoreTouchCalibration(), 1;
002391  002599  // Syntax: sys_StoreTouchCalibration();
002392  002600  // Usage : r := sys_StoreTouchCalibration();
002393  002601  // Notes : Store the touch calibration values in non-volatile memory.
002394  002602  //       : Returns true if the values have been accepted and stored,
002395  002603  //       : else returns false if write could not be performed, or
002396  002604  //       : touch calibration values are improbable.
002397  002605  //       : The values that are stored are obtained from:-
002398  002606  //     : TOUCH_XMINCAL             78  // touch calibration value
002399  002607  //     : TOUCH_YMINCAL             79  // touch calibration value
002400  002608  //       : TOUCH_XMAXCAL             80  // touch calibration value
002401  002609  //       : TOUCH_YMAXCAL             81  // touch calibration value
002402  002610  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002403  002611  //       : This function is not supported on uVGA, Capicitive touch
002404  002612  //       : and 4.3" resistive touch modules.
002405  002613        
002406  002614        
002407  002615  func unicode_page("charbeg","charend","charoffset"), 1;
002408  002616  // Syntax: unicode_page("charbeg","charend","charoffset");
002409  002617  // Usage : eg:  F_Traditional_0x20_0xFF
002410  002618  // Notes : After selecting a unicode image control with txt_FontID,
002411  002619  //       : this function is called to set the required font within the
002412  002620  //       : unicode set. The file "Unicode.inc" contains wrappers for
002413  002621  //       : this function, and it is not normally called directly.
002414  002622  //       : Returns count of characters in the set.
002415  002623  //       : Refer to "Unicode.inc" for further information.
002416  002624        
002417  002625        
002418  002626  func EVE_SP(), 1;
002419  002627  // Syntax: EVE_SP();
002420  002628  // Usage : eg:  print(EVE_SP());
002421  002629  // Notes : Used for debugging to assess the current stack level,
002422  002630  //       : mainly for checking stack leaks
002423  002631        
002424  002632  func EVE_SSIZE(), 1;
002425  002633  // Syntax: EVE_SSIZE();
002426  002634  // Usage : eg:  print(EVE_SSIZE());
002427  002635  // Notes : Used to get the stack size,
002428  002636  //       : mainly for debugging purposes
002429  002637        
002430  002638        
002431  002639  // uVGAII extended functions
002432  002640  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002433  002641  // Syntax: disp_Sync(line);
002434  002642  // Usage : disp_Sync(480);
002435  002643  // Notes : Waits till the hardware gets to a certain line.
002436  002644  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002437  002645  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002438  002646  //       : depending on the graphics operation. The higher the value, the slower
002439  002647  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002440  002648  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002441  002649  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002442  002650  //       : be slowest (as its actually right at the end of the blanking period) and 508
002443  002651  //       : will cause a hangup situation as it is above the highes scanline value.
002444  002652  //       : Currently, this function is only supported on displays with SSD1963 driver.
002445  002653        
002446  002654        
002447  002655  // New functions added to PmmC v2.8
002448  002656  //================================================================
002449  002657  func CY(), 1;
002450  002658  // Syntax: CY();
002451  002659  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002452  002660  //       : print(myvar," "CY(),"\n");           // carry = 1
002453  002661  // Notes : This function returns the carry status of an
002454  002662  // unsigned overflow from any 16 or 32bit additions or sutractions.
002455  002663  //================================================================
002456  002664        
002457  002665        
002458  002666  //================================================================
002459  002667  func str_ByteMove("src", "dest", "count"), 1;
002460  002668  // func str_ByteMove("src", "dest", "count"), 1;
002461  002669  // Syntax   : str_ByteMove(src, dest, bytecount);
002462  002670  // Input    : STR *source points to byte aligned source.
002463  002671  //          : STR *dest   points to byte aligned destination.
002464  002672  //          : VAR count   number of bytes to transfer.
002465  002673  // Usage    : nextpos := str_ByteMove(s, d, 100);
002466  002674  // Notes    : copy bytes from "src" to "dest", stopping only
002467  002675  //          : when "count" is exhausted.
002468  002676  //          : No terminator is appended, it is purely a
002469  002677  //          : byte copy, and any zeroes encountered will
002470  002678  //          : also be copied.
002471  002679  // Returns  : returns a pointer to the end of the destination
002472  002680  //          : (which is "dest" + "count")
002473  002681  //================================================================
002474  002682        
002475  002683        
002476  002684  //================================================================
002477  002685  func str_Copy("dest", "src"), 1;
002478  002686  // Syntax   : str_Copy(dest, src);
002479  002687  // Input    : STR *dest   points to byte aligned destination.
002480  002688  //          : STR *source points to byte aligned source.
002481  002689  // Usage    : nextplace := str_Copy(d, s);
002482  002690  // Notes    : copy a string from "src" to "dest", stopping only
002483  002691  //          : when the end of source string "src" is encountered
002484  002692  //          : (0x00 terminator).
002485  002693  //          : The terminator is always appended, even if "src" is
002486  002694  //          : an empty string.
002487  002695  // Returns  : returns a pointer to the 0x00 string terminator at
002488  002696  //          : end of "dest" (which is "dest" + str_Length(src); )
002489  002697  //================================================================
002490  002698        
002491  002699  //================================================================
002492  002700  func str_CopyN("dest", "src", "count"), 1;
002493  002701  // Syntax   : str_CopyN(dest, src, bytecount);
002494  002702  // Input    : STR *dest   points to byte aligned destination.
002495  002703  //          : STR *source points to byte aligned source.
002496  002704  //          : VAR count   max number of chars to copy.
002497  002705  // Usage    : nextplace := str_CopyN(d, s, 100);
002498  002706  // Notes    : copy a string from "src" to "dest", stopping only
002499  002707  //          : when "count" is exhausted, or end of source
002500  002708  //          : string "str" is encountered (0x00 string terminator).
002501  002709  //          : The terminator is always appended, even if
002502  002710  //          : "count" is zero, or "src" is a null string.
002503  002711  // Returns  : returns a pointer to the 0x00 string terminator
002504  002712  //          : (which is "dest" + whatever was copied)
002505  002713  //================================================================
002506  002714        
002507  002715  //================================================================
002508  002716  func umul_1616("&res32", "val1", "val2"), 1;
002509  002717  // Syntax   : umul_1616(&res32, varA, varB);
002510  002718  // Input    : DWORD *result   points to 32bit result register.
002511  002719  //          : VAR   val1  16bit register or constant
002512  002720  //          : VAR   val2  16bit register or constant
002513  002721  // Usage    : var res32[2];
002514  002722  //          : umul_1616(&res32, myvar, 50000);
002515  002723  // Notes    : performs an unsigned multiply of 2 x 16bit values
002516  002724  //          : placing the 32bit result in a 2 word array.
002517  002725  // Returns  : the pointer to the 32bit result.
002518  002726  //          : carry and overflow are not affected.
002519  002727  //================================================================
002520  002728        
002521  002729  //================================================================
002522  002730  func uadd_3232("&res32", "&val1", "&val2"), 1;
002523  002731  // Syntax   : cmp_3232(&res32, &varA, &varB);
002524  002732  // Input    : DWORD *res32 points to optional result (or zero for compare)
002525  002733  //          : DWORD *val1 points to 32bit augend
002526  002734  //          : DWORD *val2 points to 32bit addend
002527  002735  // Usage    : var res32[2];
002528  002736  //          : res := cmp_3232(res32, val1, val2);
002529  002737  // Notes    : performs an unsigned addition of 2 x 32bit values
002530  002738  //          : placing the 32bit result in a 2 word array.
002531  002739  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002532  002740  //          ; carry flag is also set on 32bit unsigned overflow
002533  002741  //          ; and can be read with the CY() function.
002534  002742  //================================================================
002535  002743        
002536  002744  //================================================================
002537  002745  func usub_3232("&res32", "&val1", "&val2"), 1;
002538  002746  // Syntax   : cmp_3232(&res32, &varA, &varB);
002539  002747  // Input    : DWORD *res32 points to optional result (or zero for compare)
002540  002748  //          : DWORD *val1 points to first 32bit minuend
002541  002749  //          : DWORD *val2 points to 32bit subtrahend
002542  002750  // Usage    : var res32[2];
002543  002751  //          : res := cmp_3232(res32, val1, val2);
002544  002752  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002545  002753  //          : placing the 32bit result in a 2 word array.
002546  002754  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002547  002755  //          ; carry flag is also set on 32bit unsigned underflow
002548  002756  //          ; and can be read with the CY() function.
002549  002757  //================================================================
002550  002758        
002551  002759  //================================================================
002552  002760  func ucmp_3232("&val1", "&val2"), 1;
002553  002761  // Syntax   : cmp_3232(&varA, &varB);
002554  002762  // Input    : DWORD *val1 points to 32bit minuend
002555  002763  //          : DWORD *val2 points to 32bit sutrahend
002556  002764  // Usage    : res := cmp_3232(val1, val2);
002557  002765  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002558  002766  //          : The result of the subtraction is returned.
002559  002767  // Returns  : 0  if equal
002560  002768  //          : 1  if val1 > val2
002561  002769  //          : -1 if val1 < val2
002562  002770  //          : This function does not affect the carry flag.
002563  002771  //================================================================
002564  002772        
002565  002773  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002566  002774  // Syntax: disp_Disconnect();                  New in v3.8
002567  002775  // Usage : disp_Disconnect();
002568  002776  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002569  002777  //       : its lowest possible power consumption. Use after disabling peripheral power
002570  002778  //       : to ensure the minimal power usage by the display.
002571  002779  //       : disp_Init() should be used to reinitialise the display.
002572  002780        
002573  002781  func reserved(), 0;                            
002574  002782        
002575  002783  func sys_DeepSleep("units"), 1;
002576  002784  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002577  002785  // Usage : t := sys_DeepSleep(10);
002578  002786  // Notes : sets the display and processor into lowest power mode for a period of time.
002579  002787  //       : When returning from DeepSleep the display should be reinitialised
002580  002788  //       : with disp_Init().
002581  002789  //       : Touching the touch screen will also wake from sleep.
002582  002790  //       : Returns remaining sleep units.
002583  002791        
002584  002792  func sys_PmmC(), 1;
002585  002793  // Syntax: sys_PmmC();
002586  002794  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer, new in v4.6
002587  002795  // Notes : print the system PmmC name and revision eg "Picaso\n4.6"
002588  002796  //       : Can be captured to a buffer using the to( function
002589  002797  //       : Returns PmmC version as a hex number, eg 0x46
002590  002798        
002591  002799  func sys_Driver(), 0;
002592  002800  // Syntax: sys_Driver();
002593  002801  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer, new in v4.6
002594  002802  // Notes : print the system PmmC name and revision eg "uLCD-32PTU"
002595  002803  //       : Can be captured to a buffer using the to( function
002596  002804  //       : Returns nothing.
002597  002805        
002598  002806  func OW_Reset("pin"), 1;                             // issue 1wire reset command
002599  002807  // Syntax   : OW_Reset(PA0);
002600  002808  // Usage    : OW_Reset(PA0);
002601  002809  // Notes    : Only available on PA0 to PA13
002602  002810  //          : Resets  ONEWIRE device
002603  002811  //          : Returns the status, 0 = ACK.
002604  002812  //          :
002605  002813        
002606  002814  func OW_Read("pin"), 1;                              // read data from 1wire bus
002607  002815  // Syntax   : OW_Read(PA0);
002608  002816  // Usage    : arg1 := OW_Read(PA0);
002609  002817  // Notes    : Only available on PA0 to PA13
002610  002818  //          : Reads value of the ONEWIRE pin
002611  002819  //          : that was previously selected for ONEWIRE comms.
002612  002820  //          :
002613  002821  //          : pin = 0 : the next byte from the ONEWIRE bus
002614  002822        
002615  002823  func OW_Read9("pin"), 1;                             // read data from 1wire bus, 9bit mode
002616  002824  // Syntax   : OW_Read9(PA0);
002617  002825  // Usage    : OW_Read9(PA0);
002618  002826  // Notes    : Only available on PA0 to PA13
002619  002827  //          : Reads 9 bit value of the appropriate ONEWIRE pin
002620  002828  //          : that was previously selected for ONEWIRE comms.
002621  002829  //          :
002622  002830  //          : read the 9 bits from the ONEWIRE bus
002623  002831        
002624  002832  func OW_Write("pin", "value"), 0;                      // write value to 1wire device
002625  002833  // Syntax   : OW_Write(PA0, arg);
002626  002834  // Usage    : OW_Write(PA0, arg);
002627  002835  // Notes    : Only available on PA0 to PA13
002628  002836  //          : Sends ONEWIRE data on the appropriate
002629  002837  //          : pin that was previously  selected as ONEWIRE comms.
002630  002838  //          :
002631  002839  //          : write arg to the ONEWIRE bus
002632  002840        
002633  002841  func snd_Freq("Freq", "Duration"), 1;
002634  002842  // Syntax	: snd_Freq("Freq", "Duration");
002635  002843  // Usage	: r := snd_Freq(1000, 2000);
002636  002844  // Notes	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002637  002845  // 	: else return True.
002638  002846  // 	: Minimum Freq is 20
002639  002847  // 	: This will produce a pure Square wave and is designed for driving
002640  002848  // 	: Piezo transducers which require this sort of drive. It can be used
002641  002849  // 	: directly with high impedience speakers.
002642  002850        
002643  002851  func gfx_SpriteSet("bitmaps", "colours", "palette"), 0;
002644  002852  // Syntax   : gfx_SpriteSet("bitmaps", "colours", "palette");
002645  002853  // Usage    : gfx_SpriteSet(mysprites, mycolours, mypalette);
002646  002854  // Notes    : 3 sets of data are required by the sprite generator,
002647  002855  //          : this function sets the internal pointers for the 3 parts.
002648  002856  //          : 1] the bitmaps for the sprites,
002649  002857  //          : 2] the colour lookup table (CLUT),
002650  002858  //          : 3] the 4 colour palettes.
002651  002859        
002652  002860        
002653  002861  func gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage"), 0;
002654  002862  // Syntax 	: gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage");
002655  002863  // Usage 	: gfx_BlitSprite(1,2,10,10,SOUTH,0);  // example show a cherry upside down using the third palette of mypalette
002656  002864  // Notes 	: Places the required sprite bitmap at the origin xpos, ypos using the required 4 colour palette.
002657  002865  //  	: orientation determines in which direction the sprite will be displayed.
002658  002866  //    	: if preimage exists it should be large enough to hold the entire image 'underneath' the sprite.
002659  002867        
002660  002868  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
002661  002869  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
002662  002870  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
002663  002871  // Notes   : reads an arbitrary rectangular area from the display to an array.
002664  002872  //         : If "ptr" is 0, the correctly sized array is created, in which case
002665  002873  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
002666  002874  //         : is expected to point to a correctly sized array.
002667  002875  //         : NB if an array is supplied, its size must be large enough, and may
002668  002876  //         : be calculated:-
002669  002877  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
002670  002878  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
002671  002879  // Returns : A pointer to the created aray, or the users array.
002672  002880  //         : In the case of ptr=0, if there is insufficient
002673  002881  //         : memory to create the array, zero is returned
002674  002882        
002675  002883        
002676  002884  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
002677  002885  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
002678  002886  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
002679  002887  // Notes   : "ptr" points to the array to be written.
002680  002888  // Returns : nothing
002681  002889        
002682  002890  func rect_Intersect("&rect1", "&rect2"), 1;
002683  002891  // Syntax   : rect_Intersect(&rect1, &rect2);
002684  002892  // Usage    : rect_Intersect(box1, box2);
002685  002893  // Notes    : return true if any part of rect1 is within rect2
002686  002894  //          : each rectangle is an array of 4 words in the format:-
002687  002895  //	    : element 0 = RECT_LEFT			
002688  002896  //	    : element 1 = RECT_TOP			
002689  002897  //	    : element 2 = RECT_WIDTH 		
002690  002898  //	    : element 3 = RECT_HEIGHT 
002691  002899  //          : This function is ideal for use as a collision detector.		
002692  002900        
002693  002901  func rect_Within("&rect1", "&rect2"), 1;
002694  002902  // Syntax   : rect_Within(&rect1, &rect2);
002695  002903  // Usage    : rect_Within(box1, box2);
002696  002904  // Notes    : return true if rect1 is fully within rect2
002697  002905  //          : each rectangle is an array of 4 words in the format:-
002698  002906  //	    : element 0 = RECT_LEFT			
002699  002907  //	    : element 1 = RECT_TOP			
002700  002908  //	    : element 2 = RECT_WIDTH
002701  002909  //	    : element 3 = RECT_HEIGHT 
002702  002910        
002703  002911  func snd_RTTTL("TunePtr",), 1;                           // play a RTTTL tune string
002704  002912  // Syntax	: snd_RTTTL(TunePtr);
002705  002913  // Usage	: snd_RTTTL("...notes...");
002706  002914  // Notes	: Play an RTTTL tune string from a data statement or a direct string
002707  002915  // 	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002708  002916        
002709  002917  func joystick("Pin"), 1;                                     // read the joystick value
002710  002918  // Syntax   : Joystick("Pin");
002711  002919  // Usage    : var := Joystick(IO1_PIN);
002712  002920  // *Notes   : Returned values are:-
002713  002921  //          :    JOY_RELEASED 0
002714  002922  //          :    JOY_UP       1
002715  002923  //          :    JOY_LEFT     2
002716  002924  //          :    JOY_DOWN     3
002717  002925  //          :    JOY_RIGHT    4
002718  002926  //          :    JOY_BTNB     5
002719  002927  //          :    JOY_BTNA     6
002720  002928        
002721  002929  func gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour"), 0;         // display an Annular ring segment
002722  002930  // Syntax 	: gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour") ;
002723  002931  // Usage 	: gfx_RingSegment(x, y, starta, enda, rx, w, colour) ;
002724  002932  // Notes 	: Draw a Segment of a ring at x, y from rad1 to rad2 starting at starta to enda
002725  002933  // 	: in colour.
002726  002934  //
002727  002935        
002728  002936  func gfx_AngularMeter("value", "&MeterRam", "&MeterDef"), 0;                           // draw an angular meter scale and value
002729  002937  // Syntax 	: gfx_AngularMeter("value", "&MeterRam", "&MeterDef") ;
002730  002938  // Usage 	: gfx_AngularMeter(value, MeterRam, MeterDef) ;
002731  002939  // Notes 	: Draw an Angular Meter as defined by MeterDef (if required), using MeterRam positioning at
002732  002940  // 	: position value. See the reference for the MeterDef values
002733  002941  //
002734  002942        
002735  002943  // AngularMeter constants
002736  002944  #CONST
002737  002995  #END
002738  002996        
002739  002997  #constant PANEL2_FILLED 0x8000
002740  002997  #constant PANEL2_FILLED 0x8000
002741  002998        
002742  002999  func gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf"), 0;                           // draw a windows style 3D panel
002743  003000  // Syntax 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002744  003001  // Usage 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002745  003002  // Notes	: Draws a panel2 (groupbox) at screen location defined by
002746  003003  // 	: x, y, width and height with left colour "cl", right colour "cr" and option fill colour "cf".
002747  003004  // 	:  w1 and w2 define the width of the outer and inner borders.
002748  003005  // 	:         state = 0 : recessed
002749  003006  // 	:         state = 1 : raised
002750  003007  // 	: 	  or state with PANEL2_FILLED to draw the fill
002751  003008        
002752  003009  func gfx_Needle("value", "&NeedleRam", "&NeedleDef"), 0;                           // draw a needle on a meter base
002753  003010  // Syntax 	: gfx_Needle("value", "&NeedleRam", "&NeedleDef") ;
002754  003011  // Usage 	: gfx_Needle(value, NeedleRam, NeedleDef) ;
002755  003012  // Notes 	: Draw a Needle as defined by NeedleDef (if required), using NeedleRam positioning at
002756  003013  // 	: position value. See the reference for the NeedleDef values
002757  003014  //
002758  003015        
002759  003016  #CONST
002760  003038  #END
002761  003039        
002762  003040  #CONST
002763  003047  #END
002764  003048        
002765  003049  func gfx_Dial("value", "&DialRam", "&DialDef"), 0;                           // draw a Dial / knob
002766  003050  // Syntax 	: gfx_Dial("value", "&DialRam", "&DialDef") ;
002767  003051  // Usage 	: gfx_Dial(value, DialRam, DialDef) ;
002768  003052  // Notes 	: Draw a Dial as defined by DialDef (if required), using DialRam positioning at
002769  003053  // 	: position value. See the reference for the DialDef values
002770  003054  //
002771  003055        
002772  003056  #CONST
002773  003114  #END
002774  003115        
002775  003116  func gfx_Gauge("value", "&GaugeRam", "&GaugeDef"), 0;                           // draw a gauge
002776  003117  // Syntax 	: gfx_Gauge("value", "&GaugeRam", "&GaugeDef") ;
002777  003118  // Usage 	: gfx_Gauge(value, GaugeRam, GaugeDef) ;
002778  003119  // Notes 	: Draw a Gauge as defined by GaugeDef (if required), using GaugeRam positioning at
002779  003120  // 	: position value. See the reference for the GaugeDef values
002780  003121  //
002781  003122        
002782  003123  #CONST
002783  003148  #END
002784  003149        
002785  003150  // widget_* functions
002786  003151  //
002787  003152  #CONST
002788  003185  #END
002789  003186        
002790  003187  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
002791  003188  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
002792  003189  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
002793  003190  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
002794  003191  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
002795  003192  //         : to be used for rounded panels, rounded buttons, circular buttons.
002796  003193  //         : "style" specifies the drawing mode
002797  003194  //         :     GRAD_DOWN         // gradient changes in the vertical direction
002798  003195  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
002799  003196  //         :     GRAD_UP           // gradient changes in the vertical direction
002800  003197  //         :     GRAD_LEFT         // gradient change in the horizontal direction
002801  003198  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
002802  003199  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
002803  003200  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
002804  003201  // Returns : nothing.
002805  003202        
002806  003203        
002807  003204  //------------------------------------------------------------------//
002808  003205  //     gradient control constants                                   //
002809  003206  //------------------------------------------------------------------//
002810  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002811  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002812  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002813  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002814  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002815  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002816  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002817  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002818  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002819  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002820  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002821  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002822  003213        
002823  003214  #CONST
002824  003217  #END
002825  003218        
002826  003219  #CONST
002827  003251  #END
002828  003252        
002829  003253  func gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef"), 0;                           // draw a value to a series of 7 segment led Digits
002830  003254  // Syntax 	: gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef");
002831  003255  // Usage 	: gfx_LedDigits(value, LedDigitRam, LedDigitDef);
002832  003256  // Notes 	: Draw a series of 7 segment Led Digits as defined by LedDigitDef, using LedDigitRam positioning at
002833  003257  // 	: position value. See the reference for LedDigitDef values.
002834  003258  //
002835  003259        
002836  003260  func gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value"), 0;                           // draw a single 7 segment led digit
002837  003261  // Syntax 	: gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value");
002838  003262  // Usage 	: gfx_LedDigit(x, y, digitsize, oncolour, offcolour, value);
002839  003263  // Notes 	: Draws a single 7 segment led Digit at x, y of size digitsize using oncolour and offcolour.
002840  003264  // 	: The value can be 0-9 (0-9), A-F (0x0a-0x0f), blank(0x10) and - (0x11).
002841  003265  //      : Or value with LEDDIGIT_F_SHOW_DP to show a decimal point, LEDDIGIT_F_DP_COMMA to make the Decimal
002842  003266  // 	: point a comma and LEDDIGIT_F_DP_ON to turn the decimal point on
002843  003267  // 	:
002844  003268  // 	: LEDDIGIT_F_SET_SEGMENTS can be used to turn value into a series of bits to turn on individual segments
002845  003269  //      : eg LEDDIGIT_F_SET_SEGMENTS + 9 will turn on the top and bottom segments. Again LEDDIGIT_F_SHOW_DP and
002846  003270  // 	: LEDDIGIT_F_DP_COMMA can be used, but in this case the DP is the 8th segment. 
002847  003271  // Returns : nothing.
002848  003272        
002849  003273  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
002850  003274  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
002851  003275  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
002852  003276  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
002853  003277  //         : determined by "radius". 
002854  003278  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
002855  003279  // Returns : nothing.
002856  003280        
002857  003281  func putstrCentred("xc", "yc", "string"), 0;
002858  003282  // Syntax  : putstrCentred(x, y, "string"),
002859  003283  // Usage   : putstrCentred(100, 100, "HELLO");
002860  003284  // Notes   : Print a string centred at position x, y
002861  003285  //         : "String" may be a string constant, or pointer to a word aligned string.
002862  003286  // Returns : nothing.
002863  003287        
002864  003288  func widget_Create("count"), 1;
002865  003289  // Syntax 	: widget_Create("count"),
002866  003290  // Usage  	: widget_Create(count);
002867  003291  // Notes  	: Creates a widget Control capable of hoolding count elements and returns
002868  003292  //        	: a handle for the control.
002869  003293  // Returns	: Widget control handle.
002870  003294        
002871  003295  func widget_Add("hndl", "index", "widget"), 1;
002872  003296  // Syntax 	: widget_Add("hndl", "index", "widget"),
002873  003297  // Usage  	: widget_Add(hndl, index, widget);
002874  003298  // Notes  	: Add a widget ram entry "widget" into index "index" of the widget control referenced
002875  003299  //        	: by "hndl".
002876  003300  // Returns	: ssnothing.
002877  003301        
002878  003302  func widget_Delete("hndl", "index"), 1;
002879  003303  // Syntax 	: widget_Delete("hndl", "index"),
002880  003304  // Usage  	: widget_Delete(hndl, index);
002881  003305  // Notes  	: Delete widget ram entry "index" from the widget control referenced by "hndl".
002882  003306  // Returns	: sssnothing.
002883  003307        
002884  003308  func widget_Show("hndl", "index"), 1;
002885  003309  // Syntax	: widget_Show(handle, index);
002886  003310  // Usage	: display a flash resident image entry.
002887  003311  // Returns	: TRUE if successful, return value usually ignored.
002888  003312        
002889  003313  func widget_LoadFlash("Extra"), 1;
002890  003314  // Syntax	: hImagelist := widget_LoadFlash("Extra") ;
002891  003315  // Usage 	: hImagelist := widget_LoadFlash(0);
002892  003316  // Notes	: Reads the flash control file to create an widget list.
002893  003317  //      	: Returns NULL if function fails.
002894  003318  //      	: Returns a handle (pointer to the memory allocation) to the
002895  003319  //      	: widget control list that has been created.
002896  003320  //      	: "Extra" is the number of extra widget controls to be created
002897  003321  //      	: beyond the count in flash memory
002898  003322  // Returns 	: pointer to Widget control, or null if failed.
002899  003323        
002900  003324  func widget_Realloc("handle", "n"), 1;
002901  003325  // Syntax	: widget_Realloc(handle, n);
002902  003326  // Usage 	: Resizes a widget control to contain n entries, allowing it to be expanded or
002903  003327  //      	: condensed. Doing this unnecessarily can lead to RAM fragmentation. It is
002904  003328  //             	: much better to allocate widget controls once with the desired number of entries.
002905  003329  // Returns	: new handle to widget control.
002906  003330        
002907  003331  func widget_GetWord("hndl", "index", "offset"), 1;
002908  003332  // Syntax	: myvar := widget_GetWord("handle", "index", "offset");
002909  003333  // Usage 	: myvar := widget_GetWord(hndl, 5, WIDGET_YPOS);
002910  003334  // Notes 	: returns specified word (0-14) from a widget entry
002911  003335  //       	: refer to widget control entry offsets.
002912  003336        
002913  003337  func widget_Setposition("hndl", "index", "xpos", "ypos"), 1;
002914  003338  // Syntax	: widget_SetPosition(handle, index, xpos, ypos);
002915  003339  // Usage 	: r := widget_SetPosition(hImageList, imagenum, x, y);
002916  003340  // Notes 	: set the position of the widget control
002917  003341  //       	: returns true if index was ok and function was successful.
002918  003342        
002919  003343  func widget_Enable("hndl", "index"), 1;
002920  003344  // Syntax	: widget_Enable(handle, index);
002921  003345  // Usage 	: r := widget_Enable(hImageList, imagenum);
002922  003346  // Notes 	: enable an item in a widget control.
002923  003347  // Returns     	: true if index was ok and function was successful.
002924  003348        
002925  003349  func widget_Disable("hndl", "index"), 1;
002926  003350  // Syntax	: widget_Disable(handle, index);
002927  003351  // Usage 	: r := widget_Disable(hImageList, imagenum);
002928  003352  // Notes 	: disable an inetm in a widget control.
002929  003353  // Returns      : true if index was ok and function was successful.
002930  003354        
002931  003355  func widget_SetWord("hndl", "index", "offset", "value"), 1;
002932  003356  // Syntax: widget_SetWord(handle, index, offset, word);
002933  003357  // Usage : widget_SetWord(hndl, 5, IMAGE_XPOS, 10);
002934  003358  // Notes : set specified word (0-7) in a image entry
002935  003359  //       : returns TRUE if successful, return value usually ignored.
002936  003360        
002937  003361  func widget_SetAttributes("hndl", "index", "value"), 1;
002938  003362  // Syntax: widget_SetAttributes("handle", "index","offset");
002939  003363  // Usage : widget_SetAttributes(hndl, 5, I_TOPMOST);
002940  003364  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
002941  003365  //       : of an image control entry. "value" refers to various bits in
002942  003366  //       : the image control entry (see image attribute flags).
002943  003367  //       : A '1' bit in the "value" field SETS the respective bit
002944  003368  //       : in the IMAGE_FLAGS field of the image control entry.
002945  003369  //       : returns TRUE if successful, return value usually ignored.
002946  003370        
002947  003371  func widget_ClearAttributes("hndl", "index", "value"), 1;
002948  003372  // Syntax: widget_ClearAttributes("handle", "index","offset");
002949  003373  // Usage : widget_ClearAttributes(hndl, 5, I_TOPMOST);
002950  003374  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
002951  003375  //       : of an image control entry. "value" refers to various bits in
002952  003376  //       : the image control entry (see image attribute flags)
002953  003377  //       : a '1' bit in the "value" field CLEARS the respective bit
002954  003378  //       : in the IMAGE_FLAGS field of the image control entry.
002955  003379  //       : returns TRUE if successful, return value usually ignored.
002956  003380        
002957  003381  func widget_Touched("hndl", "index"), 1;
002958  003382  // Syntax: r := widget_Touched(handle, index);
002959  003383  // Usage : widget_Touched(hndl, 17);
002960  003384  //       : returns -1 if image not touched, or returns index
002961  003385  // Notes : if index is passed as -1, function tests all images,
002962  003386  //       : and returns -1 if image not touched, or returns index.
002963  003387        
002964  003388  func widget_FontID("id"), 1;                   // text font ID for flash based font
002965  003389  // Syntax: widget_FontID(id);
002966  003390  // Usage : widget_FontID(0);
002967  003391  //       : returns id of previous font
002968  003392        
002969  003393  #CONST
002970  003431  #END
002971  003432        
002972  003433  func gfx_Slider5("value", "&SliderRam", "&SliderDef"), 0;                           // draw a slider
002973  003434  // Syntax 	: gfx_Slider5("value", "&SliderRam", "&SliderDef") ;
002974  003435  // Usage 	: gfx_Slider5(value, SliderRam, SliderDef) ;
002975  003436  // Notes 	: Draw a Slider as defined by SliderDef (if required), using SliderRam positioning at
002976  003437  // 	: position value. See the reference for the SliderDef values
002977  003438  //
002978  003439        
002979  003440  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
002980  003441  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
002981  003442  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
002982  003443  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
002983  003444  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
002984  003445  //         : If "radius1" is zero, the inner rectangle will have square corners.
002985  003446  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
002986  003447  // Returns : nothing.
002987  003448        
002988  003449  /////////////////////
002989  003450  #CONST
002990  003469  #END
002991  003470        
002992  003471  func gfx_Switch("state", "&SwitchRam", "&SwitchDef"), 0;                           // draw a switch
002993  003472  // Syntax 	: gfx_Switch("state", "&SwitchRam", "&SwitchDef") ;
002994  003473  // Usage 	: gfx_Switch(state, SwitchRam, SwitchDef) ;
002995  003474  // Notes 	: Draw a Switch as defined by SwitchDef (if required), using SwitchRam positioning at
002996  003475  // 	: position value. See the reference for the SwitchDef values
002997  003476  //
002998  003477        
002999  003478  #CONST
003000  003507  #END
003001  003508        
003002  003509  func gfx_Button4("state", "&gfx_ButtonRam", "&gfx_ButtonDef"), 0;                           // draw a button
003003  003510  // Syntax 	: gfx_Button4("state", "&ButtonRam", "&ButtonDef") ;
003004  003511  // Usage 	: gfx_Button4(state, ButtonRam, ButtonDef) ;
003005  003512  // Notes 	: Draw a Button as defined by ButtonDef (if required), using ButtonRam positioning at
003006  003513  // 	: position value. See the reference for the ButtonDef values
003007  003514  //
003008  003515        
003009  003516  #CONST
003010  003531  #END
003011  003532        
003012  003533  func gfx_Led("state", "&LedRam", "&LedDef"), 0;                           // draw an LED
003013  003534  // Syntax 	: gfx_Led("state", "&LedRam", "&LedDef") ;
003014  003535  // Usage 	: gfx_Led(state, LedRam, LedDef) ;
003015  003536  // Notes 	: Draw a Led as defined by LedDef (if required), using LedRam positioning in
003016  003537  // 	: state state. See the reference for the LedDef values
003017  003538  //
003018  003539        
003019  003540  #CONST
003020  003558  #END
003021  003559  #CONST
003022  003577  #END
003023  003578        
003024  003579  func gfx_Scale("&ScaleRam", "&ScaleDef"), 0;                           // draw a Scale
003025  003580  // Syntax 	: gfx_Scale("&ScaleRam", "&ScaleDef") ;
003026  003581  // Usage 	: gfx_Scale(ScaleRam, ScaleDef) ;
003027  003582  // Notes 	: Draw a Scale as defined by ScaleDef, setting LedRam for use in touch processing.
003028  003583  // 	: See the reference for the ScaleDef values. If touch processing is not required 0 may be used as the SclaleRam parameter.
003029  003584  //
003030  003585        
003031  003586  #CONST
003032  003590  #END
003033  003591        
003034  003592  #CONST
003035  003612  #END
003036  003613        
003037  003614  func gfx_RulerGauge("state", "&RulerGaugeRam", "&RulerGaugeDef"), 0;                           // draw a Ruler Gauge
003038  003615  // Syntax 	: gfx_Led("position", "&RulerGaugeRam", "&RulerGaugeDef") ;
003039  003616  // Usage 	: gfx_Led(position, RulerGaugeRam, RulerGaugeDef) ;
003040  003617  // Notes 	: Draw a RulerGauge as defined by RulerGaugeDef (if required), using RulerGaugeRam positioning at
003041  003618  // 	: position value. See the reference for the RulerGaugeDef values
003042  003619  //
003043  003620        
003044  003621  #CONST
003045  003631  #END
003046  003632        
003047  003633  func file_CheckUpdate("Filename", "Options"), 1;                           // check and/or update the program running in Flash
003048  003634  // Syntax 	: file_CheckUpdate("Filename", "Options") ;
003049  003635  // Usage 	: file_CheckUpdate("thisfile.4xe", CheckUpdate_Check) ;
003050  003636  // Notes 	: Check and/or update the program running in flash using the specified file on uSD.
003051  003637  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003052  003638  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003053  003639  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003054  003640  //
003055  003641  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003056  003642  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003057  003643  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003058  003644  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003059  003645  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003060  003646  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003061  003647        
003062  003648  func udiv_3232("res32", "val1", "val2"), 1;
003063  003649  // Syntax   : udiv_1616(res32, varA, varB);
003064  003650  // Input    : DWORD *result   points to 32bit result register.
003065  003651  //          : DWORD   val1  pointer to 32bit value (dividend)
003066  003652  //          : DWORD   val2  pointer to 32bit value (divisor)
003067  003653  // Usage    : var res32[2];
003068  003654  //          : umul_1616(res32, myvar, 50000);
003069  003655  // Notes    : performs an unsigned division of 2 x 32bit values
003070  003656  //          : placing the 32bit result in a 2 word array.
003071  003657  // Returns  : the pointer to the 32bit result.
003072  003658  //          : carry and overflow are not affected.
003073  003659        
003074  003660  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
003075  003661  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
003076  003662  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
003077  003663  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
003078  003664  //         : "style" specifies the drawing mode
003079  003665  //         :     GRAD_DOWN         // gradient changes in the vertical direction
003080  003666  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
003081  003667  //         :     GRAD_UP           // gradient changes in the vertical direction
003082  003668  //         :     GRAD_LEFT         // gradient change in the horizontal direction
003083  003669  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
003084  003670  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
003085  003671  // Returns : nothing.
003086  003672        
003087  003673  func I2C2_Open("speed"), 1;
003088  003674  // Syntax : I2C2_Openx(speed),
003089  003675  // Usage  : I2C2_Open(I2C_MED);
003090  003676  // Notes : configures the I2C1 module
003091  003677  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003092  003678  // Returns: True if successful
003093  003679        
003094  003680        
003095  003681  func I2C3_Open("speed"), 1;
003096  003682  // Syntax : I2C3_Openx(speed),
003097  003683  // Usage  : I2C3_Open(I2C_MED);
003098  003684  // Notes : configures the I2C1 module
003099  003685  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003100  003686  // Returns: True if successful
003101  003687        
003102  003688  func I2C2_Close(), 0;
003103  003689  // Usage : I2C2_Close();
003104  003690  // Notes : disables the I2C2 module.
003105  003691        
003106  003692  func I2C3_Close(), 0;
003107  003693  // Usage : I2C3_Close();
003108  003694  // Notes : disables the I2C3 module.
003109  003695        
003110  003696  func I2C2_Start(), 1;
003111  003697  // Syntax: I2C2_Start();
003112  003698  // Usage : I2C2_Start();
003113  003699  // Notes : generates a Start condition.
003114  003700  //       : returns true if successful (usually ignored)
003115  003701        
003116  003702  func I2C3_Start(), 1;
003117  003703  // Syntax: I2C3_Start();
003118  003704  // Usage : I2C3_Start();
003119  003705  // Notes : generates a Start condition.
003120  003706  //       : returns true if successful (usually ignored)
003121  003707        
003122  003708  func I2C2_Stop(), 1;
003123  003709  // Syntax: I2C2_Stop();
003124  003710  // Usage : I2C2_Stop();
003125  003711  // Notes : generates a Stop condition.
003126  003712  //       : returns true if successful (usually ignored)
003127  003713        
003128  003714  func I2C3_Stop(), 1;
003129  003715  // Syntax: I2C3_Stop();
003130  003716  // Usage : I2C3_Stop();
003131  003717  // Notes : generates a Stop condition.
003132  003718  //       : returns true if successful (usually ignored)
003133  003719        
003134  003720  func I2C2_Restart(), 1;
003135  003721  // Syntax: I2C2_Restart();
003136  003722  // Usage : I2C2_Restart();
003137  003723  // Notes : generates a Restart condition.
003138  003724  //       : returns true if successful (usually ignored)
003139  003725        
003140  003726  func I2C3_Restart(), 1;
003141  003727  // Syntax: I2C3_Restart();
003142  003728  // Usage : I2C3_Restart();
003143  003729  // Notes : generates a Restart condition.
003144  003730  //       : returns true if successful (usually ignored)
003145  003731        
003146  003732  func I2C2_Read(), 1;
003147  003733  // Syntax: I2C2_Read();
003148  003734  // Usage : ch := I2C2_Read();
003149  003735  // Notes : reads a single byte from the I2C Bus.
003150  003736        
003151  003737  func I2C3_Read(), 1;
003152  003738  // Syntax: I2C3_Read();
003153  003739  // Usage : ch := I2C3_Read();
003154  003740  // Notes : reads a single byte from the I2C Bus.
003155  003741        
003156  003742  func I2C2_Write("byte"), 1;
003157  003743  // Syntax: I2C2_Write(byte);
003158  003744  // Usage : r := I2C2_Write(ch);
003159  003745  // Notes : is used to write a byte to the I2C bus.
003160  003746  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003161  003747        
003162  003748  func I2C3_Write("byte"), 1;
003163  003749  // Syntax: I2C3_Write(byte);
003164  003750  // Usage : r := I2C3_Write(ch);
003165  003751  // Notes : is used to write a byte to the I2C bus.
003166  003752  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003167  003753        
003168  003754  func I2C2_Ack(), 0;
003169  003755  // Syntax: I2C2_Ack();
003170  003756  // Usage : I2C2_Ack();
003171  003757  // Notes : generates the acknowledge condition.
003172  003758        
003173  003759  func I2C3_Ack(), 0;
003174  003760  // Syntax: I2C3_Ack();
003175  003761  // Usage : I2C3_Ack();
003176  003762  // Notes : generates the acknowledge condition.
003177  003763        
003178  003764  func I2C2_Nack(), 0;
003179  003765  // Syntax: I2C2_Nack();
003180  003766  // Usage : I2C2_Nack();
003181  003767  // Notes : generates the negative acknowledge condition.
003182  003768        
003183  003769  func I2C3_Nack(), 0;
003184  003770  // Syntax: I2C3_Nack();
003185  003771  // Usage : I2C3_Nack();
003186  003772  // Notes : generates the negative acknowledge condition.
003187  003773        
003188  003774  func I2C2_AckStatus(), 1;
003189  003775  // Syntax: I2C2_AckStatus();
003190  003776  // Usage : r := I2C2_AckStatus();
003191  003777  // Notes : returns the ACK status from the device.
003192  003778        
003193  003779  func I2C3_AckStatus(), 1;
003194  003780  // Syntax: I2C3_AckStatus();
003195  003781  // Usage : r := I2C3_AckStatus();
003196  003782  // Notes : returns the ACK status from the device.
003197  003783        
003198  003784  func I2C2_AckPoll("control"), 1;
003199  003785  // Syntax: I2C2_AckPoll();
003200  003786  // Usage : r := I2C2_AckPoll(0xA0);
003201  003787  // Notes : waits for a device to return from ACK polling.
003202  003788        
003203  003789  func I2C3_AckPoll("control"), 1;
003204  003790  // Syntax: I2C3_AckPoll();
003205  003791  // Usage : r := I2C3_AckPoll(0xA0);
003206  003792  // Notes : waits for a device to return from ACK polling.
003207  003793        
003208  003794  func I2C2_Idle(), 1;
003209  003795  // Syntax : I2C2_Idle();
003210  003796  // Usage  : r := I2C2_Idle();
003211  003797  // Notes  : waits until the I2C Bus is Inactive.
003212  003798  //        : Times out if bus not idle within 1 second
003213  003799  // Returns: TRUE if successful, else failed (timed out)
003214  003800        
003215  003801  func I2C3_Idle(), 1;
003216  003802  // Syntax : I2C3_Idle();
003217  003803  // Usage  : r := I2C3_Idle();
003218  003804  // Notes  : waits until the I2C Bus is Inactive.
003219  003805  //        : Times out if bus not idle within 1 second
003220  003806  // Returns: TRUE if successful, else failed (timed out)
003221  003807        
003222  003808  func I2C2_Gets("buffer", "size"), 1;
003223  003809  // Syntax: I2C2_Gets("buffer", "size");
003224  003810  // Usage : r := I2C2_Gets(mybuf, 16);
003225  003811  // Notes : only reads up to "size" characters into "buffer"
003226  003812  //       : Reads up to asciiz terminator including terminator
003227  003813        
003228  003814  func I2C3_Gets("buffer", "size"), 1;
003229  003815  // Syntax: I2C3_Gets("buffer", "size");
003230  003816  // Usage : r := I2C3_Gets(mybuf, 16);
003231  003817  // Notes : only reads up to "size" characters into "buffer"
003232  003818  //       : Reads up to asciiz terminator including terminator
003233  003819        
003234  003820  func I2C2_Getn("buffer", "size"), 1;
003235  003821  // Syntax: I2C2_Gets("buffer", "size");
003236  003822  // Usage : r := I2C2_Gets(mybuf, 16);
003237  003823  // Notes : reads "size" bytes into "buffer"
003238  003824  //       :
003239  003825        
003240  003826  func I2C3_Getn("buffer", "size"), 1;
003241  003827  // Syntax: I2C3_Gets("buffer", "size");
003242  003828  // Usage : r := I2C3_Gets(mybuf, 16);
003243  003829  // Notes : reads "size" bytes into "buffer"
003244  003830  //       :
003245  003831        
003246  003832  func I2C2_Puts("buffer"), 1;
003247  003833  // Syntax: I2C2_Puts("buffer");
003248  003834  // Usage : r := I2C2_Puts(mybuf);
003249  003835  // Notes : writes an asciiz string to the I2C device
003250  003836  //       : returns count of characters written
003251  003837        
003252  003838  func I2C3_Puts("buffer"), 1;
003253  003839  // Syntax: I2C3_Puts("buffer");
003254  003840  // Usage : r := I2C3_Puts(mybuf);
003255  003841  // Notes : writes an asciiz string to the I2C device
003256  003842  //       : returns count of characters written
003257  003843        
003258  003844  func I2C2_Putn("buffer", "count"), 1;
003259  003845  // Syntax: I2C2_Putn("buffer","count");
003260  003846  // Usage : r := I2C2_Puts(mybuf,10);
003261  003847  // Notes : writes up to "size" bytes to the I2C device
003262  003848  //       : returns number of bytes written
003263  003849        
003264  003850  func I2C3_Putn("buffer", "count"), 1;
003265  003851  // Syntax: I2C3_Putn("buffer","count");
003266  003852  // Usage : r := I2C3_Puts(mybuf,10);
003267  003853  // Notes : writes up to "size" bytes to the I2C device
003268  003854  //       : returns number of bytes written
003269  003855        
003270  003856  func gfx_XYrotToVal("x","y","base","mina","maxa","minv","maxv"), 1;         // convert a rotational x/y postion to a value
003271  003857  // Usage	: gfx_XYrotToVal(x,y,XYROT_EAST,starta,enda,minv,maxv)
003272  003858  // Notes	: Convert a rotational angle into a value
003273  003859  // 	: Calculates a position for a rotary input starting at mina and continuing to maxa. both angles must be greater than 0.
003274  003860  // 	: Base can be XYROT_EAST, used for internal widgets, or XYROT_SOUTH, used for GCI widgets.
003275  003861  // 	: Returns a value from minv to maxv
003276  003862        
003277  003863  func gfx_XYlinToVal("x","y","base","minpos","maxpos","minv","maxv"), 1;         // convert a linear x/y postion to a value
003278  003864  // Usage	: gfx_XYrotToVal(x,y,XYLIN_X,startp,endp,minv,maxv)
003279  003865  // Notes	: Convert a linear position into a value
003280  003866  // 	: Calculates a position for a linear input starting at minpos and continuing to maxpos. 
003281  003867  // 	: Base can be XYLIN_X, to use the x value for calculations, or XYLIN_Y, to use the y value.
003282  003868  // 	: Returns a value from minv to maxv
003283  003869        
003284  003870  func media_InitSpeed("Speed"), 1;                     // initialize uSD card at a given speed
003285  003871  // Usage	: media_Init(SPI_SPEED15);
003286  003872  // Notes	: Initialise uSD CARD at a specified speed
003287  003873  // 	: Response: 0 = No Card
003288  003874  // 	:           1 = Card Initialised
003289  003875  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003290  003876        
003291  003877  func file_MountSpeed("Speed"), 1;                     // mount a uSD card at a given speed
003292  003878  // Syntax	: r := file_Mount(SPI_SPEED15);
003293  003879  // Usage	: r := file_Mount(SPI_SPEED15);
003294  003880  // Notes	: Create a control block for FAT16 and mount the File System at the specified speed
003295  003881  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003296  003882        
003297  003883  func img_FileRead("*dest", "size", "handle", "index"), 1;
003298  003884  // Syntax: res := img_FileRead("*dest", "size", "handle", "index"),
003299  003885  // Usage : res := img_FileRead(memblock,20,hnd1);
003300  003886  // Notes : returns number of characters read
003301  003887  //       : if "dest" is zero, data is read direct to GRAM window
003302  003888  //       :
003303  003889        
003304  003890  func img_FileSeek("handle", "index", "HiWord", "LoWord"), 1;
003305  003891  // Syntax: res := img_FileSeek("handle", "index", "HiWord", "LoWord")
003306  003892  // Usage : res := img_FileSeek(hSource, 0, 0x1234);
003307  003893  // Notes : set file position to 0x00001234 (byte position 4660)
003308  003894  //       : for the file handle so subsequent data may be read
003309  003895  //       : from that position onwards with img_FileGetC(...),
003310  003896  //       : img_FileGetW(...) or img_FileGetS(...)
003311  003897  // Notes : returns true if ok, usually ignored
003312  003898        
003313  003899  func img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003314  003900  // Syntax: img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003315  003901  // Usage : res := img_FileIndex(hsource, 0, 1000, 123), 1;
003316  003902  // Notes : set file seek position to 123000
003317  003903  //       : for the file handle so subsequent data may be read
003318  003904  //       : from that record position onwards with img_FileGetC(...),
003319  003905  //       : img_FileGetW(...) or img_FileGetS(...)
003320  003906  // Notes : returns true if ok, usually ignored
003321  003907        
003322  003908  func img_FileTell("handle", "index", "&HiWord", "&LoWord"), 1;
003323  003909  // Syntax: img_FileTell("handle", "index", &HiWord, &LoWord);
003324  003910  // Usage : img_FileTell(fhndl, &SizeHi, &SizeLo);
003325  003911  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003326  003912  //       : returns true if function succeeded
003327  003913        
003328  003914  func img_FileSize("handle", "index", "&HiWord", "&LoWord"), 1;
003329  003915  // Syntax: img_FileSize("handle", "index", &HiWord, &LoWord);
003330  003916  // Usage : img_FileSize(fhndl, &SizeHi, &SizeLo);
003331  003917  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003332  003918  //       : returns true if function succeeded
003333  003919        
003334  003920  func img_FileGetC("handle", "index"), 1;
003335  003921  // Syntax: img_FileGetC("handle", "index");
003336  003922  // Usage : mychar := fgetC("handle", "index");
003337  003923  // Notes : returns next char from file
003338  003924        
003339  003925  func img_FileGetW("handle", "index"), 1;
003340  003926  // Syntax: img_FileGetW("handle", "index");
003341  003927  // Usage : myword := fgetW("handle", "index");
003342  003928  // Notes : returns next word in file
003343  003929        
003344  003930  func img_FileGetS("*string", "size", "handle", "index"), 1;
003345  003931  // Syntax: res := img_FileGets("*string", "size", "handle", "index");
003346  003932  // Usage : res := img_FileGets(mystr , 81, hnd1); // read up to 80 chars
003347  003933  // Notes : get a string from a file
003348  003934  //       : returns pointer to string or null if failed.
003349  003935  //       : img_FileGetS(...) automatically appends a null-terminator to the data read.
003350  003936  //       : NB:- only reads up to "size-1" characters into "string"
003351  003937  //       : img_FileGetS(...) will stop reading when any of the following conditions are true:
003352  003938  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003353  003939  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003354  003940  //       : C] It reaches the end of file
003355  003941  //       : D] A read error occurs.
003356  003942        
003357  003943  func img_FileRewind("handle", "index"), 1;
003358  003944  // Syntax: res := img_FileRewind("handle", "index");
003359  003945  // Usage : res := img_FileRewind(hnd1);
003360  003946  // Notes : returns true if file rewound ok (usually ignored)
003361  003947  //       : resets the file pointer the the beginning of the open file.
003362  003948        
003363  003949  func img_FileLoadFunction("handle", "index"), 1;
003364  003950  // Syntax: res := img_FileLoadFunction("handle", "index");
003365  003951  // Usage : myfunc := img_FileLoadFunction("handle", "index");
003366  003952  // Notes : Load a function or program from disk and
003367  003953  //       : return a function pointer to the allocation.
003368  003954  //       : The function can then be invoked just like any other
003369  003955  //       : function would be called via a function pointer.
003370  003956  //       : Parameters may be passed to it in a conventional way.
003371  003957  //       : The function may be discarded at any time when no
003372  003958  //       : longer required, thus freeing its memory resources.
003373  003959  //       : The loaded function can be discarded with mem_Free(..)
003374  003960  //       : eg:
003375  003961  //       : popupWindow := img_FileLoadFunction("handle", "index");
003376  003962  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003377  003963  //       : then elsewhere in your program:-
003378  003964  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003379  003965  //       : if(res == QUIT_APPLICATION) goto exitApp;
003380  003966  //       : Later in your program, when popupWindow is no longer
003381  003967  //       : required for the application:-
003382  003968  //       : res := mem_Free(popupWindow);
003383  003969  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003384  003970  //       : The callers stack is shared by the loaded function,
003385  003971  //       : however any global variables in the loaded function
003386  003972  //       : are private to that function.
003387  003973  //
003388  003974        
003389  003975  func img_FileRun("handle", "index", "arglistptr"), 1;
003390  003976  // Syntax: res := img_FileRun("handle", "index","arglistptr");
003391  003977  // Usage : res := img_FileRun("handle", "index", argptr);
003392  003978  // Notes : current program releases any allocated memory but
003393  003979  //       : retains the stack and global memory.
003394  003980  //       : If arglistptr is 0, no arguments are passed, else
003395  003981  //       : arglist points to an array, the first element being
003396  003982  //       : the number of elements in the array.
003397  003983  //       : func 'main' in the called program accepts
003398  003984  //       : the arguments, if any. THe arguments can only
003399  003985  //       : be passed by value, no pointers or references can be
003400  003986  //       : used as all memory is cleared before the file
003401  003987  //       : is loaded. Refer to img_FileExec and img_FileLoadFunction
003402  003988  //       : for functions that can pass by reference.
003403  003989        
003404  003990  func img_FileExec("handle", "index", "arglistptr"), 1;
003405  003991  // Syntax: res := img_FileExec("handle", "index","arglistptr");
003406  003992  // Usage : res := img_FileExec("handle", "index","arglistptr");
003407  003993  // Notes : returns like a function, current program
003408  003994  //       : calling program is kept active and control returns to it.
003409  003995  //       : If arglistptr is 0, no arguments are passed, else
003410  003996  //       : arglist points to an array, the first element being
003411  003997  //       : the number of elements in the array.
003412  003998  //       : func 'main' in the called program accepts the arguments.
003413  003999  //       : This function is similar to img_FileLoadFunction(...), however,
003414  004000  //       : the function argument list is passed by pointer, and
003415  004001  //       : the memory consumed by the function is released as
003416  004002  //       : soon as the function completes.
003417  004003        
003418  004004  func img_FilePlayWAV("handle", "index"), 1;
003419  004005  // Syntax: img_FilePlayWAV("handle", "index");
003420  004006  // Usage : img_FilePlayWAV("handle", "index");
003421  004007  // Notes : Play a wave file at index "index" in the filesystem "handle"
003422  004008  //       : This function automatically grabs a chunk
003423  004009  //       : of memory for a file buffer, and a wave
003424  004010  //       : buffer. The minimum memory requirement is
003425  004011  //       : about 580 bytes for the disk io service and
003426  004012  //       : a minimum wave buffer size of 1024. The siz
003427  004013  //       : of the wave buffer allocation
003428  004014  //       : can be increased by the snd_BufSize function.
003429  004015  //       : The default size 1024 bytes.
003430  004016  //       : NB the memory is only required during the
003431  004017  //       : duration of play, and is automatically
003432  004018  //       : released while not in use.
003433  004019  //       : See the Sound Class services for other associated controls.
003434  004020  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003435  004021  //       : If errors occured, the folling is returned
003436  004022  //       : -7  : Insufficient memory available for WAV buffer and file
003437  004023  //       : -6  : cant play this rate
003438  004024  //       : -5  : no data chunk found in first rsector
003439  004025  //       : -4  : no format data
003440  004026  //       : -3  : no wave chunk signature
003441  004027  //       : -2  : bad wave file format
003442  004028  //       : -1  : file not found
003443  004029        
003444  004030  func img_TxtFontID("handle", "index"), 1;                   // 2  text font ID (0 = system font)
003445  004031  // Syntax: img_TxtFontID("handle", "index");
003446  004032  // Usage : img_TxtFontID("handle", "index");
003447  004033  // Notes : Set the font to a font held in the image file system
003448  004034        
003449  004035  func img_FileCheckUpdate("handle", "index", "Options"), 1;                           // check and/or update the program running in Flash
003450  004036  // Syntax 	: img_FileCheckUpdate("handle", "index", "Options") ;
003451  004037  // Usage 	: img_FileCheckUpdate("handle", "index", CheckUpdate_Check) ;
003452  004038  // Notes 	: Check and/or update the program running in flash using the specified file in Flash memory.
003453  004039  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003454  004040  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003455  004041  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003456  004042  //
003457  004043  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003458  004044  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003459  004045  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003460  004046  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003461  004047  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003462  004048  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003463  004049        
003464  004050  func flash_Block32Erase(), 1;            // erase the required 32k flash block
003465  004051  // Syntax	: flash_Block32Erase();
003466  004052  // Usage	: flash_Block32Erase();
003467  004053  // Notes	: Erase the 32KB flash block including the currently set address
003468  004054  // 	: This uses the 0x52 command.
003469  004055        
003470  004056  func flash_Sector4Erase(), 1;            // erase the required 4k flash sector
003471  004057  // Syntax: flash_Sector4Erase();
003472  004058  // Usage : flash_Sector4Erase();
003473  004059  // Notes	: Erase the 4KB flash sector including the currently set address
003474  004060  // 	: This uses the 0x20 command.
003475  004061        
003476  004062  func com_Mode("8" ,"N", "1", "comport"), 1 ;
003477  004063  // Syntax	: comx_Mode("databits", "parity", "Stopbits", "comport");
003478  004064  // Usage	: comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
003479  004065  // *Notes	: Data Bits must be 8
003480  004066  // 	: Parity may be 'N', 'O' or 'E'.
003481  004067  // 	: Stop Bits may be 1 or 2.
003482  004068  // 	: returns true if mode was acceptable
003483  004069        
003484  004070  func img_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in a Flash GCI
003485  004071  // Syntax: img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003486  004072  // Usage : img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003487  004073  // Notes	: Load and call the Function found at index "idx" in the Flash GCI identified by "Hndl". 
003488  004074  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003489  004075  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003490  004076  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003491  004077  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003492  004078  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003493  004079  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003494  004080  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003495  004081  // 	: Returns 0 if successful.
003496  004082        
003497  004083  func img_FunctionFreeCache("handle"), 0 ;                                 // Free all cached Flash GCI Functions 
003498  004084  // Syntax: img_FunctionFreeCache(hndl);
003499  004085  // Usage : img_FunctionFreeCache(hndl);
003500  004086  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003501  004087  // 	: Flash GCI.
003502  004088        
003503  004089  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
003504  004090  // *Notes   : (if you calculate all of the incoming data
003505  004091  //          : INCLUDING the CRC, the result should be 0x00
003506  004092  //          : This is equivalent to simple addition of all bytes
003507  004093  //          : and returning the negated sum an 8 bit value.
003508  004094  //          : For the standard test string "123456789",
003509  004095  //          : crc_CSUM_8 will return 0x0023.
003510  004096        
003511  004097  func gfx_GradientShape("GradientRAM", "HorzVert", "OuterWidth", "X", "Y", "W", "H", "TLrad", "TRrad", "BLrad", "BRrad", "Darken", "OuterColor", "OuterType", "OuterLevel", "InnerColor", "InnerType", "InnerLevel", "Split"), 0 ;
003512  004098  // Syntax 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003513  004099  // Usage 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003514  004100  // Notes 	: Produce a shaped color gradient using the supplied parameters.0
003515  004101  // 	: GradientRAM	This Function requires a quantity or RAM to work. It also needs to be initialised and it's size varies accoring to the largest corner radius. Multiple gradient shape calls can
003516  004102  // 	: 	share the same GradientRAM. eg gradientRAM[29+91*2] := [-1,-1,-9999,0,0,91] ;  Would support a maximum radius of 90 degrees, note the 91 in two places.
003517  004103  // 	: HorzVert	Horizontal or Vertical -- 0 or 1
003518  004104  // 	: OuterWidth	Outer gradient width 0 to ...
003519  004105  // 	: X	x co-ordinate
003520  004106  // 	: Y	y co-ordinate
003521  004107  // 	: W	width
003522  004108  // 	: H	height
003523  004109  // 	: LTrad	Top left corner radius
003524  004110  // 	: TRrad	Top right corner radius
003525  004111  // 	: BLrad	Bottom left radius
003526  004112  // 	: BRrad	Bottom right radius
003527  004113  // 	: Darken	Darken both colours by a value. Can be a -ve value to lighten
003528  004114  // 	: OuterCol	Outer Gradient colour
003529  004115  // 	: OuterType	Outer Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003530  004116  // 	: OuterLevel	Outer Gradient level 0 - 63
003531  004117  // 	: InnerCol	Inner Gradient colour
003532  004118  // 	: InnerType	Inner Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003533  004119  // 	: InnerLevel	Inner Gradient level 0 - 63
003534  004120  // 	: Split	Split gradient, 0 - no split, 1 - top, 2 - bottom 
003535  004121  // 
003536  004122  // Returns	: nothing
003537  004123        
003538  004124        
003539  004125  func gfx_GradientColor("Type", "Darken", "Level", "H", "Pos", "Color"), 1 ;
003540  004126  // Syntax 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003541  004127  // Usage 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003542  004128  // Notes 	: Given the parameters, adjust the input color to produce the output color.
003543  004129  // 	: Type	Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003544  004130  // 	: Darken	Darken colour by a value. Can be a -ve value to lighten
003545  004131  // 	: Level	Gradient level 0 - 63
003546  004132  // 	: H	Height of the object that gradient is applied
003547  004133  // 	: Pos	Position in the height that gradient is calculated
003548  004134  // 	: Color	Source colour that gradient is applied to
003549  004135  // 
003550  004136  // Returns	: Color after Adjustment.
003551  004137        
003552  004138  func gfx_GradTriangleFilled("X0", "Y0", "X1", "Y1", "X2", "Y2", "SolidCol", "GradientCol", "GradientHeight", "GradientY", "GradientLevel", "Type"), 0;
003553  004139  // Syntax 	: gfx_GradTriangleFilled(X0, Y0, X1, Y1, X2, Y2, SolidCol, GradientCol, GradientHeight, GradientY, GradientLevel, Type);
003554  004140  // Usage 	: gfx_GradTriangleFilled(10, 10, 10, 100, 100, 100 ,YELLOW, DARKKHAKI, 100, 10, 30, 1);
003555  004141  // Notes 	: Produce a triangle with or without a gradient.
003556  004142  // 	: X0	First triangle point x coordinate
003557  004143  // 	: Y0	First triangle point y coordinate
003558  004144  // 	: X1	Second triangle point x coordinate
003559  004145  // 	: Y1	Second triangle point y coordinate
003560  004146  // 	: X2	Third triangle point x coordinate
003561  004147  // 	: Y2	Third triangle point y coordinate
003562  004148  // 	: SolidCol	Colour that will be used if the Solid or Gradient parameter is set to 0
003563  004149  // 	: GradientCol	Colour that will be used if the Solid or Gradient parameter is set to 1
003564  004150  // 	: GradientHeight	Height of the area that the gradient will be calculated. Can be larger than the triangle
003565  004151  // 	: GradientY	Position on the Y axis that the gradient will be calculated from with respect to triangle position
003566  004152  // 	: GradientLevel	Level of gradient applied
003567  004153  // 	: Type	Select wether solid triangle or gardient triangle is drawn. 
003568  004154        
003569  004155  func media_InitFlash("Command"), 1;                    // initialize Flash Memory
003570  004156  // Usage	: media_InitFlash();
003571  004157  // Notes	: Initialise Flash Memory 
003572  004158  // 	: Response: 0 = Normally ignored, but should be 0
003573  004159  // 	:           1 = a uSD Card has been Initialised, you should not use this command for uSD cards
003574  004160  // 	: Note that for systems with SPI Flash the response will be 0, however, this function needs to be called to 
003575  004161  // 	: init the Flash memory chip.
003576  004162  // 	: Command	The command used to set the flash memory into 4 byte addressing mode
003577  004163  // 	: FLASH_ADDR_DEF_COMMAND	The default command will be used (0xB7)
003578  004164  // 	: FLASH_ADDR_ALWAYS_4BYTE	No command will be sent (for chips permantly in 4 byte mode)
003579  004165  // 	: else this command will be sent to enter 4 Byte Addressing mode, if the capacity of the chip appears to
003580  004166  // 	: be greater than 16MB. Requires the JEDEC approved response to the 'FLASH READ ID' (0x9F) command.
003581  004167        
003582  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003583  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003584  004169        
003585  004170  func file_RunSpeed("Speed", "fname.4xe", "arglistptr"), 1;
003586  004171  // Syntax	: res := file_Run(SPI_SPEED15, "fname.4xe","arglistptr");
003587  004172  // Usage	: res := file_Run(SPI_SPEED15, fname, argptr);
003588  004173  // Notes	: current program releases any allocated memory but
003589  004174  // 	: retains the stack and global memory.
003590  004175  // 	: If arglistptr is 0, no arguments are passed, else
003591  004176  // 	: arglist points to an array, the first element being
003592  004177  // 	: the number of elements in the array.
003593  004178  // 	: func 'main' in the called program accepts
003594  004179  // 	: the arguments, if any. The arguments can only
003595  004180  // 	: be passed by value, no pointers or references can be
003596  004181  // 	: used as all memory is cleared before the file
003597  004182  // 	: is loaded. Refer to file_Exec and file_LoadFunction
003598  004183  // 	: for functions that can pass by reference.
003599  004184  // 	: Speed specifies the File System is mounted at the specified speed
003600  004185  // 	: can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003601  004186        
003602  004187  func I2CS_Open("Addr", "RdBuf", "RdBufSize", "WrBuf", "WrBufSize", "WaitOption"), 0;  // Open I2C Slave
003603  004188  // Usage	: I2CS_Open(Addr, RdBuf, RdBufS, WrBuf, WrBufs, 0xaa);
003604  004189  // Notes	: Initialize and open the I2C Slave 
003605  004190  // 	: The slave ACKs any transmissions from the master until the read buffer fills
003606  004191  // 	: The slave NAKs any receives by the master until the write buffer is released, or is empty
003607  004192  // 	: Addr	The I2C Address for this Slave
003608  004193  // 	: RdBuf	The buffer for receiving 'commands' from the master
003609  004194  // 	: RdBufSize	The size of the receive buffer 
003610  004195  // 	: WrBuf	The buffer for sending 'responses' to the master
003611  004196  // 	: WrBufSize	The size of the write buffer
003612  004197  // 	: WaitOption	The character to send when no data is available, or all sent, or with I2C_CLOCK_STRETCHING to use clock stretching 
003613  004198  // 	: Response: None
003614  004199        
003615  004200  func I2CS_Close(), 0;          // Close I2C Slave
003616  004201  // Usage	: I2CS_Close();
003617  004202  // Notes	: Closes the I2C Slave 
003618  004203  // 	: Response: None
003619  004204        
003620  004205  func I2CS_Write("Byte"), 0;      // Write byte to output buffer
003621  004206  // Usage	: I2CS_Write("Byte");
003622  004207  // Notes	: Writes a byte to the I2C Slave Write Buffer
003623  004208  // 	: When everything to be written to the Master is in the write buffer, the buffer should be released
003624  004209  // 	: with I2CS_Release()
003625  004210  // 	: Response: None
003626  004211        
003627  004212  func I2CS_Count(), 1;          // Count of bytes in input buffer
003628  004213  // Usage	: I2CS_Count();
003629  004214  // Notes	: Retrieve the number of bytes available in the I2C Slave's read buffer
003630  004215  // 	: Response: Number of bytes in the buffer
003631  004216        
003632  004217  func I2CS_Read(), 1;           // Read byte from Read Buffer
003633  004218  // Usage	: I2CS_Read();
003634  004219  // Notes	: Read a byte from the I2C Slave's read buffer
003635  004220  // 	: Response: byte read from buffer
003636  004221        
003637  004222  func I2CS_Release(), 0;        // Release output buffer to enable Master to read
003638  004223  // Usage	: I2CS_Release();
003639  004224  // Notes	: Release an accumulated I2C Slave write buffer for sending to the master
003640  004225  // 	: Response: None
003641  004226        
003642  004227  func I2CS_Overflow(), 1;        // Check for any overflow in the read or write processes
003643  004228  // Usage	: I2CS_Overflow();
003644  004229  // Notes	: Check for any overflow in the read or write processes, the error is automatically
003645  004230  // 	: Reset at the start of the next I2CS_Write() or the last I2CS_Read() for the current buffer.
003646  004231  // 	: Response: Overflow flags
003647  004232  // 	: 0x01 : The host has sent more data than the I2CS_Read() buffer can hold
003648  004233  // 	: 0x02 : The host has read all the data the I2CS_Write() buffer contained
003649  004234  // 	: 0x04 : The host has read more data than the I2CS_Write() buffer contained
003650  004235        
003651  004236  func com_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003652  004237  // Usage	: com_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003653  004238  // Usage	: com_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003654  004239  // Notes	: initialize a serial buffer for the COM0 output.
003655  004240  // 	: The program must declare a var array as a circular buffer.
003656  004241  // 	: When a TX buffer is declared for comms, the transmission
003657  004242  // 	: of characters becomes non blocking. If the buffer has
003658  004243  // 	: insufficient space to accept the next character from a
003659  004244  // 	: serout_x() function, the excess characters will be ignored,
003660  004245  // 	: and the com_Full_x() error will be asserted.   If the
003661  004246  // 	: TX buffer is no longer required, just set the buffer pointer
003662  004247  // 	: to zero, the size in this case doesnt matter and is ignored.
003663  004248  // 	: The function can resize or reallocated to another buffer at
003664  004249  // 	: any time. The buffer is flushed before any changes are made.
003665  004250  // 	: "pin" designates an IO pin to control a bi-directional
003666  004251  // 	: control device for half duplex mode. "pin" will go HI at the
003667  004252  // 	: start of a transmission, and will return low after the final
003668  004253  // 	: byte is transmitted. If not required, just set "pin" to zero.
003669  004254        
003670  004255  func com_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003671  004256  // Syntax	: com_InitBrk(buffer, bufsize, qualifier);
003672  004257  // Usage1	: com_InitBrk(mybuf, 20, 0);
003673  004258  // Usage2	: com_InitBrk(mybuf, 20, ':');
003674  004259  // Notes	: initialize a serial capture buffer for the comms input
003675  004260  // 	: The program must declare a var array as a circular buffer.
003676  004261  // 	: Usage1 declares a circular buffer which will continually
003677  004262  // 	: buffer characters.
003678  004263  // 	: Usage2 must receive ':' before any characters will
003679  004264  // 	: accumulate in the buffer.
003680  004265        
003681  004266  //------------------------------------------------------------------//
003682  004267  //     break control constant                                       //
003683  004268  //------------------------------------------------------------------//
003684  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003685  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003686  004270        
003687  004271  func disp_Refresh(), 0;  // Refresh an ePaper display
003688  004272  // Syntax	: disp_Refresh();
003689  004273  // Usage	: disp_Refresh();
003690  004274  // Notes	: This command is only applicable to ePaper displays.
003691  004275  // 	: Refresh an ePaper display
003692  004276  // 	: After updating the RAM in an ePaper display thuis commmand is used
003693  004277  // 	: to place the contents of the RAM onto the ePaper.
003694  004278        
003695  004279  func disp_Busy(), 1;  // Check the busy status of an ePaper display
003696  004280  // Syntax	: disp_Busy();
003697  004281  // Usage	: disp_Busy();
003698  004282  // Notes	: This command is only applicable to ePaper displays.
003699  004283  // 	: Return the busy status of an ePaper display
003700  004284  // 
003701  004285  // Returns	: 1 if the display is busy, 0 otherwise
003702  004286        
003703  004287  //=========================================================================================================
003704  004288  // Internal FLASH memory functions
003705  004289  //=========================================================================================================
003706  004290  func intflash_GetByte("ptr"), 1;
003707  004291  // Syntax   : intflash_GetByte(ptr);
003708  004292  // Usage    : myvar := intflash_GetByte(1); // read the first byte from internal flash
003709  004293  // Notes    : Reads a single byte from internal flash.
003710  004294  // Returns  : the byte value from the location
003711  004295        
003712  004296        
003713  004297  func intflash_GetWord("ptr"), 1;
003714  004298  // Syntax   : intflash_GetWord(ptr);
003715  004299  // Usage    : myvar := intflash_GetWord(0x0000); // read first word from internal flash
003716  004300  // Notes    : Reads a single word from any internal flash location.
003717  004301  //          : The pointer is byte aligned.
003718  004302  // Returns  : the byte value from the location
003719  004303        
003720  004304        
003721  004305  func intflash_Copy("ptr", "dest", "count"), 1;
003722  004306  // Syntax   : intflash_Copy(ptr, dest, count);
003723  004307  // Usage    : myvar := intflash_Copy(0x123, mybuf, 20); // read 20 bytes from internal flash starting from 0x123
003724  004308  // Notes    : Copies bytes from any internal flash locations to a user buffer.
003725  004309  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
003726  004310  // Returns  : the count of bytes transferred.
003727  004311        
003728  004312  func intflash_WriteBlock("sourceptr", "Size"), 1;
003729  004313  // Syntax   : intflash_WriteBlock(pbuf);
003730  004314  // Usage    : result := intflash_WriteBlock(buffer); // store the 2k buffer 
003731  004315  // Notes    : Copies a buffer to NVM. Size bytes are written. A maximum of 2048 bytes can be written.
003732  004316  // Returns  : returns true if the function succeeded.
003733  004317        
003734  004318  func intflash_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in internal flash
003735  004319  // Syntax: intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003736  004320  // Usage : intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003737  004321  // Notes	: Load and call the Function found at index "idx" in the internal flash widget identified by "Hndl". 
003738  004322  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003739  004323  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003740  004324  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003741  004325  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003742  004326  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003743  004327  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003744  004328  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003745  004329  // 	: Returns 0 if successful.
003746  004330        
003747  004331  func intflash_FunctionFreeCache("handle"), 0 ;                                 // Free all cached internal Flash Functions 
003748  004332  // Syntax: img_FunctionFreeCache(hndl);
003749  004333  // Usage : img_FunctionFreeCache(hndl);
003750  004334  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003751  004335  // 	: widget handle.
003752  004336        
003753  004337  func com1_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003754  004338  // Usage	: com1_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003755  004339  // Usage	: com1_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003756  004340  // Notes	: initialize a serial buffer for the COM1 output.
003757  004341  // 	: The program must declare a var array as a circular buffer.
003758  004342  // 	: When a TX buffer is declared for comms, the transmission
003759  004343  // 	: of characters becomes non blocking. If the buffer has
003760  004344  // 	: insufficient space to accept the next character from a
003761  004345  // 	: serout_x() function, the excess characters will be ignored,
003762  004346  // 	: and the com_Full_x() error will be asserted.   If the
003763  004347  // 	: TX buffer is no longer required, just set the buffer pointer
003764  004348  // 	: to zero, the size in this case doesnt matter and is ignored.
003765  004349  // 	: The function can resize or reallocated to another buffer at
003766  004350  // 	: any time. The buffer is flushed before any changes are made.
003767  004351  // 	: "pin" designates an IO pin to control a bi-directional
003768  004352  // 	: control device for half duplex mode. "pin" will go HI at the
003769  004353  // 	: start of a transmission, and will return low after the final
003770  004354  // 	: byte is transmitted. If not required, just set "pin" to zero.
003771  004355        
003772  004356  func com1_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003773  004357  // Syntax	: com1_InitBrk(buffer, bufsize, qualifier);
003774  004358  // Usage1	: com1_InitBrk(mybuf, 20, 0);
003775  004359  // Usage2	: com1_InitBrk(mybuf, 20, ':');
003776  004360  // Notes	: initialize a serial capture buffer for the comms input
003777  004361  // 	: The program must declare a var array as a circular buffer.
003778  004362  // 	: Usage1 declares a circular buffer which will continually
003779  004363  // 	: buffer characters.
003780  004364  // 	: Usage2 must receive ':' before any characters will
003781  004365  // 	: accumulate in the buffer.
003782  004366        
003783  004367  //------------------------------------------------------------------//
003784  004368  // CONSTANTS
003785  004369  //------------------------------------------------------------------//
003786  004370        
003787  004371  #CONST
003788  004500  #END
003789  004501        
003790  004502  // generic constants
003791  004503  #CONST
003792  004514  #END
003793  004515        
003794  004516  // other constants
003795  004517  #CONST
003796  004520  #END
003797  004521        
003798  004522  //------------------------------------------------------------------------------
003799  004523  // Pin related constants
003800  004524  //------------------------------------------------------------------------------
003801  004525  #CONST
003802  004547  #END
003803  004548        
003804  004549  //------------------------------------------------------------------------------
003805  004550  //gfx_Set() related constants
003806  004551  //------------------------------------------------------------------------------
003807  004552  #CONST
003808  004569  #END
003809  004570        
003810  004571        
003811  004572  //gfx_Get() related constants
003812  004573  #CONST
003813  004582  #END
003814  004583        
003815  004584        
003816  004585        
003817  004586        
003818  004587  #CONST
003819  004600  #END
003820  004601        
003821  004602        
003822  004603  #CONST
003823  004625  #END
003824  004626        
003825  004627  //------------------------------------------------------------------------------
003826  004628  //txt_Set() related constants
003827  004629  //------------------------------------------------------------------------------
003828  004630  #CONST
003829  004649  #END
003830  004650        
003831  004651        
003832  004652        
003833  004653  //------------------------------------------------------------------------------
003834  004654  //txt_Set() related arguments
003835  004655  // NB:- FONT4 must be inherited if required,
003836  004656  // eg #inherit "FONT4.fnt"
003837  004657  //------------------------------------------------------------------------------
003838  004658  #CONST
003839  004670  #END
003840  004671        
003841  004672        
003842  004673        
003843  004674  //touch_Set() related constants
003844  004675  #CONST
003845  004679  #END
003846  004680        
003847  004681  //touch_Get() related constants
003848  004682  #CONST
003849  004690  #END
003850  004691        
003851  004692  // image control offset related constants
003852  004693  #CONST
003853  004700  #END
003854  004701        
003855  004702  // image attribute flags
003856  004703  // for img_SetAttributes(...) and img_ClearAttributes(...)
003857  004704  #CONST
003858  004718  #END
003859  004719        
003860  004720        
003861  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003862  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003863  004722        
003864  004723  // image control entry offsets
003865  004724  #CONST
003866  004739  #END
003867  004740        
003868  004741  #CONST
003869  004759  #END
003870  004760        
003871  004761        
003872  004762        
003873  004763        
003874  004764  #CONST
003875  004784  #END
003876  004785        
003877  004786        
003878  004787        
003879  004788  // timer control  related constants
003880  004789  #CONST
003881  004798  #END
003882  004799        
003883  004800  // I2C timing related constants
003884  004801  #CONST
003885  004805  #END
003886  004806        
003887  004807        
003888  004808  // spi_Init(...)  mode arguments
003889  004809  #CONST
003890  004832  #END
003891  004833        
003892  004834  //------------------------------------------------------------------------------
003893  004835  // system WORD variables accesible with peekW and pokeW or pointer access
003894  004836  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
003895  004837  // can also be accessed with peekW and pokeW
003896  004838  //------------------------------------------------------------------------------
003897  004839        
003898  004840  #CONST
003899  004934  #END
003900  004935        
003901  004936  //------------------------------------------------------------------------------
003902  004937  // FILEIO Error Code Constants
003903  004938  //------------------------------------------------------------------------------
003904  004939  #CONST
003905  004965  #END
003906  004966        
003907  004967  //==================================================================================================
003908  004968        
003909  004969        
003910  004970        
003911  000013      #ENDIF
003912  000014        
003913  000015        
003914  000016  //===========================================================================================
003915  000017        
003916  000018        
003917  000002        
003918  000003  //#constant OLDCOMPILE
003919  000004        
003920  000005        
003921  000006        
003922  000007        
003923  000008        
003924  000009  // generated 3/30/2023 11:03:27 AM
003925  000010  // uSDRequired:- 1   InternalRequired:- 1   InherentsInProgFlash:- 0   GciFlashFS:- 1   InherentWidgets:- 0   InternalObjects:- 14   GciFlashFiles:- 1
003926  000011        
003927  000012        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

003928  000013  #inherit "4DGL_16bitColours.fnc"
003929  000013  #inherit "4DGL_16bitColours.fnc"
003930  000004  */
003931  000005        
003932  000006        
003933  000007        
003934  000008  #CONST
003935  000149  #END
003936  000150        
003937  000014        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

003938  000015  #inherit "VisualConst.inc"
003939  000015  #inherit "VisualConst.inc"
003940  000001  // Line Patterns
003941  000002  #constant  LPCOARSE    0xF0F0
003942  000002  #constant  LPCOARSE    0xF0F0
003943  000003  #constant  LPMEDIUM    0x3333
003944  000003  #constant  LPMEDIUM    0x3333
003945  000004  #constant  LPFINE      0xAAAA
003946  000004  #constant  LPFINE      0xAAAA
003947  000005  #constant  LPDASHDOT   0x03CF
003948  000005  #constant  LPDASHDOT   0x03CF
003949  000006  #constant  LPDASHDOTDOT 0x0333
003950  000006  #constant  LPDASHDOTDOT 0x0333
003951  000007  #constant  LPSOLID     0x0000
003952  000007  #constant  LPSOLID     0x0000
003953  000016        
003954  000017        
file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGaugeConst.inc

003955  000018  #inherit "SprinterGaugeConst.inc"
003956  000018  #inherit "SprinterGaugeConst.inc"
003957  000001  // File generated 3/30/2023 11:03:21 AM
003958  000002  // Warning! This is a generated file, any manual changes will be
003959  000003  // lost during the next generation.
003960  000004        
003961  000005  #constant  Strings2Count    1
003962  000005  #constant  Strings2Count    1
003963  000006  #constant  Strings2Size     17
003964  000006  #constant  Strings2Size     17
003965  000007  #constant  Strings0Count    1
003966  000007  #constant  Strings0Count    1
003967  000008  #constant  Strings0Size     22
003968  000008  #constant  Strings0Size     22
003969  000009  #constant  Strings4Count    1
003970  000009  #constant  Strings4Count    1
003971  000010  #constant  Strings4Size     6
003972  000010  #constant  Strings4Size     6
003973  000011  #constant  Strings5Count    1
003974  000011  #constant  Strings5Count    1
003975  000012  #constant  Strings5Size     6
003976  000012  #constant  Strings5Size     6
003977  000013  #constant  Strings7Count    1
003978  000013  #constant  Strings7Count    1
003979  000014  #constant  Strings7Size     14
003980  000014  #constant  Strings7Size     14
003981  000015  #constant  Strings9Count    1
003982  000015  #constant  Strings9Count    1
003983  000016  #constant  Strings9Size     7
003984  000016  #constant  Strings9Size     7
003985  000017  #constant  Strings37Count    1
003986  000017  #constant  Strings37Count    1
003987  000018  #constant  Strings37Size     8
003988  000018  #constant  Strings37Size     8
003989  000019  #constant  Strings38Count    1
003990  000019  #constant  Strings38Count    1
003991  000020  #constant  Strings38Size     6
003992  000020  #constant  Strings38Size     6
003993  000021  #constant  Strings10Count    1
003994  000021  #constant  Strings10Count    1
003995  000022  #constant  Strings10Size     6
003996  000022  #constant  Strings10Size     6
003997  000023  #constant  Strings11Count    1
003998  000023  #constant  Strings11Count    1
003999  000024  #constant  Strings11Size     15
004000  000024  #constant  Strings11Size     15
004001  000025  #constant  Strings12Count    1
004002  000025  #constant  Strings12Count    1
004003  000026  #constant  Strings12Size     17
004004  000026  #constant  Strings12Size     17
004005  000027  #constant  Strings15Count    1
004006  000027  #constant  Strings15Count    1
004007  000028  #constant  Strings15Size     13
004008  000028  #constant  Strings15Size     13
004009  000029  #constant  Strings16Count    1
004010  000029  #constant  Strings16Count    1
004011  000030  #constant  Strings16Size     13
004012  000030  #constant  Strings16Size     13
004013  000031  #constant  Strings18Count    1
004014  000031  #constant  Strings18Count    1
004015  000032  #constant  Strings18Size     5
004016  000032  #constant  Strings18Size     5
004017  000033  #constant  Strings19Count    1
004018  000033  #constant  Strings19Count    1
004019  000034  #constant  Strings19Size     5
004020  000034  #constant  Strings19Size     5
004021  000035  #constant  Strings20Count    1
004022  000035  #constant  Strings20Count    1
004023  000036  #constant  Strings20Size     5
004024  000036  #constant  Strings20Size     5
004025  000037  #constant  Strings21Count    1
004026  000037  #constant  Strings21Count    1
004027  000038  #constant  Strings21Size     7
004028  000038  #constant  Strings21Size     7
004029  000039  #constant  Strings22Count    1
004030  000039  #constant  Strings22Count    1
004031  000040  #constant  Strings22Size     13
004032  000040  #constant  Strings22Size     13
004033  000041  #constant  Strings23Count    1
004034  000041  #constant  Strings23Count    1
004035  000042  #constant  Strings23Size     7
004036  000042  #constant  Strings23Size     7
004037  000043  #constant  Strings24Count    1
004038  000043  #constant  Strings24Count    1
004039  000044  #constant  Strings24Size     12
004040  000044  #constant  Strings24Size     12
004041  000045  #constant  Strings13Count    1
004042  000045  #constant  Strings13Count    1
004043  000046  #constant  Strings13Size     7
004044  000046  #constant  Strings13Size     7
004045  000047  #constant  Strings14Count    1
004046  000047  #constant  Strings14Count    1
004047  000048  #constant  Strings14Size     16
004048  000048  #constant  Strings14Size     16
004049  000049  #constant  Strings25Count    1
004050  000049  #constant  Strings25Count    1
004051  000050  #constant  Strings25Size     7
004052  000050  #constant  Strings25Size     7
004053  000051  #constant  Strings26Count    1
004054  000051  #constant  Strings26Count    1
004055  000052  #constant  Strings26Size     17
004056  000052  #constant  Strings26Size     17
004057  000053  #constant  Strings17Count    1
004058  000053  #constant  Strings17Count    1
004059  000054  #constant  Strings17Size     5
004060  000054  #constant  Strings17Size     5
004061  000055  #constant  Strings3Count    1
004062  000055  #constant  Strings3Count    1
004063  000056  #constant  Strings3Size     5
004064  000056  #constant  Strings3Size     5
004065  000057  #constant  Strings6Count    1
004066  000057  #constant  Strings6Count    1
004067  000058  #constant  Strings6Size     12
004068  000058  #constant  Strings6Size     12
004069  000059  #constant  Strings27Count    1
004070  000059  #constant  Strings27Count    1
004071  000060  #constant  Strings27Size     3
004072  000060  #constant  Strings27Size     3
004073  000061  #constant  Strings28Count    1
004074  000061  #constant  Strings28Count    1
004075  000062  #constant  Strings28Size     8
004076  000062  #constant  Strings28Size     8
004077  000063  #constant  Strings8Count    1
004078  000063  #constant  Strings8Count    1
004079  000064  #constant  Strings8Size     13
004080  000064  #constant  Strings8Size     13
004081  000065  #constant  Strings29Count    1
004082  000065  #constant  Strings29Count    1
004083  000066  #constant  Strings29Size     5
004084  000066  #constant  Strings29Size     5
004085  000067  #constant  Strings30Count    1
004086  000067  #constant  Strings30Count    1
004087  000068  #constant  Strings30Size     5
004088  000068  #constant  Strings30Size     5
004089  000069  #constant  Strings31Count    1
004090  000069  #constant  Strings31Count    1
004091  000070  #constant  Strings31Size     13
004092  000070  #constant  Strings31Size     13
004093  000071  #constant  Strings1Count    1
004094  000071  #constant  Strings1Count    1
004095  000072  #constant  Strings1Size     12
004096  000072  #constant  Strings1Size     12
004097  000073  #constant  Strings32Count    1
004098  000073  #constant  Strings32Count    1
004099  000074  #constant  Strings32Size     7
004100  000074  #constant  Strings32Size     7
004101  000075  #constant  Strings33Count    1
004102  000075  #constant  Strings33Count    1
004103  000076  #constant  Strings33Size     13
004104  000076  #constant  Strings33Size     13
004105  000077  #constant  Strings34Count    0
004106  000077  #constant  Strings34Count    0
004107  000078  #constant  Strings34Size     1
004108  000078  #constant  Strings34Size     1
004109  000079  #constant  Strings35Count    1
004110  000079  #constant  Strings35Count    1
004111  000080  #constant  Strings35Size     17
004112  000080  #constant  Strings35Size     17
004113  000081  #constant  Strings36Count    0
004114  000081  #constant  Strings36Count    0
004115  000082  #constant  Strings36Size     1
004116  000082  #constant  Strings36Size     1
004117  000083  #constant  IFONT_OFFSET     39
004118  000083  #constant  IFONT_OFFSET     39
004119  000084  // object indexes into WIDGET pointer
004120  000085  #CONST
004121  000100  #END
004122  000101        
004123  000102  // object indexes into ImageControl
004124  000103  #CONST
004125  000143  #END
004126  000144        
004127  000145        
004128  000146  #constant  Strings2StartH   0x0
004129  000146  #constant  Strings2StartH   0x0
004130  000147  #constant  Strings2StartL   0x0
004131  000147  #constant  Strings2StartL   0x0
004132  000148  #constant  Strings0StartH   0x0
004133  000148  #constant  Strings0StartH   0x0
004134  000149  #constant  Strings0StartL   0x200
004135  000149  #constant  Strings0StartL   0x200
004136  000150  #constant  Strings4StartH   0x0
004137  000150  #constant  Strings4StartH   0x0
004138  000151  #constant  Strings4StartL   0x400
004139  000151  #constant  Strings4StartL   0x400
004140  000152  #constant  Strings5StartH   0x0
004141  000152  #constant  Strings5StartH   0x0
004142  000153  #constant  Strings5StartL   0x600
004143  000153  #constant  Strings5StartL   0x600
004144  000154  #constant  Strings7StartH   0x0
004145  000154  #constant  Strings7StartH   0x0
004146  000155  #constant  Strings7StartL   0x800
004147  000155  #constant  Strings7StartL   0x800
004148  000156  #constant  Strings9StartH   0x0
004149  000156  #constant  Strings9StartH   0x0
004150  000157  #constant  Strings9StartL   0xA00
004151  000157  #constant  Strings9StartL   0xA00
004152  000158  #constant  Strings37StartH   0x0
004153  000158  #constant  Strings37StartH   0x0
004154  000159  #constant  Strings37StartL   0xC00
004155  000159  #constant  Strings37StartL   0xC00
004156  000160  #constant  Strings38StartH   0x0
004157  000160  #constant  Strings38StartH   0x0
004158  000161  #constant  Strings38StartL   0xE00
004159  000161  #constant  Strings38StartL   0xE00
004160  000162  #constant  Strings10StartH   0x0
004161  000162  #constant  Strings10StartH   0x0
004162  000163  #constant  Strings10StartL   0x1000
004163  000163  #constant  Strings10StartL   0x1000
004164  000164  #constant  Strings11StartH   0x0
004165  000164  #constant  Strings11StartH   0x0
004166  000165  #constant  Strings11StartL   0x1200
004167  000165  #constant  Strings11StartL   0x1200
004168  000166  #constant  Strings12StartH   0x0
004169  000166  #constant  Strings12StartH   0x0
004170  000167  #constant  Strings12StartL   0x1400
004171  000167  #constant  Strings12StartL   0x1400
004172  000168  #constant  Strings15StartH   0x0
004173  000168  #constant  Strings15StartH   0x0
004174  000169  #constant  Strings15StartL   0x1600
004175  000169  #constant  Strings15StartL   0x1600
004176  000170  #constant  Strings16StartH   0x0
004177  000170  #constant  Strings16StartH   0x0
004178  000171  #constant  Strings16StartL   0x1800
004179  000171  #constant  Strings16StartL   0x1800
004180  000172  #constant  Strings18StartH   0x0
004181  000172  #constant  Strings18StartH   0x0
004182  000173  #constant  Strings18StartL   0x1A00
004183  000173  #constant  Strings18StartL   0x1A00
004184  000174  #constant  Strings19StartH   0x0
004185  000174  #constant  Strings19StartH   0x0
004186  000175  #constant  Strings19StartL   0x1C00
004187  000175  #constant  Strings19StartL   0x1C00
004188  000176  #constant  Strings20StartH   0x0
004189  000176  #constant  Strings20StartH   0x0
004190  000177  #constant  Strings20StartL   0x1E00
004191  000177  #constant  Strings20StartL   0x1E00
004192  000178  #constant  Strings21StartH   0x0
004193  000178  #constant  Strings21StartH   0x0
004194  000179  #constant  Strings21StartL   0x2000
004195  000179  #constant  Strings21StartL   0x2000
004196  000180  #constant  Strings22StartH   0x0
004197  000180  #constant  Strings22StartH   0x0
004198  000181  #constant  Strings22StartL   0x2200
004199  000181  #constant  Strings22StartL   0x2200
004200  000182  #constant  Strings23StartH   0x0
004201  000182  #constant  Strings23StartH   0x0
004202  000183  #constant  Strings23StartL   0x2400
004203  000183  #constant  Strings23StartL   0x2400
004204  000184  #constant  Strings24StartH   0x0
004205  000184  #constant  Strings24StartH   0x0
004206  000185  #constant  Strings24StartL   0x2600
004207  000185  #constant  Strings24StartL   0x2600
004208  000186  #constant  Strings13StartH   0x0
004209  000186  #constant  Strings13StartH   0x0
004210  000187  #constant  Strings13StartL   0x2800
004211  000187  #constant  Strings13StartL   0x2800
004212  000188  #constant  Strings14StartH   0x0
004213  000188  #constant  Strings14StartH   0x0
004214  000189  #constant  Strings14StartL   0x2A00
004215  000189  #constant  Strings14StartL   0x2A00
004216  000190  #constant  Strings25StartH   0x0
004217  000190  #constant  Strings25StartH   0x0
004218  000191  #constant  Strings25StartL   0x2C00
004219  000191  #constant  Strings25StartL   0x2C00
004220  000192  #constant  Strings26StartH   0x0
004221  000192  #constant  Strings26StartH   0x0
004222  000193  #constant  Strings26StartL   0x2E00
004223  000193  #constant  Strings26StartL   0x2E00
004224  000194  #constant  Strings17StartH   0x0
004225  000194  #constant  Strings17StartH   0x0
004226  000195  #constant  Strings17StartL   0x3000
004227  000195  #constant  Strings17StartL   0x3000
004228  000196  #constant  Strings3StartH   0x0
004229  000196  #constant  Strings3StartH   0x0
004230  000197  #constant  Strings3StartL   0x3200
004231  000197  #constant  Strings3StartL   0x3200
004232  000198  #constant  Strings6StartH   0x0
004233  000198  #constant  Strings6StartH   0x0
004234  000199  #constant  Strings6StartL   0x3400
004235  000199  #constant  Strings6StartL   0x3400
004236  000200  #constant  Strings27StartH   0x0
004237  000200  #constant  Strings27StartH   0x0
004238  000201  #constant  Strings27StartL   0x3600
004239  000201  #constant  Strings27StartL   0x3600
004240  000202  #constant  Strings28StartH   0x0
004241  000202  #constant  Strings28StartH   0x0
004242  000203  #constant  Strings28StartL   0x3800
004243  000203  #constant  Strings28StartL   0x3800
004244  000204  #constant  Strings8StartH   0x0
004245  000204  #constant  Strings8StartH   0x0
004246  000205  #constant  Strings8StartL   0x3A00
004247  000205  #constant  Strings8StartL   0x3A00
004248  000206  #constant  Strings29StartH   0x0
004249  000206  #constant  Strings29StartH   0x0
004250  000207  #constant  Strings29StartL   0x3C00
004251  000207  #constant  Strings29StartL   0x3C00
004252  000208  #constant  Strings30StartH   0x0
004253  000208  #constant  Strings30StartH   0x0
004254  000209  #constant  Strings30StartL   0x3E00
004255  000209  #constant  Strings30StartL   0x3E00
004256  000210  #constant  Strings31StartH   0x0
004257  000210  #constant  Strings31StartH   0x0
004258  000211  #constant  Strings31StartL   0x4000
004259  000211  #constant  Strings31StartL   0x4000
004260  000212  #constant  Strings1StartH   0x0
004261  000212  #constant  Strings1StartH   0x0
004262  000213  #constant  Strings1StartL   0x4200
004263  000213  #constant  Strings1StartL   0x4200
004264  000214  #constant  Strings32StartH   0x0
004265  000214  #constant  Strings32StartH   0x0
004266  000215  #constant  Strings32StartL   0x4400
004267  000215  #constant  Strings32StartL   0x4400
004268  000216  #constant  Strings33StartH   0x0
004269  000216  #constant  Strings33StartH   0x0
004270  000217  #constant  Strings33StartL   0x4600
004271  000217  #constant  Strings33StartL   0x4600
004272  000218  #constant  Strings34StartH   0x0
004273  000218  #constant  Strings34StartH   0x0
004274  000219  #constant  Strings34StartL   0x4800
004275  000219  #constant  Strings34StartL   0x4800
004276  000220  #constant  Strings35StartH   0x0
004277  000220  #constant  Strings35StartH   0x0
004278  000221  #constant  Strings35StartL   0x4A00
004279  000221  #constant  Strings35StartL   0x4A00
004280  000222  #constant  Strings36StartH   0x0
004281  000222  #constant  Strings36StartH   0x0
004282  000223  #constant  Strings36StartL   0x4C00
004283  000223  #constant  Strings36StartL   0x4C00
004284  000224        
004285  000225  #constant  ffsEndUnits4k    0x0075  // First unused 4k Sector on Flash
004286  000225  #constant  ffsEndUnits4k    0x0075  // First unused 4k Sector on Flash
004287  000226  #constant  ffsEnd4kH        0x0007  // Address of first unused 4k Sector on Flash, High
004288  000226  #constant  ffsEnd4kH        0x0007  // Address of first unused 4k Sector on Flash, High
004289  000227  #constant  ffsEnd4kL        0x5000  // Address of first unused 4k Sector on Flash, Low
004290  000227  #constant  ffsEnd4kL        0x5000  // Address of first unused 4k Sector on Flash, Low
004291  000228  #constant  ffsEndUnits32k   0x000F  // First unused 32k Block on Flash
004292  000228  #constant  ffsEndUnits32k   0x000F  // First unused 32k Block on Flash
004293  000229  #constant  ffsEnd32kH       0x0007  // Address of first unused 32k Block on Flash, High
004294  000229  #constant  ffsEnd32kH       0x0007  // Address of first unused 32k Block on Flash, High
004295  000230  #constant  ffsEnd32kL       0x8000  // Address of first unused 32k Block on Flash, Low
004296  000230  #constant  ffsEnd32kL       0x8000  // Address of first unused 32k Block on Flash, Low
004297  000231  #constant  ffsEndUnits64k   0x0008  // First unused 64k Block on Flash
004298  000231  #constant  ffsEndUnits64k   0x0008  // First unused 64k Block on Flash
004299  000232  #constant  ffsEnd64kH       0x0008  // Address of first unused 64k Block on Flash, High
004300  000232  #constant  ffsEnd64kH       0x0008  // Address of first unused 64k Block on Flash, High
004301  000233  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
004302  000233  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
004303  000234        
004304  000235  #IFNOT EXISTS NOGLOBALS
004305  000236  var hndl ;
004306  000237  #ENDIF
004307  000019        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\CLPrintStringsGciFS.inc

004308  000020  #inherit "CLPrintStringsGciFS.inc"
004309  000020  #inherit "CLPrintStringsGciFS.inc"
004310  000001  func PrintStrings(var ID, var *msgid, var String)
004311  000002      var StringID, i, ch, offs32[2], res32[2] ;
004312  000003      StringID := oStringss[1+ID] ;
004313  000004      if (String)
004314  000005          stringsCV[ID] := -1 ;
004315  000006      else
004316  000007          stringsCV[ID] := msgid ;
004317  000008      endif
004318  000009      if ((StringID == -1) || (*(StringID + Ofs_String_Form) != CurrentForm)) return ;
004319  000010      i := *(StringID + Ofs_String_GciFSFontIdx) ;
004320  000011      if (i < 0)
004321  000012  //to(COM0) ; print("CLP Font Flash ", -1-i, "\n") ;
004322  000013          img_TxtFontID(0xffff, -1-i) ;
004323  000014      else
004324  000015  //to(COM0) ; print("CLP Font Internal ", i, "\n") ;
004325  000016          txt_FontID(i) ;
004326  000017      endif
004327  000018      txt_Attributes(*(StringID + Ofs_String_FontAttribs)) ; // >> 4 fix for r25,6,7,8 PmmC
004328  000019  //    txt_Opacity(*(StringID + STTransparent)) ;
004329  000020        
004330  000021      if (*(StringID + Ofs_String_Transparent))
004331  000022          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), *(StringID + Ofs_String_BGColor));
004332  000023      else if (FormBGcolors[CurrentForm] != ColorBGimage)
004333  000024          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), FormBGcolors[CurrentForm]);
004334  000025      else
004335  000026          gfx_ClipWindow(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2)) ;
004336  000027          gfx_Clipping(ON) ;
004337  000028          img_Show(hndl,FormStartIndex[CurrentForm]) ;
004338  000029          gfx_Clipping(OFF) ;
004339  000030        
004340  000031      endif
004341  000032        
004342  000033      txt_FGcolour(*(StringID + Ofs_String_FGColor)) ;
004343  000034      txt_BGcolour(*(StringID + Ofs_String_BGColor)) ;
004344  000035      txt_Opacity(TRANSPARENT);                // 8  text OPAQUE or TRANSPARENT
004345  000036        
004346  000037      gfx_MoveTo(*(StringID + Ofs_String_x1) , *(StringID + Ofs_String_y1)) ;
004347  000038        
004348  000039      if (String)
004349  000040          i := 0 ;
004350  000041          ch := msgid[i++] ;
004351  000042          while (ch != 0)
004352  000043              putch(ch) ;
004353  000044              ch := msgid[i++] ;
004354  000045          wend
004355  000046      else
004356  000047          umul_1616(offs32, *(StringID + Ofs_String_Size), msgid);
004357  000048          res32[1] := *(StringID + Ofs_String_StartH) ;
004358  000049          res32[0] := *(StringID + Ofs_String_StartL) ;
004359  000050          uadd_3232(res32,res32,offs32) ;
004360  000051          img_FileSeek(hndl, iTextStrings, res32[1], res32[0]);
004361  000052          repeat
004362  000053              if (*(StringID + Ofs_String_Ansi))
004363  000054                  ch := img_FileGetC(hndl, iTextStrings) ;
004364  000055              else
004365  000056                  ch := img_FileGetW(hndl, iTextStrings) ;
004366  000057              endif
004367  000058              putch(ch) ;
004368  000059          until (ch == 0) ;
004369  000060      endif
004370  000061        
004371  000062  endfunc
004372  000063        
004373  000021        
004374  000022  #constant IPDatasize 22
004375  000022  #constant IPDatasize 22
004376  000023        
004377  000024  #CONST
004378  000028  #END
004379  000029        
004380  000030        
004381  000031        
004382  000032  #CONST
004383  000175  #END
004384  000176        
004385  000310  #END
4386  0C34
4387  0C35
4388  0C36
4389  0C37
4390  0C38
4391  0C39
4392  0C3A
4393  0C3B
4394  0C3C
4395  0C3D
4396  0C3E
4397  0C3F
4398  0C40
4399  0C41
4400  0C42
4401  0C43
4402  0C44
4403  0C45
4404  0C46
4405  0C47
4406  0C48
4407  0C49
4408  0C4A
4409  0C4B
4410  0C4C
4411  0C4D
4412  0C4E
4413  0C4F
4414  0C50
4415  0C51
4416  0C52
4417  0C53
4418  0C54
4419  0C55
4420  0C56
4421  0C57
4422  0C58
4423  0C59
4424  0C5A
4425  0C5B
4426  0C5C
4427  0C5D
4428  0C5E
4429  0C5F
4430  0C60
4431  0C61
4432  0C62
4433  0C63
4434  0C64
4435  0C65
4436  0C66
4437  0C67
4438  0C68
4439  0C69
4440  0C6A
4441  0C6B
4442  0C6C
4443  0C6D
4444  0C6E
4445  0C6F
4446  0C70
4447  0C71
4448  0C72
4449  0C73
4450  0C74
4451  0C75
4452  0C76
4453  0C77
4454  0C78
4455  0C79
4456  0C7A
4457  0C7B
4458  0C7C
4459  0C7D
4460  0C7E
4461  0C7F
4462  0C80
4463  0C81
4464  0C82
4465  0C83
4466  0C84
4467  0C85
4468  0C86
4469  0C87
4470  0C88
4471  0C89
4472  0C8A
4473  0C8B
4474  0C8C
4475  0C8D
4476  0C8E
4477  0C8F
4478  0C90
4479  0C91
4480  0C92
4481  0C93
4482  0C94
4483  0C95
4484  0C96
4485  0C97
4486  0C98
4487  0C99
4488  0C9A
4489  0C9B
4490  0C9C
4491  0C9D
4492  0C9E
4493  0C9F
4494  0CA0
4495  0CA1
4496  0CA2
4497  0CA3
4498  0CA4
4499  0CA5
4500  0CA6
4501  0CA7
4502  0CA8
4503  0CA9
4504  0CAA
4505  0CAB
4506  0CAC
4507  0CAD
4508  0CAE
4509  0CAF
4510  0CB0
4511  0CB1
4512  0CB2
4513  0CB3
4514  0CB4
4515  0CB5
4516  0CB6
4517  0CB7
4518  0CB8
4519  0CB9
4520  0CBA
4521  0CBB
4522  0CBC
4523  0CBD
4524  0CBE
4525  0CBF
4526  0CC0
4527  0CC1
4528  0CC2
4529  0CC3
4530  0CC4
4531  0CC5
4532  0CC6
4533  0CC7
4534  0CC8
4535  0CC9
4536  0CCA
4537  0CCB
4538  0CCC
4539  0CCD
4540  0CCE
4541  0CCF
4542  0CD0
4543  0CD1
4544  0CD2
4545  0CD3
4546  0CD4
4547  0CD5
4548  0CD6
4549  0CD7
4550  0CD8
4551  0CD9
4552  0CDA
4553  0CDB
4554  0CDC
4555  0CDD
4556  0CDE
4557  0CDF
4558  0CE0
4559  0CE1
4560  0CE2
4561  0CE3
4562  0CE4
4563  0CE5
4564  0CE6
4565  0CE7
4566  0CE8
4567  0CE9
4568  0CEA
4569  0CEB
4570  0CEC
4571  0CED
4572  0CEE
4573  0CEF
4574  0CF0
4575  0CF1
4576  0CF2
4577  0CF3
4578  0CF4
4579  0CF5
4580  0CF6
4581  0CF7
4582  0CF8
4583  0CF9
4584  0CFA
4585  0CFB
4586  0CFC
4587  0CFD
4588  0CFE
4589  0CFF
4590  0D00
4591  0D01
4592  0D02
4593  0D03
4594  0D04
4595  0D05
4596  0D06
4597  0D07
4598  0D08
4599  0D09
4600  0D0A
4601  0D0B
4602  0D0C
4603  0D0D
4604  0D0E
4605  0D0F
4606  0D10
4607  0D11
4608  0D12
4609  0D13
4610  0D14
4611  0D15
4612  0D16
4613  0D17
4614  0D18
4615  0D19
4616  0D1A
4617  0D1B
4618  0D1C
4619  0D1D
4620  0D1E
4621  0D1F
4622  0D20
4623  0D21
4624  0D22
4625  0D23
4626  0D24
4627  0D25
4628  0D26
4629  0D27
4630  0D28
4631  0D29
4632  0D2A
4633  0D2B
4634  0D2C
4635  0D2D
4636  0D2E
4637  0D2F
4638  0D30
4639  0D31
4640  0D32
4641  0D33
4642  0D34
4643  0D35
4644  0D36
4645  0D37
4646  0D38
4647  0D39
4648  0D3A
4649  0D3B
4650  0D3C
4651  0D3D
4652  0D3E
4653  0D3F
4654  0D40
4655  0D41
4656  0D42
4657  0D43
4658  0D44
4659  0D45
4660  0D46
4661  0D47
4662  0D48
4663  0D49
4664  0D4A
4665  0D4B
4666  0D4C
4667  0D4D
4668  0D4E
4669  0D4F
4670  0D50
4671  0D51
4672  0D52
4673  0D53
4674  0D54
4675  0D55
4676  0D56
4677  0D57
4678  0D58
4679  0D59
4680  0D5A
4681  0D5B
4682  0D5C
4683  0D5D
4684  0D5E
4685  0D5F
4686  0D60
4687  0D61
4688  0D62
4689  0D63
4690  0D64
4691  0D65
4692  0D66
4693  0D67
4694  0D68
4695  0D69
4696  0D6A
4697  0D6B
4698  0D6C
4699  0D6D
4700  0D6E
4701  0D6F
4702  0D70
4703  0D71
4704  0D72
4705  0D73
4706  0D74
4707  0D75
4708  0D76
4709  0D77
4710  0D78
4711  0D79
4712  0D7A
4713  0D7B
4714  0D7C
4715  0D7D
4716  0D7E
4717  0D7F
4718  0D80
4719  0D81
4720  0D82
4721  0D83
4722  0D84
4723  0D85
4724  0D86
4725  0D87
4726  0D88
4727  0D89
4728  0D8A
4729  0D8B
4730  0D8C
4731  0D8D
4732  0D8E
4733  0D8F
4734  0D90
4735  0D91
4736  0D92
4737  0D93
4738  0D94
4739  0D95
4740  0D96
4741  0D97
4742  0D98
4743  0D99
4744  0D9A
4745  0D9B
4746  0D9C
4747  0D9D
4748  0D9E
4749  0D9F
4750  0DA0
4751  0DA1
4752  0DA2
4753  0DA3
4754  0DA4
4755  0DA5
4756  0DA6
4757  0DA7
4758  0DA8
4759  0DA9
4760  0DAA
4761  0DAB
4762  0DAC
4763  0DAD
4764  0DAE
4765  0DAF
4766  0DB0
4767  0DB1
4768  0DB2
4769  0DB3
4770  0DB4
4771  0DB5
4772  0DB6
4773  0DB7
4774  0DB8
4775  0DB9
4776  0DBA
4777  0DBB
4778  0DBC
4779  0DBD
4780  0DBE
4781  0DBF
4782  0DC0
4783  0DC1
4784  0DC2
4785  0DC3
4786  0DC4
4787  0DC5
4788  0DC6
4789  0DC7
4790  0DC8
4791  0DC9
4792  0DCA
4793  0DCB
4794  0DCC
4795  0DCD
4796  0DCE
4797  0DCF
4798  0DD0
4799  0DD1
4800  0DD2
4801  0DD3
4802  0DD4
4803  0DD5
4804  0DD6
4805  0DD7
4806  0DD8
4807  0DD9
4808  0DDA
4809  0DDB
4810  0DDC
4811  0DDD
4812  0DDE
4813  0DDF
4814  0DE0
4815  0DE1
4816  0DE2
4817  0DE3
4818  0DE4
4819  0DE5
4820  0DE6
4821  0DE7
4822  0DE8
4823  0DE9
4824  0DEA
4825  0DEB
4826  0DEC
4827  0DED
4828  0DEE
4829  0DEF
4830  0DF0
4831  0DF1
4832  0DF2
4833  0DF3
4834  0DF4
4835  0DF5
4836  0DF6
4837  0DF7
4838  0DF8
4839  0DF9
4840  0DFA
4841  0DFB
4842  0DFC
4843  0DFD
4844  0DFE
4845  0DFF
4846  0E00
4847  0E01
4848  0E02
4849  0E03
4850  0E04
4851  0E05
4852  0E06
4853  0E07
4854  0E08
4855  0E09
4856  0E0A
4857  0E0B
4858  0E0C
4859  0E0D
4860  0E0E
4861  0E0F
4862  0E10
4863  0E11
4864  0E12
4865  0E13
4866  0E14
4867  0E15
4868  0E16
4869  0E17
4870  0E18
4871  0E19
4872  0E1A
4873  0E1B
4874  0E1C
4875  0E1D
4876  0E1E
4877  0E1F
4878  0E20
4879  0E21
4880  0E22
4881  0E23
4882  0E24
4883  0E25
4884  0E26
4885  0E27
4886  0E28
4887  0E29
4888  0E2A
4889  0E2B
4890  0E2C
4891  0E2D
4892  0E2E
4893  0E2F
4894  0E30
4895  0E31
4896  0E32
4897  0E33
4898  0E34
4899  0E35
4900  0E36
4901  0E37
4902  0E38
4903  0E39
4904  0E3A
4905  0E3B
4906  0E3C
4907  0E3D
4908  0E3E
4909  0E3F
4910  0E40
4911  0E41
4912  0E42
4913  0E43
4914  0E44
4915  0E45
4916  0E46
4917  0E47
4918  0E48
4919  0E49
4920  0E4A
4921  0E4B
4922  0E4C
4923  0E4D
4924  0E4E
4925  0E4F
4926  0E50
4927  0E51
4928  0E52
4929  0E53
4930  0E54
4931  0E55
4932  0E56
4933  0E57
4934  0E58
4935  0E59
4936  0E5A
4937  0E5B
4938  0E5C
4939  0E5D
4940  0E5E
4941  0E5F
4942  0E60
4943  0E61
4944  0E62
4945  0E63
4946  0E64
4947  0E65
4948  0E66
4949  0E67
4950  0E68
4951  0E69
4952  0E6A
4953  0E6B
4954  0E6C
4955  0E6D
4956  0E6E
4957  0E6F
4958  0E70
4959  0E71
4960  0E72
4961  0E73
4962  0E74
4963  0E75
4964  0E76
4965  0E77
4966  0E78
4967  0E79
4968  0E7A
4969  0E7B
4970  0E7C
4971  0E7D
4972  0E7E
4973  0E7F
4974  0E80
4975  0E81
4976  0E82
4977  0E83
4978  0E84
4979  0E85
4980  0E86
4981  0E87
4982  0E88
4983  0E89
4984  0E8A
4985  0E8B
4986  0E8C
4987  0E8D
4988  0E8E
4989  0E8F
4990  0E90
4991  0E91
4992  0E92
4993  0E93
4994  0E94
4995  0E95
4996  0E96
4997  0E97
4998  0E98
4999  0E99
5000  0E9A
5001  0E9B
5002  0E9C
5003  0E9D
5004  0E9E
5005  0E9F
5006  0EA0
5007  0EA1
5008  0EA2
5009  0EA3
5010  0EA4
5011  0EA5
5012  0EA6
5013  0EA7
5014  0EA8
5015  0EA9
5016  0EAA
5017  0EAB
5018  0EAC
5019  0EAD
5020  0EAE
5021  0EAF
5022  0EB0
5023  0EB1
5024  0EB2
5025  0EB3
5026  0EB4
5027  0EB5
5028  0EB6
5029  0EB7
5030  0EB8
5031  0EB9
5032  0EBA
5033  0EBB
5034  0EBC
5035  0EBD
5036  0EBE
5037  0EBF
5038  0EC0
5039  0EC1
5040  0EC2
5041  0EC3
5042  0EC4
5043  0EC5
5044  0EC6
5045  0EC7
5046  0EC8
5047  0EC9
5048  0ECA
5049  0ECB
5050  0ECC
5051  0ECD
5052  0ECE
5053  0ECF
5054  0ED0
5055  0ED1
5056  0ED2
5057  0ED3
5058  0ED4
5059  0ED5
5060  0ED6
5061  0ED7
5062  0ED8
5063  0ED9
5064  0EDA
5065  0EDB
5066  0EDC
5067  0EDD
5068  0EDE
5069  0EDF
5070  0EE0
5071  0EE1
5072  0EE2
5073  0EE3
5074  0EE4
5075  0EE5
5076  0EE6
5077  0EE7
5078  0EE8
5079  0EE9
5080  0EEA
5081  0EEB
5082  0EEC
5083  0EED
5084  0EEE
5085  0EEF
5086  0EF0
5087  0EF1
5088  0EF2
5089  0EF3
5090  0EF4
5091  0EF5
5092  0EF6
5093  0EF7
5094  0EF8
5095  0EF9
5096  0EFA
5097  0EFB
5098  0EFC
5099  0EFD
5100  0EFE
5101  0EFF
5102  0F00
5103  0F01
5104  0F02
5105  0F03
5106  0F04
5107  0F05
5108  0F06
5109  0F07
5110  0F08
5111  0F09
5112  0F0A
5113  0F0B
5114  0F0C
5115  0F0D
5116  0F0E
5117  0F0F
5118  0F10
5119  0F11
5120  0F12
5121  0F13
5122  0F14
5123  0F15
5124  0F16
5125  0F17
5126  0F18
5127  0F19
5128  0F1A
5129  0F1B
5130  0F1C
5131  0F1D
5132  0F1E
5133  0F1F
5134  0F20
5135  0F21
5136  0F22
5137  0F23
5138  0F24
5139  0F25
5140  0F26
5141  0F27
5142  0F28
5143  0F29
5144  0F2A
5145  0F2B
5146  0F2C
5147  0F2D
5148  0F2E
5149  0F2F
5150  0F30
5151  0F31
5152  0F32
5153  0F33
5154  0F34
5155  0F35
5156  0F36
5157  0F37
5158  0F38
5159  0F39
5160  0F3A
5161  0F3B
5162  0F3C
5163  0F3D
5164  0F3E
5165  0F3F
5166  0F40
5167  0F41
5168  0F42
5169  0F43
5170  0F44
5171  0F45
5172  0F46
5173  0F47
5174  0F48
5175  0F49
5176  0F4A
5177  0F4B
5178  0F4C
5179  0F4D
5180  0F4E
5181  0F4F
5182  0F50
5183  0F51
5184  0F52
5185  0F53
5186  0F54
5187  0F55
5188  0F56
5189  0F57
5190  0F58
5191  0F59
5192  0F5A
5193  0F5B
5194  0F5C
5195  0F5D
5196  0F5E
5197  0F5F
5198  0F60
5199  0F61
5200  0F62
5201  0F63
5202  0F64
5203  0F65
5204  0F66
5205  0F67
5206  0F68
5207  0F69
5208  0F6A
5209  0F6B
5210  0F6C
5211  0F6D
5212  0F6E
5213  0F6F
5214  0F70
5215  0F71
5216  0F72
5217  0F73
5218  0F74
5219  0F75
5220  0F76
5221  0F77
5222  0F78
5223  0F79
5224  0F7A
5225  0F7B
5226  0F7C
5227  0F7D
5228  0F7E
5229  0F7F
5230  0F80
5231  0F81
5232  0F82
5233  0F83
5234  0F84
5235  0F85
5236  0F86
5237  0F87
5238  0F88
5239  0F89
5240  0F8A
5241  0F8B
5242  0F8C
5243  0F8D
5244  0F8E
5245  0F8F
5246  0F90
5247  0F91
5248  0F92
5249  0F93
5250  0F94
5251  0F95
5252  0F96
5253  0F97
5254  0F98
5255  0F99
5256  0F9A
5257  0F9B
5258  0F9C
5259  0F9D
5260  0F9E
5261  0F9F
5262  0FA0
5263  0FA1
5264  0FA2
5265  0FA3
5266  0FA4
5267  0FA5
5268  0FA6
5269  0FA7
5270  0FA8
5271  0FA9
5272  0FAA
5273  0FAB
5274  0FAC
5275  0FAD
5276  0FAE
5277  0FAF
5278  0FB0
5279  0FB1
5280  0FB2
5281  0FB3
5282  0FB4
5283  0FB5
5284  0FB6
5285  0FB7
5286  0FB8
5287  0FB9
5288  0FBA
5289  0FBB
5290  0FBC
5291  0FBD
5292  0FBE
5293  0FBF
5294  0FC0
5295  0FC1
5296  0FC2
5297  0FC3
5298  0FC4
5299  0FC5
5300  0FC6
5301  0FC7
5302  0FC8
5303  0FC9
5304  0FCA
5305  0FCB
5306  0FCC
5307  0FCD
5308  0FCE
5309  0FCF
5310  0FD0
5311  0FD1
5312  0FD2
5313  0FD3
5314  0FD4
5315  0FD5
5316  0FD6
5317  0FD7
5318  0FD8
5319  0FD9
5320  0FDA
5321  0FDB
5322  0FDC
5323  0FDD
5324  0FDE
5325  0FDF
5326  0FE0
5327  0FE1
5328  0FE2
5329  0FE3
5330  0FE4
5331  0FE5
5332  0FE6
5333  0FE7
5334  0FE8
5335  0FE9
5336  0FEA
5337  0FEB
5338  0FEC
5339  0FED
5340  0FEE
5341  0FEF
5342  0FF0
5343  0FF1
5344  0FF2
5345  0FF3
5346  0FF4
5347  0FF5
5348  0FF6
5349  0FF7
5350  0FF8
5351  0FF9
5352  0FFA
5353  0FFB
5354  0FFC
5355  0FFD
5356  0FFE
5357  0FFF
5358  1000
5359  1001
5360  1002
5361  1003
5362  1004
5363  1005
5364  1006
5365  1007
5366  1008
5367  1009
5368  100A
5369  100B
5370  100C
5371  100D
5372  100E
5373  100F
5374  1010
5375  1011
5376  1012
5377  1013
5378  1014
5379  1015
5380  1016
5381  1017
5382  1018
5383  1019
5384  101A
5385  101B
5386  101C
5387  101D
5388  101E
5389  101F
5390  1020
5391  1021
5392  1022
5393  1023
5394  1024
5395  1025
5396  1026
5397  1027
5398  1028
5399  1029
5400  102A
5401  102B
5402  102C
5403  102D
5404  102E
5405  102F
5406  1030
5407  1031
5408  1032
5409  1033
5410  1034
5411  1035
5412  1036
5413  1037
5414  1038
5415  1039
5416  103A
5417  103B
5418  103C
5419  103D
5420  103E
5421  103F
5422  1040
5423  1041
5424  1042
5425  1043
5426  1044
5427  1045
5428  1046
5429  1047
5430  1048
5431  1049
5432  104A
5433  104B
5434  104C
5435  104D
5436  104E
5437  104F
5438  1050
5439  1051
5440  1052
5441  1053
5442  1054
5443  1055
5444  1056
5445  1057
5446  1058
5447  1059
5448  105A
5449  105B
5450  105C
5451  105D
5452  105E
5453  105F
5454  1060
5455  1061
5456  1062
5457  1063
5458  1064
5459  1065
5460  1066
5461  1067
5462  1068
5463  1069
5464  106A
5465  106B
5466  106C
5467  106D
5468  106E
5469  106F
5470  1070
5471  1071
5472  1072
5473  1073
5474  1074
5475  1075
5476  1076
5477  1077
5478  1078
5479  1079
5480  107A
5481  107B
5482  107C
5483  107D
5484  107E
5485  107F
5486  1080
5487  1081
5488  1082
5489  1083
5490  1084
5491  1085
5492  1086
5493  1087
5494  1088
5495  1089
5496  108A
5497  108B
5498  108C
5499  108D
5500  108E
5501  108F
5502  1090
5503  1091
5504  1092
5505  1093
5506  1094
5507  1095
5508  1096
5509  1097
5510  1098
5511  1099
5512  109A
5513  109B
5514  109C
5515  109D
5516  109E
5517  109F
5518  10A0
5519  10A1
5520  10A2
5521  10A3
5522  10A4
5523  10A5
5524  10A6
5525  10A7
5526  10A8
5527  10A9
5528  10AA
5529  10AB
5530  10AC
5531  10AD
5532  10AE
5533  10AF
5534  10B0
5535  10B1
5536  10B2
5537  10B3
5538  10B4
5539  10B5
5540  10B6
5541  10B7
5542  10B8
5543  10B9
5544  10BA
5545  10BB
5546  10BC
5547  10BD
5548  10BE
5549  10BF
5550  10C0
5551  10C1
5552  10C2
5553  10C3
5554  10C4
5555  10C5
5556  10C6
5557  10C7
5558  10C8
5559  10C9
5560  10CA
5561  10CB
5562  10CC
5563  10CD
5564  10CE
5565  10CF
5566  10D0
5567  10D1
5568  10D2
5569  10D3
5570  10D4
5571  10D5
5572  10D6
5573  10D7
5574  10D8
5575  10D9
5576  10DA
5577  10DB
5578  10DC
5579  10DD
5580  10DE
5581  10DF
5582  10E0
5583  10E1
5584  10E2
5585  10E3
5586  10E4
5587  10E5
5588  10E6
5589  10E7
5590  10E8
5591  10E9
5592  10EA
5593  10EB
5594  10EC
5595  10ED
5596  10EE
5597  10EF
5598  10F0
5599  10F1
5600  10F2
5601  10F3
5602  10F4
5603  10F5
5604  10F6
5605  10F7
5606  10F8
5607  10F9
5608  10FA
5609  10FB
5610  10FC
5611  10FD
5612  10FE
5613  10FF
5614  1100
5615  1101
5616  1102
5617  1103
5618  1104
5619  1105
5620  1106
5621  1107
5622  1108
5623  1109
5624  110A
5625  110B
5626  110C
5627  110D
5628  110E
5629  110F
5630  1110
5631  1111
5632  1112
5633  1113
5634  1114
5635  1115
5636  1116
5637  1117
5638  1118
5639  1119
5640  111A
5641  111B
5642  111C
5643  111D
5644  111E
5645  111F
5646  1120
5647  1121
5648  1122
5649  1123
5650  1124
5651  1125
5652  1126
5653  1127
5654  1128
5655  1129
5656  112A
5657  112B
5658  112C
5659  112D
5660  112E
5661  112F
5662  1130
5663  1131
5664  1132
5665  1133
5666  1134
5667  1135
5668  1136
5669  1137
5670  1138
5671  1139
5672  113A
5673  113B
5674  113C
5675  113D
5676  113E
5677  113F
5678  1140
5679  1141
5680  1142
5681  1143
5682  1144
5683  1145
5684  1146
5685  1147
5686  1148
5687  1149
5688  114A
5689  114B
5690  114C
5691  114D
5692  114E
5693  114F
5694  1150
5695  1151
5696  1152
5697  1153
5698  1154
5699  1155
5700  1156
5701  1157
5702  1158
5703  1159
5704  115A
5705  115B
5706  115C
5707  115D
5708  115E
5709  115F
5710  1160
5711  1161
5712  1162
5713  1163
5714  1164
5715  1165
5716  1166
5717  1167
5718  1168
5719  1169
5720  116A
5721  116B
5722  116C
5723  116D
5724  116E
5725  116F
5726  1170
5727  1171
5728  1172
5729  1173
5730  1174
5731  1175
5732  1176
5733  1177
5734  1178
5735  1179
5736  117A
5737  117B
5738  117C
5739  117D
5740  117E
5741  117F
5742  1180
5743  1181
5744  1182
5745  1183
5746  1184
5747  1185
5748  1186
5749  1187
5750  1188
5751  1189
5752  118A
5753  118B
5754  118C
5755  118D
5756  118E
5757  118F
5758  1190
5759  1191
5760  1192
5761  1193
5762  1194
5763  1195
5764  1196
5765  1197
5766  1198
5767  1199
5768  119A
5769  119B
5770  119C
5771  119D
5772  119E
5773  119F
5774  11A0
5775  11A1
5776  11A2
5777  11A3
5778  11A4
5779  11A5
5780  11A6
5781  11A7
5782  11A8
5783  11A9
5784  11AA
5785  11AB
5786  11AC
5787  11AD
5788  11AE
5789  11AF
5790  11B0
5791  11B1
5792  11B2
5793  11B3
5794  11B4
5795  11B5
5796  11B6
5797  11B7
5798  11B8
5799  11B9
5800  11BA
5801  11BB
5802  11BC
5803  11BD
5804  11BE
5805  11BF
5806  11C0
5807  11C1
5808  11C2
5809  11C3
5810  11C4
5811  11C5
5812  11C6
5813  11C7
5814  11C8
5815  11C9
5816  11CA
5817  11CB
5818  11CC
5819  11CD
5820  11CE
5821  11CF
5822  11D0
5823  11D1
5824  11D2
5825  11D3
5826  11D4
5827  11D5
5828  11D6
5829  11D7
5830  11D8
5831  11D9
5832  11DA
5833  11DB
5834  11DC
5835  11DD
5836  11DE
5837  11DF
5838  11E0
5839  11E1
5840  11E2
5841  11E3
5842  11E4
5843  11E5
5844  11E6
5845  11E7
5846  11E8
5847  11E9
5848  11EA
5849  11EB
5850  11EC
5851  11ED
5852  11EE
5853  11EF
5854  11F0
5855  11F1
5856  11F2
5857  11F3
5858  11F4
5859  11F5
5860  11F6
5861  11F7
5862  11F8
5863  11F9
5864  11FA
5865  11FB
5866  11FC
5867  11FD
5868  11FE
5869  11FF
5870  1200
5871  1201
5872  1202
5873  1203
5874  1204
5875  1205
5876  1206
5877  1207
5878  1208
5879  1209
5880  120A
5881  120B
5882  120C
5883  120D
5884  120E
5885  120F
5886  1210
5887  1211
5888  1212
5889  1213
5890  1214
5891  1215
5892  1216
5893  1217
5894  1218
5895  1219
5896  121A
5897  121B
5898  121C
5899  121D
5900  121E
5901  121F
5902  1220
5903  1221
5904  1222
5905  1223
5906  1224
5907  1225
5908  1226
5909  1227
5910  1228
5911  1229
5912  122A
5913  122B
5914  122C
5915  122D
5916  122E
5917  122F
5918  1230
5919  1231
5920  1232
5921  1233
5922  1234
5923  1235
5924  1236
5925  1237
5926  1238
5927  1239
5928  123A
5929  123B
5930  123C
5931  123D
5932  123E
5933  123F
5934  1240
5935  1241
5936  1242
5937  1243
5938  1244
5939  1245
5940  1246
5941  1247
5942  1248
5943  1249
5944  124A
5945  124B
5946  124C
5947  124D
5948  124E
5949  124F
5950  1250
5951  1251
5952  1252
5953  1253
5954  1254
5955  1255
5956  1256
5957  1257
5958  1258
5959  1259
5960  125A
5961  125B
5962  125C
5963  125D
5964  125E
5965  125F
5966  1260
5967  1261
5968  1262
5969  1263
5970  1264
5971  1265
5972  1266
5973  1267
5974  1268
5975  1269
5976  126A
5977  126B
5978  126C
5979  126D
5980  126E
5981  126F
5982  1270
5983  1271
5984  1272
5985  1273
5986  1274
5987  1275
5988  1276
5989  1277
5990  1278
5991  1279
5992  127A
5993  127B
5994  127C
5995  127D
5996  127E
5997  127F
5998  1280
5999  1281
6000  1282
6001  1283
6002  1284
6003  1285
6004  1286
6005  1287
6006  1288
6007  1289
6008  128A
6009  128B
6010  128C
6011  128D
6012  128E
6013  128F
6014  1290
6015  1291
6016  1292
6017  1293
6018  1294
6019  1295
6020  1296
6021  1297
6022  1298
6023  1299
6024  129A
6025  129B
6026  129C
6027  129D
6028  129E
6029  129F
6030  12A0
6031  12A1
6032  12A2
6033  12A3
6034  12A4
6035  12A5
6036  12A6
6037  12A7
6038  12A8
6039  12A9
6040  12AA
6041  12AB
6042  12AC
6043  12AD
6044  12AE
6045  12AF
6046  12B0
6047  12B1
6048  12B2
6049  12B3
6050  12B4
6051  12B5
6052  12B6
6053  12B7
6054  12B8
6055  12B9
6056  12BA
6057  12BB
6058  12BC
6059  12BD
6060  12BE
6061  12BF
6062  12C0
6063  12C1
6064  12C2
6065  12C3
6066  12C4
6067  12C5
6068  12C6
6069  12C7
6070  12C8
6071  12C9
6072  12CA
6073  12CB
6074  12CC
6075  12CD
6076  12CE
6077  12CF
6078  12D0
6079  12D1
6080  12D2
6081  12D3
6082  12D4
6083  12D5
6084  12D6
6085  12D7
6086  12D8
6087  12D9
6088  12DA
6089  12DB
6090  12DC
6091  12DD
6092  12DE
6093  12DF
6094  12E0
6095  12E1
6096  12E2
6097  12E3
6098  12E4
6099  12E5
6100  12E6
6101  12E7
6102  12E8
6103  12E9
6104  12EA
6105  12EB
6106  12EC
6107  12ED
6108  12EE
6109  12EF
6110  12F0
6111  12F1
6112  12F2
6113  12F3
6114  12F4
6115  12F5
6116  12F6
6117  12F7
6118  12F8
6119  12F9
6120  12FA
6121  12FB
6122  12FC
6123  12FD
6124  12FE
6125  12FF
6126  1300
6127  1301
6128  1302
6129  1303
6130  1304
6131  1305
6132  1306
6133  1307
6134  1308
6135  1309
6136  130A
6137  130B
6138  130C
6139  130D
6140  130E
6141  130F
6142  1310
6143  1311
6144  1312
6145  1313
6146  1314
6147  1315
6148  1316
6149  1317
6150  1318
6151  1319
6152  131A
6153  131B
6154  131C
6155  131D
6156  131E
6157  131F
6158  1320
6159  1321
6160  1322
6161  1323
6162  1324
6163  1325
6164  1326
6165  1327
6166  1328
6167  1329
6168  132A
6169  132B
6170  132C
6171  132D
6172  132E
6173  132F
6174  1330
6175  1331
6176  1332
6177  1333
6178  1334
6179  1335
6180  1336
6181  1337
6182  1338
6183  1339
6184  133A
6185  133B
6186  133C
6187  133D
6188  133E
6189  133F
6190  1340
6191  1341
6192  1342
6193  1343
6194  1344
6195  1345
6196  1346
6197  1347
6198  1348
6199  1349
6200  134A
6201  134B
6202  134C
6203  134D
6204  134E
6205  134F
6206  1350
6207  1351
6208  1352
6209  1353
6210  1354
6211  1355
6212  1356
6213  1357
6214  1358
6215  1359
6216  135A
6217  135B
6218  135C
6219  135D
6220  135E
6221  135F
6222  1360
6223  1361
6224  1362
6225  1363
6226  1364
6227  1365
6228  1366
6229  1367
6230  1368
6231  1369
6232  136A
6233  136B
6234  136C
6235  136D
6236  136E
6237  136F
6238  1370
6239  1371
6240  1372
6241  1373
6242  1374
6243  1375
6244  1376
6245  1377
6246  1378
6247  1379
6248  137A
6249  137B
6250  137C
6251  137D
6252  137E
6253  137F
6254  1380
6255  1381
6256  1382
6257  1383
6258  1384
6259  1385
6260  1386
6261  1387
6262  1388
6263  1389
6264  138A
6265  138B
6266  138C
6267  138D
6268  138E
6269  138F
6270  1390
6271  1391
6272  1392
6273  1393
6274  1394
6275  1395
6276  1396
6277  1397
6278  1398
6279  1399
6280  139A
6281  139B
6282  139C
6283  139D
6284  139E
6285  139F
6286  13A0
6287  13A1
6288  13A2
6289  13A3
6290  13A4
6291  13A5
6292  13A6
6293  13A7
6294  13A8
6295  13A9
6296  13AA
6297  13AB
6298  13AC
6299  13AD
6300  13AE
6301  13AF
6302  13B0
6303  13B1
6304  13B2
6305  13B3
6306  13B4
6307  13B5
6308  13B6
6309  13B7
6310  13B8
6311  13B9
6312  13BA
6313  13BB
6314  13BC
6315  13BD
6316  13BE
6317  13BF
6318  13C0
6319  13C1
6320  13C2
6321  13C3
6322  13C4
6323  13C5
6324  13C6
6325  13C7
6326  13C8
6327  13C9
6328  13CA
6329  13CB
6330  13CC
6331  13CD
6332  13CE
6333  13CF
6334  13D0
6335  13D1
6336  13D2
6337  13D3
6338  13D4
6339  13D5
6340  13D6
6341  13D7
6342  13D8
6343  13D9
6344  13DA
6345  13DB
6346  13DC
6347  13DD
6348  13DE
6349  13DF
6350  13E0
6351  13E1
6352  13E2
6353  13E3
6354  13E4
6355  13E5
6356  13E6
6357  13E7
6358  13E8
6359  13E9
6360  13EA
6361  13EB
6362  13EC
6363  13ED
6364  13EE
6365  13EF
6366  13F0
6367  13F1
6368  13F2
6369  13F3
6370  13F4
6371  13F5
6372  13F6
6373  13F7
6374  13F8
6375  13F9
6376  13FA
6377  13FB
6378  13FC
6379  13FD
6380  13FE
6381  13FF
6382  1400
6383  1401
6384  1402
6385  1403
6386  1404
6387  1405
6388  1406
6389  1407
6390  1408
6391  1409
6392  140A
6393  140B
6394  140C
6395  140D
6396  140E
6397  140F
6398  1410
6399  1411
6400  1412
6401  1413
6402  1414
6403  1415
6404  1416
6405  1417
6406  1418
6407  1419
6408  141A
6409  141B
6410  141C
6411  141D
6412  141E
6413  141F
6414  1420
6415  1421
6416  1422
6417  1423
6418  1424
6419  1425
6420  1426
6421  1427
6422  1428
6423  1429
6424  142A
6425  142B
6426  142C
6427  142D
6428  142E
6429  142F
6430  1430
6431  1431
6432  1432
6433  1433
6434  1434
6435  1435
6436  1436
6437  1437
6438  1438
6439  1439
6440  143A
6441  143B
6442  143C
6443  143D
6444  143E
6445  143F
6446  1440
6447  1441
6448  1442
6449  1443
6450  1444
6451  1445
6452  1446
6453  1447
6454  1448
6455  1449
6456  144A
6457  144B
6458  144C
6459  144D
6460  144E
6461  144F
6462  1450
6463  1451
6464  1452
6465  1453
6466  1454
6467  1455
6468  1456
6469  1457
6470  1458
6471  1459
6472  145A
6473  145B
6474  145C
6475  145D
6476  145E
6477  145F
6478  1460
6479  1461
6480  1462
6481  1463
6482  1464
6483  1465
6484  1466
6485  1467
6486  1468
6487  1469
6488  146A
6489  146B
6490  146C
6491  146D
6492  146E
6493  146F
6494  1470
6495  1471
6496  1472
6497  1473
6498  1474
6499  1475
6500  1476
6501  1477
6502  1478
6503  1479
6504  147A
6505  147B
6506  147C
6507  147D
6508  147E
6509  147F
6510  1480
6511  1481
6512  1482
6513  1483
6514  1484
6515  1485
6516  1486
6517  1487
6518  1488
6519  1489
6520  148A
6521  148B
6522  148C
6523  148D
6524  148E
6525  148F
6526  1490
6527  1491
6528  1492
6529  1493
6530  1494
6531  1495
6532  1496
6533  1497
6534  1498
6535  1499
6536  149A
6537  149B
6538  149C
6539  149D
6540  149E
6541  149F
6542  14A0
6543  14A1
6544  14A2
6545  14A3
6546  14A4
6547  14A5
6548  14A6
6549  14A7
6550  14A8
6551  14A9
6552  14AA
6553  14AB
6554  14AC
6555  14AD
6556  14AE
6557  14AF
6558  14B0
6559  14B1
6560  14B2
6561  14B3
6562  14B4
6563  14B5
6564  14B6
6565  14B7
6566  14B8
6567  14B9
6568  14BA
6569  14BB
6570  14BC
6571  14BD
6572  14BE
6573  14BF
6574  14C0
6575  14C1
6576  14C2
6577  14C3
6578  14C4
6579  14C5
6580  14C6
6581  14C7
6582  14C8
6583  14C9
6584  14CA
6585  14CB
6586  14CC
6587  14CD
6588  14CE
6589  14CF
6590  14D0
6591  14D1
6592  14D2
6593  14D3
6594  14D4
6595  14D5
6596  14D6
6597  14D7
6598  14D8
6599  14D9
6600  14DA
6601  14DB
6602  14DC
6603  14DD
6604  14DE
6605  14DF
6606  14E0
6607  14E1
6608  14E2
6609  14E3
6610  14E4
6611  14E5
6612  14E6
6613  14E7
6614  14E8
6615  14E9
6616  14EA
6617  14EB
6618  14EC
6619  14ED
6620  14EE
6621  14EF
6622  14F0
6623  14F1
6624  14F2
6625  14F3
6626  14F4
6627  14F5
6628  14F6
6629  14F7
6630  14F8
6631  14F9
6632  14FA
6633  14FB
6634  14FC
6635  14FD
6636  14FE
6637  14FF
6638  1500
6639  1501
6640  1502
6641  1503
6642  1504
6643  1505
6644  1506
6645  1507
6646  1508
6647  1509
6648  150A
6649  150B
6650  150C
6651  150D
6652  150E
6653  150F
6654  1510
6655  1511
6656  1512
6657  1513
6658  1514
6659  1515
6660  1516
6661  1517
6662  1518
6663  1519
6664  151A
6665  151B
6666  151C
6667  151D
6668  151E
6669  151F
6670  1520
6671  1521
6672  1522
6673  1523
6674  1524
6675  1525
6676  1526
6677  1527
6678  1528
6679  1529
6680  152A
6681  152B
6682  152C
6683  152D
6684  152E
6685  152F
6686  1530
6687  1531
6688  1532
6689  1533
6690  1534
6691  1535
6692  1536
6693  1537
6694  1538
6695  1539
6696  153A
6697  153B
6698  153C
6699  153D
6700  153E
6701  153F
6702  1540
6703  1541
6704  1542
6705  1543
6706  1544
6707  1545
6708  1546
6709  1547
6710  1548
6711  1549
6712  154A
6713  154B
6714  154C
6715  154D
6716  154E
6717  154F
6718  1550
6719  1551
6720  1552
6721  1553
6722  1554
6723  1555
6724  1556
6725  1557
6726  1558
6727  1559
6728  155A
6729  155B
6730  155C
6731  155D
6732  155E
6733  155F
6734  1560
6735  1561
6736  1562
6737  1563
6738  1564
6739  1565
6740  1566
6741  1567
6742  1568
6743  1569
6744  156A
6745  156B
6746  156C
6747  156D
6748  156E
6749  156F
6750  1570
6751  1571
6752  1572
6753  1573
6754  1574
6755  1575
6756  1576
6757  1577
6758  1578
6759  1579
6760  157A
6761  157B
6762  157C
6763  157D
6764  157E
6765  157F
6766  1580
6767  1581
6768  1582
6769  1583
6770  1584
6771  1585
6772  1586
6773  1587
6774  1588
6775  1589
6776  158A
6777  158B
6778  158C
6779  158D
6780  158E
6781  158F
6782  1590
6783  1591
6784  1592
6785  1593
6786  1594
6787  1595
6788  1596
6789  1597
6790  1598
6791  1599
6792  159A
6793  159B
6794  159C
6795  159D
6796  159E
6797  159F
6798  15A0
6799  15A1
6800  15A2
6801  15A3
6802  15A4
6803  15A5
6804  15A6
6805  15A7
6806  15A8
6807  15A9
6808  15AA
6809  15AB
6810  15AC
6811  15AD
6812  15AE
6813  15AF
6814  15B0
6815  15B1
6816  15B2
6817  15B3
6818  15B4
6819  15B5
6820  15B6
6821  15B7
6822  15B8
6823  15B9
6824  15BA
6825  15BB
6826  15BC
6827  15BD
6828  15BE
6829  15BF
6830  15C0
6831  15C1
6832  15C2
6833  15C3
6834  15C4
6835  15C5
6836  15C6
6837  15C7
6838  15C8
6839  15C9
6840  15CA
6841  15CB
6842  15CC
6843  15CD
6844  15CE
6845  15CF
6846  15D0
6847  15D1
6848  15D2
6849  15D3
6850  15D4
6851  15D5
6852  15D6
6853  15D7
6854  15D8
6855  15D9
6856  15DA
6857  15DB
6858  15DC
6859  15DD
6860  15DE
6861  15DF
6862  15E0
6863  15E1
6864  15E2
6865  15E3
6866  15E4
6867  15E5
6868  15E6
6869  15E7
6870  15E8
6871  15E9
6872  15EA
6873  15EB
6874  15EC
6875  15ED
6876  15EE
6877  15EF
6878  15F0
6879  15F1
6880  15F2
6881  15F3
6882  15F4
6883  15F5
6884  15F6
6885  15F7
6886  15F8
6887  15F9
6888  15FA
6889  15FB
6890  15FC
6891  15FD
6892  15FE
6893  15FF
6894  1600
6895  1601
6896  1602
6897  1603
6898  1604
6899  1605
6900  1606
6901  1607
6902  1608
6903  1609
6904  160A
6905  160B
6906  160C
6907  160D
6908  160E
6909  160F
6910  1610
6911  1611
6912  1612
6913  1613
6914  1614
6915  1615
6916  1616
6917  1617
6918  1618
6919  1619
6920  161A
6921  161B
6922  161C
6923  161D
6924  161E
6925  161F
6926  1620
6927  1621
6928  1622
6929  1623
6930  1624
6931  1625
6932  1626
6933  1627
6934  1628
6935  1629
6936  162A
6937  162B
6938  162C
6939  162D
6940  162E
6941  162F
6942  1630
6943  1631
6944  1632
6945  1633
6946  1634
6947  1635
6948  1636
6949  1637
6950  1638
6951  1639
6952  163A
6953  163B
6954  163C
6955  163D
6956  163E
6957  163F
6958  1640
6959  1641
6960  1642
6961  1643
6962  1644
6963  1645
6964  1646
6965  1647
6966  1648
6967  1649
6968  164A
6969  164B
6970  164C
6971  164D
6972  164E
6973  164F
6974  1650
6975  1651
6976  1652
6977  1653
6978  1654
6979  1655
6980  1656
6981  1657
6982  1658
6983  1659
6984  165A
6985  165B
6986  165C
6987  165D
6988  165E
6989  165F
6990  1660
6991  1661
6992  1662
6993  1663
6994  1664
6995  1665
6996  1666
6997  1667
6998  1668
6999  1669
7000  166A
7001  166B
7002  166C
7003  166D
7004  166E
7005  166F
7006  1670
7007  1671
7008  1672
7009  1673
7010  1674
7011  1675
7012  1676
7013  1677
7014  1678
7015  1679
7016  167A
7017  167B
7018  167C
7019  167D
7020  167E
7021  167F
7022  1680
7023  1681
7024  1682
7025  1683
7026  1684
7027  1685
7028  1686
7029  1687
7030  1688
7031  1689
7032  168A
7033  168B
7034  168C
7035  168D
7036  168E
7037  168F
7038  1690
7039  1691
7040  1692
7041  1693
7042  1694
7043  1695
7044  1696
7045  1697
7046  1698
7047  1699
7048  169A
7049  169B
7050  169C
7051  169D
7052  169E
7053  169F
7054  16A0
7055  16A1
7056  16A2
7057  16A3
7058  16A4
7059  16A5
7060  16A6
7061  16A7
7062  16A8
7063  16A9
7064  16AA
7065  16AB
7066  16AC
7067  16AD
7068  16AE
7069  16AF
7070  16B0
7071  16B1
7072  16B2
7073  16B3
7074  16B4
7075  16B5
7076  16B6
7077  16B7
7078  16B8
7079  16B9
7080  16BA
7081  16BB
7082  16BC
7083  16BD
7084  16BE
7085  16BF
7086  16C0
7087  16C1
7088  16C2
7089  16C3
7090  16C4
7091  16C5
7092  16C6
7093  16C7
7094  16C8
7095  16C9
7096  16CA
7097  16CB
7098  16CC
7099  16CD
7100  16CE
7101  16CF
7102  16D0
7103  16D1
7104  16D2
7105  16D3
7106  16D4
7107  16D5
7108  16D6
7109  16D7
7110  16D8
7111  16D9
7112  16DA
7113  16DB
7114  16DC
7115  16DD
7116  16DE
7117  16DF
7118  16E0
7119  16E1
7120  16E2
7121  16E3
7122  16E4
7123  16E5
7124  16E6
7125  16E7
7126  16E8
7127  16E9
7128  16EA
7129  16EB
7130  16EC
7131  16ED
7132  16EE
7133  16EF
7134  16F0
7135  16F1
7136  16F2
7137  16F3
7138  16F4
7139  16F5
7140  16F6
7141  16F7
7142  16F8
7143  16F9
7144  16FA
7145  16FB
7146  16FC
7147  16FD
7148  16FE
7149  16FF
7150  1700
7151  1701
7152  1702
7153  1703
7154  1704
7155  1705
7156  1706
7157  1707
7158  1708
7159  1709
7160  170A
7161  170B
7162  170C
7163  170D
7164  170E
7165  170F
7166  1710
7167  1711
7168  1712
7169  1713
7170  1714
7171  1715
7172  1716
7173  1717
7174  1718
7175  1719
7176  171A
7177  171B
7178  171C
7179  171D
7180  171E
7181  171F
7182  1720
7183  1721
7184  1722
7185  1723
7186  1724
7187  1725
7188  1726
7189  1727
7190  1728
7191  1729
7192  172A
7193  172B
7194  172C
7195  172D
7196  172E
7197  172F
7198  1730
7199  1731
7200  1732
7201  1733
7202  1734
7203  1735
7204  1736
7205  1737
7206  1738
7207  1739
7208  173A
7209  173B
7210  173C
7211  173D
7212  173E
7213  173F
7214  1740
7215  1741
7216  1742
7217  1743
7218  1744
7219  1745
7220  1746
7221  1747
7222  1748
7223  1749
7224  174A
7225  174B
7226  174C
7227  174D
7228  174E
7229  174F
7230  1750
7231  1751
7232  1752
7233  1753
7234  1754
7235  1755
7236  1756
7237  1757
7238  1758
7239  1759
7240  175A
7241  175B
7242  175C
7243  175D
7244  175E
7245  175F
7246  1760
7247  1761
7248  1762
7249  1763
7250  1764
7251  1765
7252  1766
7253  1767
7254  1768
7255  1769
7256  176A
7257  176B
7258  176C
7259  176D
7260  176E
7261  176F
7262  1770
7263  1771
7264  1772
7265  1773
7266  1774
7267  1775
7268  1776
7269  1777
7270  1778
7271  1779
7272  177A
7273  177B
7274  177C
7275  177D
7276  177E
7277  177F
7278  1780
7279  1781
7280  1782
7281  1783
7282  1784
7283  1785
7284  1786
7285  1787
7286  1788
7287  1789
7288  178A
7289  178B
7290  178C
7291  178D
7292  178E
7293  178F
7294  1790
7295  1791
7296  1792
7297  1793
7298  1794
7299  1795
7300  1796
7301  1797
7302  1798
7303  1799
7304  179A
7305  179B
7306  179C
7307  179D
7308  179E
7309  179F
7310  17A0
7311  17A1
7312  17A2
7313  17A3
7314  17A4
7315  17A5
7316  17A6
7317  17A7
7318  17A8
7319  17A9
7320  17AA
7321  17AB
7322  17AC
7323  17AD
7324  17AE
7325  17AF
7326  17B0
7327  17B1
7328  17B2
7329  17B3
7330  17B4
7331  17B5
7332  17B6
7333  17B7
7334  17B8
7335  17B9
7336  17BA
7337  17BB
7338  17BC
7339  17BD
7340  17BE
7341  17BF
7342  17C0
7343  17C1
7344  17C2
7345  17C3
7346  17C4
7347  17C5
7348  17C6
7349  17C7
7350  17C8
7351  17C9
7352  17CA
7353  17CB
7354  17CC
7355  17CD
7356  17CE
7357  17CF
7358  17D0
7359  17D1
7360  17D2
7361  17D3
7362  17D4
7363  17D5
7364  17D6
7365  17D7
7366  17D8
7367  17D9
7368  17DA
7369  17DB
7370  17DC
7371  17DD
7372  17DE
7373  17DF
7374  17E0
7375  17E1
7376  17E2
7377  17E3
7378  17E4
7379  17E5
7380  17E6
7381  17E7
7382  17E8
7383  17E9
7384  17EA
7385  17EB
7386  17EC
7387  17ED
7388  17EE
7389  17EF
7390  17F0
7391  17F1
7392  17F2
7393  17F3
7394  17F4
7395  17F5
7396  17F6
7397  17F7
7398  17F8
7399  17F9
7400  17FA
7401  17FB
7402  17FC
7403  17FD
7404  17FE
7405  17FF
7406  1800
7407  1801
7408  1802
7409  1803
7410  1804
7411  1805
7412  1806
7413  1807
7414  1808
7415  1809
7416  180A
7417  180B
7418  180C
7419  180D
7420  180E
7421  180F
7422  1810
7423  1811
7424  1812
7425  1813
7426  1814
7427  1815
7428  1816
7429  1817
7430  1818
7431  1819
7432  181A
7433  181B
7434  181C
7435  181D
7436  181E
7437  181F
7438  1820
7439  1821
7440  1822
7441  1823
7442  1824
7443  1825
7444  1826
7445  1827
7446  1828
7447  1829
7448  182A
7449  182B
7450  182C
7451  182D
7452  182E
7453  182F
7454  1830
7455  1831
7456  1832
7457  1833
7458  1834
7459  1835
7460  1836
7461  1837
7462  1838
7463  1839
7464  183A
7465  183B
7466  183C
7467  183D
7468  183E
7469  183F
7470  1840
7471  1841
7472  1842
7473  1843
7474  1844
7475  1845
7476  1846
7477  1847
7478  1848
7479  1849
7480  184A
7481  184B
7482  184C
7483  184D
7484  184E
7485  184F
7486  1850
7487  1851
7488  1852
7489  1853
7490  1854
7491  1855
7492  1856
7493  1857
7494  1858
7495  1859
7496  185A
7497  185B
7498  185C
7499  185D
7500  185E
7501  185F
7502  1860
7503  1861
007504  000311        
007505  000312      var vIAngularMeter0[WIDGET_RAM_SPACE] ;
007506  000313      var vIAngularMeter1[WIDGET_RAM_SPACE] ;
007507  000314      var vIAngularMeter3[WIDGET_RAM_SPACE] ;
007508  000315      var vILedDigits1[WIDGET_RAM_SPACE+2] ;
007509  000316      var vILedDigits2[WIDGET_RAM_SPACE+2] ;
007510  000317      var vILedDigits3[WIDGET_RAM_SPACE+2] ;
007511  000318      var vIAngularMeter2[WIDGET_RAM_SPACE] ;
007512  000319      var vILedDigits4[WIDGET_RAM_SPACE+2] ;
007513  000320      var vILedDigits6[WIDGET_RAM_SPACE+2] ;
007514  000321      var vILedDigits7[WIDGET_RAM_SPACE+2] ;
007515  000322      var vILedDigits8[WIDGET_RAM_SPACE+2] ;
007516  000323      var vILedDigits5[WIDGET_RAM_SPACE+2] ;
007517  000324      var vILedDigits9[WIDGET_RAM_SPACE+2] ;
007518  000325      var vILedDigits0[WIDGET_RAM_SPACE+2] ;
007519  000326  var stringsCV[39] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], hstrings ;
7520  0C82
7521  0C83
7522  0C84
7523  0C85
7524  0C86
7525  0C87
7526  0C88
7527  0C89
7528  0C8A
7529  0C8B
7530  0C8C
7531  0C8D
7532  0C8E
7533  0C8F
7534  0C90
7535  0C91
7536  0C92
7537  0C93
7538  0C94
7539  0C95
7540  0C96
7541  0C97
7542  0C98
7543  0C99
7544  0C9A
7545  0C9B
7546  0C9C
7547  0C9D
7548  0C9E
7549  0C9F
7550  0CA0
7551  0CA1
7552  0CA2
7553  0CA3
7554  0CA4
7555  0CA5
7556  0CA6
7557  0CA7
7558  0CA8
7559  0CA9
7560  0CAA
7561  0CAB
7562  0CAC
7563  0CAD
7564  0CAE
7565  0CAF
7566  0CB0
7567  0CB1
7568  0CB2
7569  0CB3
7570  0CB4
7571  0CB5
7572  0CB6
7573  0CB7
7574  0CB8
7575  0CB9
7576  0CBA
7577  0CBB
7578  0CBC
7579  0CBD
7580  0CBE
7581  0CBF
7582  0CC0
7583  0CC1
7584  0CC2
7585  0CC3
7586  0CC4
7587  0CC5
7588  0CC6
7589  0CC7
7590  0CC8
7591  0CC9
7592  0CCA
7593  0CCB
7594  0CCC
7595  0CCD
7596  0CCE
7597  0CCF
007598  000327  // Start P2.inc
007599  000328  var vObjects[MaxIntObjects+1] ;              // address of RAM objects
007600  000329  var GObjectIdx, GObjectFunc, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings ;
007601  000330  var oObjects[MaxTotObjects+1] ;                 // address of objects
007602  000331  var CurrentForm, oldn, ImageTouched ;
007603  000332  var TouchXpos, TouchYpos ;
007604  000333  var GObjectType, TouchState, CurInputData, pInputIndex ;
007605  000334  var comRX[40], cmd[CMDLenMAX] ;
007606  000335        
007607  000336  var InputCS, OutputCS ;
007608  000337        
007609  000338  // > ? Constant/Global/Data ? <
007610  000339        
007611  000340  func addressInternalWidget(var idx var iponly)
007612  000341      var i, j ;
007613  000342  //to(COM0) ; print("Address Int ", idx, " ") ; pause(2) ;
007614  000343      GObjectIdx := xobj2iobj[idx] ;
007615  000344      GObjectType := (GObjectIdx>>8) ;                          // extract object type
007616  000345      i := oObjects[GObjectType] ;                              // i is address of list of all objects of this type
007617  000346      GObjectIdx &= 0xff ;
007618  000347      //GObjectIdx *= 2 ;
007619  000348      j := GObjectIdx * 2 ;
007620  000349      GObjectDATA := i[j + 2] ;                                 // address of this object
007621  000350      i := vObjects[GObjectType-tiAngularMeter] ;               // i is address of list of all ram objects of his type
007622  000351      GObjectRAM := i[j] ;                                      // address of this objects' ram
007623  000352      i := GObjectType-tiAngularMeter ;
007624  000353      GObjectFunc := gfxInternals[i] ; // address function
007625  000354      GObjectParms := gfxIntParms[i] ;
007626  000355      GObjectStrings := gfxIntStrings[i] ;
007627  000356  //to(COM0) ; print([HEX4] GObjectFunc, " ", [HEX4] GObjectRAM, " ", [HEX4] GObjectDATA, " ", GObjectType, " ", GObjectIdx, "\r\n") ;
007628  000357  //    GObjectFunc(0, GObjectRAM, GObjectDATA) ;
007629  000358  endfunc
007630  000359        
007631  000360  func seroutCS(var op)
007632  000361      serout(op) ;
007633  000362      OutputCS ^= op ;
007634  000363  endfunc
007635  000364        
007636  000365  func nak0()
007637  000366      serout(NAK) ;
007638  000367      InputCS := 0 ;
007639  000368  endfunc
007640  000369        
007641  000370  func seroutOcs()
007642  000371      serout(OutputCS) ;
007643  000372      OutputCS := 0 ;
007644  000373  endfunc
007645  000374        
007646  000375  func SendReport(var id, var objt, var objn, var val)
007647  000376      seroutCS(id) ;
007648  000377      seroutCS(objt) ;
007649  000378      seroutCS(objn) ;
007650  000379      seroutCS(val >> 8) ; // first 8 bits
007651  000380      seroutCS(val) ;
007652  000381      seroutOcs() ;
007653  000382  endfunc
007654  000383        
007655  000384        
007656  000385  func ReadObject(var ObjectType, var ObjectIdx)
007657  000386      var j, k, Objects ;
007658  000387      if ((ObjectType >= tiLedDigitsH) && (ObjectType <= tiLinearInput))
007659  000388          j := ObjectIdx *2 ;
007660  000389          k := vObjects[ObjectType-tiAngularMeter] ;               // k is address of list of all ram objects of his type
007661  000390          k := k[j] ;                                              // k is address of this objects' ram
007662  000391          if (ObjectType == tiLedDigit)
007663  000392              k := k[0] ;
007664  000393          else 
007665  000394              k := k[WIDGET_VAL1] ;
007666  000395          endif
007667  000396  //gfx_MoveTo(0,0); txt_Opacity(OPAQUE) ; print(ObjectType, " ", ObjectIdx, " ", k," ") ;
007668  000397      else
007669  000398      Objects := *(oObjects+ObjectType) ;
007670  000399        
007671  000400      j := 2 + ObjectIdx * 2 + Objects ;
007672  000401       if (ObjectType == tForm)
007673  000402          k := CurrentForm ;
007674  000403      else if (ObjectType == tStrings)
007675  000404          k := stringsCV[ObjectIdx];
007676  000405          else
007677  000406          k := img_GetWord(hndl, *j, IMAGE_INDEX);
007678  000407          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
007679  000408                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
007680  000409      endif
007681  000410      endif
007682  000411      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
007683  000412  endfunc
007684  000413        
007685  000414  var wp ;
007686  000415        
007687  000416        
007688  000417  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
007689  000418      var i, j, k, Objects ;
007690  000419  //    ObjectType &= 0x3f ; Why was his there? Anibuttons? Complex cascades?
007691  000420      if (ObjectType == tForm)
007692  000421          ActivateForm(ObjectIdx) ;
007693  000422          return ;
007694  000423      endif
007695  000424      Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
007696  000425      i := *(Objects) ;
007697  000426      if ((ObjectType >= tiAngularMeter) && (ObjectType <= tiLinearInput))
007698  000427          i := oObjects[ObjectType] ;                              // f is address of list of all objects of this type
007699  000428          j := ObjectIdx *2 ;
007700  000429          i := i[j + 2] ;                         // f is address of this object
007701  000430          k := vObjects[ObjectType-tiAngularMeter] ;               // a is address of list of all ram objects of his type
007702  000431          k := k[j] ;                             // a is address of this objects' ram
007703  000432              j := ObjectType-tiAngularMeter ;
007704  000433              Objects := gfxInternals[j] ;           // locate function address   
007705  000434              Objects(NewVal, k, i) ; 
007706  000435          return ;
007707  000436      endif
007708  000437      switch (ObjectType)
007709  000438          case tWinButton :
007710  000439              j := InputControls[oWinButtons[ObjectIdx+1]] ;
007711  000440              break ;
007712  000441          case tUserButton :
007713  000442              j := InputControls[oUserButtons[ObjectIdx+1]] ;
007714  000443              break ;
007715  000444          default : j := -1 ;
007716  000445      endswitch
007717  000446        
007718  000447      if (j != -1)
007719  000448          k := img_GetWord(hndl, i , IMAGE_INDEX) ;
007720  000449          if (   (k == -1)                    // currently disabled
007721  000450              && (NewVal != -1) )             // and don't want it disabled
007722  000451              img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);    // enable touch
007723  000452          else if (   (k != -1)               // currently enabled
007724  000453                   && (NewVal == -1) )        // and want it disabled
007725  000454              img_SetWord(hndl, i, IMAGE_INDEX, 0xffff) ;       // make invisible
007726  000455              img_SetAttributes(hndl, i, I_TOUCH_DISABLE);      // and disable touch
007727  000456              if (img_GetWord(hndl,i,IMAGE_FLAGS) & I_ENABLED)  // only clear if we are enabled (i.e. on current form) 
007728  000457                  if (FormBGcolors[CurrentForm] != ColorBGimage)
007729  000458                      gfx_RectangleFilled(img_GetWord(hndl, i, IMAGE_XPOS), img_GetWord(hndl, i, IMAGE_YPOS),
007730  000459                                          img_GetWord(hndl, i, IMAGE_XPOS) + img_GetWord(hndl, i, IMAGE_WIDTH),
007731  000460                                          img_GetWord(hndl, i, IMAGE_YPOS) + img_GetWord(hndl, i, IMAGE_HEIGHT), FormBGcolors[CurrentForm]);
007732  000461                  else
007733  000462                      gfx_ClipWindow(img_GetWord(hndl, i, IMAGE_XPOS), img_GetWord(hndl, i, IMAGE_YPOS),
007734  000463                                     img_GetWord(hndl, i, IMAGE_XPOS) + img_GetWord(hndl, i, IMAGE_WIDTH),
007735  000464                                     img_GetWord(hndl, i, IMAGE_YPOS) + img_GetWord(hndl, i, IMAGE_HEIGHT)) ;
007736  000465                      gfx_Clipping(ON) ;
007737  000466                      img_Show(hndl,FormStartIndex[CurrentForm]) ;
007738  000467                      gfx_Clipping(OFF) ;
007739  000468                  endif
007740  000469              endif
007741  000470              return ;
007742  000471          else
007743  000472              NewVal := NewVal << 1 ;
007744  000473              if (OVF())      // button group index change
007745  000474                  if (*(j+InputData+Ofs_IPD_P1))
007746  000475                      k &= 1 ;    // mask off old group index for momentary
007747  000476                  else
007748  000477                      k &= 3 ;    // mask off old group index for toggle
007749  000478                  endif
007750  000479              else            // normal set
007751  000480                  if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
007752  000481                  k &= 0xfffc ;    // retain only group index for state set
007753  000482              endif
007754  000483              NewVal |= k ;
007755  000484              endif
007756  000485  //        endif
007757  000486          endif
007758  000487        
007759  000488          if (ObjectType == tStrings)
007760  000489              PrintStrings(ObjectIdx, NewVal, 0);
007761  000490              return ;
007762  000491          endif
007763  000492      img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
007764  000493      img_Show(hndl, i) ; // will only display if form is current
007765  000494      return ; // compiler bug circumvention!
007766  000495  endfunc
007767  000496        
007768  000497  func TurnOffButtons(var group)
007769  000498      var j, k, l, m, n, o, p;
007770  000499      m := GObjectIdx ;     // save as will be clobbered
007771  000500      n := GObjectType ;     // save as will be clobbered
007772  000501      for (j := 0; j < nInputs; j++)
007773  000502          k := j*IPDatasize ;
007774  000503          if (*(InputData+k+Ofs_IPD_P2) == group)
007775  000504              l := -1 ;
007776  000505               if (*(InputData+k) == tWinButton)
007777  000506                  l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007778  000507                  if (img_GetWord(hndl, l, IMAGE_INDEX) != 0xffff)
007779  000508                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
007780  000509                  img_Show(hndl, l);      // only shows on current form
007781  000510                  endif
007782  000511        
007783  000512              else if (*(InputData+k) == tUserButton)
007784  000513                  l := oUserButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007785  000514                  if (img_GetWord(hndl, l, IMAGE_INDEX) != 0xffff)
007786  000515                  img_SetWord(hndl, l, IMAGE_INDEX, img_GetWord(hndl, l, IMAGE_INDEX) & 0xfffc );
007787  000516                  img_Show(hndl, l);      // only shows on current form
007788  000517                  endif
007789  000518              endif
007790  000519          endif
007791  000520      next
007792  000521      GObjectIdx := m ;     // Restore
007793  000522      GObjectType := n ;    // Restore
007794  000523  endfunc
007795  000524        
007796  000525        
007797  000526        
007798  000527        
007799  000528  func ActivateForm(var newform)
007800  000529      var i, j, *p ;
007801  000530        
007802  000531          widget_Disable(wp, ALL) ;
007803  000532      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
007804  000533          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
007805  000534              if (img_GetWord(hndl, i, IMAGE_TAG))
007806  000535                  img_Disable(hndl,i) ;
007807  000536              endif
007808  000537          next
007809  000538      endif
007810  000539      CurrentForm := newform ;
007811  000540      // display newform image or clear to image color
007812  000541      if (FormBGcolors[CurrentForm] != ColorBGimage)
007813  000542          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
007814  000543          gfx_Cls() ;
007815  000544          DoGFXObjects() ;                                    // display GFX 'widgets'
007816  000545      endif
007817  000546        
007818  000547      // enable inputs
007819  000548      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
007820  000549          j := img_GetWord(hndl, i, IMAGE_TAG) ;
007821  000550          if (j)
007822  000551              j-- ;
007823  000552              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
007824  000553              //if (j != tKeyboard)
007825  000554              if (img_GetWord(hndl, i, IMAGE_INDEX) != 0xffff)
007826  000555              if (((j <= tWinButton) || (j >= t4Dbutton)) && (j != tSmartGauge) )               // enable inputs
007827  000556                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
007828  000557              endif
007829  000558              img_Show(hndl,i) ; // show initialy, if required
007830  000559              endif
007831  000560              if (j == tForm)
007832  000561                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
007833  000562              endif
007834  000563          endif
007835  000564      next
007836  000565        
007837  000566      // enable inputs
007838  000567         var a, f ; 
007839  000578  */
007840  000579      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007841  000580          addressInternalWidget(i, 0) ;
007842  000581          widget_Enable(wp,i) ;
007843  000582          if (GObjectType != tiLabelB) widget_ClearAttributes(wp,i,WIDGET_F_INITIALISED) ; // don't clear initialised for tiLabelB
007844  000583                  j := GObjectRAM[WIDGET_VAL1] ;
007845  000584                  GObjectFunc(j, GObjectRAM, GObjectDATA) ; 
007846  000585      next
007847  000586      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007848  000587          if (InternalInputControls[i] != -1)
007849  000588              widget_SetAttributes(wp,i,WIDGET_F_TOUCH_ENABLE) ;
007850  000589          endif
007851  000590      next
007852  000591        
007853  000592      for (i := 0; i < nStrings; i++)
007854  000593          if (stringsCV[i] != -1)
007855  000594              WriteObject(tStrings, i, stringsCV[i]) ;
007856  000595          endif
007857  000596      next
007858  000597        
007859  000598  endfunc
007860  000599        
007861  000600  func UpdateObjects(var newval)
007862  000601      var IPidx, otherOBJ, oldvalue ;
007863  000602      if (GObjectType < tiLedDigitsH)
007864  000603          oldvalue := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ;
007865  000604      else
007866  000605          oldvalue := GObjectRAM[WIDGET_VAL1] ;
007867  000606      endif
007868  000607      if ( ( oldvalue != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
007869  000608        
007870  000609      if (GObjectType < tiLedDigitsH)
007871  000610          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
007872  000611              img_Show(hndl, *(pInputIndex));      // only shows on current form
007873  000612      else
007874  000613          WriteObject(GObjectType, GObjectIdx, newval) ;
007875  000614      endif
007876  000615          if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
007877  000616              if (*(CurInputData+Ofs_IPD_P1))
007878  000617                  newval &= 1;
007879  000618              else
007880  000619                  newval &= 3;
007881  000620              endif
007882  000621              if (newval > 1) newval := 1;
007883  000622          endif
007884  000623          IPidx := *(CurInputData+TouchState) ;
007885  000624          while(IPidx != 0)
007886  000625              otherOBJ := IPidx + InputData;
007887  000626              if (*(otherOBJ) == OT_REPORT)
007888  000627                  SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
007889  000628              else if (*(otherOBJ) == OT_MAGIC)
007890  000629                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
007891  000630                  IPidx(newval) ;
007892  000631  //            else if (TouchState == *(otherOBJ+Ofs_IPD_P4))  // test prior to Workshop 6.5.0.0
007893  000632              else if ((TouchState == *(otherOBJ+Ofs_IPD_P4)) || (*(CurInputData+Ofs_IPD_P1) && ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))))
007894  000633                  if (*(otherOBJ) == OT_ACTIVATE)
007895  000634                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
007896  000635                      GObjectType := tForm ;
007897  000636                  else if (*(otherOBJ) == OT_SETCONST)
007898  000637                      newval := *(otherOBJ+Ofs_IPD_P3) ;
007899  000638                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007900  000639                  else if (*(otherOBJ) == OT_SETANOTHER)
007901  000640                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007902  000641                  else if (*(otherOBJ) == OT_PREVFRAME)
007903  000642                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
007904  000643                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
007905  000644                      endif
007906  000645                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007907  000646                  else if (*(otherOBJ) == OT_NEXTFRAME)
007908  000647                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
007909  000648                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
007910  000649                      endif
007911  000650                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007912  000651                  else if (*(otherOBJ) == OT_PREVSTRING)
007913  000652                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)])
007914  000653                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]-1) ;
007915  000654                      endif
007916  000655                  else if (*(otherOBJ) == OT_NEXTSTRING)
007917  000656                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)] < *(otherOBJ+Ofs_IPD_P3)) // fix IPD_P2 not filled in yet
007918  000657                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]+1) ;
007919  000658                      endif
007920  000659                  endif
007921  000660              endif
007922  000661              IPidx := *(otherOBJ+TouchState) ;
007923  000662          wend
007924  000663      endif
007925  000664  endfunc
007926  000665        
007927  000666  // End P2.inc
007928  000667  func DoGFXObjects()
007929  000668  endfunc
007930  000669        
007931  000670  // Start P3.inc
007932  000671  func main()
007933  000672      var comTX[50], cmdi, i, j, TouchStatus ;
007934  000673        
007935  000674        
007936  000675      gfx_ScreenMode(LANDSCAPE) ;
007937  000676        
007938  000677      media_InitFlash(FLASH_ADDR_DEF_COMMAND) ;
007939  000678        
007940  000679        
007941  000680  //    gfx_MoveTo(0, 0);
007942  000681  //    print(mem_Heap()," ") ;
007943  000682  //    gfx_TransparentColour(0x0020);
007944  000683  //    gfx_Transparency(ON);
007945  000684        
007946  000685        
007947  000686      // open image control
007948  000687      hndl := file_LoadImageControl(0, 0, 3);
007949  000688        
007950  000689      // init 'constants'
007951  000690  // End P3.inc
007952  000691        
007953  000692      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
007954  000693      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
007955  000694      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
007956  000695      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
007957  000696      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
007958  000697      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
007959  000698      oObjects[tWinButton] := oWinButtons ;
007960  000699      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
007961  000700      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
007962  000701      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
007963  000702      oObjects[tForm] := oForms ;
007964  000703      oObjects[tGauge] := oGauges ;
007965  000704      oObjects[tImage] := oImages ;
007966  000705      oObjects[tKeyboard] := oDipSwitchs ; // dummy as no object there
007967  000706      oObjects[tLed] := oDipSwitchs ; // dummy as no object there
007968  000707      oObjects[tLeddigits] := oDipSwitchs ; // dummy as no object there
007969  000708      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
007970  000709      oObjects[tStrings] := oStringss ;
007971  000710      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
007972  000711      oObjects[tUserled] := oUserleds ;
007973  000712      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
007974  000713      oObjects[tStaticText] := oStaticTexts ;
007975  000714      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
007976  000715      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
007977  000716      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
007978  000717      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
007979  000718      oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
007980  000719      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
007981  000720      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
007982  000721      oObjects[t4Dbutton] := oDipSwitchs ; // dummy as no object there
007983  000722      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
007984  000723      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
007985  000724      oObjects[tUserButton] := oUserButtons ;
007986  000725      oObjects[tMagicObject] := oDipSwitchs ; // dummy as no object there
007987  000726      oObjects[tSmartGauge] := oDipSwitchs ; // dummy as no object there
007988  000727      oObjects[tSmartSlider] := oDipSwitchs ; // dummy as no object there
007989  000728      oObjects[tSmartKnob] := oDipSwitchs ; // dummy as no object there
007990  000729      oObjects[tiLedDigitsH] := oDipSwitchs ; // dummy as no object there
007991  000730      oObjects[tiAngularMeter] := oiAngularMeters ;
007992  000731      oObjects[tiGauge] := oDipSwitchs ; // dummy as no object there
007993  000732      oObjects[tiLabelB] := oDipSwitchs ; // dummy as no object there
007994  000733      oObjects[tiUserGauge] := oDipSwitchs ; // dummy as no object there
007995  000734      oObjects[tiMediaGauge] := oDipSwitchs ; // dummy as no object there
007996  000735      oObjects[tiMediaThermometer] := oDipSwitchs ; // dummy as no object there
007997  000736      oObjects[tiLed] := oDipSwitchs ; // dummy as no object there
007998  000737      oObjects[tiMediaLed] := oDipSwitchs ; // dummy as no object there
007999  000738      oObjects[tiLedDigits] := oiLedDigitss ;
008000  000739      oObjects[tiNeedle] := oDipSwitchs ; // dummy as no object there
008001  000740      oObjects[tiRuler] := oDipSwitchs ; // dummy as no object there
008002  000741      oObjects[tiLedDigit] := oDipSwitchs ; // dummy as no object there
008003  000742      oObjects[tiButtonD] := oDipSwitchs ; // dummy as no object there
008004  000743      oObjects[tiButtonE] := oDipSwitchs ; // dummy as no object there
008005  000744      oObjects[tiMediaButton] := oDipSwitchs ; // dummy as no object there
008006  000745      oObjects[tiToggleInput] := oDipSwitchs ; // dummy as no object there
008007  000746      oObjects[tiDial] := oDipSwitchs ; // dummy as no object there
008008  000747      oObjects[tiMediaRotary] := oDipSwitchs ; // dummy as no object there
008009  000748      oObjects[tiRotaryInput] := oDipSwitchs ; // dummy as no object there
008010  000749      oObjects[tiSwitch] := oDipSwitchs ; // dummy as no object there
008011  000750      oObjects[tiSwitchB] := oDipSwitchs ; // dummy as no object there
008012  000751      oObjects[tiSliderE] := oDipSwitchs ; // dummy as no object there
008013  000752      oObjects[tiMediaSlider] := oDipSwitchs ; // dummy as no object there
008014  000753      oObjects[tiSliderH] := oDipSwitchs ; // dummy as no object there
008015  000754      oObjects[tiSliderG] := oDipSwitchs ; // dummy as no object there
008016  000755      oObjects[tiSliderF] := oDipSwitchs ; // dummy as no object there
008017  000756      oObjects[tiSliderD] := oDipSwitchs ; // dummy as no object there
008018  000757      oObjects[tiSliderC] := oDipSwitchs ; // dummy as no object there
008019  000758      oObjects[tiLinearInput] := oDipSwitchs ; // dummy as no object there
008020  000759      vObjects[0] := oiviAngularMeter ;
008021  000760      vObjects[8] := oiviLedDigits ;
008022  000761  // Start P4.inc
008023  000762      wp := widget_Create(14) ;
008024  000763      for (i := 0; i < 14; i++)
008025  000764  	addressInternalWidget(i, 0) ;
008026  000765          if (GObjectType != tiLedDigit) widget_Add(wp, i, GObjectRAM) ;    // don't add tiLedDigit objects as they are only 1 word long
008027  000766      next
008028  000767        
008029  000768      // init comms
008030  000769      com_Init(comRX,CMDLenMAX,0);
008031  000770      com_SetBaud(COM0,19886);
008032  000771      com_TXbuffer(comTX, 100, 0);
008033  000772      // tag 'real' objects
008034  000773      for (i := 0; i <= MaxTotObjects; i++)
008035  000774          if (   (i != tSounds)
008036  000775              && (i != tTimer)
008037  000776              && (i != tPinOutput)
008038  000777              && (i != tMagicObject)
008039  000778              && (i != tPinInput) )
008040  000779              TouchXpos := oObjects[i] ;
008041  000780              TouchYpos := *(TouchXpos) ;
008042  000781              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
008043  000782                  oldn := *(TouchXpos+ImageTouched*2) ;
008044  000783                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
008045  000784                  if (oldn != -1)
008046  000785                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
008047  000786                      img_Disable(hndl, oldn) ;
008048  000787                  endif
008049  000788              next
008050  000789          endif
008051  000790      next
008052  000791        
008053  000792      // display initial form
008054  000793      CurrentForm := -1 ;
008055  000794  // End P4.inc
008056  000795  // Start P5.inc
008057  000796      ActivateForm(5) ; // need to change this according to first actual form
008058  000797        
008059  000798  // End P5.inc
008060  000799  // Start P6.inc px44
008061  000800      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
008062  000801      oldn := -1 ;
008063  000802      repeat
008064  000803        
008065  000804          // check comms for command, how to NAK invalid command
008066  000805          if (com_Count() != 0)
008067  000806              i := serin() ;
008068  000807              InputCS ^= i ;               // update checksum
008069  000808              if (   (cmdi > 2)
008070  000809                  && (cmd[0] == WRITE_STRU) )
008071  000810                  j := (cmdi-1) >> 1 + 2 ;
008072  000811                  if (j == CMDLenMAX)    // max length exceeded
008073  000812                      nak0() ;
008074  000813                      cmdi := -1 ;
008075  000814                  else if (cmdi & 1)
008076  000815                      cmd[j] := i ;
008077  000816                      if (cmd[2] == 0)    // if string complete
008078  000817                          if (InputCS)
008079  000818                              nak0() ;
008080  000819                          else
008081  000820                              if (cmd[0] == WRITE_STRU)
008082  000821                              cmd[j] := 0 ;                     // terminate it
008083  000822                              PrintStrings(cmd[1], &cmd[3], 1) ;
008084  000823                              serout(ACK) ;
008085  000824                              else
008086  000825                              endif
008087  000826                          endif
008088  000827                          cmdi := -1 ;
008089  000828                      endif
008090  000829                  else
008091  000830                      cmd[j] := cmd[j] << 8 + i ;
008092  000831                      cmd[2]-- ;          // dec length
008093  000832                  endif
008094  000833                  cmdi++ ;
008095  000834              else // not unicode string
008096  000835                  cmd[cmdi++] := i ;
008097  000836                   if ((cmd[0] == WRITE_STR) || (cmd[0] == WRITE_LABEL) )                  // Ansi String or Label
008098  000837                      if (cmdi == CMDLenMAX)      // max length exceeded
008099  000838                          nak0() ;
008100  000839                          cmdi := 0 ;
008101  000840                      else if (cmdi > 2)
008102  000841                          if (cmd[2] == -1)
008103  000842                              if (InputCS)
008104  000843                                  nak0() ;
008105  000844                              else
008106  000845                                  if ((cmd[0] == WRITE_STR) || (cmd[0] == WRITE_LABEL))
008107  000846                                  cmd[cmdi-1] := 0 ;                     // terminate it
008108  000847                                  PrintStrings(cmd[1], &cmd[3], 1) ;
008109  000848                                  serout(ACK) ;
008110  000849                                  else
008111  000850                                  endif
008112  000851                              endif
008113  000852                              cmdi := 0 ;
008114  000853                          else
008115  000854                              cmd[2]-- ;          // dec length
008116  000855                          endif
008117  000856                      endif
008118  000857                  else if (   (cmd[0] == READ_OBJ)
008119  000858                           && (cmdi == 4)         )
008120  000859                      if (InputCS)
008121  000860                          nak0() ;
008122  000861                      else
008123  000862                          ReadObject(cmd[1], cmd[2]) ;
008124  000863                      endif
008125  000864                      cmdi := 0 ;
008126  000865                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
008127  000866                           && (cmdi == 6)          )
008128  000867                      if (InputCS)
008129  000868                          nak0() ;
008130  000869                      else
008131  000870                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
008132  000871                          serout(ACK) ;
008133  000872                      endif
008134  000873                      cmdi := 0 ;
008135  000874                  else if (   (cmd[0] == WRITE_CONTRAST)
008136  000875                           && (cmdi == 3)         )
008137  000876                      if (InputCS)
008138  000877                          nak0() ;
008139  000878                      else
008140  000879                          gfx_Contrast(cmd[1]) ;
008141  000880                          serout(ACK) ;
008142  000881                      endif
008143  000882                      cmdi := 0 ;
008144  000883                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
008145  000884                      nak0() ;
008146  000885                      cmdi := 0 ;
008147  000886                  endif
008148  000887              endif   // not unicode string
008149  000888          endif   // a character is available
008150  000889        
008151  000890        
008152  000891      // touch code processing
008153  000892        
008154  000893          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
008155  000894          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
008156  000895              ImageTouched := img_Touched(hndl,-1) ;
008157  000896              if (ImageTouched == -1)
008158  000897                  ImageTouched := widget_Touched(wp, ALL) ;
008159  000898                  if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
008160  000899              endif
008161  000900              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
008162  000901                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
008163  000902              endif
008164  000903              if (TouchStatus != TOUCH_RELEASED)        // if not released
008165  000904                  if (oldn != -1)
008166  000905                      ImageTouched := oldn ;
008167  000906                  else
008168  000907                      if (oldn != ImageTouched)
008169  000908                  oldn := ImageTouched ;
008170  000909                          TouchStatus := TOUCH_PRESSED ;
008171  000910                      endif
008172  000911                  endif
008173  000912                  TouchXpos  := touch_Get(TOUCH_GETX);
008174  000913                  TouchYpos  := touch_Get(TOUCH_GETY);
008175  000914                  TouchState := Ofs_IPD_DOWN ;
008176  000915              else
008177  000916                  ImageTouched := oldn ;                     // simulate release of what we touched
008178  000917                  oldn := -1 ;                    // prevent double release
008179  000918                  TouchState := Ofs_IPD_RELEASE ;
008180  000919              endif
008181  000920              if (ImageTouched >= 0)
008182  000921                          CurInputData := InputControls[ImageTouched] + InputData;
008183  000922                          GObjectType := *(CurInputData) ;
008184  000923                          if (GObjectType == tSmartSlider)
008185  000924                              i := tTrackbar ; // GSlider ;
008186  000925                          else if (GObjectType == tSmartKnob)
008187  000926                              i := tKnob ;
008188  000927                          else if (GObjectType >= t4Dbutton) 
008189  000928                              i := GObjectType - 23 ; // adjust to ensure next in gosub
008190  000929                          else 
008191  000930                              i := GObjectType ;
008192  000931                          endif
008193  000932                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
008194  000933                          ImageTouched := -1 ; // show processed here
008195  000934              endif
008196  000935              if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
008197  000936              if (ImageTouched >= 0)
008198  000937  //print(ImageTouched," ") ;
008199  000938  //                        CurInputData := InternalInputControls[ImageTouched] + InternalInputData;
008200  000939                          CurInputData := InternalInputControls[ImageTouched] + InputData;
008201  000940  //                        GObjectType := *(CurInputData) ;
008202  000941  //                        i := GObjectType ;
008203  000942  //                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
008204  000943  //                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
008205  000944                          addressInternalWidget(ImageTouched, 0) ;
008206  000945  //                        i := xobj2iiobj[ImageTouched] ;                            // address object type and hash from ram index
008207  000946  //                        GObjectIdx := i & 0xff ;
008208  000947  //                        GObjectType := (i>>8) ;                                   // extract object type
008209  000948                          if (GObjectType <= tiToggleInput) 
008210  000949                              i := 0 ;
008211  000950                          else if (GObjectType <= tiRotaryInput) 
008212  000951                              i := 1 ;
008213  000952                          else if (GObjectType <= tiSwitchB) 
008214  000953                              i := 2 ;
008215  000954                          else 
008216  000955                              i := 3 ;
008217  000956                          endif
008218  000957  //to(COM0) ; print(i, "\r\n") ;  
008219  000958        
008220  000959                          gosub (i), (ciButton, ciDial, ciSwitch, ciSlider) ;
008221  000960        
008222  000961        
008223  000962  //            ImageTouched := widget_Touched(wp, ALL) ;
008224  000963              endif
008225  000964          endif
008226  000965   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
008227  000966        
008228  000967          sys_EventsResume() ;
008229  000968      forever
008230  000969        
008231  000970  ciSwitch:
008232  000971  cDipswitch:
008233  000972        
008234  000973  cKnob:
008235  000974  ciDial:
008236  000975        
008237  000976  cRockerswitch:
008238  000977        
008239  000978  cRotaryswitch:
008240  000979        
008241  000980  cSlider:
008242  000981  cTrackbar:
008243  000982  ciSlider:
008244  000983        
008245  000984  ciButton:
008246  000985        
008247  000986  c4DButton:
008248  000987  cUserButton:
008249  000988  cWinbutton:
008250  000989      pInputIndex := oObjects[GObjectType]  + *(CurInputData+Ofs_IPD_OBJVIDX) ;
008251  000990      i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
008252  000991  CommonButtons:
008253  000992      if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
008254  000993          if (TouchStatus == TOUCH_RELEASED)
008255  000994              i &= 0xfffe ;
008256  000995              TouchState == Ofs_IPD_DOWN ;
008257  000996          else
008258  000997              i |= 1 ;
008259  000998              TouchState == Ofs_IPD_RELEASE ;
008260  000999          endif
008261  001000      else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
008262  001001          if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
008263  001002              if ((i & 3) == 3)
008264  001003                  i &= 0xfffc ;
008265  001004              else
008266  001005                  i++ ;
008267  001006              endif
008268  001007          else
008269  001008              i |= 1 ;                                      // make down regardless of current state
008270  001009          endif
008271  001010      else                        // group action, up all other buttons on touch press, reports 0 for button down
008272  001011          if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
008273  001012              TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
008274  001013          endif
008275  001014          if (GObjectType < tiLedDigits)
008276  001015              i := (i & 0xfffc) | 2 ;         // uSD button, four, grouping and blocking states
008277  001016          else
008278  001017              i := 1 ;                        // Internal button two states
008279  001018          endif
008280  001019      endif
008281  001020        
008282  001021      UpdateObjects(i) ;
008283  001022  endsub ;
008284  001023        
008285  001024  cAniButton:
008286  001025        
008287  001026  cColorPicker:
008288  001027        
008289  001028  endfunc
008290  001029  // End P6.inc
Notice: variable 'GObjectRAM' is being indexed (line 605 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'IPidx' requires 1 argument (line 630 file:SprinterGauge.4DGenieS)
Notice: variable 'GObjectRAM' is being indexed (line 583 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'GObjectFunc' requires 3 arguments (line 584 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 529 file:SprinterGauge.4DGenieS)
Notice: local var 'a' in func 'ActivateForm' is never used (line 567 file:SprinterGauge.4DGenieS)
Notice: local var 'f' in func 'ActivateForm' is never used (line 567 file:SprinterGauge.4DGenieS)
Notice: local var 'o' in func 'TurnOffButtons' is never used (line 498 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'TurnOffButtons' is never used (line 498 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 429 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 431 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'Objects' requires 3 arguments (line 434 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 390 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 392 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 394 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 349 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 351 file:SprinterGauge.4DGenieS)
Notice: function argument 'iponly' in func 'addressInternalWidget' is never used (line 340 file:SprinterGauge.4DGenieS)


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXFLASH                           128  0x00000080 (const dword)  (not used)
__MAXMEM                           30290  0x00007652 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             4  0x00000004 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 12)
ActivateForm                        6258  0x00001872 (User func) args[1] r=0  (usage 9)
addressInternalWidget               8130  0x00001fc2 (User func) args[2] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (usage 6)
ANALOGUE                               2  0x00000002 (const dword)  (not used)
ANGULAR_bgcol                         66  0x00000042 (const dword)  (not used)
ANGULAR_c1                            24  0x00000018 (const dword)  (not used)
ANGULAR_c2                            26  0x0000001a (const dword)  (not used)
ANGULAR_c3                            28  0x0000001c (const dword)  (not used)
ANGULAR_capcol                        46  0x0000002e (const dword)  (not used)
ANGULAR_capfnt                        44  0x0000002c (const dword)  (not used)
ANGULAR_capofsx                       48  0x00000030 (const dword)  (not used)
ANGULAR_capofsy                       50  0x00000032 (const dword)  (not used)
ANGULAR_Caption                       52  0x00000034 (const dword)  (not used)
ANGULAR_cxx                           62  0x0000003e (const dword)  (not used)
ANGULAR_cyx                           64  0x00000040 (const dword)  (not used)
ANGULAR_F_BG_TRANSPARENT             N/A         N/A (macro)   0x0002   (not used)
ANGULAR_F_LABEL_STRINGS              N/A         N/A (macro)   0x0001   (not used)
ANGULAR_F_TEXT_PCT_COLOUR            N/A         N/A (macro)   0x0008   (not used)
ANGULAR_F_TICK_PCT_COLOUR            N/A         N/A (macro)   0x0004   (not used)
ANGULAR_flags                         42  0x0000002a (const dword)  (not used)
ANGULAR_h                             60  0x0000003c (const dword)  (not used)
ANGULAR_incro                         30  0x0000001e (const dword)  (not used)
ANGULAR_labcol                        36  0x00000024 (const dword)  (not used)
ANGULAR_labfnt                        34  0x00000022 (const dword)  (not used)
ANGULAR_labofs                        38  0x00000026 (const dword)  (not used)
ANGULAR_labs                          32  0x00000020 (const dword)  (not used)
ANGULAR_labstr                        40  0x00000028 (const dword)  (not used)
ANGULAR_maxa                          70  0x00000046 (const dword)  (not used)
ANGULAR_maxv                          74  0x0000004a (const dword)  (not used)
ANGULAR_mina                          68  0x00000044 (const dword)  (not used)
ANGULAR_minv                          72  0x00000048 (const dword)  (not used)
ANGULAR_p1                            20  0x00000014 (const dword)  (not used)
ANGULAR_p2                            22  0x00000016 (const dword)  (not used)
ANGULAR_ri                             2  0x00000002 (const dword)  (not used)
ANGULAR_ro                             0  0x00000000 (const dword)  (not used)
ANGULAR_tc                            18  0x00000012 (const dword)  (not used)
ANGULAR_tcks                           4  0x00000004 (const dword)  (not used)
ANGULAR_tiszl                         12  0x0000000c (const dword)  (not used)
ANGULAR_tiszs                         14  0x0000000e (const dword)  (not used)
ANGULAR_tkl                            6  0x00000006 (const dword)  (not used)
ANGULAR_toszl                          8  0x00000008 (const dword)  (not used)
ANGULAR_toszs                         10  0x0000000a (const dword)  (not used)
ANGULAR_tw                            16  0x00000010 (const dword)  (not used)
ANGULAR_w                             58  0x0000003a (const dword)  (not used)
ANGULAR_x                             54  0x00000036 (const dword)  (not used)
ANGULAR_y                             56  0x00000038 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                          24  0x00000018 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 129)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BREAK                              65533  0x0000fffd (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON4_BC0                           12  0x0000000c (const dword)  (not used)
BUTTON4_BC1                           14  0x0000000e (const dword)  (not used)
BUTTON4_BR1                           28  0x0000001c (const dword)  (not used)
BUTTON4_BR2                           30  0x0000001e (const dword)  (not used)
BUTTON4_BRG                           32  0x00000020 (const dword)  (not used)
BUTTON4_CAP                           26  0x0000001a (const dword)  (not used)
BUTTON4_FC0                           28  0x0000001c (const dword)  (not used)
BUTTON4_FC1                           30  0x0000001e (const dword)  (not used)
BUTTON4_FST                           32  0x00000020 (const dword)  (not used)
BUTTON4_FSZ                           34  0x00000022 (const dword)  (not used)
BUTTON4_IB1                           16  0x00000010 (const dword)  (not used)
BUTTON4_IB2                           18  0x00000012 (const dword)  (not used)
BUTTON4_IG0                           20  0x00000014 (const dword)  (not used)
BUTTON4_IG1                           22  0x00000016 (const dword)  (not used)
BUTTON4_OB1                            6  0x00000006 (const dword)  (not used)
BUTTON4_OB2                            8  0x00000008 (const dword)  (not used)
BUTTON4_OBG                           10  0x0000000a (const dword)  (not used)
BUTTON4_rad                            4  0x00000004 (const dword)  (not used)
BUTTON4_TPC                           24  0x00000018 (const dword)  (not used)
BUTTON4_XP                             0  0x00000000 (const dword)  (not used)
BUTTON4_YP                             2  0x00000002 (const dword)  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHECKUPDATE_INVALIDFILE                5  0x00000005 (const dword)  (not used)
CHECKUPDATE_NEWFILE                    1  0x00000001 (const dword)  (not used)
CHECKUPDATE_NOFILE                     4  0x00000004 (const dword)  (not used)
CHECKUPDATE_OLDFILE                    2  0x00000002 (const dword)  (not used)
CHECKUPDATE_QUERY                      1  0x00000001 (const dword)  (not used)
CHECKUPDATE_UPDATEALWAYS               3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATEDONE                 3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATENEWER                2  0x00000002 (const dword)  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
ciButton                          UNRESOLVED  (not used)
ciDial                            UNRESOLVED  (not used)
ciSlider                          UNRESOLVED  (not used)
ciSwitch                          UNRESOLVED  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  704  0x000002c0 (mem) word[80] (global)  (usage 90)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 12)
ColorBGimage                          32  0x00000020 (const dword)  (usage 12)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_InitBrk                        -427  0xfffffe55 (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferBrk                    -426  0xfffffe56 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_InitBrk                         -417  0xfffffe5f (PmmC func) args[3] r=0  (not used)
com_Mode                            -400  0xfffffe70 (PmmC func) args[4] r=1  (not used)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferBrk                     -416  0xfffffe60 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                                624  0x00000270 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
crc_CSUM_8                          -403  0xfffffe6d (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         620  0x0000026c (mem) word (global)  (usage 30)
CurrentForm                          606  0x0000025e (mem) word (global)  (usage 63)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIAL_bevColour                        28  0x0000001c (const dword)  (not used)
DIAL_bevColour2                       30  0x0000001e (const dword)  (not used)
DIAL_bevSize                          26  0x0000001a (const dword)  (not used)
DIAL_bgcolour                         22  0x00000016 (const dword)  (not used)
DIAL_capcol                           72  0x00000048 (const dword)  (not used)
DIAL_capfnt                           70  0x00000046 (const dword)  (not used)
DIAL_capofsx                          74  0x0000004a (const dword)  (not used)
DIAL_capofsy                          76  0x0000004c (const dword)  (not used)
DIAL_caption                          78  0x0000004e (const dword)  (not used)
DIAL_colour                           24  0x00000018 (const dword)  (not used)
DIAL_cx                                8  0x00000008 (const dword)  (not used)
DIAL_cy                               10  0x0000000a (const dword)  (not used)
DIAL_F_BG_TRANSPARENT                N/A         N/A (macro)   0x0002   (not used)
DIAL_F_HANDLE_CIRCLE                 N/A         N/A (macro)   0x0000   (not used)
DIAL_F_HANDLE_LINE                   N/A         N/A (macro)   0x0030   (not used)
DIAL_F_HANDLE_RECTANGLE              N/A         N/A (macro)   0x0020   (not used)
DIAL_F_HANDLE_STYLE                  N/A         N/A (macro)   0x00f0   (not used)
DIAL_F_HANDLE_TRIANGLE               N/A         N/A (macro)   0x0010   (not used)
DIAL_F_INDICATOR_CIRCLE              N/A         N/A (macro)   0x0000   (not used)
DIAL_F_INDICATOR_LINE                N/A         N/A (macro)   0x0300   (not used)
DIAL_F_INDICATOR_RECTANGLE           N/A         N/A (macro)   0x0200   (not used)
DIAL_F_INDICATOR_STYLE               N/A         N/A (macro)   0x0f00   (not used)
DIAL_F_INDICATOR_TRIANGLE            N/A         N/A (macro)   0x0100   (not used)
DIAL_F_LABEL_STRINGS                 N/A         N/A (macro)   0x0001   (not used)
DIAL_flags                            80  0x00000050 (const dword)  (not used)
DIAL_h                                 6  0x00000006 (const dword)  (not used)
DIAL_handlecolour                     54  0x00000036 (const dword)  (not used)
DIAL_handlelength                     58  0x0000003a (const dword)  (not used)
DIAL_handlesize                       56  0x00000038 (const dword)  (not used)
DIAL_indc1h                           42  0x0000002a (const dword)  (not used)
DIAL_indc1l                           36  0x00000024 (const dword)  (not used)
DIAL_indc2h                           44  0x0000002c (const dword)  (not used)
DIAL_indc2l                           38  0x00000026 (const dword)  (not used)
DIAL_indc3h                           46  0x0000002e (const dword)  (not used)
DIAL_indc3l                           40  0x00000028 (const dword)  (not used)
DIAL_indlength                        52  0x00000034 (const dword)  (not used)
DIAL_indOffset                        48  0x00000030 (const dword)  (not used)
DIAL_indp1                            32  0x00000020 (const dword)  (not used)
DIAL_indp2                            34  0x00000022 (const dword)  (not used)
DIAL_indsize                          50  0x00000032 (const dword)  (not used)
DIAL_labcolour                        60  0x0000003c (const dword)  (not used)
DIAL_labcount                         66  0x00000042 (const dword)  (not used)
DIAL_labfont                          62  0x0000003e (const dword)  (not used)
DIAL_labofs                           64  0x00000040 (const dword)  (not used)
DIAL_labstr                           68  0x00000044 (const dword)  (not used)
DIAL_maxa                             16  0x00000010 (const dword)  (not used)
DIAL_maxv                             20  0x00000014 (const dword)  (not used)
DIAL_mina                             14  0x0000000e (const dword)  (not used)
DIAL_minv                             18  0x00000012 (const dword)  (not used)
DIAL_rad                              12  0x0000000c (const dword)  (not used)
DIAL_w                                 4  0x00000004 (const dword)  (not used)
DIAL_x                                 0  0x00000000 (const dword)  (not used)
DIAL_y                                 2  0x00000002 (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Busy                           -419  0xfffffe5d (PmmC func) args[0] r=1  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[2] r=1  (not used)
disp_Refresh                        -418  0xfffffe5e (PmmC func) args[0] r=0  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        5511  0x00001587 (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
EAST                                   3  0x00000003 (const dword)  (not used)
EAST_MIRRORED                          7  0x00000007 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
ffsEnd32kH                             7  0x00000007 (const dword)  (not used)
ffsEnd32kL                         32768  0x00008000 (const dword)  (not used)
ffsEnd4kH                              7  0x00000007 (const dword)  (not used)
ffsEnd4kL                          20480  0x00005000 (const dword)  (not used)
ffsEnd64kH                             8  0x00000008 (const dword)  (not used)
ffsEnd64kL                             0  0x00000000 (const dword)  (not used)
ffsEndUnits32k                        15  0x0000000f (const dword)  (not used)
ffsEndUnits4k                        117  0x00000075 (const dword)  (not used)
ffsEndUnits64k                         8  0x00000008 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_CheckUpdate                    -344  0xfffffea8 (PmmC func) args[2] r=1  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (not used)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
file_MountSpeed                     -382  0xfffffe82 (PmmC func) args[1] r=1  (not used)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_RunSpeed                       -408  0xfffffe68 (PmmC func) args[3] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
FLASH_ADDR_ALWAYS_4BYTE            65534  0x0000fffe (const dword)  (not used)
FLASH_ADDR_DEF_COMMAND             65535  0x0000ffff (const dword)  (usage 3)
flash_Block32Erase                  -398  0xfffffe72 (PmmC func) args[0] r=1  (not used)
flash_Block64Erase                  -157  0xffffff63 (PmmC func) args[0] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_Sector4Erase                  -399  0xfffffe71 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                        3107  0x00000c23FormBGcolors                        3107  0x00000c23 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 14)
FormBGcolors                      UNRESOLVED  (usage 4)
FormEndIndex                         871  0x00000367FormEndIndex                         871  0x00000367 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
FormStartIndex                       857  0x00000359FormStartIndex                       857  0x00000359 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 10)
FormStartIndex                    UNRESOLVED  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAUGE_COLOR                           18  0x00000012 (const dword)  (not used)
GAUGE_F_HORZ                         N/A         N/A (macro)    0x0002   (not used)
GAUGE_F_TOPRIGHT                     N/A         N/A (macro)    0x0001   (not used)
GAUGE_FLAGS                           36  0x00000024 (const dword)  (not used)
GAUGE_H                                6  0x00000006 (const dword)  (not used)
GAUGE_MAXV                            12  0x0000000c (const dword)  (not used)
GAUGE_MINV                            10  0x0000000a (const dword)  (not used)
GAUGE_P1                              34  0x00000022 (const dword)  (not used)
GAUGE_P1H                             22  0x00000016 (const dword)  (not used)
GAUGE_P1L                             20  0x00000014 (const dword)  (not used)
GAUGE_P2                              32  0x00000020 (const dword)  (not used)
GAUGE_P2H                             26  0x0000001a (const dword)  (not used)
GAUGE_P2L                             24  0x00000018 (const dword)  (not used)
GAUGE_P3H                             30  0x0000001e (const dword)  (not used)
GAUGE_P3L                             28  0x0000001c (const dword)  (not used)
GAUGE_SPACING                         16  0x00000010 (const dword)  (not used)
GAUGE_T                                8  0x00000008 (const dword)  (not used)
GAUGE_TICKH                           14  0x0000000e (const dword)  (not used)
GAUGE_W                                4  0x00000004 (const dword)  (not used)
GAUGE_X                                0  0x00000000 (const dword)  (not used)
GAUGE_Y                                2  0x00000002 (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_AngularMeter                    -312  0xfffffec8 (PmmC func) args[3] r=0  (usage 3)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
gfx_BlitSprite                      -304  0xfffffed0 (PmmC func) args[6] r=0  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
gfx_Button4                         -340  0xfffffeac (PmmC func) args[3] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 12)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 6)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 3)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dial                            -315  0xfffffec5 (PmmC func) args[3] r=0  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Gauge                           -316  0xfffffec4 (PmmC func) args[3] r=0  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -346  0xfffffea6 (PmmC func) args[7] r=0  (not used)
gfx_GradientColor                   -405  0xfffffe6b (PmmC func) args[6] r=1  (not used)
gfx_GradientShape                   -404  0xfffffe6c (PmmC func) args[19] r=0  (not used)
gfx_GradTriangleFilled              -406  0xfffffe6a (PmmC func) args[12] r=0  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
gfx_Led                             -341  0xfffffeab (PmmC func) args[3] r=0  (not used)
gfx_LedDigit                        -319  0xfffffec1 (PmmC func) args[6] r=0  (not used)
gfx_LedDigits                       -318  0xfffffec2 (PmmC func) args[3] r=0  (usage 3)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_Needle                          -314  0xfffffec6 (PmmC func) args[3] r=0  (not used)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_Panel2                          -313  0xfffffec7 (PmmC func) args[10] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
gfx_ReadGRAMarea                    -305  0xfffffecf (PmmC func) args[5] r=1  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 9)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_RingSegment                     -311  0xfffffec9 (PmmC func) args[7] r=0  (not used)
gfx_RoundGradient                   -317  0xfffffec3 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -320  0xfffffec0 (PmmC func) args[6] r=0  (not used)
gfx_RulerGauge                      -343  0xfffffea9 (PmmC func) args[3] r=0  (not used)
gfx_Scale                           -342  0xfffffeaa (PmmC func) args[2] r=0  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
gfx_Slider5                         -337  0xfffffeaf (PmmC func) args[3] r=0  (not used)
gfx_SpriteSet                       -303  0xfffffed1 (PmmC func) args[3] r=0  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
gfx_Surround                        -338  0xfffffeae (PmmC func) args[7] r=0  (not used)
gfx_Switch                          -339  0xfffffead (PmmC func) args[3] r=0  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
gfx_WriteGRAMarea                   -306  0xfffffece (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
gfx_XYlinToVal                      -380  0xfffffe84 (PmmC func) args[7] r=1  (not used)
gfx_XYrotToVal                      -379  0xfffffe85 (PmmC func) args[7] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
gfxInternals                           7  0x00000007gfxInternals                           7  0x00000007 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
gfxIntParms                           65  0x00000041gfxIntParms                           65  0x00000041 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
gfxIntStrings                        123  0x0000007bgfxIntStrings                        123  0x0000007b (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectDATA                          464  0x000001d0 (mem) word (global)  (usage 6)
GObjectFunc                          460  0x000001cc (mem) word (global)  (usage 6)
GObjectIdx                           458  0x000001ca (mem) word (global)  (usage 21)
GObjectParms                         466  0x000001d2 (mem) word (global)  (usage 3)
GObjectRAM                           462  0x000001ce (mem) word (global)  (usage 15)
GObjectStrings                       468  0x000001d4 (mem) word (global)  (usage 3)
GObjectType                          616  0x00000268 (mem) word (global)  (usage 90)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (usage 12)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 162)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
hstrings                             400  0x00000190 (mem) word (global)Notice: global var 'hstrings' is never used
  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C1_Close                          -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C1_Nack                           -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C1_Putn                           -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -361  0xfffffe97 (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -367  0xfffffe91 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -365  0xfffffe93 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -349  0xfffffea3 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -373  0xfffffe8b (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -371  0xfffffe8d (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -369  0xfffffe8f (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -363  0xfffffe95 (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
I2C2_Putn                           -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -375  0xfffffe89 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -357  0xfffffe9b (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -355  0xfffffe9d (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -351  0xfffffea1 (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -359  0xfffffe99 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -362  0xfffffe96 (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -368  0xfffffe90 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -366  0xfffffe92 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -350  0xfffffea2 (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -374  0xfffffe8a (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -372  0xfffffe8c (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -370  0xfffffe8e (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -364  0xfffffe94 (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
I2C3_Putn                           -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -376  0xfffffe88 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -358  0xfffffe9a (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -356  0xfffffe9c (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -360  0xfffffe98 (PmmC func) args[1] r=1  (not used)
I2C_CLOCK_STRETCHING               32768  0x00008000 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2CS_Close                          -410  0xfffffe66 (PmmC func) args[0] r=0  (not used)
I2CS_Count                          -412  0xfffffe64 (PmmC func) args[0] r=1  (not used)
I2CS_Open                           -409  0xfffffe67 (PmmC func) args[6] r=0  (not used)
I2CS_Overflow                       -415  0xfffffe61 (PmmC func) args[0] r=1  (not used)
I2CS_Read                           -413  0xfffffe63 (PmmC func) args[0] r=1  (not used)
I2CS_Release                        -414  0xfffffe62 (PmmC func) args[0] r=0  (not used)
I2CS_Write                          -411  0xfffffe65 (PmmC func) args[1] r=0  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 6)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 12)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                          39  0x00000027 (const dword)  (not used)
iFontStrings10                        36  0x00000024 (const ??? 0)  (usage 46)
iFontStrings2                         35  0x00000023 (const ??? 0)  (usage 20)
iFontStrings8                         37  0x00000025 (const ??? 0)  (usage 12)
iForm5                                27  0x0000001b (const ??? 0)  (usage 3)
iFormEndIndex                        899  0x00000383iFormEndIndex                        899  0x00000383 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iFormStartIndex                      885  0x00000375iFormStartIndex                      885  0x00000375 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iGauge0                                1  0x00000001 (const ??? 0)  (usage 3)
iGauge1                               10  0x0000000a (const ??? 0)  (usage 3)
iGauge2                               11  0x0000000b (const ??? 0)  (usage 3)
iGauge3                               12  0x0000000c (const ??? 0)  (usage 3)
iIAngularMeter0                        0  0x00000000 (const ??? 0)  (not used)
IIAngularMeter0                      237  0x000000edIIAngularMeter0                      237  0x000000ed (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter1                        1  0x00000001 (const ??? 0)  (not used)
IIAngularMeter1                      338  0x00000152IIAngularMeter1                      338  0x00000152 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter2                        6  0x00000006 (const ??? 0)  (not used)
IIAngularMeter2                      603  0x0000025bIIAngularMeter2                      603  0x0000025b (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter3                        2  0x00000002 (const ??? 0)  (not used)
IIAngularMeter3                      438  0x000001b6IIAngularMeter3                      438  0x000001b6 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits0                          13  0x0000000d (const ??? 0)  (not used)
IILedDigits0                         835  0x00000343IILedDigits0                         835  0x00000343 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits1                           3  0x00000003 (const ??? 0)  (not used)
IILedDigits1                         537  0x00000219IILedDigits1                         537  0x00000219 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits2                           4  0x00000004 (const ??? 0)  (not used)
IILedDigits2                         559  0x0000022fIILedDigits2                         559  0x0000022f (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits3                           5  0x00000005 (const ??? 0)  (not used)
IILedDigits3                         581  0x00000245IILedDigits3                         581  0x00000245 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits4                           7  0x00000007 (const ??? 0)  (not used)
IILedDigits4                         703  0x000002bfIILedDigits4                         703  0x000002bf (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits5                          11  0x0000000b (const ??? 0)  (not used)
IILedDigits5                         791  0x00000317IILedDigits5                         791  0x00000317 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits6                           8  0x00000008 (const ??? 0)  (not used)
IILedDigits6                         725  0x000002d5IILedDigits6                         725  0x000002d5 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits7                           9  0x00000009 (const ??? 0)  (not used)
IILedDigits7                         747  0x000002ebIILedDigits7                         747  0x000002eb (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits8                          10  0x0000000a (const ??? 0)  (not used)
IILedDigits8                         769  0x00000301IILedDigits8                         769  0x00000301 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits9                          12  0x0000000c (const ??? 0)  (not used)
IILedDigits9                         813  0x0000032dIILedDigits9                         813  0x0000032d (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iImage0                                0  0x00000000 (const ??? 0)  (usage 3)
iImage1                                2  0x00000002 (const ??? 0)  (usage 3)
iImage10                              13  0x0000000d (const ??? 0)  (usage 3)
iImage3                                3  0x00000003 (const ??? 0)  (usage 3)
iImage4                                4  0x00000004 (const ??? 0)  (usage 3)
iImage5                                6  0x00000006 (const ??? 0)  (usage 3)
iImage6                                5  0x00000005 (const ??? 0)  (usage 3)
iImage7                                7  0x00000007 (const ??? 0)  (usage 3)
iImage8                                8  0x00000008 (const ??? 0)  (usage 3)
iImage9                                9  0x00000009 (const ??? 0)  (usage 3)
ILINEARIP_COLOR1                      12  0x0000000c (const dword)  (not used)
ILINEARIP_COLOR2                      14  0x0000000e (const dword)  (not used)
ILINEARIP_COLOR3                      16  0x00000010 (const dword)  (not used)
ILINEARIP_COLOR4                      18  0x00000012 (const dword)  (not used)
ILINEARIP_COLOR5                      20  0x00000014 (const dword)  (not used)
ILINEARIP_COLOR6                      22  0x00000016 (const dword)  (not used)
ILINEARIP_H                            6  0x00000006 (const dword)  (not used)
ILINEARIP_INDEX                        8  0x00000008 (const dword)  (not used)
ILINEARIP_MAXVAL                      42  0x0000002a (const dword)  (not used)
ILINEARIP_MINVAL                      44  0x0000002c (const dword)  (not used)
ILINEARIP_OFFSET_BR                   46  0x0000002e (const dword)  (not used)
ILINEARIP_OFFSET_TL                   48  0x00000030 (const dword)  (not used)
ILINEARIP_ORIENTATION                 10  0x0000000a (const dword)  (not used)
ILINEARIP_TEXT1                       36  0x00000024 (const dword)  (not used)
ILINEARIP_TEXT2                       38  0x00000026 (const dword)  (not used)
ILINEARIP_TEXT3                       40  0x00000028 (const dword)  (not used)
ILINEARIP_VALUE1                      24  0x00000018 (const dword)  (not used)
ILINEARIP_VALUE2                      26  0x0000001a (const dword)  (not used)
ILINEARIP_VALUE3                      28  0x0000001c (const dword)  (not used)
ILINEARIP_VALUE4                      30  0x0000001e (const dword)  (not used)
ILINEARIP_VALUE5                      32  0x00000020 (const dword)  (not used)
ILINEARIP_VALUE6                      34  0x00000022 (const dword)  (not used)
ILINEARIP_W                            4  0x00000004 (const dword)  (not used)
ILINEARIP_X                            0  0x00000000 (const dword)  (not used)
ILINEARIP_Y                            2  0x00000002 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (usage 3)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (usage 6)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 57)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (usage 6)
IMAGE_XPOS                             2  0x00000002 (const dword)  (usage 12)
IMAGE_YPOS                             3  0x00000003 (const dword)  (usage 12)
ImageTouched                         610  0x00000262 (mem) word (global)  (usage 72)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 6)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
img_FileCheckUpdate                 -397  0xfffffe73 (PmmC func) args[3] r=1  (not used)
img_FileExec                        -394  0xfffffe76 (PmmC func) args[3] r=1  (not used)
img_FileGetC                        -388  0xfffffe7c (PmmC func) args[2] r=1  (usage 3)
img_FileGetS                        -390  0xfffffe7a (PmmC func) args[4] r=1  (not used)
img_FileGetW                        -389  0xfffffe7b (PmmC func) args[2] r=1  (usage 3)
img_FileIndex                       -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_FileLoadFunction                -392  0xfffffe78 (PmmC func) args[2] r=1  (not used)
img_FilePlayWAV                     -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
img_FileRead                        -383  0xfffffe81 (PmmC func) args[4] r=1  (not used)
img_FileRewind                      -391  0xfffffe79 (PmmC func) args[2] r=1  (not used)
img_FileRun                         -393  0xfffffe77 (PmmC func) args[3] r=1  (not used)
img_FileSeek                        -384  0xfffffe80 (PmmC func) args[4] r=1  (usage 3)
img_FileSize                        -387  0xfffffe7d (PmmC func) args[4] r=1  (not used)
img_FileTell                        -386  0xfffffe7e (PmmC func) args[4] r=1  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
img_FunctionCall                    -401  0xfffffe6f (PmmC func) args[7] r=1  (not used)
img_FunctionFreeCache               -402  0xfffffe6e (PmmC func) args[1] r=0  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 87)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 9)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 18)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 21)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
img_TxtFontID                       -396  0xfffffe74 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
InputControls                        913  0x00000391InputControls                        913  0x00000391 (mem) word[35] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
InputCS                              864  0x00000360 (mem) word (global)  (usage 21)
InputData                           1011  0x000003f3InputData                           1011  0x000003f3 (mem) word[396] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 33)
InternalInputControls                983  0x000003d7InternalInputControls                983  0x000003d7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
intflash_Copy                       -422  0xfffffe5a (PmmC func) args[3] r=1  (not used)
intflash_FunctionCall               -424  0xfffffe58 (PmmC func) args[7] r=1  (not used)
intflash_FunctionFreeCache          -425  0xfffffe57 (PmmC func) args[1] r=0  (not used)
intflash_GetByte                    -420  0xfffffe5c (PmmC func) args[1] r=1  (not used)
intflash_GetWord                    -421  0xfffffe5b (PmmC func) args[1] r=1  (not used)
intflash_WriteBlock                 -423  0xfffffe59 (PmmC func) args[2] r=1  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO10_PIN                              10  0x0000000a (const dword)  (not used)
IO11_PIN                              11  0x0000000b (const dword)  (not used)
IO12_PIN                              12  0x0000000c (const dword)  (not used)
IO13_PIN                              13  0x0000000d (const dword)  (not used)
IO14_PIN                              14  0x0000000e (const dword)  (not used)
IO15_PIN                              15  0x0000000f (const dword)  (not used)
IO16_PIN                              16  0x00000010 (const dword)  (not used)
IO17_PIN                              17  0x00000011 (const dword)  (not used)
IO18_PIN                              18  0x00000012 (const dword)  (not used)
IO19_PIN                              19  0x00000013 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IO6_PIN                                6  0x00000006 (const dword)  (not used)
IO7_PIN                                7  0x00000007 (const dword)  (not used)
IO8_PIN                                8  0x00000008 (const dword)  (not used)
IO9_PIN                                9  0x00000009 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
IROTARYIP_COLOR1                      10  0x0000000a (const dword)  (not used)
IROTARYIP_COLOR2                      12  0x0000000c (const dword)  (not used)
IROTARYIP_COLOR3                      14  0x0000000e (const dword)  (not used)
IROTARYIP_COLOR4                      16  0x00000010 (const dword)  (not used)
IROTARYIP_COLOR5                      18  0x00000012 (const dword)  (not used)
IROTARYIP_COLOR6                      20  0x00000014 (const dword)  (not used)
IROTARYIP_H                            6  0x00000006 (const dword)  (not used)
IROTARYIP_INDEX                        8  0x00000008 (const dword)  (not used)
IROTARYIP_MAXANGLE                    40  0x00000028 (const dword)  (not used)
IROTARYIP_MAXVALUE                    42  0x0000002a (const dword)  (not used)
IROTARYIP_MINANGLE                    44  0x0000002c (const dword)  (not used)
IROTARYIP_MINVALUE                    46  0x0000002e (const dword)  (not used)
IROTARYIP_TEXT1                       34  0x00000022 (const dword)  (not used)
IROTARYIP_TEXT2                       36  0x00000024 (const dword)  (not used)
IROTARYIP_TEXT3                       38  0x00000026 (const dword)  (not used)
IROTARYIP_VALUE1                      22  0x00000016 (const dword)  (not used)
IROTARYIP_VALUE2                      24  0x00000018 (const dword)  (not used)
IROTARYIP_VALUE3                      26  0x0000001a (const dword)  (not used)
IROTARYIP_VALUE4                      28  0x0000001c (const dword)  (not used)
IROTARYIP_VALUE5                      30  0x0000001e (const dword)  (not used)
IROTARYIP_VALUE6                      32  0x00000020 (const dword)  (not used)
IROTARYIP_W                            4  0x00000004 (const dword)  (not used)
IROTARYIP_X                            0  0x00000000 (const dword)  (not used)
IROTARYIP_Y                            2  0x00000002 (const dword)  (not used)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStatictext0                          28  0x0000001c (const ??? 0)  (usage 3)
iStrings0                           1803  0x0000070biStrings0                           1803  0x0000070b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings1                           1831  0x00000727iStrings1                           1831  0x00000727 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings10                          2083  0x00000823iStrings10                          2083  0x00000823 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings11                          2111  0x0000083fiStrings11                          2111  0x0000083f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings12                          2139  0x0000085biStrings12                          2139  0x0000085b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings13                          2167  0x00000877iStrings13                          2167  0x00000877 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings14                          2195  0x00000893iStrings14                          2195  0x00000893 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings15                          2223  0x000008afiStrings15                          2223  0x000008af (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings16                          2251  0x000008cbiStrings16                          2251  0x000008cb (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings17                          2279  0x000008e7iStrings17                          2279  0x000008e7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings18                          2307  0x00000903iStrings18                          2307  0x00000903 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings19                          2335  0x0000091fiStrings19                          2335  0x0000091f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings2                           1859  0x00000743iStrings2                           1859  0x00000743 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings20                          2363  0x0000093biStrings20                          2363  0x0000093b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings21                          2391  0x00000957iStrings21                          2391  0x00000957 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings22                          2419  0x00000973iStrings22                          2419  0x00000973 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings23                          2447  0x0000098fiStrings23                          2447  0x0000098f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings24                          2475  0x000009abiStrings24                          2475  0x000009ab (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings25                          2503  0x000009c7iStrings25                          2503  0x000009c7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings26                          2531  0x000009e3iStrings26                          2531  0x000009e3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings27                          2559  0x000009ffiStrings27                          2559  0x000009ff (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings28                          2587  0x00000a1biStrings28                          2587  0x00000a1b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings29                          2615  0x00000a37iStrings29                          2615  0x00000a37 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings3                           1887  0x0000075fiStrings3                           1887  0x0000075f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings30                          2643  0x00000a53iStrings30                          2643  0x00000a53 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings31                          2671  0x00000a6fiStrings31                          2671  0x00000a6f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings32                          2699  0x00000a8biStrings32                          2699  0x00000a8b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings33                          2727  0x00000aa7iStrings33                          2727  0x00000aa7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings34                          2755  0x00000ac3iStrings34                          2755  0x00000ac3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings35                          2783  0x00000adfiStrings35                          2783  0x00000adf (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings36                          2811  0x00000afbiStrings36                          2811  0x00000afb (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings37                          2839  0x00000b17iStrings37                          2839  0x00000b17 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings38                          2867  0x00000b33iStrings38                          2867  0x00000b33 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings4                           1915  0x0000077biStrings4                           1915  0x0000077b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings5                           1943  0x00000797iStrings5                           1943  0x00000797 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings6                           1971  0x000007b3iStrings6                           1971  0x000007b3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings7                           1999  0x000007cfiStrings7                           1999  0x000007cf (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings8                           2027  0x000007ebiStrings8                           2027  0x000007eb (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings9                           2055  0x00000807iStrings9                           2055  0x00000807 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iTextStrings                          38  0x00000026 (const ??? 0)  (usage 9)
ITOGGLEIP_COLOR1                      10  0x0000000a (const dword)  (not used)
ITOGGLEIP_COLOR2                      12  0x0000000c (const dword)  (not used)
ITOGGLEIP_COLOR3                      14  0x0000000e (const dword)  (not used)
ITOGGLEIP_COLOR4                      16  0x00000010 (const dword)  (not used)
ITOGGLEIP_COLOR5                      18  0x00000012 (const dword)  (not used)
ITOGGLEIP_COLOR6                      20  0x00000014 (const dword)  (not used)
ITOGGLEIP_H                            6  0x00000006 (const dword)  (not used)
ITOGGLEIP_INDEX                        8  0x00000008 (const dword)  (not used)
ITOGGLEIP_MATRIX                      40  0x00000028 (const dword)  (not used)
ITOGGLEIP_MOMENTARY                   42  0x0000002a (const dword)  (not used)
ITOGGLEIP_TEXT1                       34  0x00000022 (const dword)  (not used)
ITOGGLEIP_TEXT2                       36  0x00000024 (const dword)  (not used)
ITOGGLEIP_TEXT3                       38  0x00000026 (const dword)  (not used)
ITOGGLEIP_VALUE1                      22  0x00000016 (const dword)  (not used)
ITOGGLEIP_VALUE2                      24  0x00000018 (const dword)  (not used)
ITOGGLEIP_VALUE3                      26  0x0000001a (const dword)  (not used)
ITOGGLEIP_VALUE4                      28  0x0000001c (const dword)  (not used)
ITOGGLEIP_VALUE5                      30  0x0000001e (const dword)  (not used)
ITOGGLEIP_VALUE6                      32  0x00000020 (const dword)  (not used)
ITOGGLEIP_W                            4  0x00000004 (const dword)  (not used)
ITOGGLEIP_X                            0  0x00000000 (const dword)  (not used)
ITOGGLEIP_Y                            2  0x00000002 (const dword)  (not used)
iUserbutton0                          16  0x00000010 (const ??? 0)  (usage 3)
iUserbutton1                          14  0x0000000e (const ??? 0)  (usage 3)
iUserbutton10                         20  0x00000014 (const ??? 0)  (usage 3)
iUserbutton11                         24  0x00000018 (const ??? 0)  (usage 3)
iUserbutton2                          34  0x00000022 (const ??? 0)  (usage 3)
iUserbutton3                          18  0x00000012 (const ??? 0)  (usage 3)
iUserbutton4                          21  0x00000015 (const ??? 0)  (usage 3)
iUserbutton5                          17  0x00000011 (const ??? 0)  (usage 3)
iUserbutton6                          25  0x00000019 (const ??? 0)  (usage 3)
iUserbutton7                          26  0x0000001a (const ??? 0)  (usage 3)
iUserbutton8                          19  0x00000013 (const ??? 0)  (usage 3)
iUserbutton9                          29  0x0000001d (const ??? 0)  (usage 3)
IUSERGAUGE_COLOR1                     10  0x0000000a (const dword)  (not used)
IUSERGAUGE_COLOR2                     12  0x0000000c (const dword)  (not used)
IUSERGAUGE_COLOR3                     14  0x0000000e (const dword)  (not used)
IUSERGAUGE_COLOR4                     16  0x00000010 (const dword)  (not used)
IUSERGAUGE_COLOR5                     18  0x00000012 (const dword)  (not used)
IUSERGAUGE_COLOR6                     20  0x00000014 (const dword)  (not used)
IUSERGAUGE_H                           6  0x00000006 (const dword)  (not used)
IUSERGAUGE_INDEX                       8  0x00000008 (const dword)  (not used)
IUSERGAUGE_TEXT1                      34  0x00000022 (const dword)  (not used)
IUSERGAUGE_TEXT2                      36  0x00000024 (const dword)  (not used)
IUSERGAUGE_TEXT3                      38  0x00000026 (const dword)  (not used)
IUSERGAUGE_VALUE1                     22  0x00000016 (const dword)  (not used)
IUSERGAUGE_VALUE2                     24  0x00000018 (const dword)  (not used)
IUSERGAUGE_VALUE3                     26  0x0000001a (const dword)  (not used)
IUSERGAUGE_VALUE4                     28  0x0000001c (const dword)  (not used)
IUSERGAUGE_VALUE5                     30  0x0000001e (const dword)  (not used)
IUSERGAUGE_VALUE6                     32  0x00000020 (const dword)  (not used)
IUSERGAUGE_W                           4  0x00000004 (const dword)  (not used)
IUSERGAUGE_X                           0  0x00000000 (const dword)  (not used)
IUSERGAUGE_Y                           2  0x00000002 (const dword)  (not used)
iUserled0                             15  0x0000000f (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton0                           22  0x00000016 (const ??? 0)  (usage 3)
iWinbutton1                           23  0x00000017 (const ??? 0)  (usage 3)
iWinbutton2                           30  0x0000001e (const ??? 0)  (usage 3)
iWinbutton3                           31  0x0000001f (const ??? 0)  (usage 3)
iWinbutton4                           32  0x00000020 (const ??? 0)  (usage 3)
iWinbutton5                           33  0x00000021 (const ??? 0)  (usage 3)
JOY_BTNA                               6  0x00000006 (const dword)  (not used)
JOY_BTNB                               5  0x00000005 (const dword)  (not used)
JOY_DOWN                               3  0x00000003 (const dword)  (not used)
JOY_FIRE                               5  0x00000005 (const dword)  (not used)
JOY_LEFT                               2  0x00000002 (const dword)  (not used)
JOY_RELEASED                           0  0x00000000 (const dword)  (not used)
JOY_RIGHT                              4  0x00000004 (const dword)  (not used)
JOY_UP                                 1  0x00000001 (const dword)  (not used)
joystick                            -310  0xfffffeca (PmmC func) args[1] r=1  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                 3121  0x00000c31kKeyboardKeystrokes                 3121  0x00000c31 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LED1_cbe                              10  0x0000000a (const dword)  (not used)
LED1_cbs                               8  0x00000008 (const dword)  (not used)
LED1_cOff                             16  0x00000010 (const dword)  (not used)
LED1_cOn                              14  0x0000000e (const dword)  (not used)
LED1_cs                               12  0x0000000c (const dword)  (not used)
LED1_h                                 6  0x00000006 (const dword)  (not used)
LED1_iBr                              18  0x00000012 (const dword)  (not used)
LED1_iLr                              22  0x00000016 (const dword)  (not used)
LED1_oBr                              20  0x00000014 (const dword)  (not used)
LED1_oLr                              24  0x00000018 (const dword)  (not used)
LED1_sh                               26  0x0000001a (const dword)  (not used)
LED1_w                                 4  0x00000004 (const dword)  (not used)
LED1_x                                 0  0x00000000 (const dword)  (not used)
LED1_y                                 2  0x00000002 (const dword)  (not used)
LEDDIGIT_F_DP_COMMA                  N/A         N/A (macro)   0x0400   (not used)
LEDDIGIT_F_DP_ON                     N/A         N/A (macro)   0x0200   (not used)
LEDDIGIT_F_SET_SEGMENTS              N/A         N/A (macro)   0x1000   (not used)
LEDDIGIT_F_SHOW_DP                   N/A         N/A (macro)   0x0800   (not used)
LEDDIGITS_decimals                    10  0x0000000a (const dword)  (not used)
LEDDIGITS_digits                       8  0x00000008 (const dword)  (not used)
LEDDIGITS_digsize                     14  0x0000000e (const dword)  (not used)
LEDDIGITS_F_DP_COMMA                 N/A         N/A (macro)   0x0040   (not used)
LEDDIGITS_F_DP_DOT                   N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_FIXED                    N/A         N/A (macro)   0x0002   (not used)
LEDDIGITS_F_FLOAT                    N/A         N/A (macro)   0x0008   (not used)
LEDDIGITS_F_FLOATFORMATS             N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_GENERAL                  N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_INT16                    N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_INT32                    N/A         N/A (macro)   0x0004   (not used)
LEDDIGITS_F_LEADING0                 N/A         N/A (macro)   0x0020   (not used)
LEDDIGITS_F_LEADINGb                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_SCIENTIFIC               N/A         N/A (macro)   0x0001   (not used)
LEDDIGITS_F_SIGNED                   N/A         N/A (macro)   0x0010   (not used)
LEDDIGITS_F_TYPES                    N/A         N/A (macro)   0x000c   (not used)
LEDDIGITS_F_UNSIGNED                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_flags                       20  0x00000014 (const dword)  (not used)
LEDDIGITS_gap                         12  0x0000000c (const dword)  (not used)
LEDDIGITS_h                            6  0x00000006 (const dword)  (not used)
LEDDIGITS_offcolour                   18  0x00000012 (const dword)  (not used)
LEDDIGITS_oncolour                    16  0x00000010 (const dword)  (not used)
LEDDIGITS_w                            4  0x00000004 (const dword)  (not used)
LEDDIGITS_x                            0  0x00000000 (const dword)  (not used)
LEDDIGITS_y                            2  0x00000002 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIAngularMeter0                      333  0x0000014dLIAngularMeter0                      333  0x0000014d (mem) byte[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter0                   UNRESOLVED  (usage 2)
LIAngularMeter1                      434  0x000001b2LIAngularMeter1                      434  0x000001b2 (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter1                   UNRESOLVED  (usage 2)
LIAngularMeter2                      699  0x000002bbLIAngularMeter2                      699  0x000002bb (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter2                   UNRESOLVED  (usage 2)
LIAngularMeter3                      534  0x00000216LIAngularMeter3                      534  0x00000216 (mem) byte[3] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter3                   UNRESOLVED  (usage 2)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                3250  0x00000cb2 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxIntObjects                         27  0x0000001b (const dword)  (usage 3)
MaxTotObjects                         67  0x00000043 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_Init4                         -407  0xfffffe69 (const dword)  (not used)
media_InitFlash                     -407  0xfffffe69 (PmmC func) args[1] r=1  (usage 6)
media_InitSpeed                     -381  0xfffffe83 (PmmC func) args[1] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                8095  0x00001f9f (User func) args[0] r=0  (usage 24)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NEEDLE_bgcol                          12  0x0000000c (const dword)  (not used)
NEEDLE_ccol                           36  0x00000024 (const dword)  (not used)
NEEDLE_colour                         32  0x00000020 (const dword)  (not used)
NEEDLE_crad                           34  0x00000022 (const dword)  (not used)
NEEDLE_cxx                             8  0x00000008 (const dword)  (not used)
NEEDLE_cyx                            10  0x0000000a (const dword)  (not used)
NEEDLE_extra                          30  0x0000001e (const dword)  (not used)
NEEDLE_F_DOUBLETRIANGLE                4  0x00000004 (const dword)  (not used)
NEEDLE_F_LINE                          0  0x00000000 (const dword)  (not used)
NEEDLE_F_POINTRECTANGLE                2  0x00000002 (const dword)  (not used)
NEEDLE_F_RECTANGLE                     1  0x00000001 (const dword)  (not used)
NEEDLE_F_ROUNDEDRECTANGLE              5  0x00000005 (const dword)  (not used)
NEEDLE_F_TRIANGLE                      3  0x00000003 (const dword)  (not used)
NEEDLE_h                               6  0x00000006 (const dword)  (not used)
NEEDLE_icol                           40  0x00000028 (const dword)  (not used)
NEEDLE_irad                           38  0x00000026 (const dword)  (not used)
NEEDLE_len                            22  0x00000016 (const dword)  (not used)
NEEDLE_maxa                           16  0x00000010 (const dword)  (not used)
NEEDLE_maxv                           20  0x00000014 (const dword)  (not used)
NEEDLE_mina                           14  0x0000000e (const dword)  (not used)
NEEDLE_minv                           18  0x00000012 (const dword)  (not used)
NEEDLE_offs                           26  0x0000001a (const dword)  (not used)
NEEDLE_rad                            28  0x0000001c (const dword)  (not used)
NEEDLE_style                          24  0x00000018 (const dword)  (not used)
NEEDLE_w                               4  0x00000004 (const dword)  (not used)
NEEDLE_x                               0  0x00000000 (const dword)  (not used)
NEEDLE_y                               2  0x00000002 (const dword)  (not used)
nInputs                               36  0x00000024 (const dword)  (usage 3)
nObjects                              35  0x00000023 (const dword)  (not used)
NORTH                                  0  0x00000000 (const dword)  (not used)
NORTH_MIRRORED                         4  0x00000004 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
nStrings                              39  0x00000027 (const dword)  (usage 3)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                         2895  0x00000b4foDipSwitchs                         2895  0x00000b4f (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 171)
OFF                                    0  0x00000000 (const dword)  (usage 6)
oForms                              2911  0x00000b5foForms                              2911  0x00000b5f (mem) word[8] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (not used)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (not used)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (not used)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (not used)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (not used)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 6)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 12)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 18)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 48)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 9)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 3)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 9)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 18)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 9)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (usage 3)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (usage 6)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (usage 3)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (usage 3)
Ofs_String_Form                       24  0x00000018 (const dword)  (usage 3)
Ofs_String_GciFSFontIdx               26  0x0000001a (const dword)  (usage 3)
Ofs_String_Size                        4  0x00000004 (const dword)  (usage 3)
Ofs_String_StartH                      0  0x00000000 (const dword)  (usage 3)
Ofs_String_StartL                      2  0x00000002 (const dword)  (usage 3)
Ofs_String_Transparent                20  0x00000014 (const dword)  (usage 3)
Ofs_String_x1                          6  0x00000006 (const dword)  (usage 12)
Ofs_String_x2                         10  0x0000000a (const dword)  (usage 9)
Ofs_String_y1                          8  0x00000008 (const dword)  (usage 12)
Ofs_String_y2                         12  0x0000000c (const dword)  (usage 9)
oGauges                             2927  0x00000b6foGauges                             2927  0x00000b6f (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiAngularMeters                     3075  0x00000c03oiAngularMeters                     3075  0x00000c03 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiLedDigitss                        3085  0x00000c0doiLedDigitss                        3085  0x00000c0d (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oImages                             2937  0x00000b79oImages                             2937  0x00000b79 (mem) word[12] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviAngularMeter                     181  0x000000b5oiviAngularMeter                     181  0x000000b5 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviLedDigits                        189  0x000000bdoiviLedDigits                        189  0x000000bd (mem) word[10] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 608  0x00000260 (mem) word (global)  (usage 42)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 6)
oObjects                             470  0x000001d6 (mem) word[68] (global)  (usage 219)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oStaticTexts                        3045  0x00000be5oStaticTexts                        3045  0x00000be5 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oStringss                           2961  0x00000b91oStringss                           2961  0x00000b91 (mem) word[40] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 4)
oStringss                         UNRESOLVED  (usage 2)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 3)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 3)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (usage 3)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (usage 3)
OT_REPORT                            100  0x00000064 (const dword)  (usage 57)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 3)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
oUserButtons                        3049  0x00000be9oUserButtons                        3049  0x00000be9 (mem) word[13] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
oUserleds                           3041  0x00000be1oUserleds                           3041  0x00000be1 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OutputCS                             866  0x00000362 (mem) word (global)  (usage 9)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (usage 3)
OW_Read                             -299  0xfffffed5 (PmmC func) args[1] r=1  (not used)
OW_Read9                            -300  0xfffffed4 (PmmC func) args[1] r=1  (not used)
OW_Reset                            -298  0xfffffed6 (PmmC func) args[1] r=1  (not used)
OW_Write                            -301  0xfffffed3 (PmmC func) args[2] r=0  (not used)
oWinButtons                         2897  0x00000b51oWinButtons                         2897  0x00000b51 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL2_FILLED                      32768  0x00008000 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (not used)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
pInputIndex                          622  0x0000026e (mem) word (global)  (usage 15)
PIXXI                                  4  0x00000004 (const dword)  (usage 3)
PIXXI44_FUNCTIONS                      0  0x00000000 (const ??? 0)  (not used)
PIXXI_44_CHIP                          5  0x00000005 (const ??? 0)  (not used)
pixxiLCD_39P4CT                        0  0x00000000 (const ??? 0)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PrintStrings                        8265  0x00002049 (User func) args[3] r=0  (usage 9)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 6)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (not used)
putstrCentred                       -321  0xfffffebf (PmmC func) args[3] r=0  (not used)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          7795  0x00001e73 (User func) args[2] r=0  (usage 3)
RECT_HEIGHT                            3  0x00000003 (const dword)  (not used)
rect_Intersect                      -307  0xfffffecd (PmmC func) args[2] r=1  (not used)
RECT_LEFT                              0  0x00000000 (const dword)  (not used)
RECT_TOP                               1  0x00000001 (const dword)  (not used)
RECT_WIDTH                             2  0x00000002 (const dword)  (not used)
rect_Within                         -308  0xfffffecc (PmmC func) args[2] r=1  (not used)
RED                                63488  0x0000f800 (const dword)  (usage 21)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 3)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                   3123  0x00000c33rKeyboardRoutines                   3123  0x00000c33 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RULERGAUGE_F_ORIENT_VERT               2  0x00000002 (const dword)  (not used)
RULERGAUGE_F_TICKS_BOTTOM              0  0x00000000 (const dword)  (not used)
RULERGAUGE_F_TICKS_TOP                 1  0x00000001 (const dword)  (not used)
RULERGAUGE_HC                         24  0x00000018 (const dword)  (not used)
RULERGAUGE_height                      6  0x00000006 (const dword)  (not used)
RULERGAUGE_IC                         30  0x0000001e (const dword)  (not used)
RULERGAUGE_LC                         22  0x00000016 (const dword)  (not used)
RULERGAUGE_majorTickSize              16  0x00000010 (const dword)  (not used)
RULERGAUGE_MC                         26  0x0000001a (const dword)  (not used)
RULERGAUGE_medium                     18  0x00000012 (const dword)  (not used)
RULERGAUGE_minorTicks                 12  0x0000000c (const dword)  (not used)
RULERGAUGE_minorTickSize              14  0x0000000e (const dword)  (not used)
RULERGAUGE_options                    32  0x00000020 (const dword)  (not used)
RULERGAUGE_range                       8  0x00000008 (const dword)  (not used)
RULERGAUGE_TC                         28  0x0000001c (const dword)  (not used)
RULERGAUGE_threshold                  20  0x00000014 (const dword)  (not used)
RULERGAUGE_ticks                      10  0x0000000a (const dword)  (not used)
RULERGAUGE_width                       4  0x00000004 (const dword)  (not used)
RULERGAUGE_XP                          0  0x00000000 (const dword)  (not used)
RULERGAUGE_YP                          2  0x00000002 (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCALE_BC                              20  0x00000014 (const dword)  (not used)
SCALE_BR                             N/A         N/A (macro)    0x0002   (not used)
SCALE_CenterGap                       26  0x0000001a (const dword)  (not used)
SCALE_CENTRE                         N/A         N/A (macro)    0x0003   (not used)
SCALE_END_ALIGN                      N/A         N/A (macro)    0x0020   (not used)
SCALE_FONT                            24  0x00000018 (const dword)  (not used)
SCALE_HIDE_ZERO                      N/A         N/A (macro)    0x0000   (not used)
SCALE_HORZ                           N/A         N/A (macro)    0x0000   (not used)
SCALE_length                           4  0x00000004 (const dword)  (not used)
SCALE_max                              8  0x00000008 (const dword)  (not used)
SCALE_min                              6  0x00000006 (const dword)  (not used)
SCALE_NO_END_ALIGN                   N/A         N/A (macro)    0x0000   (not used)
SCALE_NONE                           N/A         N/A (macro)    0x0000   (not used)
SCALE_SHOW_ZERO                      N/A         N/A (macro)    0x0040   (not used)
SCALE_TC                              18  0x00000012 (const dword)  (not used)
SCALE_ticklength                      12  0x0000000c (const dword)  (not used)
SCALE_ticklengthMinor                 16  0x00000010 (const dword)  (not used)
SCALE_ticks                           10  0x0000000a (const dword)  (not used)
SCALE_TICKS_BOTH                     N/A         N/A (macro)    0x000c   (not used)
SCALE_TICKS_BR                       N/A         N/A (macro)    0x0008   (not used)
SCALE_TICKS_NONE                     N/A         N/A (macro)    0x0000   (not used)
SCALE_TICKS_TL                       N/A         N/A (macro)    0x0004   (not used)
SCALE_ticksMinor                      14  0x0000000e (const dword)  (not used)
SCALE_TL                             N/A         N/A (macro)    0x0001   (not used)
SCALE_type                            28  0x0000001c (const dword)  (not used)
SCALE_VERT                           N/A         N/A (macro)    0x0010   (not used)
SCALE_XC                              22  0x00000016 (const dword)  (not used)
SCALE_XP                               0  0x00000000 (const dword)  (not used)
SCALE_YP                               2  0x00000002 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
SendReport                          8028  0x00001f5c (User func) args[4] r=0  (usage 6)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 21)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                            8111  0x00001faf (User func) args[1] r=0  (usage 15)
seroutOcs                           8078  0x00001f8e (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (usage 12)
SLIDER5_base_color                    14  0x0000000e (const dword)  (not used)
SLIDER5_F_ORIENT_VERT                N/A         N/A (macro)     0x0001    /* Switch orientation (0 - horizontal, 1 - vertical) */   (not used)
SLIDER5_F_PROGRESSBAR                N/A         N/A (macro)     0x0008    /* Progress Bar mode */   (not used)
SLIDER5_F_TICKS                      N/A         N/A (macro)     0x0002    /* Enable Marker Ticks*/   (not used)
SLIDER5_F_VALUE_IND                  N/A         N/A (macro)     0x0004    /* Enable slider value indicator */   (not used)
SLIDER5_font_c                        38  0x00000026 (const dword)  (not used)
SLIDER5_font_s                        36  0x00000024 (const dword)  (not used)
SLIDER5_knob_f_c_1                    46  0x0000002e (const dword)  (not used)
SLIDER5_knob_f_c_2                    48  0x00000030 (const dword)  (not used)
SLIDER5_knob_f_g                      50  0x00000032 (const dword)  (not used)
SLIDER5_knob_o_c_1                    40  0x00000028 (const dword)  (not used)
SLIDER5_knob_o_c_2                    42  0x0000002a (const dword)  (not used)
SLIDER5_knob_o_g                      44  0x0000002c (const dword)  (not used)
SLIDER5_len                            4  0x00000004 (const dword)  (not used)
SLIDER5_max_val                       12  0x0000000c (const dword)  (not used)
SLIDER5_min_val                       10  0x0000000a (const dword)  (not used)
SLIDER5_num_ticks_L_1                 24  0x00000018 (const dword)  (not used)
SLIDER5_num_ticks_L_2                 26  0x0000001a (const dword)  (not used)
SLIDER5_options                        8  0x00000008 (const dword)  (not used)
SLIDER5_thk                            6  0x00000006 (const dword)  (not used)
SLIDER5_tick_maj_c                    30  0x0000001e (const dword)  (not used)
SLIDER5_tick_maj_l                    28  0x0000001c (const dword)  (not used)
SLIDER5_tick_min_c                    34  0x00000022 (const dword)  (not used)
SLIDER5_tick_min_l                    32  0x00000020 (const dword)  (not used)
SLIDER5_total_tick_B_R                22  0x00000016 (const dword)  (not used)
SLIDER5_total_tick_T_L                20  0x00000014 (const dword)  (not used)
SLIDER5_track_color                   18  0x00000012 (const dword)  (not used)
SLIDER5_track_empty                   16  0x00000010 (const dword)  (not used)
SLIDER5_x_pos                          0  0x00000000 (const dword)  (not used)
SLIDER5_y_pos                          2  0x00000002 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Freq                            -302  0xfffffed2 (PmmC func) args[2] r=1  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_RTTTL                           -309  0xfffffecb (PmmC func) args[1] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SOUND                                  3  0x00000003 (const dword)  (not used)
SOUTH                                  1  0x00000001 (const dword)  (not used)
SOUTH_MIRRORED                         5  0x00000005 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
Strings0Count                          1  0x00000001 (const dword)  (not used)
Strings0Size                          22  0x00000016 (const dword)  (usage 3)
Strings0StartH                         0  0x00000000 (const dword)  (usage 3)
Strings0StartL                       512  0x00000200 (const dword)  (usage 3)
Strings10Count                         1  0x00000001 (const dword)  (not used)
Strings10Size                          6  0x00000006 (const dword)  (usage 3)
Strings10StartH                        0  0x00000000 (const dword)  (usage 3)
Strings10StartL                     4096  0x00001000 (const dword)  (usage 3)
Strings11Count                         1  0x00000001 (const dword)  (not used)
Strings11Size                         15  0x0000000f (const dword)  (usage 3)
Strings11StartH                        0  0x00000000 (const dword)  (usage 3)
Strings11StartL                     4608  0x00001200 (const dword)  (usage 3)
Strings12Count                         1  0x00000001 (const dword)  (not used)
Strings12Size                         17  0x00000011 (const dword)  (usage 3)
Strings12StartH                        0  0x00000000 (const dword)  (usage 3)
Strings12StartL                     5120  0x00001400 (const dword)  (usage 3)
Strings13Count                         1  0x00000001 (const dword)  (not used)
Strings13Size                          7  0x00000007 (const dword)  (usage 3)
Strings13StartH                        0  0x00000000 (const dword)  (usage 3)
Strings13StartL                    10240  0x00002800 (const dword)  (usage 3)
Strings14Count                         1  0x00000001 (const dword)  (not used)
Strings14Size                         16  0x00000010 (const dword)  (usage 3)
Strings14StartH                        0  0x00000000 (const dword)  (usage 3)
Strings14StartL                    10752  0x00002a00 (const dword)  (usage 3)
Strings15Count                         1  0x00000001 (const dword)  (not used)
Strings15Size                         13  0x0000000d (const dword)  (usage 3)
Strings15StartH                        0  0x00000000 (const dword)  (usage 3)
Strings15StartL                     5632  0x00001600 (const dword)  (usage 3)
Strings16Count                         1  0x00000001 (const dword)  (not used)
Strings16Size                         13  0x0000000d (const dword)  (usage 3)
Strings16StartH                        0  0x00000000 (const dword)  (usage 3)
Strings16StartL                     6144  0x00001800 (const dword)  (usage 3)
Strings17Count                         1  0x00000001 (const dword)  (not used)
Strings17Size                          5  0x00000005 (const dword)  (usage 3)
Strings17StartH                        0  0x00000000 (const dword)  (usage 3)
Strings17StartL                    12288  0x00003000 (const dword)  (usage 3)
Strings18Count                         1  0x00000001 (const dword)  (not used)
Strings18Size                          5  0x00000005 (const dword)  (usage 3)
Strings18StartH                        0  0x00000000 (const dword)  (usage 3)
Strings18StartL                     6656  0x00001a00 (const dword)  (usage 3)
Strings19Count                         1  0x00000001 (const dword)  (not used)
Strings19Size                          5  0x00000005 (const dword)  (usage 3)
Strings19StartH                        0  0x00000000 (const dword)  (usage 3)
Strings19StartL                     7168  0x00001c00 (const dword)  (usage 3)
Strings1Count                          1  0x00000001 (const dword)  (not used)
Strings1Size                          12  0x0000000c (const dword)  (usage 3)
Strings1StartH                         0  0x00000000 (const dword)  (usage 3)
Strings1StartL                     16896  0x00004200 (const dword)  (usage 3)
Strings20Count                         1  0x00000001 (const dword)  (not used)
Strings20Size                          5  0x00000005 (const dword)  (usage 3)
Strings20StartH                        0  0x00000000 (const dword)  (usage 3)
Strings20StartL                     7680  0x00001e00 (const dword)  (usage 3)
Strings21Count                         1  0x00000001 (const dword)  (not used)
Strings21Size                          7  0x00000007 (const dword)  (usage 3)
Strings21StartH                        0  0x00000000 (const dword)  (usage 3)
Strings21StartL                     8192  0x00002000 (const dword)  (usage 3)
Strings22Count                         1  0x00000001 (const dword)  (not used)
Strings22Size                         13  0x0000000d (const dword)  (usage 3)
Strings22StartH                        0  0x00000000 (const dword)  (usage 3)
Strings22StartL                     8704  0x00002200 (const dword)  (usage 3)
Strings23Count                         1  0x00000001 (const dword)  (not used)
Strings23Size                          7  0x00000007 (const dword)  (usage 3)
Strings23StartH                        0  0x00000000 (const dword)  (usage 3)
Strings23StartL                     9216  0x00002400 (const dword)  (usage 3)
Strings24Count                         1  0x00000001 (const dword)  (not used)
Strings24Size                         12  0x0000000c (const dword)  (usage 3)
Strings24StartH                        0  0x00000000 (const dword)  (usage 3)
Strings24StartL                     9728  0x00002600 (const dword)  (usage 3)
Strings25Count                         1  0x00000001 (const dword)  (not used)
Strings25Size                          7  0x00000007 (const dword)  (usage 3)
Strings25StartH                        0  0x00000000 (const dword)  (usage 3)
Strings25StartL                    11264  0x00002c00 (const dword)  (usage 3)
Strings26Count                         1  0x00000001 (const dword)  (not used)
Strings26Size                         17  0x00000011 (const dword)  (usage 3)
Strings26StartH                        0  0x00000000 (const dword)  (usage 3)
Strings26StartL                    11776  0x00002e00 (const dword)  (usage 3)
Strings27Count                         1  0x00000001 (const dword)  (not used)
Strings27Size                          3  0x00000003 (const dword)  (usage 3)
Strings27StartH                        0  0x00000000 (const dword)  (usage 3)
Strings27StartL                    13824  0x00003600 (const dword)  (usage 3)
Strings28Count                         1  0x00000001 (const dword)  (not used)
Strings28Size                          8  0x00000008 (const dword)  (usage 3)
Strings28StartH                        0  0x00000000 (const dword)  (usage 3)
Strings28StartL                    14336  0x00003800 (const dword)  (usage 3)
Strings29Count                         1  0x00000001 (const dword)  (not used)
Strings29Size                          5  0x00000005 (const dword)  (usage 3)
Strings29StartH                        0  0x00000000 (const dword)  (usage 3)
Strings29StartL                    15360  0x00003c00 (const dword)  (usage 3)
Strings2Count                          1  0x00000001 (const dword)  (not used)
Strings2Size                          17  0x00000011 (const dword)  (usage 3)
Strings2StartH                         0  0x00000000 (const dword)  (usage 3)
Strings2StartL                         0  0x00000000 (const dword)  (usage 3)
Strings30Count                         1  0x00000001 (const dword)  (not used)
Strings30Size                          5  0x00000005 (const dword)  (usage 3)
Strings30StartH                        0  0x00000000 (const dword)  (usage 3)
Strings30StartL                    15872  0x00003e00 (const dword)  (usage 3)
Strings31Count                         1  0x00000001 (const dword)  (not used)
Strings31Size                         13  0x0000000d (const dword)  (usage 3)
Strings31StartH                        0  0x00000000 (const dword)  (usage 3)
Strings31StartL                    16384  0x00004000 (const dword)  (usage 3)
Strings32Count                         1  0x00000001 (const dword)  (not used)
Strings32Size                          7  0x00000007 (const dword)  (usage 3)
Strings32StartH                        0  0x00000000 (const dword)  (usage 3)
Strings32StartL                    17408  0x00004400 (const dword)  (usage 3)
Strings33Count                         1  0x00000001 (const dword)  (not used)
Strings33Size                         13  0x0000000d (const dword)  (usage 3)
Strings33StartH                        0  0x00000000 (const dword)  (usage 3)
Strings33StartL                    17920  0x00004600 (const dword)  (usage 3)
Strings34Count                         0  0x00000000 (const dword)  (not used)
Strings34Size                          1  0x00000001 (const dword)  (usage 3)
Strings34StartH                        0  0x00000000 (const dword)  (usage 3)
Strings34StartL                    18432  0x00004800 (const dword)  (usage 3)
Strings35Count                         1  0x00000001 (const dword)  (not used)
Strings35Size                         17  0x00000011 (const dword)  (usage 3)
Strings35StartH                        0  0x00000000 (const dword)  (usage 3)
Strings35StartL                    18944  0x00004a00 (const dword)  (usage 3)
Strings36Count                         0  0x00000000 (const dword)  (not used)
Strings36Size                          1  0x00000001 (const dword)  (usage 3)
Strings36StartH                        0  0x00000000 (const dword)  (usage 3)
Strings36StartL                    19456  0x00004c00 (const dword)  (usage 3)
Strings37Count                         1  0x00000001 (const dword)  (not used)
Strings37Size                          8  0x00000008 (const dword)  (usage 3)
Strings37StartH                        0  0x00000000 (const dword)  (usage 3)
Strings37StartL                     3072  0x00000c00 (const dword)  (usage 3)
Strings38Count                         1  0x00000001 (const dword)  (not used)
Strings38Size                          6  0x00000006 (const dword)  (usage 3)
Strings38StartH                        0  0x00000000 (const dword)  (usage 3)
Strings38StartL                     3584  0x00000e00 (const dword)  (usage 3)
Strings3Count                          1  0x00000001 (const dword)  (not used)
Strings3Size                           5  0x00000005 (const dword)  (usage 3)
Strings3StartH                         0  0x00000000 (const dword)  (usage 3)
Strings3StartL                     12800  0x00003200 (const dword)  (usage 3)
Strings4Count                          1  0x00000001 (const dword)  (not used)
Strings4Size                           6  0x00000006 (const dword)  (usage 3)
Strings4StartH                         0  0x00000000 (const dword)  (usage 3)
Strings4StartL                      1024  0x00000400 (const dword)  (usage 3)
Strings5Count                          1  0x00000001 (const dword)  (not used)
Strings5Size                           6  0x00000006 (const dword)  (usage 3)
Strings5StartH                         0  0x00000000 (const dword)  (usage 3)
Strings5StartL                      1536  0x00000600 (const dword)  (usage 3)
Strings6Count                          1  0x00000001 (const dword)  (not used)
Strings6Size                          12  0x0000000c (const dword)  (usage 3)
Strings6StartH                         0  0x00000000 (const dword)  (usage 3)
Strings6StartL                     13312  0x00003400 (const dword)  (usage 3)
Strings7Count                          1  0x00000001 (const dword)  (not used)
Strings7Size                          14  0x0000000e (const dword)  (usage 3)
Strings7StartH                         0  0x00000000 (const dword)  (usage 3)
Strings7StartL                      2048  0x00000800 (const dword)  (usage 3)
Strings8Count                          1  0x00000001 (const dword)  (not used)
Strings8Size                          13  0x0000000d (const dword)  (usage 3)
Strings8StartH                         0  0x00000000 (const dword)  (usage 3)
Strings8StartL                     14848  0x00003a00 (const dword)  (usage 3)
Strings9Count                          1  0x00000001 (const dword)  (not used)
Strings9Size                           7  0x00000007 (const dword)  (usage 3)
Strings9StartH                         0  0x00000000 (const dword)  (usage 3)
Strings9StartL                      2560  0x00000a00 (const dword)  (usage 3)
stringsCV                            322  0x00000142 (mem) word[39] (global)  (usage 27)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
SWITCH1_cOff                          20  0x00000014 (const dword)  (not used)
SWITCH1_cOn                           18  0x00000012 (const dword)  (not used)
SWITCH1_dshd                          12  0x0000000c (const dword)  (not used)
SWITCH1_F_ORIENT_VERT                N/A         N/A (macro)   0x0001  /* switch orientation (0: Horizontal, 1: Vertical) */   (not used)
SWITCH1_fcOff                         32  0x00000020 (const dword)  (not used)
SWITCH1_fcOn                          30  0x0000001e (const dword)  (not used)
SWITCH1_flg                            8  0x00000008 (const dword)  (not used)
SWITCH1_fnt                           26  0x0000001a (const dword)  (not used)
SWITCH1_fsz                           28  0x0000001c (const dword)  (not used)
SWITCH1_len                            4  0x00000004 (const dword)  (not used)
SWITCH1_lshd                          10  0x0000000a (const dword)  (not used)
SWITCH1_oBz                           14  0x0000000e (const dword)  (not used)
SWITCH1_tBz                           16  0x00000010 (const dword)  (not used)
SWITCH1_thk                            6  0x00000006 (const dword)  (not used)
SWITCH1_tOff                          24  0x00000018 (const dword)  (not used)
SWITCH1_tOn                           22  0x00000016 (const dword)  (not used)
SWITCH1_x                              0  0x00000000 (const dword)  (not used)
SWITCH1_y                              2  0x00000002 (const dword)  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_Driver                          -297  0xfffffed7 (PmmC func) args[0] r=0  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_PmmC                            -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 18)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 3)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tiAngularMeter                        39  0x00000027 (const dword)  (usage 21)
tiButtonD                             51  0x00000033 (const dword)  (usage 3)
tiButtonE                             52  0x00000034 (const dword)  (usage 3)
tiDial                                55  0x00000037 (const dword)  (usage 3)
tiGauge                               40  0x00000028 (const dword)  (usage 3)
tiLabelB                              41  0x00000029 (const dword)  (usage 6)
tiLed                                 45  0x0000002d (const dword)  (usage 3)
tiLedDigit                            50  0x00000032 (const dword)  (usage 9)
tiLedDigits                           47  0x0000002f (const dword)  (usage 6)
tiLedDigitsH                          38  0x00000026 (const dword)  (usage 12)
tiLinearInput                         67  0x00000043 (const dword)  (usage 9)
tImage                                12  0x0000000c (const dword)  (usage 3)
tiMediaButton                         53  0x00000035 (const dword)  (usage 3)
tiMediaGauge                          43  0x0000002b (const dword)  (usage 3)
tiMediaLed                            46  0x0000002e (const dword)  (usage 3)
tiMediaRotary                         56  0x00000038 (const dword)  (usage 3)
tiMediaSlider                         61  0x0000003d (const dword)  (usage 3)
tiMediaThermometer                    44  0x0000002c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tiNeedle                              48  0x00000030 (const dword)  (usage 3)
tiRotaryInput                         57  0x00000039 (const dword)  (usage 6)
tiRuler                               49  0x00000031 (const dword)  (usage 3)
tiSliderC                             66  0x00000042 (const dword)  (usage 3)
tiSliderD                             65  0x00000041 (const dword)  (usage 3)
tiSliderE                             60  0x0000003c (const dword)  (usage 3)
tiSliderF                             64  0x00000040 (const dword)  (usage 3)
tiSliderG                             63  0x0000003f (const dword)  (usage 3)
tiSliderH                             62  0x0000003e (const dword)  (usage 3)
tiSwitch                              58  0x0000003a (const dword)  (usage 3)
tiSwitchB                             59  0x0000003b (const dword)  (usage 6)
tiToggleInput                         54  0x00000036 (const dword)  (usage 6)
tiUserGauge                           42  0x0000002a (const dword)  (usage 3)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 6)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 3)
tMagicObject                          34  0x00000022 (const dword)  (usage 6)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 9)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 18)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           618  0x0000026a (mem) word (global)  (usage 24)
TouchXpos                            612  0x00000264 (mem) word (global)  (usage 12)
TouchYpos                            614  0x00000266 (mem) word (global)  (usage 9)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSmartGauge                           35  0x00000023 (const dword)  (usage 6)
tSmartKnob                            37  0x00000025 (const dword)  (usage 6)
tSmartSlider                          36  0x00000024 (const dword)  (usage 6)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 18)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 6)
TurnOffButtons                      6811  0x00001a9b (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 54)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 39)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (usage 3)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 3)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 3)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 3)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (usage 3)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (usage 3)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                           -345  0xfffffea7 (PmmC func) args[3] r=1  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 3)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       5512  0x00001588 (User func) args[1] r=0  (usage 3)
USD_ENABLE                            25  0x00000019 (const dword)  (not used)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
vIAngularMeter0                        2  0x00000002 (mem) word[10] (global)  (usage 3)
vIAngularMeter1                       22  0x00000016 (mem) word[10] (global)  (usage 3)
vIAngularMeter2                      134  0x00000086 (mem) word[10] (global)  (usage 3)
vIAngularMeter3                       42  0x0000002a (mem) word[10] (global)  (usage 3)
vILedDigits0                         298  0x0000012a (mem) word[12] (global)  (usage 3)
vILedDigits1                          62  0x0000003e (mem) word[12] (global)  (usage 3)
vILedDigits2                          86  0x00000056 (mem) word[12] (global)  (usage 3)
vILedDigits3                         110  0x0000006e (mem) word[12] (global)  (usage 3)
vILedDigits4                         154  0x0000009a (mem) word[12] (global)  (usage 3)
vILedDigits5                         250  0x000000fa (mem) word[12] (global)  (usage 3)
vILedDigits6                         178  0x000000b2 (mem) word[12] (global)  (usage 3)
vILedDigits7                         202  0x000000ca (mem) word[12] (global)  (usage 3)
vILedDigits8                         226  0x000000e2 (mem) word[12] (global)  (usage 3)
vILedDigits9                         274  0x00000112 (mem) word[12] (global)  (usage 3)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
vObjects                             402  0x00000192 (mem) word[28] (global)  (usage 15)
WEST                                   2  0x00000002 (const dword)  (not used)
WEST_MIRRORED                          6  0x00000006 (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (usage 84)
WHITE                              65535  0x0000ffff (const dword)  (usage 75)
WHITESMOKE                         63422  0x0000f7be (const dword)  (usage 18)
widget_Add                          -323  0xfffffebd (PmmC func) args[3] r=1  (usage 3)
widget_ClearAttributes              -334  0xfffffeb2 (PmmC func) args[3] r=1  (usage 3)
widget_Create                       -322  0xfffffebe (PmmC func) args[1] r=1  (usage 3)
WIDGET_DECIMALS                       11  0x0000000b (const dword)  (not used)
WIDGET_DELAY                          10  0x0000000a (const dword)  (not used)
widget_Delete                       -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
widget_Disable                      -331  0xfffffeb5 (PmmC func) args[2] r=1  (usage 3)
widget_Enable                       -330  0xfffffeb6 (PmmC func) args[2] r=1  (usage 3)
WIDGET_F_DISABLED                   2048  0x00000800 (const dword)  (not used)
WIDGET_F_FLASH                      1024  0x00000400 (const dword)  (not used)
WIDGET_F_INITIALISED                8192  0x00002000 (const dword)  (usage 3)
WIDGET_F_INTERNAL                  16384  0x00004000 (const dword)  (not used)
WIDGET_F_RESERVED                    960  0x000003c0 (const dword)  (not used)
WIDGET_F_TOUCH_ENABLE              32768  0x00008000 (const dword)  (usage 3)
WIDGET_F_UNDRAW_ONLY                4096  0x00001000 (const dword)  (not used)
WIDGET_FLAGS                           6  0x00000006 (const dword)  (not used)
widget_FontID                       -336  0xfffffeb0 (PmmC func) args[1] r=1  (not used)
WIDGET_FRAMES                         11  0x0000000b (const dword)  (not used)
widget_GetWord                      -328  0xfffffeb8 (PmmC func) args[3] r=1  (not used)
WIDGET_HEIGHT                          3  0x00000003 (const dword)  (not used)
WIDGET_HI_WORD                         5  0x00000005 (const dword)  (not used)
WIDGET_LO_WORD                         4  0x00000004 (const dword)  (not used)
widget_LoadFlash                    -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
WIDGET_RAM_SPACE                      10  0x0000000a (const dword)  (usage 42)
widget_Realloc                      -327  0xfffffeb9 (PmmC func) args[2] r=1  (not used)
widget_SetAttributes                -333  0xfffffeb3 (PmmC func) args[3] r=1  (usage 3)
widget_Setposition                  -329  0xfffffeb7 (PmmC func) args[4] r=1  (not used)
widget_SetWord                      -332  0xfffffeb4 (PmmC func) args[4] r=1  (not used)
widget_Show                         -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
WIDGET_TAG                             7  0x00000007 (const dword)  (not used)
WIDGET_TAG2                            8  0x00000008 (const dword)  (not used)
widget_Touched                      -335  0xfffffeb1 (PmmC func) args[2] r=1  (usage 3)
WIDGET_VAL1                            9  0x00000009 (const dword)  (usage 9)
WIDGET_VAL2                           10  0x0000000a (const dword)  (not used)
WIDGET_WIDTH                           2  0x00000002 (const dword)  (not used)
WIDGET_XOTHER                          4  0x00000004 (const dword)  (not used)
WIDGET_XPOS                            0  0x00000000 (const dword)  (not used)
WIDGET_YOTHER                          5  0x00000005 (const dword)  (not used)
WIDGET_YPOS                            1  0x00000001 (const dword)  (not used)
wp                                   868  0x00000364 (mem) word (global)  (usage 21)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_LABEL                           12  0x0000000c (const dword)  (usage 6)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_STR                              2  0x00000002 (const dword)  (usage 6)
WRITE_STRU                             3  0x00000003 (const dword)  (usage 6)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         7074  0x00001ba2 (User func) args[3] r=0  (usage 27)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
xobj2iobj                            209  0x000000d1xobj2iobj                            209  0x000000d1 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
XYLIN_X                                1  0x00000001 (const dword)  (not used)
XYLIN_Y                                0  0x00000000 (const dword)  (not used)
XYROT_EAST                             0  0x00000000 (const dword)  (not used)
XYROT_SOUTH                            1  0x00000001 (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
