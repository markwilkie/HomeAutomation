file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\pixxiLCD-39P4CT.fnc

000001  000001  #platform "pixxiLCD-39P4CT"
000002  000001  #platform "pixxiLCD-39P4CT"
000003  000008  */
000004  000009      #constant pixxiLCD_39P4CT
000005  000009      #constant pixxiLCD_39P4CT
000006  000010        
000007  000011      #IFNOT EXISTS PIXXI44_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PIXXI44functions.fnc

000008  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000009  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PIXXI44_FUNCTIONS
000014  000004  #constant PIXXI44_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000019  #END
000019  000020        
000020  000021  #CONST
000021  000027  #END
000022  000028        
000023  000029        
000024  000030  #CONST
000025  000044  #END
000026  000045        
000027  000046        
000028  000047  #CONST
000029  000212  #END
000030  000213        
000031  000214        
000032  000215  // baud divisor rates for setbaud(n);
000033  000216  #CONST
000034  000238  #END
000035  000239        
000036  000240        
000037  000241        
000038  000242        
000039  000247  */
000040  000248        
000041  000249        
000042  000250  //==============================================//
000043  000251  // EVE bios functions                           //
000044  000252  //==============================================//
000045  000253                                                  //
000046  000254  func serin(), 1;                // read a byte from COM0
000047  000255  // Syntax: serin();
000048  000256  // Usage : char := serin();
000049  000257  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000258  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000259  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000260  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000261  //     : Returns: -1 if no character is available
000054  000262  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000263  //     : Returns: positive value 0 to 255 for a valid character received
000056  000264        
000057  000265  func putch("char"), 0;                // write single char to current output device
000058  000266  // Syntax: putch("char");
000059  000267  // Usage : putch("A");
000060  000268  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000269  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000270  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000271  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000272  //     : The arguments can be a variable, array element, expression or constant
000065  000273        
000066  000274  func serout("char"), 0;                // write a byte to COM0
000067  000275  // Syntax: serout1("char");
000068  000276  // Usage : serout1(ch);
000069  000277  // Notes : send character to COM1
000070  000278        
000071  000279  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000280  // Syntax: setbaud(baud_number);
000073  000281  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000282  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000283  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000284  //       : this is used as a table pointer to get the baud rate divisor
000077  000285  //       : value for one of the 20 selected baud rates, control is then
000078  000286  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000287  //       : The pre-defined constants equate to a value of 0-19.
000080  000288  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000289  //       : will occur.
000082  000290        
000083  000291  func to("device"), 1;                // output device redirection
000084  000292  // Syntax: to(outstream);
000085  000293  // Usage : to(APPEND); putstr("TWO ");
000086  000294  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000295  //     :
000088  000296  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000297  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000298  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000299  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000300  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000301  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000302  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000303  //     : sequential data to a media stream.
000096  000304  //     :
000097  000305  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000306  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000307  //     :                            appended to user memory if previous redirection was to an array.
000100  000308  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000309  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000310  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000311  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000312  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000313        
000106  000314        
000107  000315  func pause("milliseconds"), 0;            // blocking delay
000108  000316  // Syntax: pause(milliseconds);
000109  000317  // Usage : pause(1000);                //pause for 1 second
000110  000318  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000319        
000112  000320  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000321  // Syntax: putnum(format, value);
000114  000322  // Usage : var := putnum(HEX, val);
000115  000323  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000324  //     : Format: A constant that specifies the number format
000117  000325  //     : Value : The number to be printed
000118  000326  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000327  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000328  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000329  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000330  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000331  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000332  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000333  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000334  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000335  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000336  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000337  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000338  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000339  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000340  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000341  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000342  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000343  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000344  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000345  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000346  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000347  //     : | | | | V V V
000140  000348  //     : | | | | | | |
000141  000349  //     : | | | | | |
000142  000350  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000351  //     : | | | | digit count |
000144  000352  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000353  //     : | | | |
000146  000354  //     : | | | |
000147  000355  //     : | | | |
000148  000356  //     : | | | |
000149  000357  //     : | | | |
000150  000358  //     : | | | |______ 1 = leading zeros included
000151  000359  //     : | | | 0 = leading zeros suppressed
000152  000360  //     : | | |
000153  000361  //     : | | |
000154  000362  //     : | | |_______ 1 = leading zero blanking
000155  000363  //     : | |
000156  000364  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000365  //     : |
000158  000366  //     : |______ 1 = space before unsigned number
000159  000367        
000160  000368        
000161  000369  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000370        
000163  000371  func putstr("string"), 1;                       // print string to current output device
000164  000372  // Syntax: putstr(pointer);
000165  000373  // Usage : putstr("HELLO\n");
000166  000374  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000375  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000376  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000377  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000378  //       : using the to(...); function.
000171  000379  //       : A string constant is automatically terminated with a zero.
000172  000380  //       : A string in a data statement is not automatically terminated with a zero.
000173  000381  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000382  //       : element packs 1 or 2 characters.
000175  000383        
000176  000384        
000177  000385  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000386  // Syntax: strlen("varAddress);
000179  000387  // Usage : strlen("HELLO\n");
000180  000388  // Notes : gives the length of a string that is packed into regular var array
000181  000389  //       : Use str_Length(ptr)  for string pointer mode
000182  000390        
000183  000391        
000184  000392  //==============================================//
000185  000393  // Memory Access Function Prototypes            //
000186  000394  //==============================================//
000187  000395                                                  //
000188  000396  func peekW("address"), 1;                       // read a word from system memory
000189  000397  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000398  // refer to address map of internal variables   //
000191  000399  //==============================================//
000192  000400  // Math Functions                               //
000193  000401  //==============================================//
000194  000402                                                  //
000195  000403  func ABS("value"), 1;                           // return a positive number
000196  000404  // Syntax: ABS(value);
000197  000405  // Usage : var := ABS(arg);
000198  000406  // Notes : Returns the absolute value of an argument
000199  000407        
000200  000408  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000409  // Syntax: MIN(value1, value2);
000202  000410  // Usage : var := MIN(arg1, arg2);
000203  000411  // Notes : Returns the minimum of 2 arguments
000204  000412        
000205  000413  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000414  // Syntax: MAX(value1, value2);
000207  000415  // Usage : var := MAX(arg1, arg2);
000208  000416  // Notes : Returns the maximum of 2 arguments
000209  000417        
000210  000418  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000419  // Syntax: SWAP(&var1, &var2);
000212  000420  // Usage : SWAP(&var1, &var2);
000213  000421  // Notes : Swaps the contents of 2 variables or memory locations
000214  000422        
000215  000423  func SIN("angle"), 1;                           // return SIN of angle
000216  000424  // Syntax: SIN(angle);
000217  000425  // Usage : var := SIN(arg);
000218  000426  // Notes : Returns the sine in radians of an argument in degrees
000219  000427  //       : the returned value range is from 127 to -127. The real
000220  000428  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000429  //       : scaling must be done in user code.
000222  000430        
000223  000431  func COS("angle"), 1;                           // return COS of angle
000224  000432  // Syntax: COS(angle);
000225  000433  // Usage : var := COS(arg);
000226  000434  // Notes : Returns the cosine in radians of an argument in degrees
000227  000435  //       : the returned value range is from 127 to -127. The real
000228  000436  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000437  //       : scaling must be done in user code.
000230  000438        
000231  000439  func RAND(), 1;                                 // return a pseudo random number
000232  000440  // Syntax: RAND();
000233  000441  // Usage : var := RAND();
000234  000442  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000443  //       : The random number generator must first be seeded
000236  000444  //       : by using the SEED(number) function.
000237  000445        
000238  000446  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000447  // Syntax: SEED(number);
000240  000448  // Usage : SEED(arg);
000241  000449  // Notes : Seeds the random number generator.
000242  000450        
000243  000451  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000452  // Syntax: OVF();
000245  000453  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000454  //       : hiWord := OVF();
000247  000455  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000456        
000249  000457  func SQRT("number"), 1;                         // return square root of a number
000250  000458  // Syntax: SQRT(number);
000251  000459  // Usage : SQRT(arg);
000252  000460  // Notes : Returns the integer square root of a number.
000253  000461  //------------------------------------------------------------------//
000254  000462  //          Text Related Function Prototypes
000255  000463  //------------------------------------------------------------------//
000256  000464        
000257  000465  func txt_MoveCursor("line", "column"), 0;
000258  000466  // Syntax: txt_SetCursor(line, column);
000259  000467  // Usage : txt_SetCursor(arg1, arg2);
000260  000468  // Notes : Moves the text Cursor to a new screen position set by
000261  000469  //       : line,column parameters.
000262  000470        
000263  000471  func txt_Set("mode", "value"), 0;
000264  000472  // Syntax: txt_Set(mode, value);
000265  000473  // Usage : txt_Set(arg1, arg2);
000266  000474  // Returns : Original value before the change
000267  000475  // Notes : Sets various text related parameters used by other functions
000268  000476  //       : This allows the features to be set programatically with a
000269  000477  //       : single function call.It is strongly recommended to use the
000270  000478  //       : pre-defined constants rather than the mode numbers.
000271  000479  //       : NB:- Although it is often required to be able to set text
000272  000480  //       : functions with a single function call for graphics engine
000273  000481  //       : related functions, there is a complete set of single parameter
000274  000482  //       : shortcut functions that have exactly the same function as
000275  000483  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000484  //       :
000277  000485  //       : mode = TEXT_COLOUR (mode 0)
000278  000486  //       : txt_Set(TEXT_COLOUR, value);
000279  000487  //       : value = 0 to 0xFFFF, Black to White
000280  000488  //       : Sets the Text colour for the display
000281  000489  //       : Default = LIME.
000282  000490  //       :
000283  000491  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000492  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000493  //       : value = 0 to 0xFFFF, Black to White
000286  000494  //       : Sets the Text background colour for the display. Effective
000287  000495  //       : when text mode is Opaque.
000288  000496  //       : Default = BLACK.
000289  000497  //       :
000290  000498  //       : mode = FONT_ID (mode 2)
000291  000499  //       : txt_Set(FONT_ID, value);
000292  000500  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000501  //       : else this value is the name of a font included
000294  000502  //       : in a users program in a data statement.
000295  000503  //       : Default = FONT SIZE 3.
000296  000504  //       :
000297  000505  //       : mode = TEXT_WIDTH  (mode 3)
000298  000506  //       : txt_Set(TEXT_WIDTH, value);
000299  000507  //       : value = 1 to 16
000300  000508  //       : Sets the Text Width multiplier
000301  000509  //       : text will be printed magnified horizontally
000302  000510  //       : by this factor, Default = 1.
000303  000511  //       :
000304  000512  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000513  //       : txt_Set(TEXT_HEIGHT, value);
000306  000514  //       : value = 1 to 16
000307  000515  //       : Sets the Text Height multiplier
000308  000516  //       : text will be printed magnified vertically
000309  000517  //       : by this factor, Default = 1.
000310  000518  //       :
000311  000519  //       : mode = TEXT_XGAP  (mode 5)
000312  000520  //       : txt_Set(TEXT_XGAP, value);
000313  000521  //       : value = 1 to 32
000314  000522  //       : Sets the horizontal gap between characters
000315  000523  //       : The gap is in pixel units, Default = 0
000316  000524  //       :
000317  000525  //       : mode = TEXT_YGAP  (mode 6)
000318  000526  //       : txt_Set(TEXT_YGAP, value);
000319  000527  //       : value = 1 to 32
000320  000528  //       : Sets the vertical gap below characters
000321  000529  //       : The gap is in pixel units, Default = 0
000322  000530  //       :
000323  000531  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000532  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000533  //       : value = 0 to 255
000326  000534  //       : Sets the delay time (in ms) during character
000327  000535  //       : printing to give a 'teletype' like effect.
000328  000536  //       : Often used to attract attention to a string
000329  000537  //       : being printed which can often be missed if
000330  000538  //       : just suddenly appearing or changing.
000331  000539  //       : Default = 0 ms.
000332  000540  //       :
000333  000541  //       : mode = TEXT_OPACITY (mode 8)
000334  000542  //       : txt_Set(TEXT_OPACITY, value);
000335  000543  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000544  //       : value = OPAQUE (1) = Text Opaque
000337  000545  //       : Sets the Opacity/Transparency of the text
000338  000546  //       : Default = 0 or TRANSPARENT
000339  000547  //       :
000340  000548  //       : mode = TEXT_BOLD (mode 9)
000341  000549  //       : txt_Set(TEXT_BOLD, value);
000342  000550  //       : value = dont care
000343  000551  //       : Sets Bold Text mode for the next string or char
000344  000552  //       : The feature automatically resets after printing
000345  000553  //       : using putstr or print has completed
000346  000554  //       :
000347  000555  //       : mode = TEXT_ITALIC (mode 10)
000348  000556  //       : txt_Set(TEXT_ITALIC, value);
000349  000557  //       : value = dont care
000350  000558  //       : Sets Italic Text mode for the next string or char
000351  000559  //       : The feature automatically resets after printing
000352  000560  //       : using putstr or print has completed
000353  000561        
000354  000562  //       : mode = TEXT_INVERSE (mode 11)
000355  000563  //       : txt_Set(TEXT_INVERSE, value);
000356  000564  //       : value = dont care
000357  000565  //       : Sets Inverse Text mode for the next string or char
000358  000566  //       : The feature automatically resets after printing
000359  000567  //       : using putstr or print has completed
000360  000568  //       :
000361  000569  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000570  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000571  //       : value = dont care
000364  000572  //       : Sets Underlined Text mode for the next string or char
000365  000573  //       : The feature automatically resets after printing
000366  000574  //       : using putstr or print has completed
000367  000575  //       :
000368  000576  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000577  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000578  //       : value = bits are defined as:
000371  000579  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000580  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000581  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000582  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000583  //       : Allows a combination of text attributes to be defined together
000376  000584  //       : by 'or'ing the bits together.
000377  000585  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000586  //       : The feature automatically resets after printing
000379  000587  //       : using putstr or print has completed.
000380  000588  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000589  //       :
000382  000590  //       : mode = TEXT_WRAP (mode 14)
000383  000591  //       : txt_Set(TEXT_WRAP , value);
000384  000592  //       : Sets the position where text wrap will occur
000385  000593  //       : The feature automatically resets when screen
000386  000594  //       : mode is changed. If the value is set to 0,
000387  000595  //       : text wrap is turned off.
000388  000596  //       : of the current screen. Default value is 0
000389  000597  // Notes : The value is in pixel units.
000390  000598  //       :
000391  000599        
000392  000600  //       : txt_Set mode 15 reserved for future use
000393  000601  //       :
000394  000602        
000395  000603        
000396  000604        
000397  000605  //=====================================================//
000398  000606  // Single parameter short-cuts                         //
000399  000607  // for the txt_Set functions                           //
000400  000608  // These functions return the existing value before    //
000401  000609  // the change is made.                                 //
000402  000610  //=====================================================//
000403  000611  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000612  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000613  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000614  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000615  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000616  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000617  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000618  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000619  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000620  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000621  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000622  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000623  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000624  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000625  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000626  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000627        
000420  000628        
000421  000629  //------------------------------------------------------------------//
000422  000630  //                 Hardware Function Prototypes
000423  000631  //------------------------------------------------------------------//
000424  000632        
000425  000633  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000426  000634  // Syntax: pin_Set(mode, pin);
000427  000635  // Usage : pin_Set(arg1, arg2);
000428  000636  // Notes : Sets the appropriate pins to Inputs or Outputs
000429  000637  //       : returns true if the pin number is legal (usually ignored)
000430  000638  //       :
000431  000639  //       : "mode" is either INPUT or OUTPUT
000432  000640  //       :
000433  000641  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000434  000642  //       : of your PiXXi-44 processor.
000435  000643        
000436  000644  func pin_HI("pin"), 1;                    // set pin to logic '1'
000437  000645  // Syntax: pin_HI(pin);
000438  000646  // Usage : pin_HI(arg);
000439  000647  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000440  000648  //       : pin that was previously selected as an Output.
000441  000649  //       : returns true if the pin number is legal (usually ignored)
000442  000650  //       :
000443  000651  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000444  000652  //       : of your PiXXi-44 processor.
000445  000653        
000446  000654  func pin_LO("pin"), 1;                    // set pin to logic '0'
000447  000655  // Syntax: pin_LO(pin);
000448  000656  // Usage : pin_LO(arg);
000449  000657  // Notes : Outputs a logic "Low" (0V) on the appropriate
000450  000658  //       : pin that was previously selected as an Output.
000451  000659  //       : returns true if the pin number is legal (usually ignored)
000452  000660  //       :
000453  000661  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000454  000662  //       : of your PiXXi-44 processor.
000455  000663        
000456  000664  func pin_Read("pin"), 1;                // read pin, logic or analogue
000457  000665  // Syntax	: pin_Read(pin);
000458  000666  // Usage	: arg1 := pin_Read(arg2);
000459  000667  // Notes	: Reads the logic state of the appropriate
000460  000668  // 	: pin that was previously selected as an Input.
000461  000669  // 	:
000462  000670  // 	: "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000463  000671  // 	: of your PiXXi-44 processor.
000464  000672  // 	: Returns 0 or 1 for a digital input
000465  000673  // 	: Returns 0..4095 for an analogue input
000466  000674        
000467  000675  //------------------------------------------------------------------//
000468  000676  //                 P1 module BUS I/O control
000469  000677  //------------------------------------------------------------------//
000470  000678        
000471  000679  func bus_In(), 1;
000472  000680  // Syntax: bus_In();
000473  000681  // Usage : arg1 := bus_In();
000474  000682  // Notes : Read the 7bit wide bus into the lower 7 bits of arg1.
000475  000683  //       : The upper 9 bits of arg1 are set to 0.
000476  000684  //       : Only available in Mode 2 (4-Wire SPI)
000477  000685  //       : 
000478  000686  //       : BUS_0 is IO12_PIN
000479  000687  //       : BUS_1 is IO13_PIN
000480  000688  //       : BUS_2 is IO14_PIN
000481  000689  //       : BUS_3 is IO15_PIN
000482  000690  //       : BUS_4 is IO16_PIN
000483  000691  //       : BUS_5 is IO17_PIN
000484  000692  //       : BUS_6 is IO18_PIN
000485  000693  //       : BUS_7 is N/A
000486  000694        
000487  000695  func bus_Out("var"), 0;
000488  000696  // Syntax: bus_Out(var);
000489  000697  // Usage : bus_Out(arg1);
000490  000698  // Notes : The lower 7 bits of arg1 are placed on the 7bit wide bus.
000491  000699  //       : The upper 9 bits of arg1 are ignored.
000492  000700  //       : NB:- any BUS pins that are set to inputs are not affected.
000493  000701  //       : Only available in Mode 2 (4-Wire SPI)
000494  000702  //       :
000495  000703  //       : BUS_0 is pin 27 of J1
000496  000704  //       : BUS_1 is pin 25 of J1
000497  000705  //       : BUS_2 is pin 23 of J1
000498  000706  //       : BUS_3 is pin 21 of J1
000499  000707  //       : BUS_4 is pin 19 of J1
000500  000708  //       : BUS_5 is pin 17 of J1
000501  000709  //       : BUS_6 is pin 13 of J2
000502  000710  //       : BUS_7 is pin 11 of J2
000503  000711        
000504  000712  func bus_Set("var"), 0;
000505  000713  // Syntax: bus_Set(var);
000506  000714  // Usage : bus_Set(arg1);
000507  000715  // Notes : Not available on the Pixxi Chips
000508  000716        
000509  000717  func bus_Write("var"), 0;
000510  000718  // Syntax: bus_Write(var);
000511  000719  // Usage : bus_Write(arg1);
000512  000720  // Notes : Not available on the Pixxi Chips
000513  000721        
000514  000722  func bus_Read(), 1;
000515  000723  // Syntax: bus_Read();
000516  000724  // Usage : arg1 := bus_Read();
000517  000725  // Notes : Not available on the Pixxi Chips
000518  000726        
000519  000727        
000520  000728  //------------------------------------------------------------------//
000521  000729  //   Graphics Functions
000522  000730  //------------------------------------------------------------------//
000523  000731  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000524  000732  // Syntax: gfx_Set(mode, value);
000525  000733  // Usage : gfx_Set(arg1, arg2);
000526  000734  // Notes : Sets various graphics parameters used by other functions
000527  000735  //       : This allows the features to be set programatically with a
000528  000736  //       : single function call.It is strongly recommended to use the
000529  000737  //       : pre-defined constants rather than the mode numbers.
000530  000738  //       : NB:- Although it is often required to be able to set graphics
000531  000739  //       : functions with a single function call for graphics engine
000532  000740  //       : related functions, there is a complete set of single parameter
000533  000741  //       : shortcut functions that have exactly the same function as
000534  000742  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000535  000743  //       :
000536  000744  //       : mode = PEN_SIZE (mode 16)
000537  000745  //       : gfx_Set(PEN_SIZE, value);
000538  000746  //       : value = SOLID (value 0) rectangle and circle objects are solid
000539  000747  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000540  000748  //       : Sets the mode of the Pen used by most graphics objects
000541  000749  //       :
000542  000750  //       : mode = BACKGROUND_COLOUR (mode 17)
000543  000751  //       : gfx_Set(BACKGROUND_COLOUR, value);
000544  000752  //       : value = 0 to 0xFFFF, Black to White
000545  000753  //       : Sets the Background colour of the screen
000546  000754  //       :
000547  000755  //       : mode = OBJECT_COLOUR (mode 18)
000548  000756  //       : gfx_Set(OBJECT_COLOUR, value);
000549  000757  //       : value = 0 to 0xFFFF, Black to White
000550  000758  //       : Sets the Object colour used in various functions
000551  000759  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000552  000760  //       :
000553  000761  //       : mode = CLIPPING (mode 19)
000554  000762  //       : gfx_Set(CLIPPING, value);
000555  000763  //       : value = OFF (value 0) Clipping disabled
000556  000764  //       : value = ON (value 1) Clipping enabled
000557  000765  //       : Enables/Disables the Clipping feature
000558  000766  //       :
000559  000767  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000560  000768  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000561  000769  //       : value = 0 to 0xFFFF Black to White
000562  000770  //       : Sets Bitmap, Image or Animation Transparency Colour.
000563  000771  //       : NB not implemented
000564  000772  //       :
000565  000773  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000566  000774  //       : gfx_Set(5, value);
000567  000775  //       : value = OFF (value 0) Transparency disabled
000568  000776  //       : value = ON (value 1) Transparency enabled
000569  000777  //       : Enables/Disables the Transparency feature
000570  000778  //       : NB not implemented
000571  000779  //       :
000572  000780  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000573  000781  //       : gfx_Set(FRAME_DELAY, value);
000574  000782  //       : value = 0 to 65535 ms
000575  000783  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000576  000784  //       : over-ride the embedded frame delay of the clip. After the event,
000577  000785  //       : the setting will auto disable and if further inter-frame delays need
000578  000786  //       : overriding the setting must be re-issued.
000579  000787  //       :
000580  000788  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000581  000789  //       : gfx_Set(SCREEN_MODE, value);
000582  000790  //       : value = LANDSCAPE   (value 0)
000583  000791  //       : value = LANDSCAPE_R (value 1)
000584  000792  //       : value = PORTRAIT    (value 2)
000585  000793  //       : value = PORTRAIT_R  (value 3)
000586  000794  //       :
000587  000795  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000588  000796  //       : gfx_Set(OUTLINE_COLOUR, value);
000589  000797  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000590  000798  //       : Sets the filled Rectangle or Circle objects outline colour
000591  000799  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000592  000800  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000593  000801  //       :
000594  000802  //       : Only supports variable contrast for uOLED Modules
000595  000803  //       : mode = CONTRAST (mode 25) : Contrast
000596  000804  //       : gfx_Set(CONTRAST, value);
000597  000805  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000598  000806  //       : when contrast=0, display is placed in low power mode.
000599  000807  //       : This function should be called with contrast=0 when
000600  000808  //       : powering down the module.
000601  000809  //       :
000602  000810  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000603  000811  //       : gfx_Set(LINE_PATTERN, value);
000604  000812  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000605  000813  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000606  000814  //       : a value of 0 turns the feature off
000607  000815  //       :
000608  000816  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000609  000817  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000610  000818  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000611  000819  //       : NB not implemented, default is COLOUR16
000612  000820  //       :
000613  000821  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000614  000822  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000615  000823  //       : sets the button and slider objects bevel width
000616  000824  //       :
000617  000825  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000618  000826  //       : gfx_Set(BEVEL_SHADOW , 5);
000619  000827  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000620  000828  //       :
000621  000829  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000622  000830  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000623  000831  //       : sets the origin of drawn objects to a position other than 0,0
000624  000832  //       :
000625  000833  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000626  000834  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000627  000835  //       : sets the origin of drawn objects to a position other than 0,0
000628  000836        
000629  000837        
000630  000838  func gfx_Cls(), 0;                    // clear the screen
000631  000839  // Syntax: gfx_Cls();
000632  000840  // Usage : gfx_Cls();
000633  000841  // Notes : Clears the screen with current background colour
000634  000842        
000635  000843  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000636  000844  // Syntax: gfx_MoveTo(x, y);
000637  000845  // Usage : gfx_MoveTo(arg1, arg2);
000638  000846  // Notes : Moves the origin to a new x,y position
000639  000847        
000640  000848  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000641  000849  // Syntax: gfx_MoveRel(x, y);
000642  000850  // Usage : gfx_MoveRel(arg1, arg2);
000643  000851  // Notes : Moves the origin to a new x,y position
000644  000852  //       : relative to the current origing
000645  000853        
000646  000854  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000647  000855  // Syntax: gfx_LineTo(x1, y1);
000648  000856  // Usage : gfx_LineTo(arg1, arg2);
000649  000857  // Notes : Draws a Line from the origin x,y to x1,y1.
000650  000858  //       : The new origin is then set to x1, y1. Line colour needs
000651  000859  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000652  000860        
000653  000861  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000654  000862  // Syntax: gfx_LineRel(x1, y1);
000655  000863  // Usage : gfx_LineRel(arg1, arg2);
000656  000864  // Notes : Draws a Line from the origin x,y to x1,y1.
000657  000865  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000658  000866  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000659  000867        
000660  000868  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000661  000869  // Syntax: gfx_Line(x1, x2, y2, colr);
000662  000870  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000663  000871  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000664  000872        
000665  000873  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000666  000874  // Syntax: gfx_Line(x1, x2, y, colr);
000667  000875  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000668  000876  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000669  000877        
000670  000878  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000671  000879  // Syntax: gfx_Line(y1, y2, x, colr);
000672  000880  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000673  000881  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000674  000882        
000675  000883  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000676  000884  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000677  000885  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000678  000886  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000679  000887  //       : bottom corner (x2,y2) on the screen.
000680  000888        
000681  000889  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000682  000890  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000683  000891  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000684  000892  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000685  000893  //       : bottom corner (x2,y2) on the screen.
000686  000894        
000687  000895  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000688  000896  // Syntax: gfx_Circle(x, y, rad, colr);
000689  000897  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000690  000898  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000691  000899        
000692  000900  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000693  000901  // Syntax: gfx_Circle(x, y, rad, colr);
000694  000902  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000695  000903  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000696  000904        
000697  000905  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000698  000906  // Syntax: gfx_PutPixel(x, y, colr);
000699  000907  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000700  000908  // Notes : Plots a coloured pixel on the screen at x,y location
000701  000909        
000702  000910  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000703  000911  // Syntax: gfx_GetPixel(x, y);
000704  000912  // Usage : var := gfx_GetPixel(arg1, arg2);
000705  000913  // Notes : Reads and returns the colour value of a pixel at location x,y
000706  000914        
000707  000915  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000708  000916  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000709  000917  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000710  000918  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000711  000919  //       : Vertices must be specified in an anti-clockwise fashion
000712  000920        
000713  000921  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000714  000922  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000715  000923  // Usage : gfx_OrbitInit(&arg1, &arg2);
000716  000924  // Notes : Sets up the Orbit function parameters.
000717  000925  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000718  000926  //       : variables that get updated after calling gfx_Orbit(,,) function.
000719  000927  //       : The coordiantaes are calculated relative to the origin
000720  000928  //       : obtained by using the gfx_MoveTo(x, y) function.
000721  000929        
000722  000930  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000723  000931  // Syntax: gfx_Orbit(angle, distance);
000724  000932  // Usage : gfx_Orbit(arg1, arg2);
000725  000933  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000726  000934  //       : only known parameters are the angle and the distance from the current origin.
000727  000935        
000728  000936  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000729  000937  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000730  000938  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000731  000939  // Notes : This function is very similar to the Ploygon function
000732  000940  //       : with the exception of the 1st and the last vertices not joined.
000733  000941        
000734  000942  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000735  000943  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000736  000944  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000737  000945  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000738  000946  //       : Vertices must be minimum of 3 and can be specified in any fashion
000739  000947        
000740  000948  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000741  000949  // Syntax: gfx_Dot();
000742  000950  // Usage : gfx_Dot();
000743  000951  // Notes : Places a coloured dot at the origin
000744  000952        
000745  000953        
000746  000954  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000747  000955  // Syntax: gfx_Bullet();
000748  000956  // Usage : gfx_Bullet();
000749  000957  // Notes : Places a coloured circle at the origin
000750  000958  //       : filled or unfilled state is controlled by PenSize
000751  000959        
000752  000960  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000753  000961  // Syntax: gfx_IncX();
000754  000962  // Usage : var := gfx_IncX();
000755  000963  // Notes : Increments the x coordinate of the origin
000756  000964        
000757  000965  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000758  000966  // Syntax: gfx_IncY();
000759  000967  // Usage : var := gfx_IncY();
000760  000968  // Notes : Increments the y coordinate of the origin
000761  000969        
000762  000970  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000763  000971  // Syntax: gfx_BoxTo(x1, y1);
000764  000972  // Usage : gfx_BoxTo(arg1, arg2);
000765  000973  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000766  000974  //       : The new origin is then set to x1,y1. Rectangle colour needs
000767  000975  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000768  000976  //       : and the PenSize setting determines if Box is solid or outline.
000769  000977        
000770  000978  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000771  000979  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000772  000980  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000773  000981  // Notes : Specifies a clipping window region on the screen such that any objects
000774  000982  //       : and text placed onto the screen will be clipped and displayed only
000775  000983  //       : within that region. For the clipping window to take effect, "Clipping"
000776  000984  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000777  000985        
000778  000986        
000779  000987  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000780  000988  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000781  000989  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000782  000990  // *Notes:
000783  000991        
000784  000992  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000785  000993  // Syntax: gfx_SetClipRegion();
000786  000994  // Usage : var := gfx_SetClipRegion();
000787  000995  // *Notes:
000788  000996        
000789  000997  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000790  000998  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000791  000999  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000792  001000  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000793  001001  //       : with xradius = xrad and yradius = yrad.
000794  001002  //       : if PenSize = 0 Ellipse is Solid
000795  001003  //       : if PenSize = 1 Ellipse is Outline
000796  001004        
000797  001005        
000798  001006  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000799  001007  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000800  001008  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000801  001009  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000802  001010  //       : with xradius = xrad and yradius = yrad.
000803  001011        
000804  001012  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000805  001013  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000806  001014  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000807  001015  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000808  001016  //       : x,y arguments (top left corner). The size of the button depends on
000809  001017  //       : the font, width, height and length of the text.
000810  001018  //       : The button appearance will depend on the state parameter setting:
000811  001019  //       :         state = 0 : Button Pressed
000812  001020  //       :         state = 1 : Button Raised
000813  001021        
000814  001022  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000815  001023  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000816  001024  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000817  001025  // Notes : Draws a panel (groupbox) at screen location defined by
000818  001026  //       : x, y, width and height with colour "colour".
000819  001027  //       :         state = 0 : recessed
000820  001028  //       :         state = 1 : raised
000821  001029        
000822  001030  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000823  001031  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000824  001032  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000825  001033  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000826  001034  //       : Slider parameters are as follows:
000827  001035  //       :         mode = 0 : Slider recessed
000828  001036  //       :         mode = 1 : Slider raised
000829  001037  //       :         x1, y1 = top left corner
000830  001038  //       :         x2, y2 = bottom right corner
000831  001039  //       :         scale = n : sets the full scale range from 0 to n
000832  001040  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000833  001041  //       : returns:-
000834  001042        
000835  001043        
000836  001044  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000837  001045  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000838  001046  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000839  001047  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000840  001048  //       : and pastes it to another location determined by xd, yd.
000841  001049        
000842  001050  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000843  001051  // Syntax: gfx_RGBto565(red, green, blue);
000844  001052  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000845  001053  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000846  001054        
000847  001055  func gfx_332to565("COLOUR8BIT"), 1;
000848  001056  // Syntax: gfx_332to565(colour);
000849  001057  // Usage : gfx_332to565(arg);
000850  001058  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000851  001059        
000852  001060  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000853  001061  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000854  001062  // Usage : gfx_Selection(1, RED, YELLOW);
000855  001063  // Notes : Called prior to drawing a button, this function
000856  001064  //       : hilites the required text line on a multiline button.
000857  001065        
000858  001066  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000859  001067  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000860  001068  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000861  001069  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000862  001070  //       : Vertices must be specified in an anti-clockwise fashion
000863  001071        
000864  001072        
000865  001073  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000866  001074  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000867  001075  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
000868  001076  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000869  001077  //       : Vertices must be minimum of 3 and can be specified in any fashion
000870  001078        
000871  001079        
000872  001080  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
000873  001081  // Syntax: gfx_Offset(x, y);
000874  001082  // Usage : gfx_Offset(arg1, arg2);
000875  001083  // Notes : Set the screen offset
000876  001084        
000877  001085        
000878  001086        
000879  001087  func gfx_Get("mode"), 1;
000880  001088  // Syntax: gfx_Get(mode);
000881  001089  // Usage : arg1 := gfx_Get(arg);
000882  001090  // Notes : Returns various parameters to caller
000883  001091  //       :
000884  001092  //       : mode = X_MAX (mode 0) : current orientations maximum X value
000885  001093  //       : var := gfx_Get(X_MAX);
000886  001094  //       : Returns the maximum horizontal value of the display
000887  001095  //       :
000888  001096  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
000889  001097  //       : var := gfx_Get(Y_MAX);
000890  001098  //       : Returns the maximum vertical value of the display
000891  001099  //       :
000892  001100  //       : mode = LEFT_POS (mode 2) : Left location of last Object
000893  001101  //       : var := gfx_Get(LEFT_POS);
000894  001102  //       : Returns the left location of the last drawn object
000895  001103  //       : such as a slider or button or an image/video
000896  001104  //       :
000897  001105  //       : mode = TOP_POS (mode 3) : Top location of Object
000898  001106  //       : var := gfx_Get(TOP_POS);
000899  001107  //       : Returns the top location of the last drawn object
000900  001108  //       : such as a slider or button or an image/video
000901  001109  //       :
000902  001110  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
000903  001111  //       : var := gfx_Get(RIGHT_POS);
000904  001112  //       : Returns the right location of the last drawn object
000905  001113  //       : such as a slider or button or an image/video
000906  001114  //       :
000907  001115  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
000908  001116  //       : var := gfx_Get(BOTTOM_POS );
000909  001117  //       : Returns the bottom location of the last drawn object
000910  001118  //       : such as a slider or button or an image/video
000911  001119  //       :
000912  001120        
000913  001121        
000914  001122  //==================================================//
000915  001123  // Single parameter short-cuts                      //
000916  001124  // for the gfx_Set functions                        //
000917  001125  // These functions return the existing value before //
000918  001126  // the change is made.                              //
000919  001127  //==================================================//
000920  001128  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
000921  001129  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
000922  001130  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
000923  001131  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
000924  001132  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
000925  001133  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
000926  001134  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
000927  001135  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
000928  001136  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
000929  001137  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
000930  001138  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
000931  001139  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
000932  001140  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
000933  001141  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
000934  001142  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
000935  001143  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
000936  001144        
000937  001145        
000938  001146  //==================================================//
000939  001147  // uSD/FLASH Function Prototypes                    //
000940  001148  //==================================================//
000941  001149  func media_Video("x", "y"), 0;                      // display movie at position x y
000942  001150  // Syntax: media_Video(x, y);
000943  001151  // Usage : media_Video(arg1, arg2);
000944  001152  // Notes : Play a Video/Animation clip from the uSD card at screen location
000945  001153  //       : specified by x,y (top left corner). The location of the clip in the
000946  001154  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
000947  001155        
000948  001156  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
000949  001157  // Syntax: media_VideoFrame(Frame_number);
000950  001158  // Usage : arg1 := media_VideoFrame();
000951  001159  // Notes : After a pointer to a valid video has been set with media_SetSector,
000952  001160  //       : calling this function shows each fram sequentially, returning
000953  001161  //       : the number of frames remaining. The position of the image is
000954  001162  //     : at the current origin as set with gfx_MoveTo(...);
000955  001163        
000956  001164  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
000957  001165  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
000958  001166  // Usage : media_SetAdd(arg1, arg2);
000959  001167  // Notes : Set uSD internal Address pointer for bytewise access
000960  001168        
000961  001169  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
000962  001170  // Syntax: media_SetSector(SectHiWord, SectLoWord);
000963  001171  // Usage : media_SetSector(arg1, arg2);
000964  001172  // Notes : Set uSD internal Sector pointer for sector block access
000965  001173        
000966  001174  func media_RdSector("*destination"), 1;
000967  001175  // Syntax: media_RdSector(*destination);
000968  001176  // Usage : media_RdSector(rdblock);
000969  001177  // Notes : Reads and Returns 512 bytes (256 words) into a destination
000970  001178  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
000971  001179  //       : After the read the Sector pointer is automatically incremented by 1.
000972  001180  //       : Returns TRUE if uSD response was TRUE
000973  001181        
000974  001182  func media_WrSector("*source"), 1;
000975  001183  // Syntax: media_WrSector(*source);
000976  001184  // Usage : media_WrSector(wrblock);
000977  001185  // Notes : Writes 512 bytes (256 words) from a source memory block
000978  001186  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
000979  001187  //       : pointer is automatically incremented by 1.
000980  001188  //       : Returns TRUE if uSD response was TRUE
000981  001189        
000982  001190  func media_ReadByte(), 1;                // read a byte at the current stream position
000983  001191  // Syntax: media_RdByte();
000984  001192  // Usage : var := media_RdByte();
000985  001193  // Notes : Reads and Returns a single byte of data from the
000986  001194  //       : uSD card pointed to by the internal Address pointer.
000987  001195  //       : After the read the Address pointer is automatically
000988  001196  //       : incremented by 1.
000989  001197        
000990  001198  func media_ReadWord(), 1;                // read a word at the current stream position
000991  001199  // Syntax: media_ReadWord();
000992  001200  // Usage : var := media_ReadWord();
000993  001201  // *Notes : Reads and Returns a single word of data from the
000994  001202  //       : uSD card pointed to by the internal Address pointer.
000995  001203  //       : After the read the Address pointer is automatically
000996  001204  //       : incremented by 2.
000997  001205        
000998  001206  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
000999  001207  // Syntax: media_WriteByte(arg1);
001000  001208  // Usage : var := media_WriteByte(arg1);
001001  001209  // *Notes : Writes and Returns xxxxx
001002  001210  //       : After the write the Address pointer is automatically
001003  001211  //       : incremented by 1.
001004  001212        
001005  001213  func media_WriteWord("word"), 1;            // write a word to the current stream position
001006  001214  // Syntax: media_WriteWord(arg1);
001007  001215  // Usage : var := media_WriteWord(arg1);
001008  001216  // *Notes : Writes and Returns xxxxx
001009  001217  //       : After the write the Address pointer is automatically
001010  001218  //       : incremented by 2.
001011  001219        
001012  001220  func media_Image("x", "y"), 0;            // display image at position x y
001013  001221  // Syntax: media_Image(x, y);
001014  001222  // Usage : media_Image(arg1, arg2);
001015  001223  // Notes : Display an image from the uSD card at screen location
001016  001224  //       : specified by x,y (top left corner). The location of the
001017  001225  //       : Image in the uSD card must be specified by
001018  001226  //       : media_setSector(Image_Sector_Add) function.
001019  001227        
001020  001228  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001021  001229  // Syntax: media_Flush();
001022  001230  // Usage : var := media_Flush();
001023  001231  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001024  001232  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001025  001233        
001026  001234  func media_Init(), 1;                    // initialize uSD card
001027  001235  // Usage	: media_Init();
001028  001236  // Notes	: Initialise uSD CARD
001029  001237  // 	: Response: 0 = No Card
001030  001238  // 	:           1 = Card Initialised
001031  001239  // 	: Do not use this for systems with SPI Flash, use media_InitFlash() instead
001032  001240  // 	: init the Media.
001033  001241        
001034  001242        
001035  001243  //==============================================//
001036  001244  // Communications Function Prototypes           //
001037  001245  //==============================================//
001038  001246  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001039  001247  // Syntax: com_Init(buffer, bufsize, qualifier);
001040  001248  // Usage1: com_Init(mybuf, 20, 0);
001041  001249  // Usage2: com_Init(mybuf, 20, ':');
001042  001250  // Notes : initialize a serial capture buffer for the comms input
001043  001251  //       : The program must declare a var array as a circular buffer.
001044  001252  //       : Usage1 declares a circular buffer which will continually
001045  001253  //       : buffer characters.
001046  001254  //       : Usage2 must receive ':' before any characters will
001047  001255  //       : accumulate in the buffer.
001048  001256        
001049  001257  func com_Reset(), 0;                 // reset the comms receiver
001050  001258  // Syntax: com_Reset();
001051  001259  // Usage : com_Reset();
001052  001260  // Notes : reset comms to default polled mode
001053  001261        
001054  001262  func com_Count(), 1;                // return count of characters in receive buffer
001055  001263  // Syntax: com_Count();
001056  001264  // Usage : arg := com_Count();
001057  001265  // Notes : return count of buffered characters in buffer attachment
001058  001266        
001059  001267  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001060  001268  // Syntax: com_Full();
001061  001269  // Usage : if (com_Full() ,,,, go read buffer;
001062  001270  // Notes : return true if buffer full (not necessarily an error if
001063  001271  //       : buffer is sized to a packet size)
001064  001272        
001065  001273  func com_Error(), 1;                // return comms errors comms error occurred
001066  001274  // Syntax: com_Error();
001067  001275  // Usage : if (com_Error() ) ...... take recovery action;
001068  001276  // Notes : return non zero if any errors low level comms errors occured
001069  001277  // returns :
001070  001278  // bit0 = Receiver Overflow Error
001071  001279  // bit1 = Receiver Framing Error
001072  001280  // bit2 = Transmit Buffer Overflow
001073  001281        
001074  001282  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001075  001283  // Syntax: com_Sync();
001076  001284  // Usage : com_Sync();
001077  001285  // return true if sync character has been received in com_Init("...") mode
001078  001286        
001079  001287        
001080  001288  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001081  001289  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001082  001290  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001083  001291  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001084  001292  // Notes : initialize a serial buffer for the COM0 output.
001085  001293  //       : The program must declare a var array as a circular buffer.
001086  001294  //       : When a TX buffer is declared for comms, the transmission
001087  001295  //       : of characters becomes non blocking. The only time
001088  001296  //       : blocking will occur is if the buffer has insufficient space
001089  001297  //       : to accept the next character, in which case the function
001090  001298  //       : will wait for buffer space to become available. If the
001091  001299  //       : TX buffer is no longer required, just set the buffer pointer
001092  001300  //       : to zero, the size in this case doesnt matter and is ignored.
001093  001301  //       : The function can resize or reallocated to another buffer at
001094  001302  //       : any time. The buffer is flushed before any changes are made.
001095  001303  //       : "pin" designates an IO pin to control a bi-directional 
001096  001304  //       : control device for half duplex mode. "pin" will go HI at the
001097  001305  //       : start of a transmission, and will return low after the final
001098  001306  //       : byte is transmitted. If not required, just set "pin" to zero.
001099  001307        
001100  001308        
001101  001309  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001102  001310  // Syntax: com_TXcount();
001103  001311  // Usage : arg := com_Count();
001104  001312  // Notes : return count of characters remaining in COM0 transmit buffer
001105  001313  //       : that was previously allocated with com_TXbuffer(...);
001106  001314        
001107  001315        
001108  001316  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001109  001317  // Syntax: com_TXemptyEvent(function);
001110  001318  // Usage : arg := com_TXemptyEvent();
001111  001319  // Notes : If a comms TX buffer that was previously allocated with
001112  001320  //       : com_TXbuffer(...);, this function can be used to set up
001113  001321  //       : a function to be called when the COM0 TX buffer is empty.
001114  001322  //       : This is useful for either reloading the TX buffer, setting
001115  001323  //       : or clearing a pin to change the direction of eg a RS485
001116  001324  //       : line driver, or any other form of traffic control.
001117  001325  //       : The event function must not have any parameters.
001118  001326  //       : To disable the event, simply call com_TXemptyEvent(0).
001119  001327  //       : com_TXbuffer(...); also resets any active event.
001120  001328  //       : com_TXemptyEvent returns any previous event function
001121  001329  //       : address, or zero if there was no previous function.
001122  001330        
001123  001331        
001124  001332  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001125  001333  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001126  001334  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001127  001335  // Notes : Expecting that a comms TX buffer that was previously allocated with
001128  001336  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001129  001337  //       : the buffer being sent wile it is being loaded. Mormally, when
001130  001338  //       : using buffered comms, the transmit process will begin
001131  001339  //       : immediately. This is often undesirable for 2 reasons,
001132  001340  //       : 1] you may wish to build a packet then send it later
001133  001341  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001134  001342  //       : as the FIFO buffer is constantly trying to empty while
001135  001343  //       : you are busy tring to fill it.
001136  001344  // return -1 if function is called illegally when TX comms is not buffered.
001137  001345  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001138  001346  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001139  001347        
001140  001348        
001141  001349  //=============================================================//
001142  001350  // Auxilliary Communications Function Prototypes
001143  001351  //=============================================================//
001144  001352  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001145  001353  // Syntax: com_Init(buffer, bufsize, qualifier);
001146  001354  // Usage1: com_Init(mybuf, 20, 0);
001147  001355  // Usage2: com_Init(mybuf, 20, ':');
001148  001356  // Notes : initialize a serial capture buffer for the comms input
001149  001357  //       : The program must declare a var array as a circular buffer.
001150  001358  //       : Usage1 declares a circular buffer which will continually
001151  001359  //       : buffer characters.
001152  001360  //       : Usage2 must receive ':' before any characters will
001153  001361  //       : accumulate in the buffer.
001154  001362        
001155  001363  func com1_Reset(), 0;
001156  001364  // Syntax: com_Reset();
001157  001365  // Usage : com_Reset();
001158  001366  // Notes : reset comms receiver to default polled mode
001159  001367        
001160  001368  func com1_Count(), 1;
001161  001369  // Syntax: com_Count();
001162  001370  // Usage : arg := com_Count();
001163  001371  // Notes : return count of characters in receive buffer
001164  001372        
001165  001373  func com1_Full(), 1;
001166  001374  // Syntax: com_Full();
001167  001375  // Usage : if (com_Full() ,,,, go read buffer;
001168  001376  // Notes : return true if receive buffer full
001169  001377        
001170  001378  func com1_Error(), 1;
001171  001379  // Syntax: com_Error();
001172  001380  // Usage : if (com_Error() ) ...... take recovery action;
001173  001381  // Notes : return non zero if any level comms errors occured
001174  001382  // returns :
001175  001383  // bit0 = Receiver Overflow Error
001176  001384  // bit1 = Receiver Framing Error
001177  001385  // bit2 = Transmit Buffer Overflow
001178  001386        
001179  001387  func com1_Sync(), 1;
001180  001388  // Syntax: com_Sync();
001181  001389  // Usage : com_Sync();
001182  001390  // Notes : return true if sync character has been received in com_Init("...") mode
001183  001391        
001184  001392        
001185  001393  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001186  001394  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001187  001395  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001188  001396  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001189  001397  // Notes : initialize a serial buffer for the COM1 output.
001190  001398  //       : The program must declare a var array as a circular buffer.
001191  001399  //       : When a TX buffer is declared for comms, the transmission
001192  001400  //       : of characters becomes non blocking. The only time
001193  001401  //       : blocking will occur is if the buffer has insufficient space
001194  001402  //       : to accept the next character, in which case the function
001195  001403  //       : will wait for buffer space to become available. If the
001196  001404  //       : TX buffer is no longer required, just set the buffer pointer
001197  001405  //       : to zero, the size in this case doesnt matter and is ignored.
001198  001406  //       : The function can resize or reallocated to another buffer at
001199  001407  //       : any time. The buffer is flushed before any changes are made.
001200  001408  //       : "pin" designates an IO pin to control a bi-directional 
001201  001409  //       : control device for half duplex mode. "pin" will go HI at the
001202  001410  //       : start of a transmission, and will return low after the final
001203  001411  //       : byte is transmitted. If not required, just set "pin" to zero.
001204  001412        
001205  001413        
001206  001414  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001207  001415  // Syntax: com1_TXcount();
001208  001416  // Usage : arg := com1_Count();
001209  001417  // Notes : return count of characters remaining in COM1 transmit buffer
001210  001418  //       : that was previously allocated with com1_TXbuffer(...);
001211  001419        
001212  001420        
001213  001421  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001214  001422  // Syntax: com1_TXemptyEvent(function);
001215  001423  // Usage : arg := com1_TXemptyEvent();
001216  001424  // Notes : If a comms TX buffer that was previously allocated with
001217  001425  //       : com1_TXbuffer(...);, this function can be used to set up
001218  001426  //       : a function to be called when the COM1 TX buffer is empty.
001219  001427  //       : This is useful for either reloading the TX buffer, setting
001220  001428  //       : or clearing a pin to change the direction of eg a RS485
001221  001429  //       : line driver, or any other form of traffic control.
001222  001430  //       : The event function must not have any parameters.
001223  001431  //       : To disable the event, simply call com1_TXemptyEvent(0).
001224  001432  //       : com1_TXbuffer(...); also resets any active event.
001225  001433  //       : com1_TXemptyEvent returns any previous event function
001226  001434  //       : address, or zero if there was no previous function.
001227  001435        
001228  001436        
001229  001437  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001230  001438  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001231  001439  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001232  001440  // Notes : Expecting that a comms TX buffer that was previously allocated with
001233  001441  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001234  001442  //       : the buffer being sent wile it is being loaded. Mormally, when
001235  001443  //       : using buffered comms, the transmit process will begin
001236  001444  //       : immediately. This is often undesirable for 2 reasons,
001237  001445  //       : 1] you may wish to build a packet then send it later
001238  001446  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001239  001447  //       : as the FIFO buffer is constantly trying to empty while
001240  001448  //       : you are busy tring to fill it.
001241  001449  // return -1 if function is called illegally when TX comms is not buffered.
001242  001450  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001243  001451  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001244  001452        
001245  001453  func serin1(), 1;
001246  001454  // Syntax: serin1();
001247  001455  // Usage : char := serin1();
001248  001456  // Notes : return the next available character from COM1
001249  001457        
001250  001458  func serout1("char"), 0;
001251  001459  // Syntax: serout1("char");
001252  001460  // Usage : serout1(ch);
001253  001461  // Notes : send character to COM1
001254  001462        
001255  001463  func com_SetBaud("comport","baudrate/10"), 1;
001256  001464  // Syntax: com_SetBaud("comport","baudrate/10");
001257  001465  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001258  001466  // Notes : sets to any viable baud rate from 160 to 655350
001259  001467  // return true if baud rate was acceptable
001260  001468        
001261  001469        
001262  001470        
001263  001471  //==============================================//
001264  001472  // Display Access                               //
001265  001473  //==============================================//
001266  001474  func disp_Init(), 0;                            // initialize display with required tables
001267  001475  // Syntax: disp_Init();
001268  001476  // Usage : disp_Init();
001269  001477  // Notes : Initialises or reinitialises the display.
001270  001478  //       : Normally used after restoration of peripheral power
001271  001479  //       : and after DeepSleep.
001272  001480        
001273  001481  func disp_SetReg("register", "data"), 0;
001274  001482  // Syntax: display_SetReg(register, data);
001275  001483  // Usage : display_SetReg(arg1, arg2);
001276  001484  // Notes : Sets uLCD specific display driver registers. Refer
001277  001485  //       : to appropriate display driver data sheet.
001278  001486        
001279  001487  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001280  001488  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001281  001489  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001282  001490  // Notes : Prepares the GRAM area for user access.
001283  001491  //       : Data can now be written with disp_GRAM.
001284  001492  //       : GRAM will be set accordingly for the correct screen mode.
001285  001493  //       : the LO word of the 32 bit pixel count is returned. This is
001286  001494  //       : usually all that is needed unlse GRAM area exceeds 256^2
001287  001495  //       : A copy of the 32bit value can be found in
001288  001496  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001289  001497        
001290  001498  func disp_WrGRAM("colour"), 0;
001291  001499  // Syntax: display_WrGRAM(colour);
001292  001500  // Usage : display_WrGRAM(arg);
001293  001501  // Notes : Data can be written to the GRAM consecutively using
001294  001502  //       : this function once the GRAM access window has been setup.
001295  001503        
001296  001504  func disp_WriteControl("value"), 0;             // write a control byte to the display
001297  001505  func disp_WriteWord("value"), 0;                // write a word to the display
001298  001506        
001299  001507        
001300  001508  func disp_ReadWord("Command", "dummy"), 1;                        // read a word from the display
001301  001509  // Syntax	: disp_ReadWord(command, 1);
001302  001510  // Usage	: x:=disp_ReadWord(command, 1);
001303  001511  // Notes	: Read a word from the controller
001304  001512  // Eg: 	: print(disp_ReadWord(0), 0);        // select Ilitek ID register, read using 0 dummy reads, print ID
001305  001513  // 	: (Many displays are write only)
001306  001514  // 	: Some SPI displays required the command be given as part of the read sequence.
001307  001515  // 	: For displays that do not require this the value will be ignored.
001308  001516        
001309  001517                                                  //
001310  001518  //==============================================//
001311  001519  // unadorned SPI functions                      //
001312  001520  //==============================================//
001313  001521  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001314  001522  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001315  001523  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001316  001524  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001317  001525                                                  //
001318  001526  //==============================================//
001319  001527  // flash device specific functions              //
001320  001528  //==============================================//
001321  001529  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001322  001530  // Syntax: flash_SIG();
001323  001531  // Usage : flash_SIG();
001324  001532  // Notes	: Returns the Flash Signature returned from the 'FLASH WAKEUP RETURN SIG'
001325  001533  // 	: (0xAB) command.
001326  001534        
001327  001535  func flash_ID(), 1;                             // read ID code from FLASH device
001328  001536  // Syntax: flash_ID();
001329  001537  // Usage : flash_ID();
001330  001538  // Notes	: Returns the second(memory type) and third(memory capacity) bytes returned from the 
001331  001539  // 	: 'FLASH READ ID REG' (0x9F) command.
001332  001540        
001333  001541  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001334  001542        
001335  001543  func flash_Block64Erase(), 1;            // erase the required 64k flash block
001336  001544  // Syntax: flash_Block64Erase();
001337  001545  // Usage : flash_Block64Erase();
001338  001546  // Notes	: Erase the 64KB flash block including the currently set address
001339  001547  // 	: This uses the 0xD8 command.
001340  001548                                                  //
001341  001549                                                  //
001342  001550  //==============================================//
001343  001551  // string and character size function           //
001344  001552  //==============================================//
001345  001553  func charwidth("char"), 1;                      // return width of a character in pixel units
001346  001554  func charheight("char"), 1;                     // return height of a character in pixel units
001347  001555  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001348  001556  func strheight(), 1;                            // return height of a string in pixel units
001349  001557        
001350  001558        
001351  001559  //------------------------------------------------------------------//
001352  001560  //        I2C Function Prototypes
001353  001561  //------------------------------------------------------------------//
001354  001562  func I2C1_Open("speed"), 0;
001355  001563  // Syntax: I2C1_Open(speed),
001356  001564  // Usage : I2C1_Open(I2C_MED);
001357  001565  // Notes : configures the I2C1 module
001358  001566  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001359  001567        
001360  001568  func I2C1_Close(), 0;
001361  001569  // Syntax: I2C1_Close();
001362  001570  // Usage : I2C1_Close();
001363  001571  // Notes : disables the I2C1 module.
001364  001572        
001365  001573  func I2C1_Start(), 1;
001366  001574  // Syntax: I2C1_Start();
001367  001575  // Usage : I2C1_Start();
001368  001576  // Notes : generates a Start condition.
001369  001577  //       : returns true if successful (usually ignored)
001370  001578        
001371  001579  func I2C1_Stop(), 1;
001372  001580  // Syntax: I2C1_Stop();
001373  001581  // Usage : I2C1_Stop();
001374  001582  // Notes : generates a Stop condition.
001375  001583  //       : returns true if successful (usually ignored)
001376  001584        
001377  001585  func I2C1_Restart(), 1;
001378  001586  // Syntax: I2C1_Restart();
001379  001587  // Usage : I2C1_Restart();
001380  001588  // Notes : generates a Restart condition.
001381  001589  //       : returns true if successful (usually ignored)
001382  001590        
001383  001591  func I2C1_Read(), 1;
001384  001592  // Syntax: I2C1_Read();
001385  001593  // Usage : ch := I2C1_Read();
001386  001594  // Notes : reads a single byte from the I2C Bus.
001387  001595        
001388  001596  func I2C1_Write("byte"), 1;
001389  001597  // Syntax: I2C1_Write(byte);
001390  001598  // Usage : r := I2C1_Write(ch);
001391  001599  // Notes : is used to write a byte to the I2C bus.
001392  001600  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001393  001601        
001394  001602  func I2C1_Ack(), 0;
001395  001603  // Syntax: I2C1_Ack();
001396  001604  // Usage : I2C1_Ack();
001397  001605  // Notes : generates the acknowledge condition.
001398  001606        
001399  001607  func I2C1_Nack(), 0;
001400  001608  // Syntax: I2C1_Nack();
001401  001609  // Usage : I2C1_Nack();
001402  001610  // Notes : generates the negative acknowledge condition.
001403  001611        
001404  001612  func I2C1_AckStatus(), 0;
001405  001613  // Syntax: I2C1_AckStatus();
001406  001614  // Usage : r := I2C1_AckStatus();
001407  001615  // Notes : returns the ACK status from the device.
001408  001616        
001409  001617  func I2C1_AckPoll("control"), 1;
001410  001618  // Syntax: I2C1_AckPoll();
001411  001619  // Usage : r := I2C1_AckPoll(0xA0);
001412  001620  // Notes : waits for a device to return from ACK polling.
001413  001621        
001414  001622  func I2C1_Idle(), 0;
001415  001623  // Syntax: I2C1_Idle();
001416  001624  // Usage : I2C1_Idle();
001417  001625  // Notes : waits until the I2C Bus is Inactive.
001418  001626        
001419  001627  func I2C1_Gets("buffer", "size"), 1;
001420  001628  // Syntax: I2C1_Gets("buffer", "size");
001421  001629  // Usage : r := I2C1_Gets(mybuf, 16);
001422  001630  // Notes : only reads up to "size" characters into "buffer"
001423  001631  //       : Reads up to asciiz terminator including terminator
001424  001632        
001425  001633  func I2C1_Getn("buffer", "size"), 1;
001426  001634  // Syntax: I2C1_Gets("buffer", "size");
001427  001635  // Usage : r := I2C1_Gets(mybuf, 16);
001428  001636  // Notes : reads "size" bytes into "buffer"
001429  001637  //       :
001430  001638        
001431  001639  func I2C1_Puts("buffer"), 1;
001432  001640  // Syntax: I2C1_Puts("buffer");
001433  001641  // Usage : r := I2C1_Puts(mybuf);
001434  001642  // Notes : writes an asciiz string to the I2C device
001435  001643  //       : returns count of characters written
001436  001644        
001437  001645  func I2C1_Putn("buffer", "count"), 1;
001438  001646  // Syntax: I2C1_Putn("buffer","count");
001439  001647  // Usage : r := I2C1_Puts(mybuf,10);
001440  001648  // Notes : writes up to "size" bytes to the I2C device
001441  001649  //       : returns number of bytes written
001442  001650        
001443  001651        
001444  001652  //------------------------------------------------------------------//
001445  001653  //        Image Control Function Prototypes
001446  001654  //------------------------------------------------------------------//
001447  001655  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001448  001656  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001449  001657  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001450  001658  // Notes : set the position where the image will be displayed
001451  001659  //       : returns true if index was ok and function was successful.
001452  001660  //       : you may turn off an image so when img_Refresh is called,
001453  001661  //       : the image will not be shown
001454  001662        
001455  001663  func img_Enable("handle", "index"), 1;
001456  001664  // Syntax: img_Enable(handle, index);
001457  001665  // Usage : r := img_Enable(hImageList, imagenum);
001458  001666  // Notes : enable image in a image list
001459  001667  //       : returns true if index was ok and function was successful.
001460  001668  //       : this is the default state so when img_Refresh is called,
001461  001669  //       : all the images in the list will be shown
001462  001670  //       : if index is set to -1, all of the images are enabled
001463  001671        
001464  001672  func img_Disable("handle", "index"), 1;
001465  001673  // Syntax: img_Disable(handle, index);
001466  001674  // Usage : r := img_Disable(hImageList, imagenum);
001467  001675  // Notes : disable image in a image list
001468  001676  //       : returns true if index was ok and function was successful.
001469  001677  //       : you must turn off an image so when img_Refresh is called,
001470  001678  //       : the image will not be shown.
001471  001679  //       : if index is set to -1, all of the images are disabled
001472  001680        
001473  001681        
001474  001682  func img_Darken("handle", "index"), 1;
001475  001683  // Syntax: img_Darken(handle, index);
001476  001684  // Usage : r := img_Darken(hImageList, imagenum);
001477  001685  // Notes : darken image in a image list
001478  001686  //       : returns true if index was ok and function was successful.
001479  001687  //       : if index is set to -1, all of the images are darkened
001480  001688  //       : NB:- this feature will only work for the next refresh, then
001481  001689  //       : the image reverts back to normal when displayed again.
001482  001690        
001483  001691        
001484  001692  func img_Lighten("handle", "index"), 1;
001485  001693  // Syntax: img_Lighten(handle, index);
001486  001694  // Usage : r := img_Lighten(hImageList, imagenum);
001487  001695  // Notes : lighten image in a image list
001488  001696  //       : returns true if index was ok and function was successful.
001489  001697  //       : if index is set to -1, all of the images are lightened
001490  001698  //       : NB:- this feature will only work for the next refresh, then
001491  001699  //       : the image reverts back to normal when displayed again.
001492  001700        
001493  001701  func img_SetWord("handle", "index", "offset", "word"), 1;
001494  001702  // Syntax: img_SetWord(handle, index, offset, word);
001495  001703  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001496  001704  // Notes : set specified word (0-7) in a image entry
001497  001705  //       : returns TRUE if successful, return value usually ignored.
001498  001706        
001499  001707  func img_GetWord("handle", "index", "offset"), 1;
001500  001708  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001501  001709  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001502  001710  // Notes : returns specified word (0-14) from an image entry
001503  001711  //       : refer to image control entry offsets.
001504  001712        
001505  001713  func img_Show("handle", "index"), 1;
001506  001714  // Syntax: img_Show(handle, index);
001507  001715  // Usage : display image entry (regardless of enable/disable)
001508  001716  //       : returns TRUE if successful, return value usually ignored.
001509  001717        
001510  001718  func img_SetAttributes("handle", "index","value"), 1;
001511  001719  // Syntax: img_SetAttributes("handle", "index","offset");
001512  001720  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001513  001721  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001514  001722  //       : of an image control entry. "value" refers to various bits in
001515  001723  //       : the image control entry (see image attribute flags).
001516  001724  //       : A '1' bit in the "value" field SETS the respective bit
001517  001725  //       : in the IMAGE_FLAGS field of the image control entry.
001518  001726  //       : returns TRUE if successful, return value usually ignored.
001519  001727        
001520  001728  func img_ClearAttributes("handle", "index","value"), 1;
001521  001729  // Syntax: img_ClearAttributes("handle", "index","offset");
001522  001730  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001523  001731  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001524  001732  //       : of an image control entry. "value" refers to various bits in
001525  001733  //       : the image control entry (see image attribute flags)
001526  001734  //       : a '1' bit in the "value" field CLEARS the respective bit
001527  001735  //       : in the IMAGE_FLAGS field of the image control entry.
001528  001736  //       : returns TRUE if successful, return value usually ignored.
001529  001737        
001530  001738  func img_Touched("handle", "index"), 1;
001531  001739  // Syntax: r := img_Touched(handle, index);
001532  001740  // Usage : img_Touched(hndl, 17);
001533  001741  //       : returns -1 if image not touched, or returns index
001534  001742  // Notes : if index is passed as -1, function tests all images,
001535  001743  //       : and returns -1 if image not touched, or returns index.
001536  001744        
001537  001745        
001538  001746        
001539  001747        
001540  001748  //------------------------------------------------------------------//
001541  001749  //        Timer Function Prototypes
001542  001750  //------------------------------------------------------------------//
001543  001751  func sys_T(), 1;
001544  001752  // Syntax: sys_T();
001545  001753  // Usage : t := sys_T();
001546  001754  // Notes : return the current value of the rolling system timer (1msec) LO word
001547  001755        
001548  001756  func sys_T_HI(), 1;
001549  001757  // Syntax: sys_T_HI();
001550  001758  // Usage : t := sys_T_HI();
001551  001759  // Notes : return the current value of the rolling system timer (1msec) HI word
001552  001760        
001553  001761  func sys_SetTimer("timernum","value"), 0;
001554  001762  // Syntax: sys_SetTimer("timernum", "value");
001555  001763  // Usage : sys_SetTimer(TIMER5, 10000);
001556  001764  // Notes : set a countdown on the selected timer, or 'top up' if required.
001557  001765  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001558  001766  //       : Maximum timeout period is 65.535 seconds
001559  001767  //       : A timer can be read with the sys_GetTimer("timernum") function
001560  001768        
001561  001769  func sys_GetTimer("timernum"), 1;
001562  001770  // Syntax: t := sys_GetTimer("timernum");
001563  001771  // Usage : t := sys_GetTimer(TIMER3);
001564  001772  // Notes : returns 0 if timer has expired, or the current countdown value.
001565  001773  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001566  001774  //       : Maximum timeout period is 65.535 seconds
001567  001775  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001568  001776        
001569  001777  func sys_SetTimerEvent("timernum","function"), 1;
001570  001778  // Syntax: sys_SetTimerFunction("timernum", "function");
001571  001779  // Usage : sys_SetTimer(TIMER5, myfunc);
001572  001780  // Notes : set a function to be called for selected timer.
001573  001781  //       : When the timer reaches zero, the function is called.
001574  001782  //       : The called function must not have any parameters
001575  001783  //       : sys_SetTimerEvent returns any previous event function
001576  001784  //       : address, or zero if there was no previous function.
001577  001785        
001578  001786  func sys_EventQueue(), 1;
001579  001787  // Syntax: sys_EventQueue();
001580  001788  // Usage : tasks := sys_EventQueue();
001581  001789  // Notes : returns the max number of events that were pending
001582  001790  //       : in the timer queue since the last call to this function.
001583  001791  //       : This can be used to assess timer event overhead burden,
001584  001792  //       : especially after or during a sys_EventsPostpone action.
001585  001793        
001586  001794  func sys_EventsPostpone(), 0;
001587  001795  // Syntax: sys_EventPostpone();
001588  001796  // Usage : sys_EventPostpone();   // postpone the event queue
001589  001797  // Notes : postpone any events until the sys_EventResume function is executed
001590  001798  //       : The timer event queue will continue to queue events, but no action
001591  001799  //       : will take place untill a sys_EventResume function is encountered.
001592  001800  //       : The queue will continue to receive up to 32 events before discarding
001593  001801  //       : any further events. This function is required to allow a sequence of
001594  001802  //       : instructions or functions to occur that would otherwise be corrupted
001595  001803  //       : by an event occuring during the sequence of instructions or functions.
001596  001804  //       : A good example of this is when you set a position to print, if there
001597  001805  //       : was no way of locking the current sequence, an event may occur which
001598  001806  //       : does a similar thing, and a contention would occur - printing to
001599  001807  //       : the wrong position. This function should be used wisely, if any action
001600  001808  //       : that is required would take considerable time, it is better to disable
001601  001809  //       : any conflicting event functions with a bypass flag, then restart the
001602  001810  //       : conflicting event by re-issuing a timer value.
001603  001811        
001604  001812  func sys_EventsResume(), 0;
001605  001813  // Syntax: sys_EventsResume();
001606  001814  // Usage : sys_EventsResume();   // resume the event queue
001607  001815  // Notes : resume any postponed events. The queue will try to execute any timer
001608  001816  //       : events that were incurred during the postponed period.
001609  001817        
001610  001818        
001611  001819  func sys_Sleep("units"), 1;
001612  001820  // Syntax: t := sys_Sleep("units");
001613  001821  // Usage : t := sys_Sleep(10);
001614  001822  // Notes : sets the display into low power mode for a period of time.
001615  001823  //       : Touching the touch screen will also wake from sleep.
001616  001824  //       : Returns remaining sleep units.
001617  001825        
001618  001826  func iterator("offset"), 0;
001619  001827  // Syntax: t :=  iterator("offset");
001620  001828  // Usage : t :=  iterator(10);
001621  001829  // Notes : set the iterator size for ++/--
001622  001830  //       : The next postinc,postdec,preinc of predec will alter
001623  001831  //       : by the specified value.
001624  001832  //       : The offset will return to 1 after the next operation.
001625  001833        
001626  001834        
001627  001835        
001628  001836        
001629  001837  //------------------------------------------------------------------//
001630  001838  //         Touch Screen Function Prototypes
001631  001839  //------------------------------------------------------------------//
001632  001840        
001633  001841  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001634  001842  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001635  001843  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001636  001844  // Notes : Specifies a new touch detect region on the screen
001637  001845  //       : such that only touch activity in that region will
001638  001846  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001639  001847        
001640  001848  func touch_Set("mode"), 0;
001641  001849  // Syntax: touch_Set(mode);
001642  001850  // Usage : touch_Set(arg);
001643  001851  // Notes : Sets various Touch Screen related parameters
001644  001852  //       :
001645  001853  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001646  001854  //       : touch_Set(TOUCH_ENABLE);
001647  001855  //       : Enables and initialises Touch Screen hardware
001648  001856  //       :
001649  001857  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001650  001858  //       : touch_Set(TOUCH_DISABLE );
001651  001859  //       : Disables the Touch Screen
001652  001860  //       : Note: Touch Screen runs in the background and disabling
001653  001861  //       : it when not in use will free up extra resources
001654  001862  //       : such as 4DVM CPU cycles.
001655  001863  //       :
001656  001864  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001657  001865  //       : touch_Set(TOUCH_REGIONDEFAULT);
001658  001866  //       : This will reset the current active region to default
001659  001867  //       : to the full screen without the application having to
001660  001868  //       : set a new active region for the full screen.
001661  001869  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001662  001870  //       : that requre to be interfaced with an external pointing
001663  001871  //       : device, values that are poked into TOUCH_DRIVE will be
001664  001872  //       : read with the touch_Get() function)
001665  001873        
001666  001874        
001667  001875  func touch_Get("mode"), 1;
001668  001876  // Syntax: touch_Get(mode);
001669  001877  // Usage : arg1 := touch_Get(arg);
001670  001878  // Notes : Returns various Touch Screen parameters to caller
001671  001879  //       :
001672  001880  //       : mode = TOUCH_STATUS  (mode 0)
001673  001881  //       : var := touch_Get(TOUCH_STATUS);
001674  001882  //       : Returns the various states of the touch screen
001675  001883  //       : 0 = NOTOUCH
001676  001884  //       : 1 = TOUCH_PRESSED
001677  001885  //       : 2 = TOUCH_RELEASED
001678  001886  //       : 3 = TOUCH_MOVING
001679  001887  //       :
001680  001888  //       : mode = TOUCH_GETX   (mode 1)
001681  001889  //       : var := touch_Get(TOUCH_GETX);
001682  001890  //       : Returns the X coordinates of the touch
001683  001891  //       :
001684  001892  //       : mode = TOUCH_GETY   (mode 2)
001685  001893  //       : var := touch_Get(TOUCH_GETY);
001686  001894  //       : Returns the Y coordinates of the touch
001687  001895        
001688  001896  //------------------------------------------------------------------//
001689  001897  //        CTYPE Function Prototypes
001690  001898  //------------------------------------------------------------------//
001691  001899        
001692  001900  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001693  001901  // Syntax: isdigit("char");
001694  001902  // Usage : Var := isdigit(ch);
001695  001903  // Notes : char specifies the ascii character for the test
001696  001904  //     : 0 : char is not an ascii digit.
001697  001905  //     : 1 : char is an ascii digit..
001698  001906  //     : Valid range is "0123456789"
001699  001907        
001700  001908  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001701  001909  // Syntax: isxdigit("char");
001702  001910  // Usage : Var := isxdigit(ch);
001703  001911  // Notes : char specifies the ascii character for the test
001704  001912  //     : 0 : char is not an ascii hexadecimal digit.
001705  001913  //     : 1 : char is an ascii hexadecimal digit..
001706  001914  //     : Valid range is "0123456789ABCDEF"
001707  001915        
001708  001916  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001709  001917  // Syntax: isupper("char");
001710  001918  // Usage : Var := isupper(ch);
001711  001919  // Notes : char specifies the ascii character for the test
001712  001920  //     : 0 : char is not an ascii upper-case letter.
001713  001921  //     : 1 : char is an ascii upper-case letter.
001714  001922  //     : Valid range is "ABCD....WXYZ"
001715  001923        
001716  001924  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001717  001925  // Syntax: islower("char");
001718  001926  // Usage : Var := islower(ch);
001719  001927  // Notes : char specifies the ascii character for the test
001720  001928  //     : 0 : char is not an ascii lower-case letter.
001721  001929  //     : 1 : char is an ascii lower-case letter.
001722  001930  //     : Valid range is "abcd....wxyz"
001723  001931        
001724  001932  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001725  001933  // Syntax: isalpha("char");
001726  001934  // Usage : Var := isalpha(ch);
001727  001935  // Notes : char specifies the ascii character for the test
001728  001936  //     : 0 : char is not an ascii lower or upper case letter.
001729  001937  //     : 1 : char is an ascii lower or upper case letter.
001730  001938  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001731  001939        
001732  001940  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001733  001941  // Syntax: isalnum("char");
001734  001942  // Usage : Var := isalnum(ch);
001735  001943  // Notes : char specifies the ascii character for the test
001736  001944  //     : 0 : char is not an ascii alphanumeric character.
001737  001945  //     : 1 : char is an ascii alphanumeric character.
001738  001946  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001739  001947        
001740  001948  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001741  001949  // Syntax: isprint("char");
001742  001950  // Usage : Var := isprint(ch);
001743  001951  // Notes : char specifies the ascii character for the test
001744  001952  //     : 0 : char is not a printable ascii character.
001745  001953  //     : 1 : char is a printable ascii character.
001746  001954  //     : Valid range is "0x20...0x7F"
001747  001955        
001748  001956  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001749  001957  // Syntax: isspace("char");
001750  001958  // Usage : Var := isspace(ch);
001751  001959  // Notes : char specifies the ascii character for the test
001752  001960  //     : 0 : char is not a space type character.
001753  001961  //     : 1 : char is a space type character.
001754  001962  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001755  001963        
001756  001964  //unformatted
001757  001965  func iswhite("char"), 1;    //
001758  001966  // Syntax: iswhite("char");
001759  001967  // Usage : Var := iswhite(ch);
001760  001968  // Notes : char specifies the ascii character for the test
001761  001969  //     : 0 : char is not a space or tab character.
001762  001970  //     : 1 : char is not a space or tab character.
001763  001971  //     : Valid range is space or tab
001764  001972        
001765  001973  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001766  001974  // Syntax: toupper("char");
001767  001975  // Usage : Var := toupper(ch);
001768  001976  // Notes : char specifies the ascii character for the test
001769  001977  //     : "ABCD....XYZ" : if character is a lower case letter.
001770  001978  //     : char : if character is not a lower case letter.
001771  001979  //     : Valid range is "abcd....wxyz"
001772  001980        
001773  001981  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001774  001982  // Syntax: tolower("char");
001775  001983  // Usage : Var := tolower(ch);
001776  001984  // Notes : char specifies the ascii character for the test
001777  001985  //     : "abcd....xyz" : if character is an upper case letter.
001778  001986  //     : char : if character is not an upper case letter.
001779  001987  //     : Valid range is "ABCD....WXYZ"
001780  001988        
001781  001989  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001782  001990  // Syntax: LObyte(var);
001783  001991  // Usage : myVar := LObyte(myvar2);
001784  001992  // Notes : var specifies the user variable
001785  001993  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001786  001994        
001787  001995  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001788  001996  // Syntax: HIbyte(var);
001789  001997  // Usage : myVar := HIbyte(myvar2);
001790  001998  // Notes : var specifies the user variable
001791  001999  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001792  002000        
001793  002001        
001794  002002  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001795  002003  // Syntax: ByteSwap(var);
001796  002004  // Usage : myVar := ByteSwap(myvar2);
001797  002005  // Notes : var specifies the user variable
001798  002006  //     : Returns the endian swapped value of a 16 bit variable
001799  002007        
001800  002008        
001801  002009  //------------------------------------------------------------------//
001802  002010  //        Memory Allocation Function Prototypes
001803  002011  //------------------------------------------------------------------//
001804  002012        
001805  002013  func mem_Alloc("size"), 1;
001806  002014  // Syntax: mem_Alloc(bytesize);
001807  002015  // Usage : myvar := mem_Alloc(100);
001808  002016  // Notes : Allocate a block of memory to pointer myvar
001809  002017  //       : The allocated memory contains garbage but is a fast allocation.
001810  002018  //       : The block must later be released with mem_Free();
001811  002019  //       : returns 0 if function fails
001812  002020        
001813  002021  func mem_AllocV("size"), 1;
001814  002022  // Syntax: mem_AllocV(bytesize);
001815  002023  // Usage : myvar := mem_AllocV(100);
001816  002024  // Notes : Allocate a block of memory to pointer myvar
001817  002025  //       : The block of memory is filled with signature values
001818  002026  //       : the block starts with A5,5A then fills with incrementing
001819  002027  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001820  002028  //       : This can be helpful when debugging
001821  002029  //       : The block must later be released with mem_Free();
001822  002030  //       : returns 0 if function fails
001823  002031        
001824  002032  func mem_AllocZ("size"), 1;
001825  002033  // Syntax: mem_AllocZ(bytesize);
001826  002034  // Usage : myvar := mem_AllocC(100);
001827  002035  // Notes : Allocate a zeroed block of memory to pointer myvar
001828  002036  //       : The block of memory is filled with zeroes
001829  002037  //       : The block must later be released with mem_Free();
001830  002038  //       : returns 0 if function fails
001831  002039        
001832  002040  func mem_Realloc("ptr", "size"), 1;
001833  002041  // Syntax: myvar := mem_Realloc("ptr", "size");
001834  002042  // Usage : myvar := mem_Realloc(ptr, size);
001835  002043  // Notes : The function may move the memory block to a new location,
001836  002044  //       : in which case the new location is returned.
001837  002045  //       : The content of the memory block is preserved up to the lesser
001838  002046  //       : of the new and old sizes, even if the block is moved.
001839  002047  //       : If the new size is larger, the value of the newly allocated
001840  002048  //       : portion is indeterminate. In case that ptr is NULL,
001841  002049  //       : the function behaves exactly as mem_Alloc, assigning a new block
001842  002050  //       : of size bytes and returning a pointer to the beginning of it.
001843  002051  //       : In case that the size is 0, the memory previously allocated in
001844  002052  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001845  002053  //       : pointer is returned.
001846  002054        
001847  002055  func mem_Free("allocation"), 1;
001848  002056  // Syntax: myvar := mem_Free(allocation);
001849  002057  // Usage : myvar := mem_Free(myvar);
001850  002058  // Notes : De-allocate a block of memory previously created with
001851  002059  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001852  002060  //       : returns 0 if function fails
001853  002061        
001854  002062  func mem_Heap(), 1;
001855  002063  // Syntax: myvar := mem_Heap();
001856  002064  // Usage : myvar := mem_Heap();
001857  002065  // Notes : returns bytecount available in heap
001858  002066  //       :
001859  002067        
001860  002068  func mem_Set("ptr","char","size"), 1;
001861  002069  // Syntax: mem_Set(ptr,char,bytesize);
001862  002070  // Usage : mem_Set(p, 'A', 100);
001863  002071  // Notes : fill a block of memory with a byte value
001864  002072  //       : returns ptr
001865  002073        
001866  002074  func mem_Copy("src", "dest", "bytecount"), 1;
001867  002075  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001868  002076  // Usage : myvar := mem_Copy(p1, p2, 100);
001869  002077  // Notes : copy a word aligned block of memory from src to dest
001870  002078  //       : Note that count is a byte count, this facilitates
001871  002079  //       : copying word aligned byte arrays when using word
001872  002080  //       : aliggned packed strings.
001873  002081  //       : returns src
001874  002082        
001875  002083  func mem_Compare("ptr1","ptr2","count"), 1;
001876  002084  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001877  002085  // Usage : myvar := mem_Compare(p1, p2, 100);
001878  002086  // Notes : compare blocks of memory at src, dest
001879  002087  //       : returns 0 if we have a match
001880  002088        
001881  002089  //------------------------------------------------------------------//
001882  002090  //        FAT16 Function Prototypes
001883  002091  //------------------------------------------------------------------//
001884  002092        
001885  002093  func file_Error(), 1;
001886  002094  // Syntax: myvar := file_Error();
001887  002095  // Usage : e := file_Error();
001888  002096  // Notes : return the most recent file error.
001889  002097  //       :
001890  002098        
001891  002099  func file_Count("filename"), 1;
001892  002100  // Syntax: count := file_Count("filename");
001893  002101  // Usage : count := file_Count("*.4dg");
001894  002102  // Notes : returns number of files found that match the criteria
001895  002103        
001896  002104  func file_Dir("filename"), 1;
001897  002105  // Syntax: count := file_Dir("filename");
001898  002106  // Usage : count := file_Dir("*.4dg");
001899  002107  // Notes : streams a string of filenames that agree with the search key
001900  002108  //       : returns number of files found that match the criteria
001901  002109        
001902  002110  func file_FindFirst("fname"), 1;
001903  002111  // Syntax: res := file_FindFirst("fname");
001904  002112  // Usage : if (file_FindFirst("*.4xe") ....
001905  002113  // Notes : returns true if at least 1 file exists
001906  002114  //       : that satisfies the file argument.
001907  002115  //       : Wildcards are usually used so if
001908  002116  //       : file_FindFirst returns true, further
001909  002117  //       : tests can be made using file_FindNext();
001910  002118  //       : to find all the files that match the
001911  002119  //       : wildcard class. Note that the stream behaviour
001912  002120  //       : is the same as file_Dir.
001913  002121  //       :
001914  002122        
001915  002123  func file_FindNext(), 1;
001916  002124  // Syntax: res := file_FindNext();
001917  002125  // Usage : while ((file_FindNext()) ....
001918  002126  // Notes : returns true if more file exists
001919  002127  //       : that satisfies the file argument
001920  002128  //       : that was given for  file_FindFirst.
001921  002129  //       : Wildcards must be used for
001922  002130  //       : file_FindFirst, else this function will
001923  002131  //       : always return zero as the only occurence
001924  002132  //       : will have already been found.
001925  002133  //       : Note that the stream behaviour
001926  002134  //       : is the same as file_Dir.
001927  002135  //       :
001928  002136        
001929  002137  func file_Exists("fname"), 1;
001930  002138  // Syntax: res := file_Exists("fname"),
001931  002139  // Usage : if(file_Exists("myfile") ....
001932  002140  // Notes : returns true if file exists
001933  002141  //       :
001934  002142        
001935  002143  func file_Open("fname", "mode"), 1;
001936  002144  // Syntax: handle := file_Open("fname","mode"),
001937  002145  // Usage : handle := file_Open("myfile.txt", 'r');
001938  002146  // Notes : returns handle if file exists
001939  002147  //       :
001940  002148        
001941  002149  func file_Close("handle"), 1;
001942  002150  // Syntax: res := file_Close("handle");
001943  002151  // Usage : res := file_Close(hnd1);
001944  002152  // Notes : returns true if file closed ok
001945  002153  //       :
001946  002154        
001947  002155  func file_Read("*dest", "size", "handle"), 1;
001948  002156  // Syntax: res := file_Read("*dest", "size", "handle"),
001949  002157  // Usage : res := file_Read(memblock,20,hnd1);
001950  002158  // Notes : returns number of characters read
001951  002159  //       : if "dest" is zero, data is read direct to GRAM window
001952  002160  //       :
001953  002161        
001954  002162        
001955  002163  func file_Seek("handle", "HiWord", "LoWord"), 1;
001956  002164  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
001957  002165  // Usage : res := file_Seek(hSource, 0, 0x1234);
001958  002166  // Notes : set file position to 0x00001234 (byte position 4660)
001959  002167  //       : for the file handle so subsequent data may be read
001960  002168  //       : from that position onwards with file_GetC(...),
001961  002169  //       : file_GetW(...) or file_GetS(...), or an image
001962  002170  //       : can be displayed with file_Image(...)
001963  002171  // Notes : returns true if ok, usually ignored
001964  002172        
001965  002173  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001966  002174  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001967  002175  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
001968  002176  // Notes : set file seek position to 123000
001969  002177  //       : for the file handle so subsequent data may be read
001970  002178  //       : from that record position onwards with file_GetC(...),
001971  002179  //       : file_GetW(...) or file_GetS(...), or an image
001972  002180  //       : can be displayed with file_Image(...)
001973  002181  // Notes : returns true if ok, usually ignored
001974  002182        
001975  002183  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
001976  002184  // Syntax: file_Tell("handle", &HiWord, &LoWord);
001977  002185  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
001978  002186  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
001979  002187  //       : returns true if function succeeded
001980  002188        
001981  002189  func file_Write("*source", "size", "handle"), 1;
001982  002190  // Syntax: res := fwrite("*source", "size", "handle"),
001983  002191  // Usage : res := fwrite(memblock, 20, hnd1);
001984  002192  // Notes : returns number of bytes written
001985  002193  //       :
001986  002194        
001987  002195  func file_Size("handle", "&HiWord", "&LoWord"), 1;
001988  002196  // Syntax: file_Size("handle", &HiWord, &LoWord);
001989  002197  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
001990  002198  // Notes : Reads the 32 bit file size and stores it into 2 variables.
001991  002199  //       : returns true if function succeeded
001992  002200        
001993  002201  func file_Image("x", "y", "handle"), 1;
001994  002202  // Syntax: file_Image(x, y, handle);
001995  002203  // Usage : file_Image(10, 10, hnd1);
001996  002204  // Notes : Display an image from a file at the current file position.
001997  002205  //       : The image is displayed at x,y (with respect to top left corner).
001998  002206  //       : If there is more than 1 image in the file, it can be
001999  002207  //       : accessed with file_Seek(...)
002000  002208        
002001  002209  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002002  002210  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002003  002211  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002004  002212  // Notes : Save a image from screen to file at the current file position.
002005  002213  //       : The image can later be displayed with file_Image(...);
002006  002214  //       : The file may be opened in append mode to accumulate multiple
002007  002215  //       : images. Later, the images can be accessed with file_Seek(...);
002008  002216  //       : Note that the image will be sector aligned.
002009  002217  //       : All image headers must start on a sector boundary.
002010  002218  //       : The image is saved from x, y (with respect to top left corner)
002011  002219  //       : and the capture area is determined by "width" and "height".
002012  002220  //       : returns 0 if function succeeded
002013  002221        
002014  002222  func file_PutC("char","handle"), 1;
002015  002223  // Syntax: file_PutC("char", "handle");
002016  002224  // Usage : file_PutC('x', hndl);
002017  002225  // Notes : returns true if function succeeded
002018  002226        
002019  002227  func file_GetC("handle"), 1;
002020  002228  // Syntax: file_GetC("handle");
002021  002229  // Usage : mychar := fgetC("handle");
002022  002230  // Notes : returns next char from file
002023  002231        
002024  002232  func file_PutW("word","handle"), 1;
002025  002233  // Syntax: file_PutW("word","handle");
002026  002234  // Usage : file_PutW(0x1234, hndl);
002027  002235  // Notes : returns true if function succeeded
002028  002236        
002029  002237  func file_GetW("handle"), 1;
002030  002238  // Syntax: file_GetW("handle");
002031  002239  // Usage : myword := fgetW("handle");
002032  002240  // Notes : returns next word in file
002033  002241        
002034  002242  func file_PutS("*source", "handle"), 1;
002035  002243  // Syntax: res := file_Puts("*source", "handle"),
002036  002244  // Usage : res := file_Puts(mystring, hnd1);
002037  002245  // Notes : returns number of characters written
002038  002246  //       :
002039  002247        
002040  002248  func file_GetS("*string", "size", "handle"), 1;
002041  002249  // Syntax: res := file_Gets("*string", "size", "handle");
002042  002250  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002043  002251  // Notes : get a string from a file
002044  002252  //       : returns pointer to string or null if failed.
002045  002253  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002046  002254  //       : NB:- only reads up to "size-1" characters into "string"
002047  002255  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002048  002256  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002049  002257  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002050  002258  //       : C] It reaches the end of file
002051  002259  //       : D] A read error occurs.
002052  002260        
002053  002261        
002054  002262  func file_Erase("fname"), 1;
002055  002263  // Syntax: res := file_Erase("fname");
002056  002264  // Usage : res := file_Erase("myfile.txt");
002057  002265  // Notes : returns true if successful
002058  002266  //       :
002059  002267        
002060  002268  func file_Rewind("handle"), 1;
002061  002269  // Syntax: res := file_Rewind("handle");
002062  002270  // Usage : res := file_Rewind(hnd1);
002063  002271  // Notes : returns true if file rewound ok (usually ignored)
002064  002272  //       : resets the file pointer the the beginning of the open file.
002065  002273        
002066  002274  func file_LoadFunction("fname.4xe"), 1;
002067  002275  // Syntax: res := file_LoadFunction("fname.4fn");
002068  002276  // Usage : myfunc := file_LoadFunction(myfuncname);
002069  002277  // Notes : Load a function or program from disk and
002070  002278  //       : return a function pointer to the allocation.
002071  002279  //       : The function can then be invoked just like any other
002072  002280  //       : function would be called via a function pointer.
002073  002281  //       : Parameters may be passed to it in a conventional way.
002074  002282  //       : The function may be discarded at any time when no
002075  002283  //       : longer required, thus freeing its memory resources.
002076  002284  //       : The loaded function can be discarded with mem_Free(..)
002077  002285  //       : eg:
002078  002286  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002079  002287  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002080  002288  //       : then elsewhere in your program:-
002081  002289  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002082  002290  //       : if(res == QUIT_APPLICATION) goto exitApp;
002083  002291  //       : Later in your program, when popupWindow is no longer
002084  002292  //       : required for the application:-
002085  002293  //       : res := mem_Free(popupWindow);
002086  002294  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002087  002295  //       : The callers stack is shared by the loaded function,
002088  002296  //       : however any global variables in the loaded function
002089  002297  //       : are private to that function.
002090  002298  //
002091  002299        
002092  002300  func file_Run("fname.4xe", "arglistptr"), 1;
002093  002301  // Syntax: res := file_Run("fname.4xe","arglistptr");
002094  002302  // Usage : res := file_Run(fname, argptr);
002095  002303  // Notes : current program releases any allocated memory but
002096  002304  //       : retains the stack and global memory.
002097  002305  //       : If arglistptr is 0, no arguments are passed, else
002098  002306  //       : arglist points to an array, the first element being
002099  002307  //       : the number of elements in the array.
002100  002308  //       : func 'main' in the called program accepts
002101  002309  //       : the arguments, if any. THe arguments can only
002102  002310  //       : be passed by value, no pointers or references can be
002103  002311  //       : used as all memory is cleared before the file
002104  002312  //       : is loaded. Refer to file_Exec and file_LoadFunction
002105  002313  //       : for functions that can pass by reference.
002106  002314        
002107  002315  func file_Exec("fname.4xe", "arglistptr"), 1;
002108  002316  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002109  002317  // Usage : res := file_Exec("fname.4xe","arglistptr");
002110  002318  // Notes : returns like a function, current program
002111  002319  //       : calling program is kept active and control returns to it.
002112  002320  //       : If arglistptr is 0, no arguments are passed, else
002113  002321  //       : arglist points to an array, the first element being
002114  002322  //       : the number of elements in the array.
002115  002323  //       : func 'main' in the called program accepts the arguments.
002116  002324  //       : This function is similar to file_LoadFunction(...), however,
002117  002325  //       : the function argument list is passed by pointer, and
002118  002326  //       : the memory consumed by the function is released as
002119  002327  //       : soon as the function completes.
002120  002328        
002121  002329  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002122  002330  // Syntax	: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002123  002331  // Usage	: hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002124  002332  // Notes	: Reads a control file to create an image list.
002125  002333  // 	: Returns NULL if function fails.
002126  002334  // 	: Returns a handle (pointer to the memory allocation) to the
002127  002335  // 	: image control list that has been created.
002128  002336  // 	: "fname1" is the control list filename "*.dat"
002129  002337  // 	: "fname2" is the image filename "*.gci"
002130  002338  // 	: "mode" is 0 for FAT based GCI and DAT with quick load and slower for each display
002131  002339  // 	: "mode" is 1 for FAT based GCI and DAT with slower load and faster for each display
002132  002340  // 	: "mode" is 2 for FAT based DAT with RAW GCI
002133  002341  // 	: "mode" is 3 for Flash based 'file system' GCI (GCIF) with itegerated DAT and other file types
002134  002342  // 	: "fname1" and "fname2" are then the Flash high and low words of the GFIC start location.
002135  002343        
002136  002344  // Notes : This function Calculates the size of a chunk of memory required for
002137  002345  //       : a image list and populates it from the image control file ("*.dat")
002138  002346  //       : therefore, when imagelist is no longer required, you must de-allocate
002139  002347  //       : the image list memory by using eg:- mem_Free(hImagelist);
002140  002348  //       : to restore the heap.
002141  002349  //       :
002142  002350  //       : mode 0:- it is assumed that there is a graphics file with the
002143  002351  //       : file extension "fname2.gci". In this case, the images have been stored
002144  002352  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002145  002353  //       : "fname1.dat" file are saved in the image control so that the image control
002146  002354  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002147  002355  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002148  002356  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002149  002357  //       : for the file offsets and save them in the relevant entries in the image control.
002150  002358  //       : The penalty is that images take longer to find when displayed due to file_Seek
002151  002359  //       : overheads.
002152  002360  //
002153  002361  //       : mode 1:- it is assumed that there is a graphics file with the
002154  002362  //       : file extension "fname2.gci". In this case, the images have been stored
002155  002363  //       : in a FAT16 file concurrently, and the offset of the images are saved
002156  002364  //       : in the image control so that image file (*.gci) can be mapped to directly.
002157  002365  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002158  002366  //       : internally. This means that there is no seek time penalty, however, the
002159  002367  //       : image list takes a lot longer to build, as all the seeking is done at control
002160  002368  //       : build time.
002161  002369        
002162  002370  //       : mode 2:- the graphics file with the is placed in a partitioned area
002163  002371  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002164  002372  //       : disk, and the absolute address of the images are saved in the DAT file
002165  002373  //       : This is the fastest operation of the image control as there is no seeking
002166  002374  //       : or other disk activity taking place.
002167  002375        
002168  002376  func file_Mount(), 1;
002169  002377  // Syntax: r := file_Mount();
002170  002378  // Usage : r := file_Mount();
002171  002379  // Notes : Create a control block for FAT16 and mount the File System
002172  002380        
002173  002381  func file_Unmount(), 0;
002174  002382  // Syntax: file_Unmount();
002175  002383  // Usage : file_Unmount();
002176  002384  // Notes : release any control block and buffers for FAT16
002177  002385  //       : and unmount the File System
002178  002386        
002179  002387  func file_PlayWAV("fname1"), 1;
002180  002388  // Syntax: file_PlayWAV("fname1");
002181  002389  // Usage : file_PlayWAV("ding.wav");
002182  002390  // Notes : Play a wave file with filename "fname1"
002183  002391  //       : This function automatically grabs a chunk
002184  002392  //       : of memory for a file buffer, and a wave
002185  002393  //       : buffer. The minimum memory requirement is
002186  002394  //       : about 580 bytes for the disk io service and
002187  002395  //       : a minimum wave buffer size of 1024. The siz
002188  002396  //       : of the wave buffer allocation
002189  002397  //       : can be increased by the snd_BufSize function.
002190  002398  //       : The default size 1024 bytes.
002191  002399  //       : NB the memory is only required during the
002192  002400  //       : duration of play, and is automatically
002193  002401  //       : released while not in use.
002194  002402  //       : See the Sound Class services for other associated controls.
002195  002403  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002196  002404  //       : If errors occured, the folling is returned
002197  002405  //       : -7  : Insufficient memory available for WAV buffer and file
002198  002406  //       : -6  : cant play this rate
002199  002407  //       : -5  : no data chunk found in first rsector
002200  002408  //       : -4  : no format data
002201  002409  //       : -3  : no wave chunk signature
002202  002410  //       : -2  : bad wave file format
002203  002411  //       : -1  : file not found
002204  002412        
002205  002413        
002206  002414        
002207  002415  //------------------------------------------------------------------//
002208  002416  //        Sound Class Services
002209  002417  //------------------------------------------------------------------//
002210  002418        
002211  002419  func snd_Volume("var"), 0;
002212  002420  // Syntax: snd_Volume("var");
002213  002421  // Usage : snd_Volume(30);
002214  002422  // Notes : set sound playback volume.  Var must
002215  002423  //       : be in the range from 8 (min volume)
002216  002424  //       : to 127 (max volume). If var is less
002217  002425  //       : than 8 volume is set to 8, and if
002218  002426  //       : var > 127 it is set to 127.
002219  002427        
002220  002428  func snd_Pitch("pitch"), 1;
002221  002429  // func snd_Pitch("freq"), 1;
002222  002430  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002223  002431  // Notes : sets the samples playback rate to a different frequency
002224  002432  //       : The minimum value is 4khz
002225  002433  //       : Setting the pitch to zero restores the original sample rate
002226  002434  //       : Return value is the samples original sample rate.
002227  002435        
002228  002436  func snd_BufSize("var"), 0;
002229  002437  // Syntax: snd_BufSize("var");
002230  002438  // Usage : snd_BufSize(2);
002231  002439  // Notes : specify the a memory chunk size for the wavefile buffer.
002232  002440  //       : default size 1024 bytes.
002233  002441  //       : 0 = 1024 bytes (default)
002234  002442  //       : 1 = 2048 bytes
002235  002443  //       : 2 = 4096 bytes
002236  002444  //       : 3 = 8192 bytes
002237  002445        
002238  002446  func snd_Stop(), 0;
002239  002447  // Syntax: snd_Stop();
002240  002448  // Usage : snd_Stop();
002241  002449  // Notes : stop any sound that is playing, releasing
002242  002450  //       : buffers and closes any open wav file.
002243  002451        
002244  002452  func snd_Pause(), 0;
002245  002453  // Syntax: snd_Pause();
002246  002454  // Usage : snd_Pause();
002247  002455  // Notes : pauses any sound that is playing, does nothing
002248  002456  //       : until sound is resumed with snd_Continue().
002249  002457  //       : The sample cam be terminated with snd_Stop.
002250  002458  //       : buffers and closes any open wav file.
002251  002459        
002252  002460  func snd_Continue(), 0;
002253  002461  // Syntax: snd_Continue();
002254  002462  // Usage : snd_Continue();
002255  002463  // Notes : resume any sound that is paused by snd_Pause.
002256  002464        
002257  002465  func snd_Playing(), 1;
002258  002466  // Syntax: snd_Playing();
002259  002467  // Usage : r := snd_Playing();
002260  002468  // Notes : returns 0 if sound has finished playing,
002261  002469  //       : else return number of 512 byte blocks to go.
002262  002470        
002263  002471        
002264  002472        
002265  002473  //------------------------------------------------------------------//
002266  002474  //        String Class Services
002267  002475  //------------------------------------------------------------------//
002268  002476        
002269  002477  func str_Ptr("&var"), 1;
002270  002478  // Syntax: str_Ptr(&var);
002271  002479  // Usage : p := str_Ptr(&var);
002272  002480  // Notes : return a byte pointer to a word region
002273  002481        
002274  002482  func str_GetD("&ptr", "&var"), 1;
002275  002483  // Syntax: str_GetD(&ptr, &var);
002276  002484  // Usage : ok := str_GetD(&ptr, &var);
002277  002485  // Notes : convert number in a string to DWORD ( myvar[2] )
002278  002486  //       : returns true if function succeeds, advancing ptr
002279  002487        
002280  002488  func str_GetW("&ptr", "&var"), 1;
002281  002489  // Syntax: str_GetW(&ptr, &var);
002282  002490  // Usage : ok := str_GetW(&ptr, &var);
002283  002491  // Notes : convert number in a string to WORD ( myvar )
002284  002492  //       : returns true if function succeeds, advancing ptr
002285  002493        
002286  002494  func str_GetHexW("&ptr", "&var"), 1;
002287  002495  // Syntax: str_GetHexW(&ptr, &var);
002288  002496  // Usage : ok := str_GetHexW(&ptr, &var);
002289  002497  // Notes : convert HEX number in a string to WORD ( myvar )
002290  002498  //       : returns true if function succeeds, advancing ptr
002291  002499        
002292  002500  func str_GetC("&ptr", "&var"), 1;
002293  002501  // Syntax: str_GetC(&ptr, &var);
002294  002502  // Usage : ok := str_GetC(&ptr, &var);
002295  002503  // Notes : get a valid ascii char in a string to WORD ( myvar )
002296  002504  //       : returns true if function succeeds, advancing ptr
002297  002505        
002298  002506  func str_GetByte("ptr"), 1;
002299  002507  // Syntax: str_GetByte(ptr);
002300  002508  // Usage : myvar := str_GetByte(ptr);
002301  002509  // Notes : get a byte to myvar
002302  002510  //       : returns value
002303  002511        
002304  002512  func str_GetWord("ptr"), 1;
002305  002513  // Syntax: GetWord(ptr);
002306  002514  // Usage : GetWord(ptr);
002307  002515  // Notes : get a word to myvar
002308  002516  //       : returns value
002309  002517        
002310  002518  func str_PutByte("ptr","val"), 0;
002311  002519  // Syntax: str_PutByte(ptr);
002312  002520  // Usage : myvar := str_PutByte(ptr);
002313  002521  // Notes : put a byte at ptr
002314  002522  //       : returns value
002315  002523        
002316  002524  func str_PutWord("ptr","val"), 0;
002317  002525  // Syntax: str_PutWord("ptr","val");
002318  002526  // Usage : str_PutWord(p,100);
002319  002527  // Notes : put word 100 at current pointer location
002320  002528  //       : returns value
002321  002529        
002322  002530  func str_Match("&ptr", "*str"), 1;
002323  002531  // Syntax: str_Match(&ptr, *str);
002324  002532  // Usage : r := str_Match(&p, "hello");
002325  002533  // Notes : Case sensitive match
002326  002534  //       : returns true if function succeded, andvancing pointer to position past
002327  002535  //       : the matched item. Note that any whitespace characters are skipped
002328  002536  //       : in the source string prior to the test.
002329  002537        
002330  002538  func str_MatchI("&ptr", "*str"), 1;
002331  002539  // Syntax: str_MatchI(&ptr, *str);
002332  002540  // Usage : r := str_MatchI(&p, "hello");
002333  002541  // Notes : Case insensitive match
002334  002542  //       : returns true if function succeded, andvancing pointer to position past
002335  002543  //       : the matched item. Note that any whitespace characters are skipped
002336  002544  //       : in the source string prior to the test.
002337  002545        
002338  002546  func str_Find("&ptr", "*str"), 1;
002339  002547  // Syntax: str_Find(&ptr, *str);
002340  002548  // Usage : n := str_Find(&p, "hello");
002341  002549  // Notes : given the address of a pointer to a source string as the
002342  002550  //       : first argument, and a pointer to a test string as the second
002343  002551  //       : argument, attempt to find the position of the matching string
002344  002552  //       : in the source string. The test is performed with case sensitivity.
002345  002553  //       : return 0 if not found, else returns the address of the first
002346  002554  //       : character of the match. NB:- The source pointer is not altered.
002347  002555        
002348  002556  func str_FindI("&ptr", "*str"), 1;
002349  002557  // Syntax: str_Find(&ptr, *str);
002350  002558  // Usage : n := str_Find(&p, "hello");
002351  002559  // Notes : given the address of a pointer to a source string as the
002352  002560  //       : first argument, and a pointer to a test string as the second
002353  002561  //       : argument, attempt to find the position of the matching string
002354  002562  //       : in the source string. The test is performed with no case
002355  002563  //       : sensitivity, eg upper and lower case chars are accepted.
002356  002564  //       : return 0 if not found, else returns the address of the first
002357  002565  //       : character of the match. NB:- The source pointer is not altered.
002358  002566        
002359  002567  func str_Length("ptr"), 1;
002360  002568  // Syntax: str_Length(ptr);
002361  002569  // Usage : len := str_Ptr(mystring);
002362  002570  // Notes : return the length of a byte aligned string excluding terminator
002363  002571        
002364  002572  func str_Printf("&ptr", "*format"), 1;
002365  002573  // Syntax: str_Printf("&ptr", "*format");
002366  002574  // Usage : r := str_Printf(&p, "%8s");
002367  002575  // Notes : refer to documentation
002368  002576  //       :
002369  002577        
002370  002578  func str_Cat("dest","src"), 1;
002371  002579  // Syntax: str_Append("&dest","&src");
002372  002580  // Usage : str_Append(&buf,"Hello");
002373  002581  // Notes : Appends a copy of the source string to the destination string.
002374  002582  //       : The terminating null character in destination is overwritten by
002375  002583  //       : the first character of source, and a new null-character is appended
002376  002584  //       : at the end of the new string formed by the concatenation of both in destination.
002377  002585  //       : returns destination.
002378  002586        
002379  002587  func str_CatN("dest","src","count"), 1;
002380  002588  // Syntax: str_Append("&dest","&src","count");
002381  002589  // Usage : str_Append(&buf,"Monday",3);
002382  002590  // Notes : Appends a copy of the source string to the destination string.
002383  002591  //       : The number of characters copied is limited by "count".
002384  002592  //       : The terminating null character in destination is overwritten by
002385  002593  //       : the first character of source, and a new null-character is appended
002386  002594  //       : at the end of the new string formed by the concatenation of both in destination.
002387  002595  //       : returns destination.
002388  002596        
002389  002597        
002390  002598  func sys_StoreTouchCalibration(), 1;
002391  002599  // Syntax: sys_StoreTouchCalibration();
002392  002600  // Usage : r := sys_StoreTouchCalibration();
002393  002601  // Notes : Store the touch calibration values in non-volatile memory.
002394  002602  //       : Returns true if the values have been accepted and stored,
002395  002603  //       : else returns false if write could not be performed, or
002396  002604  //       : touch calibration values are improbable.
002397  002605  //       : The values that are stored are obtained from:-
002398  002606  //     : TOUCH_XMINCAL             78  // touch calibration value
002399  002607  //     : TOUCH_YMINCAL             79  // touch calibration value
002400  002608  //       : TOUCH_XMAXCAL             80  // touch calibration value
002401  002609  //       : TOUCH_YMAXCAL             81  // touch calibration value
002402  002610  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002403  002611  //       : This function is not supported on uVGA, Capicitive touch
002404  002612  //       : and 4.3" resistive touch modules.
002405  002613        
002406  002614        
002407  002615  func unicode_page("charbeg","charend","charoffset"), 1;
002408  002616  // Syntax: unicode_page("charbeg","charend","charoffset");
002409  002617  // Usage : eg:  F_Traditional_0x20_0xFF
002410  002618  // Notes : After selecting a unicode image control with txt_FontID,
002411  002619  //       : this function is called to set the required font within the
002412  002620  //       : unicode set. The file "Unicode.inc" contains wrappers for
002413  002621  //       : this function, and it is not normally called directly.
002414  002622  //       : Returns count of characters in the set.
002415  002623  //       : Refer to "Unicode.inc" for further information.
002416  002624        
002417  002625        
002418  002626  func EVE_SP(), 1;
002419  002627  // Syntax: EVE_SP();
002420  002628  // Usage : eg:  print(EVE_SP());
002421  002629  // Notes : Used for debugging to assess the current stack level,
002422  002630  //       : mainly for checking stack leaks
002423  002631        
002424  002632  func EVE_SSIZE(), 1;
002425  002633  // Syntax: EVE_SSIZE();
002426  002634  // Usage : eg:  print(EVE_SSIZE());
002427  002635  // Notes : Used to get the stack size,
002428  002636  //       : mainly for debugging purposes
002429  002637        
002430  002638        
002431  002639  // uVGAII extended functions
002432  002640  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002433  002641  // Syntax: disp_Sync(line);
002434  002642  // Usage : disp_Sync(480);
002435  002643  // Notes : Waits till the hardware gets to a certain line.
002436  002644  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002437  002645  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002438  002646  //       : depending on the graphics operation. The higher the value, the slower
002439  002647  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002440  002648  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002441  002649  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002442  002650  //       : be slowest (as its actually right at the end of the blanking period) and 508
002443  002651  //       : will cause a hangup situation as it is above the highes scanline value.
002444  002652  //       : Currently, this function is only supported on displays with SSD1963 driver.
002445  002653        
002446  002654        
002447  002655  // New functions added to PmmC v2.8
002448  002656  //================================================================
002449  002657  func CY(), 1;
002450  002658  // Syntax: CY();
002451  002659  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002452  002660  //       : print(myvar," "CY(),"\n");           // carry = 1
002453  002661  // Notes : This function returns the carry status of an
002454  002662  // unsigned overflow from any 16 or 32bit additions or sutractions.
002455  002663  //================================================================
002456  002664        
002457  002665        
002458  002666  //================================================================
002459  002667  func str_ByteMove("src", "dest", "count"), 1;
002460  002668  // func str_ByteMove("src", "dest", "count"), 1;
002461  002669  // Syntax   : str_ByteMove(src, dest, bytecount);
002462  002670  // Input    : STR *source points to byte aligned source.
002463  002671  //          : STR *dest   points to byte aligned destination.
002464  002672  //          : VAR count   number of bytes to transfer.
002465  002673  // Usage    : nextpos := str_ByteMove(s, d, 100);
002466  002674  // Notes    : copy bytes from "src" to "dest", stopping only
002467  002675  //          : when "count" is exhausted.
002468  002676  //          : No terminator is appended, it is purely a
002469  002677  //          : byte copy, and any zeroes encountered will
002470  002678  //          : also be copied.
002471  002679  // Returns  : returns a pointer to the end of the destination
002472  002680  //          : (which is "dest" + "count")
002473  002681  //================================================================
002474  002682        
002475  002683        
002476  002684  //================================================================
002477  002685  func str_Copy("dest", "src"), 1;
002478  002686  // Syntax   : str_Copy(dest, src);
002479  002687  // Input    : STR *dest   points to byte aligned destination.
002480  002688  //          : STR *source points to byte aligned source.
002481  002689  // Usage    : nextplace := str_Copy(d, s);
002482  002690  // Notes    : copy a string from "src" to "dest", stopping only
002483  002691  //          : when the end of source string "src" is encountered
002484  002692  //          : (0x00 terminator).
002485  002693  //          : The terminator is always appended, even if "src" is
002486  002694  //          : an empty string.
002487  002695  // Returns  : returns a pointer to the 0x00 string terminator at
002488  002696  //          : end of "dest" (which is "dest" + str_Length(src); )
002489  002697  //================================================================
002490  002698        
002491  002699  //================================================================
002492  002700  func str_CopyN("dest", "src", "count"), 1;
002493  002701  // Syntax   : str_CopyN(dest, src, bytecount);
002494  002702  // Input    : STR *dest   points to byte aligned destination.
002495  002703  //          : STR *source points to byte aligned source.
002496  002704  //          : VAR count   max number of chars to copy.
002497  002705  // Usage    : nextplace := str_CopyN(d, s, 100);
002498  002706  // Notes    : copy a string from "src" to "dest", stopping only
002499  002707  //          : when "count" is exhausted, or end of source
002500  002708  //          : string "str" is encountered (0x00 string terminator).
002501  002709  //          : The terminator is always appended, even if
002502  002710  //          : "count" is zero, or "src" is a null string.
002503  002711  // Returns  : returns a pointer to the 0x00 string terminator
002504  002712  //          : (which is "dest" + whatever was copied)
002505  002713  //================================================================
002506  002714        
002507  002715  //================================================================
002508  002716  func umul_1616("&res32", "val1", "val2"), 1;
002509  002717  // Syntax   : umul_1616(&res32, varA, varB);
002510  002718  // Input    : DWORD *result   points to 32bit result register.
002511  002719  //          : VAR   val1  16bit register or constant
002512  002720  //          : VAR   val2  16bit register or constant
002513  002721  // Usage    : var res32[2];
002514  002722  //          : umul_1616(&res32, myvar, 50000);
002515  002723  // Notes    : performs an unsigned multiply of 2 x 16bit values
002516  002724  //          : placing the 32bit result in a 2 word array.
002517  002725  // Returns  : the pointer to the 32bit result.
002518  002726  //          : carry and overflow are not affected.
002519  002727  //================================================================
002520  002728        
002521  002729  //================================================================
002522  002730  func uadd_3232("&res32", "&val1", "&val2"), 1;
002523  002731  // Syntax   : cmp_3232(&res32, &varA, &varB);
002524  002732  // Input    : DWORD *res32 points to optional result (or zero for compare)
002525  002733  //          : DWORD *val1 points to 32bit augend
002526  002734  //          : DWORD *val2 points to 32bit addend
002527  002735  // Usage    : var res32[2];
002528  002736  //          : res := cmp_3232(res32, val1, val2);
002529  002737  // Notes    : performs an unsigned addition of 2 x 32bit values
002530  002738  //          : placing the 32bit result in a 2 word array.
002531  002739  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002532  002740  //          ; carry flag is also set on 32bit unsigned overflow
002533  002741  //          ; and can be read with the CY() function.
002534  002742  //================================================================
002535  002743        
002536  002744  //================================================================
002537  002745  func usub_3232("&res32", "&val1", "&val2"), 1;
002538  002746  // Syntax   : cmp_3232(&res32, &varA, &varB);
002539  002747  // Input    : DWORD *res32 points to optional result (or zero for compare)
002540  002748  //          : DWORD *val1 points to first 32bit minuend
002541  002749  //          : DWORD *val2 points to 32bit subtrahend
002542  002750  // Usage    : var res32[2];
002543  002751  //          : res := cmp_3232(res32, val1, val2);
002544  002752  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002545  002753  //          : placing the 32bit result in a 2 word array.
002546  002754  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002547  002755  //          ; carry flag is also set on 32bit unsigned underflow
002548  002756  //          ; and can be read with the CY() function.
002549  002757  //================================================================
002550  002758        
002551  002759  //================================================================
002552  002760  func ucmp_3232("&val1", "&val2"), 1;
002553  002761  // Syntax   : cmp_3232(&varA, &varB);
002554  002762  // Input    : DWORD *val1 points to 32bit minuend
002555  002763  //          : DWORD *val2 points to 32bit sutrahend
002556  002764  // Usage    : res := cmp_3232(val1, val2);
002557  002765  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002558  002766  //          : The result of the subtraction is returned.
002559  002767  // Returns  : 0  if equal
002560  002768  //          : 1  if val1 > val2
002561  002769  //          : -1 if val1 < val2
002562  002770  //          : This function does not affect the carry flag.
002563  002771  //================================================================
002564  002772        
002565  002773  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002566  002774  // Syntax: disp_Disconnect();                  New in v3.8
002567  002775  // Usage : disp_Disconnect();
002568  002776  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002569  002777  //       : its lowest possible power consumption. Use after disabling peripheral power
002570  002778  //       : to ensure the minimal power usage by the display.
002571  002779  //       : disp_Init() should be used to reinitialise the display.
002572  002780        
002573  002781  func reserved(), 0;                            
002574  002782        
002575  002783  func sys_DeepSleep("units"), 1;
002576  002784  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002577  002785  // Usage : t := sys_DeepSleep(10);
002578  002786  // Notes : sets the display and processor into lowest power mode for a period of time.
002579  002787  //       : When returning from DeepSleep the display should be reinitialised
002580  002788  //       : with disp_Init().
002581  002789  //       : Touching the touch screen will also wake from sleep.
002582  002790  //       : Returns remaining sleep units.
002583  002791        
002584  002792  func sys_PmmC(), 1;
002585  002793  // Syntax: sys_PmmC();
002586  002794  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer, new in v4.6
002587  002795  // Notes : print the system PmmC name and revision eg "Picaso\n4.6"
002588  002796  //       : Can be captured to a buffer using the to( function
002589  002797  //       : Returns PmmC version as a hex number, eg 0x46
002590  002798        
002591  002799  func sys_Driver(), 0;
002592  002800  // Syntax: sys_Driver();
002593  002801  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer, new in v4.6
002594  002802  // Notes : print the system PmmC name and revision eg "uLCD-32PTU"
002595  002803  //       : Can be captured to a buffer using the to( function
002596  002804  //       : Returns nothing.
002597  002805        
002598  002806  func OW_Reset("pin"), 1;                             // issue 1wire reset command
002599  002807  // Syntax   : OW_Reset(PA0);
002600  002808  // Usage    : OW_Reset(PA0);
002601  002809  // Notes    : Only available on PA0 to PA13
002602  002810  //          : Resets  ONEWIRE device
002603  002811  //          : Returns the status, 0 = ACK.
002604  002812  //          :
002605  002813        
002606  002814  func OW_Read("pin"), 1;                              // read data from 1wire bus
002607  002815  // Syntax   : OW_Read(PA0);
002608  002816  // Usage    : arg1 := OW_Read(PA0);
002609  002817  // Notes    : Only available on PA0 to PA13
002610  002818  //          : Reads value of the ONEWIRE pin
002611  002819  //          : that was previously selected for ONEWIRE comms.
002612  002820  //          :
002613  002821  //          : pin = 0 : the next byte from the ONEWIRE bus
002614  002822        
002615  002823  func OW_Read9("pin"), 1;                             // read data from 1wire bus, 9bit mode
002616  002824  // Syntax   : OW_Read9(PA0);
002617  002825  // Usage    : OW_Read9(PA0);
002618  002826  // Notes    : Only available on PA0 to PA13
002619  002827  //          : Reads 9 bit value of the appropriate ONEWIRE pin
002620  002828  //          : that was previously selected for ONEWIRE comms.
002621  002829  //          :
002622  002830  //          : read the 9 bits from the ONEWIRE bus
002623  002831        
002624  002832  func OW_Write("pin", "value"), 0;                      // write value to 1wire device
002625  002833  // Syntax   : OW_Write(PA0, arg);
002626  002834  // Usage    : OW_Write(PA0, arg);
002627  002835  // Notes    : Only available on PA0 to PA13
002628  002836  //          : Sends ONEWIRE data on the appropriate
002629  002837  //          : pin that was previously  selected as ONEWIRE comms.
002630  002838  //          :
002631  002839  //          : write arg to the ONEWIRE bus
002632  002840        
002633  002841  func snd_Freq("Freq", "Duration"), 1;
002634  002842  // Syntax	: snd_Freq("Freq", "Duration");
002635  002843  // Usage	: r := snd_Freq(1000, 2000);
002636  002844  // Notes	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002637  002845  // 	: else return True.
002638  002846  // 	: Minimum Freq is 20
002639  002847  // 	: This will produce a pure Square wave and is designed for driving
002640  002848  // 	: Piezo transducers which require this sort of drive. It can be used
002641  002849  // 	: directly with high impedience speakers.
002642  002850        
002643  002851  func gfx_SpriteSet("bitmaps", "colours", "palette"), 0;
002644  002852  // Syntax   : gfx_SpriteSet("bitmaps", "colours", "palette");
002645  002853  // Usage    : gfx_SpriteSet(mysprites, mycolours, mypalette);
002646  002854  // Notes    : 3 sets of data are required by the sprite generator,
002647  002855  //          : this function sets the internal pointers for the 3 parts.
002648  002856  //          : 1] the bitmaps for the sprites,
002649  002857  //          : 2] the colour lookup table (CLUT),
002650  002858  //          : 3] the 4 colour palettes.
002651  002859        
002652  002860        
002653  002861  func gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage"), 0;
002654  002862  // Syntax 	: gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage");
002655  002863  // Usage 	: gfx_BlitSprite(1,2,10,10,SOUTH,0);  // example show a cherry upside down using the third palette of mypalette
002656  002864  // Notes 	: Places the required sprite bitmap at the origin xpos, ypos using the required 4 colour palette.
002657  002865  //  	: orientation determines in which direction the sprite will be displayed.
002658  002866  //    	: if preimage exists it should be large enough to hold the entire image 'underneath' the sprite.
002659  002867        
002660  002868  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
002661  002869  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
002662  002870  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
002663  002871  // Notes   : reads an arbitrary rectangular area from the display to an array.
002664  002872  //         : If "ptr" is 0, the correctly sized array is created, in which case
002665  002873  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
002666  002874  //         : is expected to point to a correctly sized array.
002667  002875  //         : NB if an array is supplied, its size must be large enough, and may
002668  002876  //         : be calculated:-
002669  002877  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
002670  002878  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
002671  002879  // Returns : A pointer to the created aray, or the users array.
002672  002880  //         : In the case of ptr=0, if there is insufficient
002673  002881  //         : memory to create the array, zero is returned
002674  002882        
002675  002883        
002676  002884  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
002677  002885  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
002678  002886  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
002679  002887  // Notes   : "ptr" points to the array to be written.
002680  002888  // Returns : nothing
002681  002889        
002682  002890  func rect_Intersect("&rect1", "&rect2"), 1;
002683  002891  // Syntax   : rect_Intersect(&rect1, &rect2);
002684  002892  // Usage    : rect_Intersect(box1, box2);
002685  002893  // Notes    : return true if any part of rect1 is within rect2
002686  002894  //          : each rectangle is an array of 4 words in the format:-
002687  002895  //	    : element 0 = RECT_LEFT			
002688  002896  //	    : element 1 = RECT_TOP			
002689  002897  //	    : element 2 = RECT_WIDTH 		
002690  002898  //	    : element 3 = RECT_HEIGHT 
002691  002899  //          : This function is ideal for use as a collision detector.		
002692  002900        
002693  002901  func rect_Within("&rect1", "&rect2"), 1;
002694  002902  // Syntax   : rect_Within(&rect1, &rect2);
002695  002903  // Usage    : rect_Within(box1, box2);
002696  002904  // Notes    : return true if rect1 is fully within rect2
002697  002905  //          : each rectangle is an array of 4 words in the format:-
002698  002906  //	    : element 0 = RECT_LEFT			
002699  002907  //	    : element 1 = RECT_TOP			
002700  002908  //	    : element 2 = RECT_WIDTH
002701  002909  //	    : element 3 = RECT_HEIGHT 
002702  002910        
002703  002911  func snd_RTTTL("TunePtr",), 1;                           // play a RTTTL tune string
002704  002912  // Syntax	: snd_RTTTL(TunePtr);
002705  002913  // Usage	: snd_RTTTL("...notes...");
002706  002914  // Notes	: Play an RTTTL tune string from a data statement or a direct string
002707  002915  // 	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002708  002916        
002709  002917  func joystick("Pin"), 1;                                     // read the joystick value
002710  002918  // Syntax   : Joystick("Pin");
002711  002919  // Usage    : var := Joystick(IO1_PIN);
002712  002920  // *Notes   : Returned values are:-
002713  002921  //          :    JOY_RELEASED 0
002714  002922  //          :    JOY_UP       1
002715  002923  //          :    JOY_LEFT     2
002716  002924  //          :    JOY_DOWN     3
002717  002925  //          :    JOY_RIGHT    4
002718  002926  //          :    JOY_BTNB     5
002719  002927  //          :    JOY_BTNA     6
002720  002928        
002721  002929  func gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour"), 0;         // display an Annular ring segment
002722  002930  // Syntax 	: gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour") ;
002723  002931  // Usage 	: gfx_RingSegment(x, y, starta, enda, rx, w, colour) ;
002724  002932  // Notes 	: Draw a Segment of a ring at x, y from rad1 to rad2 starting at starta to enda
002725  002933  // 	: in colour.
002726  002934  //
002727  002935        
002728  002936  func gfx_AngularMeter("value", "&MeterRam", "&MeterDef"), 0;                           // draw an angular meter scale and value
002729  002937  // Syntax 	: gfx_AngularMeter("value", "&MeterRam", "&MeterDef") ;
002730  002938  // Usage 	: gfx_AngularMeter(value, MeterRam, MeterDef) ;
002731  002939  // Notes 	: Draw an Angular Meter as defined by MeterDef (if required), using MeterRam positioning at
002732  002940  // 	: position value. See the reference for the MeterDef values
002733  002941  //
002734  002942        
002735  002943  // AngularMeter constants
002736  002944  #CONST
002737  002995  #END
002738  002996        
002739  002997  #constant PANEL2_FILLED 0x8000
002740  002997  #constant PANEL2_FILLED 0x8000
002741  002998        
002742  002999  func gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf"), 0;                           // draw a windows style 3D panel
002743  003000  // Syntax 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002744  003001  // Usage 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002745  003002  // Notes	: Draws a panel2 (groupbox) at screen location defined by
002746  003003  // 	: x, y, width and height with left colour "cl", right colour "cr" and option fill colour "cf".
002747  003004  // 	:  w1 and w2 define the width of the outer and inner borders.
002748  003005  // 	:         state = 0 : recessed
002749  003006  // 	:         state = 1 : raised
002750  003007  // 	: 	  or state with PANEL2_FILLED to draw the fill
002751  003008        
002752  003009  func gfx_Needle("value", "&NeedleRam", "&NeedleDef"), 0;                           // draw a needle on a meter base
002753  003010  // Syntax 	: gfx_Needle("value", "&NeedleRam", "&NeedleDef") ;
002754  003011  // Usage 	: gfx_Needle(value, NeedleRam, NeedleDef) ;
002755  003012  // Notes 	: Draw a Needle as defined by NeedleDef (if required), using NeedleRam positioning at
002756  003013  // 	: position value. See the reference for the NeedleDef values
002757  003014  //
002758  003015        
002759  003016  #CONST
002760  003038  #END
002761  003039        
002762  003040  #CONST
002763  003047  #END
002764  003048        
002765  003049  func gfx_Dial("value", "&DialRam", "&DialDef"), 0;                           // draw a Dial / knob
002766  003050  // Syntax 	: gfx_Dial("value", "&DialRam", "&DialDef") ;
002767  003051  // Usage 	: gfx_Dial(value, DialRam, DialDef) ;
002768  003052  // Notes 	: Draw a Dial as defined by DialDef (if required), using DialRam positioning at
002769  003053  // 	: position value. See the reference for the DialDef values
002770  003054  //
002771  003055        
002772  003056  #CONST
002773  003114  #END
002774  003115        
002775  003116  func gfx_Gauge("value", "&GaugeRam", "&GaugeDef"), 0;                           // draw a gauge
002776  003117  // Syntax 	: gfx_Gauge("value", "&GaugeRam", "&GaugeDef") ;
002777  003118  // Usage 	: gfx_Gauge(value, GaugeRam, GaugeDef) ;
002778  003119  // Notes 	: Draw a Gauge as defined by GaugeDef (if required), using GaugeRam positioning at
002779  003120  // 	: position value. See the reference for the GaugeDef values
002780  003121  //
002781  003122        
002782  003123  #CONST
002783  003148  #END
002784  003149        
002785  003150  // widget_* functions
002786  003151  //
002787  003152  #CONST
002788  003185  #END
002789  003186        
002790  003187  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
002791  003188  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
002792  003189  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
002793  003190  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
002794  003191  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
002795  003192  //         : to be used for rounded panels, rounded buttons, circular buttons.
002796  003193  //         : "style" specifies the drawing mode
002797  003194  //         :     GRAD_DOWN         // gradient changes in the vertical direction
002798  003195  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
002799  003196  //         :     GRAD_UP           // gradient changes in the vertical direction
002800  003197  //         :     GRAD_LEFT         // gradient change in the horizontal direction
002801  003198  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
002802  003199  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
002803  003200  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
002804  003201  // Returns : nothing.
002805  003202        
002806  003203        
002807  003204  //------------------------------------------------------------------//
002808  003205  //     gradient control constants                                   //
002809  003206  //------------------------------------------------------------------//
002810  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002811  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002812  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002813  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002814  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002815  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002816  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002817  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002818  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002819  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002820  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002821  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002822  003213        
002823  003214  #CONST
002824  003217  #END
002825  003218        
002826  003219  #CONST
002827  003251  #END
002828  003252        
002829  003253  func gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef"), 0;                           // draw a value to a series of 7 segment led Digits
002830  003254  // Syntax 	: gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef");
002831  003255  // Usage 	: gfx_LedDigits(value, LedDigitRam, LedDigitDef);
002832  003256  // Notes 	: Draw a series of 7 segment Led Digits as defined by LedDigitDef, using LedDigitRam positioning at
002833  003257  // 	: position value. See the reference for LedDigitDef values.
002834  003258  //
002835  003259        
002836  003260  func gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value"), 0;                           // draw a single 7 segment led digit
002837  003261  // Syntax 	: gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value");
002838  003262  // Usage 	: gfx_LedDigit(x, y, digitsize, oncolour, offcolour, value);
002839  003263  // Notes 	: Draws a single 7 segment led Digit at x, y of size digitsize using oncolour and offcolour.
002840  003264  // 	: The value can be 0-9 (0-9), A-F (0x0a-0x0f), blank(0x10) and - (0x11).
002841  003265  //      : Or value with LEDDIGIT_F_SHOW_DP to show a decimal point, LEDDIGIT_F_DP_COMMA to make the Decimal
002842  003266  // 	: point a comma and LEDDIGIT_F_DP_ON to turn the decimal point on
002843  003267  // 	:
002844  003268  // 	: LEDDIGIT_F_SET_SEGMENTS can be used to turn value into a series of bits to turn on individual segments
002845  003269  //      : eg LEDDIGIT_F_SET_SEGMENTS + 9 will turn on the top and bottom segments. Again LEDDIGIT_F_SHOW_DP and
002846  003270  // 	: LEDDIGIT_F_DP_COMMA can be used, but in this case the DP is the 8th segment. 
002847  003271  // Returns : nothing.
002848  003272        
002849  003273  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
002850  003274  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
002851  003275  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
002852  003276  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
002853  003277  //         : determined by "radius". 
002854  003278  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
002855  003279  // Returns : nothing.
002856  003280        
002857  003281  func putstrCentred("xc", "yc", "string"), 0;
002858  003282  // Syntax  : putstrCentred(x, y, "string"),
002859  003283  // Usage   : putstrCentred(100, 100, "HELLO");
002860  003284  // Notes   : Print a string centred at position x, y
002861  003285  //         : "String" may be a string constant, or pointer to a word aligned string.
002862  003286  // Returns : nothing.
002863  003287        
002864  003288  func widget_Create("count"), 1;
002865  003289  // Syntax 	: widget_Create("count"),
002866  003290  // Usage  	: widget_Create(count);
002867  003291  // Notes  	: Creates a widget Control capable of hoolding count elements and returns
002868  003292  //        	: a handle for the control.
002869  003293  // Returns	: Widget control handle.
002870  003294        
002871  003295  func widget_Add("hndl", "index", "widget"), 1;
002872  003296  // Syntax 	: widget_Add("hndl", "index", "widget"),
002873  003297  // Usage  	: widget_Add(hndl, index, widget);
002874  003298  // Notes  	: Add a widget ram entry "widget" into index "index" of the widget control referenced
002875  003299  //        	: by "hndl".
002876  003300  // Returns	: ssnothing.
002877  003301        
002878  003302  func widget_Delete("hndl", "index"), 1;
002879  003303  // Syntax 	: widget_Delete("hndl", "index"),
002880  003304  // Usage  	: widget_Delete(hndl, index);
002881  003305  // Notes  	: Delete widget ram entry "index" from the widget control referenced by "hndl".
002882  003306  // Returns	: sssnothing.
002883  003307        
002884  003308  func widget_Show("hndl", "index"), 1;
002885  003309  // Syntax	: widget_Show(handle, index);
002886  003310  // Usage	: display a flash resident image entry.
002887  003311  // Returns	: TRUE if successful, return value usually ignored.
002888  003312        
002889  003313  func widget_LoadFlash("Extra"), 1;
002890  003314  // Syntax	: hImagelist := widget_LoadFlash("Extra") ;
002891  003315  // Usage 	: hImagelist := widget_LoadFlash(0);
002892  003316  // Notes	: Reads the flash control file to create an widget list.
002893  003317  //      	: Returns NULL if function fails.
002894  003318  //      	: Returns a handle (pointer to the memory allocation) to the
002895  003319  //      	: widget control list that has been created.
002896  003320  //      	: "Extra" is the number of extra widget controls to be created
002897  003321  //      	: beyond the count in flash memory
002898  003322  // Returns 	: pointer to Widget control, or null if failed.
002899  003323        
002900  003324  func widget_Realloc("handle", "n"), 1;
002901  003325  // Syntax	: widget_Realloc(handle, n);
002902  003326  // Usage 	: Resizes a widget control to contain n entries, allowing it to be expanded or
002903  003327  //      	: condensed. Doing this unnecessarily can lead to RAM fragmentation. It is
002904  003328  //             	: much better to allocate widget controls once with the desired number of entries.
002905  003329  // Returns	: new handle to widget control.
002906  003330        
002907  003331  func widget_GetWord("hndl", "index", "offset"), 1;
002908  003332  // Syntax	: myvar := widget_GetWord("handle", "index", "offset");
002909  003333  // Usage 	: myvar := widget_GetWord(hndl, 5, WIDGET_YPOS);
002910  003334  // Notes 	: returns specified word (0-14) from a widget entry
002911  003335  //       	: refer to widget control entry offsets.
002912  003336        
002913  003337  func widget_Setposition("hndl", "index", "xpos", "ypos"), 1;
002914  003338  // Syntax	: widget_SetPosition(handle, index, xpos, ypos);
002915  003339  // Usage 	: r := widget_SetPosition(hImageList, imagenum, x, y);
002916  003340  // Notes 	: set the position of the widget control
002917  003341  //       	: returns true if index was ok and function was successful.
002918  003342        
002919  003343  func widget_Enable("hndl", "index"), 1;
002920  003344  // Syntax	: widget_Enable(handle, index);
002921  003345  // Usage 	: r := widget_Enable(hImageList, imagenum);
002922  003346  // Notes 	: enable an item in a widget control.
002923  003347  // Returns     	: true if index was ok and function was successful.
002924  003348        
002925  003349  func widget_Disable("hndl", "index"), 1;
002926  003350  // Syntax	: widget_Disable(handle, index);
002927  003351  // Usage 	: r := widget_Disable(hImageList, imagenum);
002928  003352  // Notes 	: disable an inetm in a widget control.
002929  003353  // Returns      : true if index was ok and function was successful.
002930  003354        
002931  003355  func widget_SetWord("hndl", "index", "offset", "value"), 1;
002932  003356  // Syntax: widget_SetWord(handle, index, offset, word);
002933  003357  // Usage : widget_SetWord(hndl, 5, IMAGE_XPOS, 10);
002934  003358  // Notes : set specified word (0-7) in a image entry
002935  003359  //       : returns TRUE if successful, return value usually ignored.
002936  003360        
002937  003361  func widget_SetAttributes("hndl", "index", "value"), 1;
002938  003362  // Syntax: widget_SetAttributes("handle", "index","offset");
002939  003363  // Usage : widget_SetAttributes(hndl, 5, I_TOPMOST);
002940  003364  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
002941  003365  //       : of an image control entry. "value" refers to various bits in
002942  003366  //       : the image control entry (see image attribute flags).
002943  003367  //       : A '1' bit in the "value" field SETS the respective bit
002944  003368  //       : in the IMAGE_FLAGS field of the image control entry.
002945  003369  //       : returns TRUE if successful, return value usually ignored.
002946  003370        
002947  003371  func widget_ClearAttributes("hndl", "index", "value"), 1;
002948  003372  // Syntax: widget_ClearAttributes("handle", "index","offset");
002949  003373  // Usage : widget_ClearAttributes(hndl, 5, I_TOPMOST);
002950  003374  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
002951  003375  //       : of an image control entry. "value" refers to various bits in
002952  003376  //       : the image control entry (see image attribute flags)
002953  003377  //       : a '1' bit in the "value" field CLEARS the respective bit
002954  003378  //       : in the IMAGE_FLAGS field of the image control entry.
002955  003379  //       : returns TRUE if successful, return value usually ignored.
002956  003380        
002957  003381  func widget_Touched("hndl", "index"), 1;
002958  003382  // Syntax: r := widget_Touched(handle, index);
002959  003383  // Usage : widget_Touched(hndl, 17);
002960  003384  //       : returns -1 if image not touched, or returns index
002961  003385  // Notes : if index is passed as -1, function tests all images,
002962  003386  //       : and returns -1 if image not touched, or returns index.
002963  003387        
002964  003388  func widget_FontID("id"), 1;                   // text font ID for flash based font
002965  003389  // Syntax: widget_FontID(id);
002966  003390  // Usage : widget_FontID(0);
002967  003391  //       : returns id of previous font
002968  003392        
002969  003393  #CONST
002970  003431  #END
002971  003432        
002972  003433  func gfx_Slider5("value", "&SliderRam", "&SliderDef"), 0;                           // draw a slider
002973  003434  // Syntax 	: gfx_Slider5("value", "&SliderRam", "&SliderDef") ;
002974  003435  // Usage 	: gfx_Slider5(value, SliderRam, SliderDef) ;
002975  003436  // Notes 	: Draw a Slider as defined by SliderDef (if required), using SliderRam positioning at
002976  003437  // 	: position value. See the reference for the SliderDef values
002977  003438  //
002978  003439        
002979  003440  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
002980  003441  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
002981  003442  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
002982  003443  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
002983  003444  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
002984  003445  //         : If "radius1" is zero, the inner rectangle will have square corners.
002985  003446  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
002986  003447  // Returns : nothing.
002987  003448        
002988  003449  /////////////////////
002989  003450  #CONST
002990  003469  #END
002991  003470        
002992  003471  func gfx_Switch("state", "&SwitchRam", "&SwitchDef"), 0;                           // draw a switch
002993  003472  // Syntax 	: gfx_Switch("state", "&SwitchRam", "&SwitchDef") ;
002994  003473  // Usage 	: gfx_Switch(state, SwitchRam, SwitchDef) ;
002995  003474  // Notes 	: Draw a Switch as defined by SwitchDef (if required), using SwitchRam positioning at
002996  003475  // 	: position value. See the reference for the SwitchDef values
002997  003476  //
002998  003477        
002999  003478  #CONST
003000  003507  #END
003001  003508        
003002  003509  func gfx_Button4("state", "&gfx_ButtonRam", "&gfx_ButtonDef"), 0;                           // draw a button
003003  003510  // Syntax 	: gfx_Button4("state", "&ButtonRam", "&ButtonDef") ;
003004  003511  // Usage 	: gfx_Button4(state, ButtonRam, ButtonDef) ;
003005  003512  // Notes 	: Draw a Button as defined by ButtonDef (if required), using ButtonRam positioning at
003006  003513  // 	: position value. See the reference for the ButtonDef values
003007  003514  //
003008  003515        
003009  003516  #CONST
003010  003531  #END
003011  003532        
003012  003533  func gfx_Led("state", "&LedRam", "&LedDef"), 0;                           // draw an LED
003013  003534  // Syntax 	: gfx_Led("state", "&LedRam", "&LedDef") ;
003014  003535  // Usage 	: gfx_Led(state, LedRam, LedDef) ;
003015  003536  // Notes 	: Draw a Led as defined by LedDef (if required), using LedRam positioning in
003016  003537  // 	: state state. See the reference for the LedDef values
003017  003538  //
003018  003539        
003019  003540  #CONST
003020  003558  #END
003021  003559  #CONST
003022  003577  #END
003023  003578        
003024  003579  func gfx_Scale("&ScaleRam", "&ScaleDef"), 0;                           // draw a Scale
003025  003580  // Syntax 	: gfx_Scale("&ScaleRam", "&ScaleDef") ;
003026  003581  // Usage 	: gfx_Scale(ScaleRam, ScaleDef) ;
003027  003582  // Notes 	: Draw a Scale as defined by ScaleDef, setting LedRam for use in touch processing.
003028  003583  // 	: See the reference for the ScaleDef values. If touch processing is not required 0 may be used as the SclaleRam parameter.
003029  003584  //
003030  003585        
003031  003586  #CONST
003032  003590  #END
003033  003591        
003034  003592  #CONST
003035  003612  #END
003036  003613        
003037  003614  func gfx_RulerGauge("state", "&RulerGaugeRam", "&RulerGaugeDef"), 0;                           // draw a Ruler Gauge
003038  003615  // Syntax 	: gfx_Led("position", "&RulerGaugeRam", "&RulerGaugeDef") ;
003039  003616  // Usage 	: gfx_Led(position, RulerGaugeRam, RulerGaugeDef) ;
003040  003617  // Notes 	: Draw a RulerGauge as defined by RulerGaugeDef (if required), using RulerGaugeRam positioning at
003041  003618  // 	: position value. See the reference for the RulerGaugeDef values
003042  003619  //
003043  003620        
003044  003621  #CONST
003045  003631  #END
003046  003632        
003047  003633  func file_CheckUpdate("Filename", "Options"), 1;                           // check and/or update the program running in Flash
003048  003634  // Syntax 	: file_CheckUpdate("Filename", "Options") ;
003049  003635  // Usage 	: file_CheckUpdate("thisfile.4xe", CheckUpdate_Check) ;
003050  003636  // Notes 	: Check and/or update the program running in flash using the specified file on uSD.
003051  003637  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003052  003638  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003053  003639  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003054  003640  //
003055  003641  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003056  003642  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003057  003643  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003058  003644  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003059  003645  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003060  003646  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003061  003647        
003062  003648  func udiv_3232("res32", "val1", "val2"), 1;
003063  003649  // Syntax   : udiv_1616(res32, varA, varB);
003064  003650  // Input    : DWORD *result   points to 32bit result register.
003065  003651  //          : DWORD   val1  pointer to 32bit value (dividend)
003066  003652  //          : DWORD   val2  pointer to 32bit value (divisor)
003067  003653  // Usage    : var res32[2];
003068  003654  //          : umul_1616(res32, myvar, 50000);
003069  003655  // Notes    : performs an unsigned division of 2 x 32bit values
003070  003656  //          : placing the 32bit result in a 2 word array.
003071  003657  // Returns  : the pointer to the 32bit result.
003072  003658  //          : carry and overflow are not affected.
003073  003659        
003074  003660  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
003075  003661  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
003076  003662  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
003077  003663  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
003078  003664  //         : "style" specifies the drawing mode
003079  003665  //         :     GRAD_DOWN         // gradient changes in the vertical direction
003080  003666  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
003081  003667  //         :     GRAD_UP           // gradient changes in the vertical direction
003082  003668  //         :     GRAD_LEFT         // gradient change in the horizontal direction
003083  003669  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
003084  003670  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
003085  003671  // Returns : nothing.
003086  003672        
003087  003673  func I2C2_Open("speed"), 1;
003088  003674  // Syntax : I2C2_Openx(speed),
003089  003675  // Usage  : I2C2_Open(I2C_MED);
003090  003676  // Notes : configures the I2C1 module
003091  003677  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003092  003678  // Returns: True if successful
003093  003679        
003094  003680        
003095  003681  func I2C3_Open("speed"), 1;
003096  003682  // Syntax : I2C3_Openx(speed),
003097  003683  // Usage  : I2C3_Open(I2C_MED);
003098  003684  // Notes : configures the I2C1 module
003099  003685  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003100  003686  // Returns: True if successful
003101  003687        
003102  003688  func I2C2_Close(), 0;
003103  003689  // Usage : I2C2_Close();
003104  003690  // Notes : disables the I2C2 module.
003105  003691        
003106  003692  func I2C3_Close(), 0;
003107  003693  // Usage : I2C3_Close();
003108  003694  // Notes : disables the I2C3 module.
003109  003695        
003110  003696  func I2C2_Start(), 1;
003111  003697  // Syntax: I2C2_Start();
003112  003698  // Usage : I2C2_Start();
003113  003699  // Notes : generates a Start condition.
003114  003700  //       : returns true if successful (usually ignored)
003115  003701        
003116  003702  func I2C3_Start(), 1;
003117  003703  // Syntax: I2C3_Start();
003118  003704  // Usage : I2C3_Start();
003119  003705  // Notes : generates a Start condition.
003120  003706  //       : returns true if successful (usually ignored)
003121  003707        
003122  003708  func I2C2_Stop(), 1;
003123  003709  // Syntax: I2C2_Stop();
003124  003710  // Usage : I2C2_Stop();
003125  003711  // Notes : generates a Stop condition.
003126  003712  //       : returns true if successful (usually ignored)
003127  003713        
003128  003714  func I2C3_Stop(), 1;
003129  003715  // Syntax: I2C3_Stop();
003130  003716  // Usage : I2C3_Stop();
003131  003717  // Notes : generates a Stop condition.
003132  003718  //       : returns true if successful (usually ignored)
003133  003719        
003134  003720  func I2C2_Restart(), 1;
003135  003721  // Syntax: I2C2_Restart();
003136  003722  // Usage : I2C2_Restart();
003137  003723  // Notes : generates a Restart condition.
003138  003724  //       : returns true if successful (usually ignored)
003139  003725        
003140  003726  func I2C3_Restart(), 1;
003141  003727  // Syntax: I2C3_Restart();
003142  003728  // Usage : I2C3_Restart();
003143  003729  // Notes : generates a Restart condition.
003144  003730  //       : returns true if successful (usually ignored)
003145  003731        
003146  003732  func I2C2_Read(), 1;
003147  003733  // Syntax: I2C2_Read();
003148  003734  // Usage : ch := I2C2_Read();
003149  003735  // Notes : reads a single byte from the I2C Bus.
003150  003736        
003151  003737  func I2C3_Read(), 1;
003152  003738  // Syntax: I2C3_Read();
003153  003739  // Usage : ch := I2C3_Read();
003154  003740  // Notes : reads a single byte from the I2C Bus.
003155  003741        
003156  003742  func I2C2_Write("byte"), 1;
003157  003743  // Syntax: I2C2_Write(byte);
003158  003744  // Usage : r := I2C2_Write(ch);
003159  003745  // Notes : is used to write a byte to the I2C bus.
003160  003746  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003161  003747        
003162  003748  func I2C3_Write("byte"), 1;
003163  003749  // Syntax: I2C3_Write(byte);
003164  003750  // Usage : r := I2C3_Write(ch);
003165  003751  // Notes : is used to write a byte to the I2C bus.
003166  003752  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003167  003753        
003168  003754  func I2C2_Ack(), 0;
003169  003755  // Syntax: I2C2_Ack();
003170  003756  // Usage : I2C2_Ack();
003171  003757  // Notes : generates the acknowledge condition.
003172  003758        
003173  003759  func I2C3_Ack(), 0;
003174  003760  // Syntax: I2C3_Ack();
003175  003761  // Usage : I2C3_Ack();
003176  003762  // Notes : generates the acknowledge condition.
003177  003763        
003178  003764  func I2C2_Nack(), 0;
003179  003765  // Syntax: I2C2_Nack();
003180  003766  // Usage : I2C2_Nack();
003181  003767  // Notes : generates the negative acknowledge condition.
003182  003768        
003183  003769  func I2C3_Nack(), 0;
003184  003770  // Syntax: I2C3_Nack();
003185  003771  // Usage : I2C3_Nack();
003186  003772  // Notes : generates the negative acknowledge condition.
003187  003773        
003188  003774  func I2C2_AckStatus(), 1;
003189  003775  // Syntax: I2C2_AckStatus();
003190  003776  // Usage : r := I2C2_AckStatus();
003191  003777  // Notes : returns the ACK status from the device.
003192  003778        
003193  003779  func I2C3_AckStatus(), 1;
003194  003780  // Syntax: I2C3_AckStatus();
003195  003781  // Usage : r := I2C3_AckStatus();
003196  003782  // Notes : returns the ACK status from the device.
003197  003783        
003198  003784  func I2C2_AckPoll("control"), 1;
003199  003785  // Syntax: I2C2_AckPoll();
003200  003786  // Usage : r := I2C2_AckPoll(0xA0);
003201  003787  // Notes : waits for a device to return from ACK polling.
003202  003788        
003203  003789  func I2C3_AckPoll("control"), 1;
003204  003790  // Syntax: I2C3_AckPoll();
003205  003791  // Usage : r := I2C3_AckPoll(0xA0);
003206  003792  // Notes : waits for a device to return from ACK polling.
003207  003793        
003208  003794  func I2C2_Idle(), 1;
003209  003795  // Syntax : I2C2_Idle();
003210  003796  // Usage  : r := I2C2_Idle();
003211  003797  // Notes  : waits until the I2C Bus is Inactive.
003212  003798  //        : Times out if bus not idle within 1 second
003213  003799  // Returns: TRUE if successful, else failed (timed out)
003214  003800        
003215  003801  func I2C3_Idle(), 1;
003216  003802  // Syntax : I2C3_Idle();
003217  003803  // Usage  : r := I2C3_Idle();
003218  003804  // Notes  : waits until the I2C Bus is Inactive.
003219  003805  //        : Times out if bus not idle within 1 second
003220  003806  // Returns: TRUE if successful, else failed (timed out)
003221  003807        
003222  003808  func I2C2_Gets("buffer", "size"), 1;
003223  003809  // Syntax: I2C2_Gets("buffer", "size");
003224  003810  // Usage : r := I2C2_Gets(mybuf, 16);
003225  003811  // Notes : only reads up to "size" characters into "buffer"
003226  003812  //       : Reads up to asciiz terminator including terminator
003227  003813        
003228  003814  func I2C3_Gets("buffer", "size"), 1;
003229  003815  // Syntax: I2C3_Gets("buffer", "size");
003230  003816  // Usage : r := I2C3_Gets(mybuf, 16);
003231  003817  // Notes : only reads up to "size" characters into "buffer"
003232  003818  //       : Reads up to asciiz terminator including terminator
003233  003819        
003234  003820  func I2C2_Getn("buffer", "size"), 1;
003235  003821  // Syntax: I2C2_Gets("buffer", "size");
003236  003822  // Usage : r := I2C2_Gets(mybuf, 16);
003237  003823  // Notes : reads "size" bytes into "buffer"
003238  003824  //       :
003239  003825        
003240  003826  func I2C3_Getn("buffer", "size"), 1;
003241  003827  // Syntax: I2C3_Gets("buffer", "size");
003242  003828  // Usage : r := I2C3_Gets(mybuf, 16);
003243  003829  // Notes : reads "size" bytes into "buffer"
003244  003830  //       :
003245  003831        
003246  003832  func I2C2_Puts("buffer"), 1;
003247  003833  // Syntax: I2C2_Puts("buffer");
003248  003834  // Usage : r := I2C2_Puts(mybuf);
003249  003835  // Notes : writes an asciiz string to the I2C device
003250  003836  //       : returns count of characters written
003251  003837        
003252  003838  func I2C3_Puts("buffer"), 1;
003253  003839  // Syntax: I2C3_Puts("buffer");
003254  003840  // Usage : r := I2C3_Puts(mybuf);
003255  003841  // Notes : writes an asciiz string to the I2C device
003256  003842  //       : returns count of characters written
003257  003843        
003258  003844  func I2C2_Putn("buffer", "count"), 1;
003259  003845  // Syntax: I2C2_Putn("buffer","count");
003260  003846  // Usage : r := I2C2_Puts(mybuf,10);
003261  003847  // Notes : writes up to "size" bytes to the I2C device
003262  003848  //       : returns number of bytes written
003263  003849        
003264  003850  func I2C3_Putn("buffer", "count"), 1;
003265  003851  // Syntax: I2C3_Putn("buffer","count");
003266  003852  // Usage : r := I2C3_Puts(mybuf,10);
003267  003853  // Notes : writes up to "size" bytes to the I2C device
003268  003854  //       : returns number of bytes written
003269  003855        
003270  003856  func gfx_XYrotToVal("x","y","base","mina","maxa","minv","maxv"), 1;         // convert a rotational x/y postion to a value
003271  003857  // Usage	: gfx_XYrotToVal(x,y,XYROT_EAST,starta,enda,minv,maxv)
003272  003858  // Notes	: Convert a rotational angle into a value
003273  003859  // 	: Calculates a position for a rotary input starting at mina and continuing to maxa. both angles must be greater than 0.
003274  003860  // 	: Base can be XYROT_EAST, used for internal widgets, or XYROT_SOUTH, used for GCI widgets.
003275  003861  // 	: Returns a value from minv to maxv
003276  003862        
003277  003863  func gfx_XYlinToVal("x","y","base","minpos","maxpos","minv","maxv"), 1;         // convert a linear x/y postion to a value
003278  003864  // Usage	: gfx_XYrotToVal(x,y,XYLIN_X,startp,endp,minv,maxv)
003279  003865  // Notes	: Convert a linear position into a value
003280  003866  // 	: Calculates a position for a linear input starting at minpos and continuing to maxpos. 
003281  003867  // 	: Base can be XYLIN_X, to use the x value for calculations, or XYLIN_Y, to use the y value.
003282  003868  // 	: Returns a value from minv to maxv
003283  003869        
003284  003870  func media_InitSpeed("Speed"), 1;                     // initialize uSD card at a given speed
003285  003871  // Usage	: media_Init(SPI_SPEED15);
003286  003872  // Notes	: Initialise uSD CARD at a specified speed
003287  003873  // 	: Response: 0 = No Card
003288  003874  // 	:           1 = Card Initialised
003289  003875  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003290  003876        
003291  003877  func file_MountSpeed("Speed"), 1;                     // mount a uSD card at a given speed
003292  003878  // Syntax	: r := file_Mount(SPI_SPEED15);
003293  003879  // Usage	: r := file_Mount(SPI_SPEED15);
003294  003880  // Notes	: Create a control block for FAT16 and mount the File System at the specified speed
003295  003881  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003296  003882        
003297  003883  func img_FileRead("*dest", "size", "handle", "index"), 1;
003298  003884  // Syntax: res := img_FileRead("*dest", "size", "handle", "index"),
003299  003885  // Usage : res := img_FileRead(memblock,20,hnd1);
003300  003886  // Notes : returns number of characters read
003301  003887  //       : if "dest" is zero, data is read direct to GRAM window
003302  003888  //       :
003303  003889        
003304  003890  func img_FileSeek("handle", "index", "HiWord", "LoWord"), 1;
003305  003891  // Syntax: res := img_FileSeek("handle", "index", "HiWord", "LoWord")
003306  003892  // Usage : res := img_FileSeek(hSource, 0, 0x1234);
003307  003893  // Notes : set file position to 0x00001234 (byte position 4660)
003308  003894  //       : for the file handle so subsequent data may be read
003309  003895  //       : from that position onwards with img_FileGetC(...),
003310  003896  //       : img_FileGetW(...) or img_FileGetS(...)
003311  003897  // Notes : returns true if ok, usually ignored
003312  003898        
003313  003899  func img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003314  003900  // Syntax: img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003315  003901  // Usage : res := img_FileIndex(hsource, 0, 1000, 123), 1;
003316  003902  // Notes : set file seek position to 123000
003317  003903  //       : for the file handle so subsequent data may be read
003318  003904  //       : from that record position onwards with img_FileGetC(...),
003319  003905  //       : img_FileGetW(...) or img_FileGetS(...)
003320  003906  // Notes : returns true if ok, usually ignored
003321  003907        
003322  003908  func img_FileTell("handle", "index", "&HiWord", "&LoWord"), 1;
003323  003909  // Syntax: img_FileTell("handle", "index", &HiWord, &LoWord);
003324  003910  // Usage : img_FileTell(fhndl, &SizeHi, &SizeLo);
003325  003911  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003326  003912  //       : returns true if function succeeded
003327  003913        
003328  003914  func img_FileSize("handle", "index", "&HiWord", "&LoWord"), 1;
003329  003915  // Syntax: img_FileSize("handle", "index", &HiWord, &LoWord);
003330  003916  // Usage : img_FileSize(fhndl, &SizeHi, &SizeLo);
003331  003917  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003332  003918  //       : returns true if function succeeded
003333  003919        
003334  003920  func img_FileGetC("handle", "index"), 1;
003335  003921  // Syntax: img_FileGetC("handle", "index");
003336  003922  // Usage : mychar := fgetC("handle", "index");
003337  003923  // Notes : returns next char from file
003338  003924        
003339  003925  func img_FileGetW("handle", "index"), 1;
003340  003926  // Syntax: img_FileGetW("handle", "index");
003341  003927  // Usage : myword := fgetW("handle", "index");
003342  003928  // Notes : returns next word in file
003343  003929        
003344  003930  func img_FileGetS("*string", "size", "handle", "index"), 1;
003345  003931  // Syntax: res := img_FileGets("*string", "size", "handle", "index");
003346  003932  // Usage : res := img_FileGets(mystr , 81, hnd1); // read up to 80 chars
003347  003933  // Notes : get a string from a file
003348  003934  //       : returns pointer to string or null if failed.
003349  003935  //       : img_FileGetS(...) automatically appends a null-terminator to the data read.
003350  003936  //       : NB:- only reads up to "size-1" characters into "string"
003351  003937  //       : img_FileGetS(...) will stop reading when any of the following conditions are true:
003352  003938  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003353  003939  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003354  003940  //       : C] It reaches the end of file
003355  003941  //       : D] A read error occurs.
003356  003942        
003357  003943  func img_FileRewind("handle", "index"), 1;
003358  003944  // Syntax: res := img_FileRewind("handle", "index");
003359  003945  // Usage : res := img_FileRewind(hnd1);
003360  003946  // Notes : returns true if file rewound ok (usually ignored)
003361  003947  //       : resets the file pointer the the beginning of the open file.
003362  003948        
003363  003949  func img_FileLoadFunction("handle", "index"), 1;
003364  003950  // Syntax: res := img_FileLoadFunction("handle", "index");
003365  003951  // Usage : myfunc := img_FileLoadFunction("handle", "index");
003366  003952  // Notes : Load a function or program from disk and
003367  003953  //       : return a function pointer to the allocation.
003368  003954  //       : The function can then be invoked just like any other
003369  003955  //       : function would be called via a function pointer.
003370  003956  //       : Parameters may be passed to it in a conventional way.
003371  003957  //       : The function may be discarded at any time when no
003372  003958  //       : longer required, thus freeing its memory resources.
003373  003959  //       : The loaded function can be discarded with mem_Free(..)
003374  003960  //       : eg:
003375  003961  //       : popupWindow := img_FileLoadFunction("handle", "index");
003376  003962  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003377  003963  //       : then elsewhere in your program:-
003378  003964  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003379  003965  //       : if(res == QUIT_APPLICATION) goto exitApp;
003380  003966  //       : Later in your program, when popupWindow is no longer
003381  003967  //       : required for the application:-
003382  003968  //       : res := mem_Free(popupWindow);
003383  003969  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003384  003970  //       : The callers stack is shared by the loaded function,
003385  003971  //       : however any global variables in the loaded function
003386  003972  //       : are private to that function.
003387  003973  //
003388  003974        
003389  003975  func img_FileRun("handle", "index", "arglistptr"), 1;
003390  003976  // Syntax: res := img_FileRun("handle", "index","arglistptr");
003391  003977  // Usage : res := img_FileRun("handle", "index", argptr);
003392  003978  // Notes : current program releases any allocated memory but
003393  003979  //       : retains the stack and global memory.
003394  003980  //       : If arglistptr is 0, no arguments are passed, else
003395  003981  //       : arglist points to an array, the first element being
003396  003982  //       : the number of elements in the array.
003397  003983  //       : func 'main' in the called program accepts
003398  003984  //       : the arguments, if any. THe arguments can only
003399  003985  //       : be passed by value, no pointers or references can be
003400  003986  //       : used as all memory is cleared before the file
003401  003987  //       : is loaded. Refer to img_FileExec and img_FileLoadFunction
003402  003988  //       : for functions that can pass by reference.
003403  003989        
003404  003990  func img_FileExec("handle", "index", "arglistptr"), 1;
003405  003991  // Syntax: res := img_FileExec("handle", "index","arglistptr");
003406  003992  // Usage : res := img_FileExec("handle", "index","arglistptr");
003407  003993  // Notes : returns like a function, current program
003408  003994  //       : calling program is kept active and control returns to it.
003409  003995  //       : If arglistptr is 0, no arguments are passed, else
003410  003996  //       : arglist points to an array, the first element being
003411  003997  //       : the number of elements in the array.
003412  003998  //       : func 'main' in the called program accepts the arguments.
003413  003999  //       : This function is similar to img_FileLoadFunction(...), however,
003414  004000  //       : the function argument list is passed by pointer, and
003415  004001  //       : the memory consumed by the function is released as
003416  004002  //       : soon as the function completes.
003417  004003        
003418  004004  func img_FilePlayWAV("handle", "index"), 1;
003419  004005  // Syntax: img_FilePlayWAV("handle", "index");
003420  004006  // Usage : img_FilePlayWAV("handle", "index");
003421  004007  // Notes : Play a wave file at index "index" in the filesystem "handle"
003422  004008  //       : This function automatically grabs a chunk
003423  004009  //       : of memory for a file buffer, and a wave
003424  004010  //       : buffer. The minimum memory requirement is
003425  004011  //       : about 580 bytes for the disk io service and
003426  004012  //       : a minimum wave buffer size of 1024. The siz
003427  004013  //       : of the wave buffer allocation
003428  004014  //       : can be increased by the snd_BufSize function.
003429  004015  //       : The default size 1024 bytes.
003430  004016  //       : NB the memory is only required during the
003431  004017  //       : duration of play, and is automatically
003432  004018  //       : released while not in use.
003433  004019  //       : See the Sound Class services for other associated controls.
003434  004020  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003435  004021  //       : If errors occured, the folling is returned
003436  004022  //       : -7  : Insufficient memory available for WAV buffer and file
003437  004023  //       : -6  : cant play this rate
003438  004024  //       : -5  : no data chunk found in first rsector
003439  004025  //       : -4  : no format data
003440  004026  //       : -3  : no wave chunk signature
003441  004027  //       : -2  : bad wave file format
003442  004028  //       : -1  : file not found
003443  004029        
003444  004030  func img_TxtFontID("handle", "index"), 1;                   // 2  text font ID (0 = system font)
003445  004031  // Syntax: img_TxtFontID("handle", "index");
003446  004032  // Usage : img_TxtFontID("handle", "index");
003447  004033  // Notes : Set the font to a font held in the image file system
003448  004034        
003449  004035  func img_FileCheckUpdate("handle", "index", "Options"), 1;                           // check and/or update the program running in Flash
003450  004036  // Syntax 	: img_FileCheckUpdate("handle", "index", "Options") ;
003451  004037  // Usage 	: img_FileCheckUpdate("handle", "index", CheckUpdate_Check) ;
003452  004038  // Notes 	: Check and/or update the program running in flash using the specified file in Flash memory.
003453  004039  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003454  004040  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003455  004041  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003456  004042  //
003457  004043  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003458  004044  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003459  004045  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003460  004046  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003461  004047  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003462  004048  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003463  004049        
003464  004050  func flash_Block32Erase(), 1;            // erase the required 32k flash block
003465  004051  // Syntax	: flash_Block32Erase();
003466  004052  // Usage	: flash_Block32Erase();
003467  004053  // Notes	: Erase the 32KB flash block including the currently set address
003468  004054  // 	: This uses the 0x52 command.
003469  004055        
003470  004056  func flash_Sector4Erase(), 1;            // erase the required 4k flash sector
003471  004057  // Syntax: flash_Sector4Erase();
003472  004058  // Usage : flash_Sector4Erase();
003473  004059  // Notes	: Erase the 4KB flash sector including the currently set address
003474  004060  // 	: This uses the 0x20 command.
003475  004061        
003476  004062  func com_Mode("8" ,"N", "1", "comport"), 1 ;
003477  004063  // Syntax	: comx_Mode("databits", "parity", "Stopbits", "comport");
003478  004064  // Usage	: comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
003479  004065  // *Notes	: Data Bits must be 8
003480  004066  // 	: Parity may be 'N', 'O' or 'E'.
003481  004067  // 	: Stop Bits may be 1 or 2.
003482  004068  // 	: returns true if mode was acceptable
003483  004069        
003484  004070  func img_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in a Flash GCI
003485  004071  // Syntax: img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003486  004072  // Usage : img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003487  004073  // Notes	: Load and call the Function found at index "idx" in the Flash GCI identified by "Hndl". 
003488  004074  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003489  004075  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003490  004076  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003491  004077  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003492  004078  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003493  004079  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003494  004080  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003495  004081  // 	: Returns 0 if successful.
003496  004082        
003497  004083  func img_FunctionFreeCache("handle"), 0 ;                                 // Free all cached Flash GCI Functions 
003498  004084  // Syntax: img_FunctionFreeCache(hndl);
003499  004085  // Usage : img_FunctionFreeCache(hndl);
003500  004086  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003501  004087  // 	: Flash GCI.
003502  004088        
003503  004089  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
003504  004090  // *Notes   : (if you calculate all of the incoming data
003505  004091  //          : INCLUDING the CRC, the result should be 0x00
003506  004092  //          : This is equivalent to simple addition of all bytes
003507  004093  //          : and returning the negated sum an 8 bit value.
003508  004094  //          : For the standard test string "123456789",
003509  004095  //          : crc_CSUM_8 will return 0x0023.
003510  004096        
003511  004097  func gfx_GradientShape("GradientRAM", "HorzVert", "OuterWidth", "X", "Y", "W", "H", "TLrad", "TRrad", "BLrad", "BRrad", "Darken", "OuterColor", "OuterType", "OuterLevel", "InnerColor", "InnerType", "InnerLevel", "Split"), 0 ;
003512  004098  // Syntax 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003513  004099  // Usage 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003514  004100  // Notes 	: Produce a shaped color gradient using the supplied parameters.0
003515  004101  // 	: GradientRAM	This Function requires a quantity or RAM to work. It also needs to be initialised and it's size varies accoring to the largest corner radius. Multiple gradient shape calls can
003516  004102  // 	: 	share the same GradientRAM. eg gradientRAM[29+91*2] := [-1,-1,-9999,0,0,91] ;  Would support a maximum radius of 90 degrees, note the 91 in two places.
003517  004103  // 	: HorzVert	Horizontal or Vertical -- 0 or 1
003518  004104  // 	: OuterWidth	Outer gradient width 0 to ...
003519  004105  // 	: X	x co-ordinate
003520  004106  // 	: Y	y co-ordinate
003521  004107  // 	: W	width
003522  004108  // 	: H	height
003523  004109  // 	: LTrad	Top left corner radius
003524  004110  // 	: TRrad	Top right corner radius
003525  004111  // 	: BLrad	Bottom left radius
003526  004112  // 	: BRrad	Bottom right radius
003527  004113  // 	: Darken	Darken both colours by a value. Can be a -ve value to lighten
003528  004114  // 	: OuterCol	Outer Gradient colour
003529  004115  // 	: OuterType	Outer Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003530  004116  // 	: OuterLevel	Outer Gradient level 0 - 63
003531  004117  // 	: InnerCol	Inner Gradient colour
003532  004118  // 	: InnerType	Inner Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003533  004119  // 	: InnerLevel	Inner Gradient level 0 - 63
003534  004120  // 	: Split	Split gradient, 0 - no split, 1 - top, 2 - bottom 
003535  004121  // 
003536  004122  // Returns	: nothing
003537  004123        
003538  004124        
003539  004125  func gfx_GradientColor("Type", "Darken", "Level", "H", "Pos", "Color"), 1 ;
003540  004126  // Syntax 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003541  004127  // Usage 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003542  004128  // Notes 	: Given the parameters, adjust the input color to produce the output color.
003543  004129  // 	: Type	Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003544  004130  // 	: Darken	Darken colour by a value. Can be a -ve value to lighten
003545  004131  // 	: Level	Gradient level 0 - 63
003546  004132  // 	: H	Height of the object that gradient is applied
003547  004133  // 	: Pos	Position in the height that gradient is calculated
003548  004134  // 	: Color	Source colour that gradient is applied to
003549  004135  // 
003550  004136  // Returns	: Color after Adjustment.
003551  004137        
003552  004138  func gfx_GradTriangleFilled("X0", "Y0", "X1", "Y1", "X2", "Y2", "SolidCol", "GradientCol", "GradientHeight", "GradientY", "GradientLevel", "Type"), 0;
003553  004139  // Syntax 	: gfx_GradTriangleFilled(X0, Y0, X1, Y1, X2, Y2, SolidCol, GradientCol, GradientHeight, GradientY, GradientLevel, Type);
003554  004140  // Usage 	: gfx_GradTriangleFilled(10, 10, 10, 100, 100, 100 ,YELLOW, DARKKHAKI, 100, 10, 30, 1);
003555  004141  // Notes 	: Produce a triangle with or without a gradient.
003556  004142  // 	: X0	First triangle point x coordinate
003557  004143  // 	: Y0	First triangle point y coordinate
003558  004144  // 	: X1	Second triangle point x coordinate
003559  004145  // 	: Y1	Second triangle point y coordinate
003560  004146  // 	: X2	Third triangle point x coordinate
003561  004147  // 	: Y2	Third triangle point y coordinate
003562  004148  // 	: SolidCol	Colour that will be used if the Solid or Gradient parameter is set to 0
003563  004149  // 	: GradientCol	Colour that will be used if the Solid or Gradient parameter is set to 1
003564  004150  // 	: GradientHeight	Height of the area that the gradient will be calculated. Can be larger than the triangle
003565  004151  // 	: GradientY	Position on the Y axis that the gradient will be calculated from with respect to triangle position
003566  004152  // 	: GradientLevel	Level of gradient applied
003567  004153  // 	: Type	Select wether solid triangle or gardient triangle is drawn. 
003568  004154        
003569  004155  func media_InitFlash("Command"), 1;                    // initialize Flash Memory
003570  004156  // Usage	: media_InitFlash();
003571  004157  // Notes	: Initialise Flash Memory 
003572  004158  // 	: Response: 0 = Normally ignored, but should be 0
003573  004159  // 	:           1 = a uSD Card has been Initialised, you should not use this command for uSD cards
003574  004160  // 	: Note that for systems with SPI Flash the response will be 0, however, this function needs to be called to 
003575  004161  // 	: init the Flash memory chip.
003576  004162  // 	: Command	The command used to set the flash memory into 4 byte addressing mode
003577  004163  // 	: FLASH_ADDR_DEF_COMMAND	The default command will be used (0xB7)
003578  004164  // 	: FLASH_ADDR_ALWAYS_4BYTE	No command will be sent (for chips permantly in 4 byte mode)
003579  004165  // 	: else this command will be sent to enter 4 Byte Addressing mode, if the capacity of the chip appears to
003580  004166  // 	: be greater than 16MB. Requires the JEDEC approved response to the 'FLASH READ ID' (0x9F) command.
003581  004167        
003582  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003583  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003584  004169        
003585  004170  func file_RunSpeed("Speed", "fname.4xe", "arglistptr"), 1;
003586  004171  // Syntax	: res := file_Run(SPI_SPEED15, "fname.4xe","arglistptr");
003587  004172  // Usage	: res := file_Run(SPI_SPEED15, fname, argptr);
003588  004173  // Notes	: current program releases any allocated memory but
003589  004174  // 	: retains the stack and global memory.
003590  004175  // 	: If arglistptr is 0, no arguments are passed, else
003591  004176  // 	: arglist points to an array, the first element being
003592  004177  // 	: the number of elements in the array.
003593  004178  // 	: func 'main' in the called program accepts
003594  004179  // 	: the arguments, if any. The arguments can only
003595  004180  // 	: be passed by value, no pointers or references can be
003596  004181  // 	: used as all memory is cleared before the file
003597  004182  // 	: is loaded. Refer to file_Exec and file_LoadFunction
003598  004183  // 	: for functions that can pass by reference.
003599  004184  // 	: Speed specifies the File System is mounted at the specified speed
003600  004185  // 	: can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003601  004186        
003602  004187  func I2CS_Open("Addr", "RdBuf", "RdBufSize", "WrBuf", "WrBufSize", "WaitOption"), 0;  // Open I2C Slave
003603  004188  // Usage	: I2CS_Open(Addr, RdBuf, RdBufS, WrBuf, WrBufs, 0xaa);
003604  004189  // Notes	: Initialize and open the I2C Slave 
003605  004190  // 	: The slave ACKs any transmissions from the master until the read buffer fills
003606  004191  // 	: The slave NAKs any receives by the master until the write buffer is released, or is empty
003607  004192  // 	: Addr	The I2C Address for this Slave
003608  004193  // 	: RdBuf	The buffer for receiving 'commands' from the master
003609  004194  // 	: RdBufSize	The size of the receive buffer 
003610  004195  // 	: WrBuf	The buffer for sending 'responses' to the master
003611  004196  // 	: WrBufSize	The size of the write buffer
003612  004197  // 	: WaitOption	The character to send when no data is available, or all sent, or with I2C_CLOCK_STRETCHING to use clock stretching 
003613  004198  // 	: Response: None
003614  004199        
003615  004200  func I2CS_Close(), 0;          // Close I2C Slave
003616  004201  // Usage	: I2CS_Close();
003617  004202  // Notes	: Closes the I2C Slave 
003618  004203  // 	: Response: None
003619  004204        
003620  004205  func I2CS_Write("Byte"), 0;      // Write byte to output buffer
003621  004206  // Usage	: I2CS_Write("Byte");
003622  004207  // Notes	: Writes a byte to the I2C Slave Write Buffer
003623  004208  // 	: When everything to be written to the Master is in the write buffer, the buffer should be released
003624  004209  // 	: with I2CS_Release()
003625  004210  // 	: Response: None
003626  004211        
003627  004212  func I2CS_Count(), 1;          // Count of bytes in input buffer
003628  004213  // Usage	: I2CS_Count();
003629  004214  // Notes	: Retrieve the number of bytes available in the I2C Slave's read buffer
003630  004215  // 	: Response: Number of bytes in the buffer
003631  004216        
003632  004217  func I2CS_Read(), 1;           // Read byte from Read Buffer
003633  004218  // Usage	: I2CS_Read();
003634  004219  // Notes	: Read a byte from the I2C Slave's read buffer
003635  004220  // 	: Response: byte read from buffer
003636  004221        
003637  004222  func I2CS_Release(), 0;        // Release output buffer to enable Master to read
003638  004223  // Usage	: I2CS_Release();
003639  004224  // Notes	: Release an accumulated I2C Slave write buffer for sending to the master
003640  004225  // 	: Response: None
003641  004226        
003642  004227  func I2CS_Overflow(), 1;        // Check for any overflow in the read or write processes
003643  004228  // Usage	: I2CS_Overflow();
003644  004229  // Notes	: Check for any overflow in the read or write processes, the error is automatically
003645  004230  // 	: Reset at the start of the next I2CS_Write() or the last I2CS_Read() for the current buffer.
003646  004231  // 	: Response: Overflow flags
003647  004232  // 	: 0x01 : The host has sent more data than the I2CS_Read() buffer can hold
003648  004233  // 	: 0x02 : The host has read all the data the I2CS_Write() buffer contained
003649  004234  // 	: 0x04 : The host has read more data than the I2CS_Write() buffer contained
003650  004235        
003651  004236  func com_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003652  004237  // Usage	: com_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003653  004238  // Usage	: com_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003654  004239  // Notes	: initialize a serial buffer for the COM0 output.
003655  004240  // 	: The program must declare a var array as a circular buffer.
003656  004241  // 	: When a TX buffer is declared for comms, the transmission
003657  004242  // 	: of characters becomes non blocking. If the buffer has
003658  004243  // 	: insufficient space to accept the next character from a
003659  004244  // 	: serout_x() function, the excess characters will be ignored,
003660  004245  // 	: and the com_Full_x() error will be asserted.   If the
003661  004246  // 	: TX buffer is no longer required, just set the buffer pointer
003662  004247  // 	: to zero, the size in this case doesnt matter and is ignored.
003663  004248  // 	: The function can resize or reallocated to another buffer at
003664  004249  // 	: any time. The buffer is flushed before any changes are made.
003665  004250  // 	: "pin" designates an IO pin to control a bi-directional
003666  004251  // 	: control device for half duplex mode. "pin" will go HI at the
003667  004252  // 	: start of a transmission, and will return low after the final
003668  004253  // 	: byte is transmitted. If not required, just set "pin" to zero.
003669  004254        
003670  004255  func com_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003671  004256  // Syntax	: com_InitBrk(buffer, bufsize, qualifier);
003672  004257  // Usage1	: com_InitBrk(mybuf, 20, 0);
003673  004258  // Usage2	: com_InitBrk(mybuf, 20, ':');
003674  004259  // Notes	: initialize a serial capture buffer for the comms input
003675  004260  // 	: The program must declare a var array as a circular buffer.
003676  004261  // 	: Usage1 declares a circular buffer which will continually
003677  004262  // 	: buffer characters.
003678  004263  // 	: Usage2 must receive ':' before any characters will
003679  004264  // 	: accumulate in the buffer.
003680  004265        
003681  004266  //------------------------------------------------------------------//
003682  004267  //     break control constant                                       //
003683  004268  //------------------------------------------------------------------//
003684  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003685  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003686  004270        
003687  004271  func disp_Refresh(), 0;  // Refresh an ePaper display
003688  004272  // Syntax	: disp_Refresh();
003689  004273  // Usage	: disp_Refresh();
003690  004274  // Notes	: This command is only applicable to ePaper displays.
003691  004275  // 	: Refresh an ePaper display
003692  004276  // 	: After updating the RAM in an ePaper display thuis commmand is used
003693  004277  // 	: to place the contents of the RAM onto the ePaper.
003694  004278        
003695  004279  func disp_Busy(), 1;  // Check the busy status of an ePaper display
003696  004280  // Syntax	: disp_Busy();
003697  004281  // Usage	: disp_Busy();
003698  004282  // Notes	: This command is only applicable to ePaper displays.
003699  004283  // 	: Return the busy status of an ePaper display
003700  004284  // 
003701  004285  // Returns	: 1 if the display is busy, 0 otherwise
003702  004286        
003703  004287  //=========================================================================================================
003704  004288  // Internal FLASH memory functions
003705  004289  //=========================================================================================================
003706  004290  func intflash_GetByte("ptr"), 1;
003707  004291  // Syntax   : intflash_GetByte(ptr);
003708  004292  // Usage    : myvar := intflash_GetByte(1); // read the first byte from internal flash
003709  004293  // Notes    : Reads a single byte from internal flash.
003710  004294  // Returns  : the byte value from the location
003711  004295        
003712  004296        
003713  004297  func intflash_GetWord("ptr"), 1;
003714  004298  // Syntax   : intflash_GetWord(ptr);
003715  004299  // Usage    : myvar := intflash_GetWord(0x0000); // read first word from internal flash
003716  004300  // Notes    : Reads a single word from any internal flash location.
003717  004301  //          : The pointer is byte aligned.
003718  004302  // Returns  : the byte value from the location
003719  004303        
003720  004304        
003721  004305  func intflash_Copy("ptr", "dest", "count"), 1;
003722  004306  // Syntax   : intflash_Copy(ptr, dest, count);
003723  004307  // Usage    : myvar := intflash_Copy(0x123, mybuf, 20); // read 20 bytes from internal flash starting from 0x123
003724  004308  // Notes    : Copies bytes from any internal flash locations to a user buffer.
003725  004309  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
003726  004310  // Returns  : the count of bytes transferred.
003727  004311        
003728  004312  func intflash_WriteBlock("sourceptr", "Size"), 1;
003729  004313  // Syntax   : intflash_WriteBlock(pbuf);
003730  004314  // Usage    : result := intflash_WriteBlock(buffer); // store the 2k buffer 
003731  004315  // Notes    : Copies a buffer to NVM. Size bytes are written. A maximum of 2048 bytes can be written.
003732  004316  // Returns  : returns true if the function succeeded.
003733  004317        
003734  004318  func intflash_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in internal flash
003735  004319  // Syntax: intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003736  004320  // Usage : intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003737  004321  // Notes	: Load and call the Function found at index "idx" in the internal flash widget identified by "Hndl". 
003738  004322  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003739  004323  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003740  004324  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003741  004325  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003742  004326  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003743  004327  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003744  004328  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003745  004329  // 	: Returns 0 if successful.
003746  004330        
003747  004331  func intflash_FunctionFreeCache("handle"), 0 ;                                 // Free all cached internal Flash Functions 
003748  004332  // Syntax: img_FunctionFreeCache(hndl);
003749  004333  // Usage : img_FunctionFreeCache(hndl);
003750  004334  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003751  004335  // 	: widget handle.
003752  004336        
003753  004337  func com1_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003754  004338  // Usage	: com1_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003755  004339  // Usage	: com1_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003756  004340  // Notes	: initialize a serial buffer for the COM1 output.
003757  004341  // 	: The program must declare a var array as a circular buffer.
003758  004342  // 	: When a TX buffer is declared for comms, the transmission
003759  004343  // 	: of characters becomes non blocking. If the buffer has
003760  004344  // 	: insufficient space to accept the next character from a
003761  004345  // 	: serout_x() function, the excess characters will be ignored,
003762  004346  // 	: and the com_Full_x() error will be asserted.   If the
003763  004347  // 	: TX buffer is no longer required, just set the buffer pointer
003764  004348  // 	: to zero, the size in this case doesnt matter and is ignored.
003765  004349  // 	: The function can resize or reallocated to another buffer at
003766  004350  // 	: any time. The buffer is flushed before any changes are made.
003767  004351  // 	: "pin" designates an IO pin to control a bi-directional
003768  004352  // 	: control device for half duplex mode. "pin" will go HI at the
003769  004353  // 	: start of a transmission, and will return low after the final
003770  004354  // 	: byte is transmitted. If not required, just set "pin" to zero.
003771  004355        
003772  004356  func com1_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003773  004357  // Syntax	: com1_InitBrk(buffer, bufsize, qualifier);
003774  004358  // Usage1	: com1_InitBrk(mybuf, 20, 0);
003775  004359  // Usage2	: com1_InitBrk(mybuf, 20, ':');
003776  004360  // Notes	: initialize a serial capture buffer for the comms input
003777  004361  // 	: The program must declare a var array as a circular buffer.
003778  004362  // 	: Usage1 declares a circular buffer which will continually
003779  004363  // 	: buffer characters.
003780  004364  // 	: Usage2 must receive ':' before any characters will
003781  004365  // 	: accumulate in the buffer.
003782  004366        
003783  004367  //------------------------------------------------------------------//
003784  004368  // CONSTANTS
003785  004369  //------------------------------------------------------------------//
003786  004370        
003787  004371  #CONST
003788  004500  #END
003789  004501        
003790  004502  // generic constants
003791  004503  #CONST
003792  004514  #END
003793  004515        
003794  004516  // other constants
003795  004517  #CONST
003796  004520  #END
003797  004521        
003798  004522  //------------------------------------------------------------------------------
003799  004523  // Pin related constants
003800  004524  //------------------------------------------------------------------------------
003801  004525  #CONST
003802  004547  #END
003803  004548        
003804  004549  //------------------------------------------------------------------------------
003805  004550  //gfx_Set() related constants
003806  004551  //------------------------------------------------------------------------------
003807  004552  #CONST
003808  004569  #END
003809  004570        
003810  004571        
003811  004572  //gfx_Get() related constants
003812  004573  #CONST
003813  004582  #END
003814  004583        
003815  004584        
003816  004585        
003817  004586        
003818  004587  #CONST
003819  004600  #END
003820  004601        
003821  004602        
003822  004603  #CONST
003823  004625  #END
003824  004626        
003825  004627  //------------------------------------------------------------------------------
003826  004628  //txt_Set() related constants
003827  004629  //------------------------------------------------------------------------------
003828  004630  #CONST
003829  004649  #END
003830  004650        
003831  004651        
003832  004652        
003833  004653  //------------------------------------------------------------------------------
003834  004654  //txt_Set() related arguments
003835  004655  // NB:- FONT4 must be inherited if required,
003836  004656  // eg #inherit "FONT4.fnt"
003837  004657  //------------------------------------------------------------------------------
003838  004658  #CONST
003839  004670  #END
003840  004671        
003841  004672        
003842  004673        
003843  004674  //touch_Set() related constants
003844  004675  #CONST
003845  004679  #END
003846  004680        
003847  004681  //touch_Get() related constants
003848  004682  #CONST
003849  004690  #END
003850  004691        
003851  004692  // image control offset related constants
003852  004693  #CONST
003853  004700  #END
003854  004701        
003855  004702  // image attribute flags
003856  004703  // for img_SetAttributes(...) and img_ClearAttributes(...)
003857  004704  #CONST
003858  004718  #END
003859  004719        
003860  004720        
003861  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003862  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003863  004722        
003864  004723  // image control entry offsets
003865  004724  #CONST
003866  004739  #END
003867  004740        
003868  004741  #CONST
003869  004759  #END
003870  004760        
003871  004761        
003872  004762        
003873  004763        
003874  004764  #CONST
003875  004784  #END
003876  004785        
003877  004786        
003878  004787        
003879  004788  // timer control  related constants
003880  004789  #CONST
003881  004798  #END
003882  004799        
003883  004800  // I2C timing related constants
003884  004801  #CONST
003885  004805  #END
003886  004806        
003887  004807        
003888  004808  // spi_Init(...)  mode arguments
003889  004809  #CONST
003890  004832  #END
003891  004833        
003892  004834  //------------------------------------------------------------------------------
003893  004835  // system WORD variables accesible with peekW and pokeW or pointer access
003894  004836  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
003895  004837  // can also be accessed with peekW and pokeW
003896  004838  //------------------------------------------------------------------------------
003897  004839        
003898  004840  #CONST
003899  004934  #END
003900  004935        
003901  004936  //------------------------------------------------------------------------------
003902  004937  // FILEIO Error Code Constants
003903  004938  //------------------------------------------------------------------------------
003904  004939  #CONST
003905  004965  #END
003906  004966        
003907  004967  //==================================================================================================
003908  004968        
003909  004969        
003910  004970        
003911  000013      #ENDIF
003912  000014        
003913  000015        
003914  000016  //===========================================================================================
003915  000017        
003916  000018        
003917  000002        
003918  000003  //#constant OLDCOMPILE
003919  000004        
003920  000005        
003921  000006        
003922  000007        
003923  000008        
003924  000009  // generated 2/24/2023 2:55:01 PM
003925  000010  // uSDRequired:- 1   InternalRequired:- 1   InherentsInProgFlash:- 0   GciFlashFS:- 1   InherentWidgets:- 0   InternalObjects:- 14   GciFlashFiles:- 1
003926  000011        
003927  000012        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

003928  000013  #inherit "4DGL_16bitColours.fnc"
003929  000013  #inherit "4DGL_16bitColours.fnc"
003930  000004  */
003931  000005        
003932  000006        
003933  000007        
003934  000008  #CONST
003935  000149  #END
003936  000150        
003937  000014        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

003938  000015  #inherit "VisualConst.inc"
003939  000015  #inherit "VisualConst.inc"
003940  000001  // Line Patterns
003941  000002  #constant  LPCOARSE    0xF0F0
003942  000002  #constant  LPCOARSE    0xF0F0
003943  000003  #constant  LPMEDIUM    0x3333
003944  000003  #constant  LPMEDIUM    0x3333
003945  000004  #constant  LPFINE      0xAAAA
003946  000004  #constant  LPFINE      0xAAAA
003947  000005  #constant  LPDASHDOT   0x03CF
003948  000005  #constant  LPDASHDOT   0x03CF
003949  000006  #constant  LPDASHDOTDOT 0x0333
003950  000006  #constant  LPDASHDOTDOT 0x0333
003951  000007  #constant  LPSOLID     0x0000
003952  000007  #constant  LPSOLID     0x0000
003953  000016        
003954  000017        
file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGaugeConst.inc

003955  000018  #inherit "SprinterGaugeConst.inc"
003956  000018  #inherit "SprinterGaugeConst.inc"
003957  000001  // File generated 2/24/2023 2:54:57 PM
003958  000002  // Warning! This is a generated file, any manual changes will be
003959  000003  // lost during the next generation.
003960  000004        
003961  000005  #constant  Strings2Count    1
003962  000005  #constant  Strings2Count    1
003963  000006  #constant  Strings2Size     17
003964  000006  #constant  Strings2Size     17
003965  000007  #constant  Strings0Count    1
003966  000007  #constant  Strings0Count    1
003967  000008  #constant  Strings0Size     22
003968  000008  #constant  Strings0Size     22
003969  000009  #constant  Strings4Count    1
003970  000009  #constant  Strings4Count    1
003971  000010  #constant  Strings4Size     6
003972  000010  #constant  Strings4Size     6
003973  000011  #constant  Strings5Count    1
003974  000011  #constant  Strings5Count    1
003975  000012  #constant  Strings5Size     6
003976  000012  #constant  Strings5Size     6
003977  000013  #constant  Strings7Count    1
003978  000013  #constant  Strings7Count    1
003979  000014  #constant  Strings7Size     14
003980  000014  #constant  Strings7Size     14
003981  000015  #constant  Strings9Count    1
003982  000015  #constant  Strings9Count    1
003983  000016  #constant  Strings9Size     7
003984  000016  #constant  Strings9Size     7
003985  000017  #constant  Strings10Count    1
003986  000017  #constant  Strings10Count    1
003987  000018  #constant  Strings10Size     6
003988  000018  #constant  Strings10Size     6
003989  000019  #constant  Strings11Count    1
003990  000019  #constant  Strings11Count    1
003991  000020  #constant  Strings11Size     15
003992  000020  #constant  Strings11Size     15
003993  000021  #constant  Strings12Count    1
003994  000021  #constant  Strings12Count    1
003995  000022  #constant  Strings12Size     17
003996  000022  #constant  Strings12Size     17
003997  000023  #constant  Strings15Count    1
003998  000023  #constant  Strings15Count    1
003999  000024  #constant  Strings15Size     13
004000  000024  #constant  Strings15Size     13
004001  000025  #constant  Strings16Count    1
004002  000025  #constant  Strings16Count    1
004003  000026  #constant  Strings16Size     13
004004  000026  #constant  Strings16Size     13
004005  000027  #constant  Strings18Count    1
004006  000027  #constant  Strings18Count    1
004007  000028  #constant  Strings18Size     5
004008  000028  #constant  Strings18Size     5
004009  000029  #constant  Strings19Count    1
004010  000029  #constant  Strings19Count    1
004011  000030  #constant  Strings19Size     5
004012  000030  #constant  Strings19Size     5
004013  000031  #constant  Strings20Count    1
004014  000031  #constant  Strings20Count    1
004015  000032  #constant  Strings20Size     5
004016  000032  #constant  Strings20Size     5
004017  000033  #constant  Strings21Count    1
004018  000033  #constant  Strings21Count    1
004019  000034  #constant  Strings21Size     7
004020  000034  #constant  Strings21Size     7
004021  000035  #constant  Strings22Count    1
004022  000035  #constant  Strings22Count    1
004023  000036  #constant  Strings22Size     13
004024  000036  #constant  Strings22Size     13
004025  000037  #constant  Strings23Count    1
004026  000037  #constant  Strings23Count    1
004027  000038  #constant  Strings23Size     7
004028  000038  #constant  Strings23Size     7
004029  000039  #constant  Strings24Count    1
004030  000039  #constant  Strings24Count    1
004031  000040  #constant  Strings24Size     12
004032  000040  #constant  Strings24Size     12
004033  000041  #constant  Strings13Count    1
004034  000041  #constant  Strings13Count    1
004035  000042  #constant  Strings13Size     7
004036  000042  #constant  Strings13Size     7
004037  000043  #constant  Strings14Count    1
004038  000043  #constant  Strings14Count    1
004039  000044  #constant  Strings14Size     16
004040  000044  #constant  Strings14Size     16
004041  000045  #constant  Strings25Count    1
004042  000045  #constant  Strings25Count    1
004043  000046  #constant  Strings25Size     7
004044  000046  #constant  Strings25Size     7
004045  000047  #constant  Strings26Count    1
004046  000047  #constant  Strings26Count    1
004047  000048  #constant  Strings26Size     17
004048  000048  #constant  Strings26Size     17
004049  000049  #constant  Strings17Count    1
004050  000049  #constant  Strings17Count    1
004051  000050  #constant  Strings17Size     5
004052  000050  #constant  Strings17Size     5
004053  000051  #constant  Strings3Count    1
004054  000051  #constant  Strings3Count    1
004055  000052  #constant  Strings3Size     5
004056  000052  #constant  Strings3Size     5
004057  000053  #constant  Strings6Count    1
004058  000053  #constant  Strings6Count    1
004059  000054  #constant  Strings6Size     12
004060  000054  #constant  Strings6Size     12
004061  000055  #constant  Strings27Count    1
004062  000055  #constant  Strings27Count    1
004063  000056  #constant  Strings27Size     3
004064  000056  #constant  Strings27Size     3
004065  000057  #constant  Strings28Count    1
004066  000057  #constant  Strings28Count    1
004067  000058  #constant  Strings28Size     10
004068  000058  #constant  Strings28Size     10
004069  000059  #constant  Strings8Count    1
004070  000059  #constant  Strings8Count    1
004071  000060  #constant  Strings8Size     13
004072  000060  #constant  Strings8Size     13
004073  000061  #constant  Strings29Count    1
004074  000061  #constant  Strings29Count    1
004075  000062  #constant  Strings29Size     5
004076  000062  #constant  Strings29Size     5
004077  000063  #constant  Strings30Count    1
004078  000063  #constant  Strings30Count    1
004079  000064  #constant  Strings30Size     5
004080  000064  #constant  Strings30Size     5
004081  000065  #constant  Strings31Count    1
004082  000065  #constant  Strings31Count    1
004083  000066  #constant  Strings31Size     13
004084  000066  #constant  Strings31Size     13
004085  000067  #constant  Strings1Count    1
004086  000067  #constant  Strings1Count    1
004087  000068  #constant  Strings1Size     12
004088  000068  #constant  Strings1Size     12
004089  000069  #constant  Strings32Count    1
004090  000069  #constant  Strings32Count    1
004091  000070  #constant  Strings32Size     7
004092  000070  #constant  Strings32Size     7
004093  000071  #constant  Strings33Count    1
004094  000071  #constant  Strings33Count    1
004095  000072  #constant  Strings33Size     13
004096  000072  #constant  Strings33Size     13
004097  000073  #constant  IFONT_OFFSET     34
004098  000073  #constant  IFONT_OFFSET     34
004099  000074  // object indexes into WIDGET pointer
004100  000075  #CONST
004101  000090  #END
004102  000091        
004103  000092  // object indexes into ImageControl
004104  000093  #CONST
004105  000123  #END
004106  000124        
004107  000125        
004108  000126  #constant  Strings2StartH   0x0
004109  000126  #constant  Strings2StartH   0x0
004110  000127  #constant  Strings2StartL   0x0
004111  000127  #constant  Strings2StartL   0x0
004112  000128  #constant  Strings0StartH   0x0
004113  000128  #constant  Strings0StartH   0x0
004114  000129  #constant  Strings0StartL   0x200
004115  000129  #constant  Strings0StartL   0x200
004116  000130  #constant  Strings4StartH   0x0
004117  000130  #constant  Strings4StartH   0x0
004118  000131  #constant  Strings4StartL   0x400
004119  000131  #constant  Strings4StartL   0x400
004120  000132  #constant  Strings5StartH   0x0
004121  000132  #constant  Strings5StartH   0x0
004122  000133  #constant  Strings5StartL   0x600
004123  000133  #constant  Strings5StartL   0x600
004124  000134  #constant  Strings7StartH   0x0
004125  000134  #constant  Strings7StartH   0x0
004126  000135  #constant  Strings7StartL   0x800
004127  000135  #constant  Strings7StartL   0x800
004128  000136  #constant  Strings9StartH   0x0
004129  000136  #constant  Strings9StartH   0x0
004130  000137  #constant  Strings9StartL   0xA00
004131  000137  #constant  Strings9StartL   0xA00
004132  000138  #constant  Strings10StartH   0x0
004133  000138  #constant  Strings10StartH   0x0
004134  000139  #constant  Strings10StartL   0xC00
004135  000139  #constant  Strings10StartL   0xC00
004136  000140  #constant  Strings11StartH   0x0
004137  000140  #constant  Strings11StartH   0x0
004138  000141  #constant  Strings11StartL   0xE00
004139  000141  #constant  Strings11StartL   0xE00
004140  000142  #constant  Strings12StartH   0x0
004141  000142  #constant  Strings12StartH   0x0
004142  000143  #constant  Strings12StartL   0x1000
004143  000143  #constant  Strings12StartL   0x1000
004144  000144  #constant  Strings15StartH   0x0
004145  000144  #constant  Strings15StartH   0x0
004146  000145  #constant  Strings15StartL   0x1200
004147  000145  #constant  Strings15StartL   0x1200
004148  000146  #constant  Strings16StartH   0x0
004149  000146  #constant  Strings16StartH   0x0
004150  000147  #constant  Strings16StartL   0x1400
004151  000147  #constant  Strings16StartL   0x1400
004152  000148  #constant  Strings18StartH   0x0
004153  000148  #constant  Strings18StartH   0x0
004154  000149  #constant  Strings18StartL   0x1600
004155  000149  #constant  Strings18StartL   0x1600
004156  000150  #constant  Strings19StartH   0x0
004157  000150  #constant  Strings19StartH   0x0
004158  000151  #constant  Strings19StartL   0x1800
004159  000151  #constant  Strings19StartL   0x1800
004160  000152  #constant  Strings20StartH   0x0
004161  000152  #constant  Strings20StartH   0x0
004162  000153  #constant  Strings20StartL   0x1A00
004163  000153  #constant  Strings20StartL   0x1A00
004164  000154  #constant  Strings21StartH   0x0
004165  000154  #constant  Strings21StartH   0x0
004166  000155  #constant  Strings21StartL   0x1C00
004167  000155  #constant  Strings21StartL   0x1C00
004168  000156  #constant  Strings22StartH   0x0
004169  000156  #constant  Strings22StartH   0x0
004170  000157  #constant  Strings22StartL   0x1E00
004171  000157  #constant  Strings22StartL   0x1E00
004172  000158  #constant  Strings23StartH   0x0
004173  000158  #constant  Strings23StartH   0x0
004174  000159  #constant  Strings23StartL   0x2000
004175  000159  #constant  Strings23StartL   0x2000
004176  000160  #constant  Strings24StartH   0x0
004177  000160  #constant  Strings24StartH   0x0
004178  000161  #constant  Strings24StartL   0x2200
004179  000161  #constant  Strings24StartL   0x2200
004180  000162  #constant  Strings13StartH   0x0
004181  000162  #constant  Strings13StartH   0x0
004182  000163  #constant  Strings13StartL   0x2400
004183  000163  #constant  Strings13StartL   0x2400
004184  000164  #constant  Strings14StartH   0x0
004185  000164  #constant  Strings14StartH   0x0
004186  000165  #constant  Strings14StartL   0x2600
004187  000165  #constant  Strings14StartL   0x2600
004188  000166  #constant  Strings25StartH   0x0
004189  000166  #constant  Strings25StartH   0x0
004190  000167  #constant  Strings25StartL   0x2800
004191  000167  #constant  Strings25StartL   0x2800
004192  000168  #constant  Strings26StartH   0x0
004193  000168  #constant  Strings26StartH   0x0
004194  000169  #constant  Strings26StartL   0x2A00
004195  000169  #constant  Strings26StartL   0x2A00
004196  000170  #constant  Strings17StartH   0x0
004197  000170  #constant  Strings17StartH   0x0
004198  000171  #constant  Strings17StartL   0x2C00
004199  000171  #constant  Strings17StartL   0x2C00
004200  000172  #constant  Strings3StartH   0x0
004201  000172  #constant  Strings3StartH   0x0
004202  000173  #constant  Strings3StartL   0x2E00
004203  000173  #constant  Strings3StartL   0x2E00
004204  000174  #constant  Strings6StartH   0x0
004205  000174  #constant  Strings6StartH   0x0
004206  000175  #constant  Strings6StartL   0x3000
004207  000175  #constant  Strings6StartL   0x3000
004208  000176  #constant  Strings27StartH   0x0
004209  000176  #constant  Strings27StartH   0x0
004210  000177  #constant  Strings27StartL   0x3200
004211  000177  #constant  Strings27StartL   0x3200
004212  000178  #constant  Strings28StartH   0x0
004213  000178  #constant  Strings28StartH   0x0
004214  000179  #constant  Strings28StartL   0x3400
004215  000179  #constant  Strings28StartL   0x3400
004216  000180  #constant  Strings8StartH   0x0
004217  000180  #constant  Strings8StartH   0x0
004218  000181  #constant  Strings8StartL   0x3600
004219  000181  #constant  Strings8StartL   0x3600
004220  000182  #constant  Strings29StartH   0x0
004221  000182  #constant  Strings29StartH   0x0
004222  000183  #constant  Strings29StartL   0x3800
004223  000183  #constant  Strings29StartL   0x3800
004224  000184  #constant  Strings30StartH   0x0
004225  000184  #constant  Strings30StartH   0x0
004226  000185  #constant  Strings30StartL   0x3A00
004227  000185  #constant  Strings30StartL   0x3A00
004228  000186  #constant  Strings31StartH   0x0
004229  000186  #constant  Strings31StartH   0x0
004230  000187  #constant  Strings31StartL   0x3C00
004231  000187  #constant  Strings31StartL   0x3C00
004232  000188  #constant  Strings1StartH   0x0
004233  000188  #constant  Strings1StartH   0x0
004234  000189  #constant  Strings1StartL   0x3E00
004235  000189  #constant  Strings1StartL   0x3E00
004236  000190  #constant  Strings32StartH   0x0
004237  000190  #constant  Strings32StartH   0x0
004238  000191  #constant  Strings32StartL   0x4000
004239  000191  #constant  Strings32StartL   0x4000
004240  000192  #constant  Strings33StartH   0x0
004241  000192  #constant  Strings33StartH   0x0
004242  000193  #constant  Strings33StartL   0x4200
004243  000193  #constant  Strings33StartL   0x4200
004244  000194        
004245  000195  #constant  ffsEndUnits4k    0x0048  // First unused 4k Sector on Flash
004246  000195  #constant  ffsEndUnits4k    0x0048  // First unused 4k Sector on Flash
004247  000196  #constant  ffsEnd4kH        0x0004  // Address of first unused 4k Sector on Flash, High
004248  000196  #constant  ffsEnd4kH        0x0004  // Address of first unused 4k Sector on Flash, High
004249  000197  #constant  ffsEnd4kL        0x8000  // Address of first unused 4k Sector on Flash, Low
004250  000197  #constant  ffsEnd4kL        0x8000  // Address of first unused 4k Sector on Flash, Low
004251  000198  #constant  ffsEndUnits32k   0x0009  // First unused 32k Block on Flash
004252  000198  #constant  ffsEndUnits32k   0x0009  // First unused 32k Block on Flash
004253  000199  #constant  ffsEnd32kH       0x0004  // Address of first unused 32k Block on Flash, High
004254  000199  #constant  ffsEnd32kH       0x0004  // Address of first unused 32k Block on Flash, High
004255  000200  #constant  ffsEnd32kL       0x8000  // Address of first unused 32k Block on Flash, Low
004256  000200  #constant  ffsEnd32kL       0x8000  // Address of first unused 32k Block on Flash, Low
004257  000201  #constant  ffsEndUnits64k   0x0005  // First unused 64k Block on Flash
004258  000201  #constant  ffsEndUnits64k   0x0005  // First unused 64k Block on Flash
004259  000202  #constant  ffsEnd64kH       0x0005  // Address of first unused 64k Block on Flash, High
004260  000202  #constant  ffsEnd64kH       0x0005  // Address of first unused 64k Block on Flash, High
004261  000203  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
004262  000203  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
004263  000204        
004264  000205  #IFNOT EXISTS NOGLOBALS
004265  000206  var hndl ;
004266  000207  #ENDIF
004267  000019        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\CLPrintStringsGciFS.inc

004268  000020  #inherit "CLPrintStringsGciFS.inc"
004269  000020  #inherit "CLPrintStringsGciFS.inc"
004270  000001  func PrintStrings(var ID, var *msgid, var String)
004271  000002      var StringID, i, ch, offs32[2], res32[2] ;
004272  000003      StringID := oStringss[1+ID] ;
004273  000004      if (String)
004274  000005          stringsCV[ID] := -1 ;
004275  000006      else
004276  000007          stringsCV[ID] := msgid ;
004277  000008      endif
004278  000009      if ((StringID == -1) || (*(StringID + Ofs_String_Form) != CurrentForm)) return ;
004279  000010      i := *(StringID + Ofs_String_GciFSFontIdx) ;
004280  000011      if (i < 0)
004281  000012  //to(COM0) ; print("CLP Font Flash ", -1-i, "\n") ;
004282  000013          img_TxtFontID(0xffff, -1-i) ;
004283  000014      else
004284  000015  //to(COM0) ; print("CLP Font Internal ", i, "\n") ;
004285  000016          txt_FontID(i) ;
004286  000017      endif
004287  000018      txt_Attributes(*(StringID + Ofs_String_FontAttribs)) ; // >> 4 fix for r25,6,7,8 PmmC
004288  000019  //    txt_Opacity(*(StringID + STTransparent)) ;
004289  000020        
004290  000021      if (*(StringID + Ofs_String_Transparent))
004291  000022          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), *(StringID + Ofs_String_BGColor));
004292  000023      else if (FormBGcolors[CurrentForm] != ColorBGimage)
004293  000024          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), FormBGcolors[CurrentForm]);
004294  000025      else
004295  000026          gfx_ClipWindow(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2)) ;
004296  000027          gfx_Clipping(ON) ;
004297  000028          img_Show(hndl,FormStartIndex[CurrentForm]) ;
004298  000029          gfx_Clipping(OFF) ;
004299  000030        
004300  000031      endif
004301  000032        
004302  000033      txt_FGcolour(*(StringID + Ofs_String_FGColor)) ;
004303  000034      txt_BGcolour(*(StringID + Ofs_String_BGColor)) ;
004304  000035      txt_Opacity(TRANSPARENT);                // 8  text OPAQUE or TRANSPARENT
004305  000036        
004306  000037      gfx_MoveTo(*(StringID + Ofs_String_x1) , *(StringID + Ofs_String_y1)) ;
004307  000038        
004308  000039      if (String)
004309  000040          i := 0 ;
004310  000041          ch := msgid[i++] ;
004311  000042          while (ch != 0)
004312  000043              putch(ch) ;
004313  000044              ch := msgid[i++] ;
004314  000045          wend
004315  000046      else
004316  000047          umul_1616(offs32, *(StringID + Ofs_String_Size), msgid);
004317  000048          res32[1] := *(StringID + Ofs_String_StartH) ;
004318  000049          res32[0] := *(StringID + Ofs_String_StartL) ;
004319  000050          uadd_3232(res32,res32,offs32) ;
004320  000051          img_FileSeek(hndl, iTextStrings, res32[1], res32[0]);
004321  000052          repeat
004322  000053              if (*(StringID + Ofs_String_Ansi))
004323  000054                  ch := img_FileGetC(hndl, iTextStrings) ;
004324  000055              else
004325  000056                  ch := img_FileGetW(hndl, iTextStrings) ;
004326  000057              endif
004327  000058              putch(ch) ;
004328  000059          until (ch == 0) ;
004329  000060      endif
004330  000061        
004331  000062  endfunc
004332  000063        
004333  000021        
004334  000022  #constant IPDatasize 22
004335  000022  #constant IPDatasize 22
004336  000023        
004337  000024  #CONST
004338  000028  #END
004339  000029        
004340  000030        
004341  000031        
004342  000032  #CONST
004343  000175  #END
004344  000176        
004345  000286  #END
4346  09C6
4347  09C7
4348  09C8
4349  09C9
4350  09CA
4351  09CB
4352  09CC
4353  09CD
4354  09CE
4355  09CF
4356  09D0
4357  09D1
4358  09D2
4359  09D3
4360  09D4
4361  09D5
4362  09D6
4363  09D7
4364  09D8
4365  09D9
4366  09DA
4367  09DB
4368  09DC
4369  09DD
4370  09DE
4371  09DF
4372  09E0
4373  09E1
4374  09E2
4375  09E3
4376  09E4
4377  09E5
4378  09E6
4379  09E7
4380  09E8
4381  09E9
4382  09EA
4383  09EB
4384  09EC
4385  09ED
4386  09EE
4387  09EF
4388  09F0
4389  09F1
4390  09F2
4391  09F3
4392  09F4
4393  09F5
4394  09F6
4395  09F7
4396  09F8
4397  09F9
4398  09FA
4399  09FB
4400  09FC
4401  09FD
4402  09FE
4403  09FF
4404  0A00
4405  0A01
4406  0A02
4407  0A03
4408  0A04
4409  0A05
4410  0A06
4411  0A07
4412  0A08
4413  0A09
4414  0A0A
4415  0A0B
4416  0A0C
4417  0A0D
4418  0A0E
4419  0A0F
4420  0A10
4421  0A11
4422  0A12
4423  0A13
4424  0A14
4425  0A15
4426  0A16
4427  0A17
4428  0A18
4429  0A19
4430  0A1A
4431  0A1B
4432  0A1C
4433  0A1D
4434  0A1E
4435  0A1F
4436  0A20
4437  0A21
4438  0A22
4439  0A23
4440  0A24
4441  0A25
4442  0A26
4443  0A27
4444  0A28
4445  0A29
4446  0A2A
4447  0A2B
4448  0A2C
4449  0A2D
4450  0A2E
4451  0A2F
4452  0A30
4453  0A31
4454  0A32
4455  0A33
4456  0A34
4457  0A35
4458  0A36
4459  0A37
4460  0A38
4461  0A39
4462  0A3A
4463  0A3B
4464  0A3C
4465  0A3D
4466  0A3E
4467  0A3F
4468  0A40
4469  0A41
4470  0A42
4471  0A43
4472  0A44
4473  0A45
4474  0A46
4475  0A47
4476  0A48
4477  0A49
4478  0A4A
4479  0A4B
4480  0A4C
4481  0A4D
4482  0A4E
4483  0A4F
4484  0A50
4485  0A51
4486  0A52
4487  0A53
4488  0A54
4489  0A55
4490  0A56
4491  0A57
4492  0A58
4493  0A59
4494  0A5A
4495  0A5B
4496  0A5C
4497  0A5D
4498  0A5E
4499  0A5F
4500  0A60
4501  0A61
4502  0A62
4503  0A63
4504  0A64
4505  0A65
4506  0A66
4507  0A67
4508  0A68
4509  0A69
4510  0A6A
4511  0A6B
4512  0A6C
4513  0A6D
4514  0A6E
4515  0A6F
4516  0A70
4517  0A71
4518  0A72
4519  0A73
4520  0A74
4521  0A75
4522  0A76
4523  0A77
4524  0A78
4525  0A79
4526  0A7A
4527  0A7B
4528  0A7C
4529  0A7D
4530  0A7E
4531  0A7F
4532  0A80
4533  0A81
4534  0A82
4535  0A83
4536  0A84
4537  0A85
4538  0A86
4539  0A87
4540  0A88
4541  0A89
4542  0A8A
4543  0A8B
4544  0A8C
4545  0A8D
4546  0A8E
4547  0A8F
4548  0A90
4549  0A91
4550  0A92
4551  0A93
4552  0A94
4553  0A95
4554  0A96
4555  0A97
4556  0A98
4557  0A99
4558  0A9A
4559  0A9B
4560  0A9C
4561  0A9D
4562  0A9E
4563  0A9F
4564  0AA0
4565  0AA1
4566  0AA2
4567  0AA3
4568  0AA4
4569  0AA5
4570  0AA6
4571  0AA7
4572  0AA8
4573  0AA9
4574  0AAA
4575  0AAB
4576  0AAC
4577  0AAD
4578  0AAE
4579  0AAF
4580  0AB0
4581  0AB1
4582  0AB2
4583  0AB3
4584  0AB4
4585  0AB5
4586  0AB6
4587  0AB7
4588  0AB8
4589  0AB9
4590  0ABA
4591  0ABB
4592  0ABC
4593  0ABD
4594  0ABE
4595  0ABF
4596  0AC0
4597  0AC1
4598  0AC2
4599  0AC3
4600  0AC4
4601  0AC5
4602  0AC6
4603  0AC7
4604  0AC8
4605  0AC9
4606  0ACA
4607  0ACB
4608  0ACC
4609  0ACD
4610  0ACE
4611  0ACF
4612  0AD0
4613  0AD1
4614  0AD2
4615  0AD3
4616  0AD4
4617  0AD5
4618  0AD6
4619  0AD7
4620  0AD8
4621  0AD9
4622  0ADA
4623  0ADB
4624  0ADC
4625  0ADD
4626  0ADE
4627  0ADF
4628  0AE0
4629  0AE1
4630  0AE2
4631  0AE3
4632  0AE4
4633  0AE5
4634  0AE6
4635  0AE7
4636  0AE8
4637  0AE9
4638  0AEA
4639  0AEB
4640  0AEC
4641  0AED
4642  0AEE
4643  0AEF
4644  0AF0
4645  0AF1
4646  0AF2
4647  0AF3
4648  0AF4
4649  0AF5
4650  0AF6
4651  0AF7
4652  0AF8
4653  0AF9
4654  0AFA
4655  0AFB
4656  0AFC
4657  0AFD
4658  0AFE
4659  0AFF
4660  0B00
4661  0B01
4662  0B02
4663  0B03
4664  0B04
4665  0B05
4666  0B06
4667  0B07
4668  0B08
4669  0B09
4670  0B0A
4671  0B0B
4672  0B0C
4673  0B0D
4674  0B0E
4675  0B0F
4676  0B10
4677  0B11
4678  0B12
4679  0B13
4680  0B14
4681  0B15
4682  0B16
4683  0B17
4684  0B18
4685  0B19
4686  0B1A
4687  0B1B
4688  0B1C
4689  0B1D
4690  0B1E
4691  0B1F
4692  0B20
4693  0B21
4694  0B22
4695  0B23
4696  0B24
4697  0B25
4698  0B26
4699  0B27
4700  0B28
4701  0B29
4702  0B2A
4703  0B2B
4704  0B2C
4705  0B2D
4706  0B2E
4707  0B2F
4708  0B30
4709  0B31
4710  0B32
4711  0B33
4712  0B34
4713  0B35
4714  0B36
4715  0B37
4716  0B38
4717  0B39
4718  0B3A
4719  0B3B
4720  0B3C
4721  0B3D
4722  0B3E
4723  0B3F
4724  0B40
4725  0B41
4726  0B42
4727  0B43
4728  0B44
4729  0B45
4730  0B46
4731  0B47
4732  0B48
4733  0B49
4734  0B4A
4735  0B4B
4736  0B4C
4737  0B4D
4738  0B4E
4739  0B4F
4740  0B50
4741  0B51
4742  0B52
4743  0B53
4744  0B54
4745  0B55
4746  0B56
4747  0B57
4748  0B58
4749  0B59
4750  0B5A
4751  0B5B
4752  0B5C
4753  0B5D
4754  0B5E
4755  0B5F
4756  0B60
4757  0B61
4758  0B62
4759  0B63
4760  0B64
4761  0B65
4762  0B66
4763  0B67
4764  0B68
4765  0B69
4766  0B6A
4767  0B6B
4768  0B6C
4769  0B6D
4770  0B6E
4771  0B6F
4772  0B70
4773  0B71
4774  0B72
4775  0B73
4776  0B74
4777  0B75
4778  0B76
4779  0B77
4780  0B78
4781  0B79
4782  0B7A
4783  0B7B
4784  0B7C
4785  0B7D
4786  0B7E
4787  0B7F
4788  0B80
4789  0B81
4790  0B82
4791  0B83
4792  0B84
4793  0B85
4794  0B86
4795  0B87
4796  0B88
4797  0B89
4798  0B8A
4799  0B8B
4800  0B8C
4801  0B8D
4802  0B8E
4803  0B8F
4804  0B90
4805  0B91
4806  0B92
4807  0B93
4808  0B94
4809  0B95
4810  0B96
4811  0B97
4812  0B98
4813  0B99
4814  0B9A
4815  0B9B
4816  0B9C
4817  0B9D
4818  0B9E
4819  0B9F
4820  0BA0
4821  0BA1
4822  0BA2
4823  0BA3
4824  0BA4
4825  0BA5
4826  0BA6
4827  0BA7
4828  0BA8
4829  0BA9
4830  0BAA
4831  0BAB
4832  0BAC
4833  0BAD
4834  0BAE
4835  0BAF
4836  0BB0
4837  0BB1
4838  0BB2
4839  0BB3
4840  0BB4
4841  0BB5
4842  0BB6
4843  0BB7
4844  0BB8
4845  0BB9
4846  0BBA
4847  0BBB
4848  0BBC
4849  0BBD
4850  0BBE
4851  0BBF
4852  0BC0
4853  0BC1
4854  0BC2
4855  0BC3
4856  0BC4
4857  0BC5
4858  0BC6
4859  0BC7
4860  0BC8
4861  0BC9
4862  0BCA
4863  0BCB
4864  0BCC
4865  0BCD
4866  0BCE
4867  0BCF
4868  0BD0
4869  0BD1
4870  0BD2
4871  0BD3
4872  0BD4
4873  0BD5
4874  0BD6
4875  0BD7
4876  0BD8
4877  0BD9
4878  0BDA
4879  0BDB
4880  0BDC
4881  0BDD
4882  0BDE
4883  0BDF
4884  0BE0
4885  0BE1
4886  0BE2
4887  0BE3
4888  0BE4
4889  0BE5
4890  0BE6
4891  0BE7
4892  0BE8
4893  0BE9
4894  0BEA
4895  0BEB
4896  0BEC
4897  0BED
4898  0BEE
4899  0BEF
4900  0BF0
4901  0BF1
4902  0BF2
4903  0BF3
4904  0BF4
4905  0BF5
4906  0BF6
4907  0BF7
4908  0BF8
4909  0BF9
4910  0BFA
4911  0BFB
4912  0BFC
4913  0BFD
4914  0BFE
4915  0BFF
4916  0C00
4917  0C01
4918  0C02
4919  0C03
4920  0C04
4921  0C05
4922  0C06
4923  0C07
4924  0C08
4925  0C09
4926  0C0A
4927  0C0B
4928  0C0C
4929  0C0D
4930  0C0E
4931  0C0F
4932  0C10
4933  0C11
4934  0C12
4935  0C13
4936  0C14
4937  0C15
4938  0C16
4939  0C17
4940  0C18
4941  0C19
4942  0C1A
4943  0C1B
4944  0C1C
4945  0C1D
4946  0C1E
4947  0C1F
4948  0C20
4949  0C21
4950  0C22
4951  0C23
4952  0C24
4953  0C25
4954  0C26
4955  0C27
4956  0C28
4957  0C29
4958  0C2A
4959  0C2B
4960  0C2C
4961  0C2D
4962  0C2E
4963  0C2F
4964  0C30
4965  0C31
4966  0C32
4967  0C33
4968  0C34
4969  0C35
4970  0C36
4971  0C37
4972  0C38
4973  0C39
4974  0C3A
4975  0C3B
4976  0C3C
4977  0C3D
4978  0C3E
4979  0C3F
4980  0C40
4981  0C41
4982  0C42
4983  0C43
4984  0C44
4985  0C45
4986  0C46
4987  0C47
4988  0C48
4989  0C49
4990  0C4A
4991  0C4B
4992  0C4C
4993  0C4D
4994  0C4E
4995  0C4F
4996  0C50
4997  0C51
4998  0C52
4999  0C53
5000  0C54
5001  0C55
5002  0C56
5003  0C57
5004  0C58
5005  0C59
5006  0C5A
5007  0C5B
5008  0C5C
5009  0C5D
5010  0C5E
5011  0C5F
5012  0C60
5013  0C61
5014  0C62
5015  0C63
5016  0C64
5017  0C65
5018  0C66
5019  0C67
5020  0C68
5021  0C69
5022  0C6A
5023  0C6B
5024  0C6C
5025  0C6D
5026  0C6E
5027  0C6F
5028  0C70
5029  0C71
5030  0C72
5031  0C73
5032  0C74
5033  0C75
5034  0C76
5035  0C77
5036  0C78
5037  0C79
5038  0C7A
5039  0C7B
5040  0C7C
5041  0C7D
5042  0C7E
5043  0C7F
5044  0C80
5045  0C81
5046  0C82
5047  0C83
5048  0C84
5049  0C85
5050  0C86
5051  0C87
5052  0C88
5053  0C89
5054  0C8A
5055  0C8B
5056  0C8C
5057  0C8D
5058  0C8E
5059  0C8F
5060  0C90
5061  0C91
5062  0C92
5063  0C93
5064  0C94
5065  0C95
5066  0C96
5067  0C97
5068  0C98
5069  0C99
5070  0C9A
5071  0C9B
5072  0C9C
5073  0C9D
5074  0C9E
5075  0C9F
5076  0CA0
5077  0CA1
5078  0CA2
5079  0CA3
5080  0CA4
5081  0CA5
5082  0CA6
5083  0CA7
5084  0CA8
5085  0CA9
5086  0CAA
5087  0CAB
5088  0CAC
5089  0CAD
5090  0CAE
5091  0CAF
5092  0CB0
5093  0CB1
5094  0CB2
5095  0CB3
5096  0CB4
5097  0CB5
5098  0CB6
5099  0CB7
5100  0CB8
5101  0CB9
5102  0CBA
5103  0CBB
5104  0CBC
5105  0CBD
5106  0CBE
5107  0CBF
5108  0CC0
5109  0CC1
5110  0CC2
5111  0CC3
5112  0CC4
5113  0CC5
5114  0CC6
5115  0CC7
5116  0CC8
5117  0CC9
5118  0CCA
5119  0CCB
5120  0CCC
5121  0CCD
5122  0CCE
5123  0CCF
5124  0CD0
5125  0CD1
5126  0CD2
5127  0CD3
5128  0CD4
5129  0CD5
5130  0CD6
5131  0CD7
5132  0CD8
5133  0CD9
5134  0CDA
5135  0CDB
5136  0CDC
5137  0CDD
5138  0CDE
5139  0CDF
5140  0CE0
5141  0CE1
5142  0CE2
5143  0CE3
5144  0CE4
5145  0CE5
5146  0CE6
5147  0CE7
5148  0CE8
5149  0CE9
5150  0CEA
5151  0CEB
5152  0CEC
5153  0CED
5154  0CEE
5155  0CEF
5156  0CF0
5157  0CF1
5158  0CF2
5159  0CF3
5160  0CF4
5161  0CF5
5162  0CF6
5163  0CF7
5164  0CF8
5165  0CF9
5166  0CFA
5167  0CFB
5168  0CFC
5169  0CFD
5170  0CFE
5171  0CFF
5172  0D00
5173  0D01
5174  0D02
5175  0D03
5176  0D04
5177  0D05
5178  0D06
5179  0D07
5180  0D08
5181  0D09
5182  0D0A
5183  0D0B
5184  0D0C
5185  0D0D
5186  0D0E
5187  0D0F
5188  0D10
5189  0D11
5190  0D12
5191  0D13
5192  0D14
5193  0D15
5194  0D16
5195  0D17
5196  0D18
5197  0D19
5198  0D1A
5199  0D1B
5200  0D1C
5201  0D1D
5202  0D1E
5203  0D1F
5204  0D20
5205  0D21
5206  0D22
5207  0D23
5208  0D24
5209  0D25
5210  0D26
5211  0D27
5212  0D28
5213  0D29
5214  0D2A
5215  0D2B
5216  0D2C
5217  0D2D
5218  0D2E
5219  0D2F
5220  0D30
5221  0D31
5222  0D32
5223  0D33
5224  0D34
5225  0D35
5226  0D36
5227  0D37
5228  0D38
5229  0D39
5230  0D3A
5231  0D3B
5232  0D3C
5233  0D3D
5234  0D3E
5235  0D3F
5236  0D40
5237  0D41
5238  0D42
5239  0D43
5240  0D44
5241  0D45
5242  0D46
5243  0D47
5244  0D48
5245  0D49
5246  0D4A
5247  0D4B
5248  0D4C
5249  0D4D
5250  0D4E
5251  0D4F
5252  0D50
5253  0D51
5254  0D52
5255  0D53
5256  0D54
5257  0D55
5258  0D56
5259  0D57
5260  0D58
5261  0D59
5262  0D5A
5263  0D5B
5264  0D5C
5265  0D5D
5266  0D5E
5267  0D5F
5268  0D60
5269  0D61
5270  0D62
5271  0D63
5272  0D64
5273  0D65
5274  0D66
5275  0D67
5276  0D68
5277  0D69
5278  0D6A
5279  0D6B
5280  0D6C
5281  0D6D
5282  0D6E
5283  0D6F
5284  0D70
5285  0D71
5286  0D72
5287  0D73
5288  0D74
5289  0D75
5290  0D76
5291  0D77
5292  0D78
5293  0D79
5294  0D7A
5295  0D7B
5296  0D7C
5297  0D7D
5298  0D7E
5299  0D7F
5300  0D80
5301  0D81
5302  0D82
5303  0D83
5304  0D84
5305  0D85
5306  0D86
5307  0D87
5308  0D88
5309  0D89
5310  0D8A
5311  0D8B
5312  0D8C
5313  0D8D
5314  0D8E
5315  0D8F
5316  0D90
5317  0D91
5318  0D92
5319  0D93
5320  0D94
5321  0D95
5322  0D96
5323  0D97
5324  0D98
5325  0D99
5326  0D9A
5327  0D9B
5328  0D9C
5329  0D9D
5330  0D9E
5331  0D9F
5332  0DA0
5333  0DA1
5334  0DA2
5335  0DA3
5336  0DA4
5337  0DA5
5338  0DA6
5339  0DA7
5340  0DA8
5341  0DA9
5342  0DAA
5343  0DAB
5344  0DAC
5345  0DAD
5346  0DAE
5347  0DAF
5348  0DB0
5349  0DB1
5350  0DB2
5351  0DB3
5352  0DB4
5353  0DB5
5354  0DB6
5355  0DB7
5356  0DB8
5357  0DB9
5358  0DBA
5359  0DBB
5360  0DBC
5361  0DBD
5362  0DBE
5363  0DBF
5364  0DC0
5365  0DC1
5366  0DC2
5367  0DC3
5368  0DC4
5369  0DC5
5370  0DC6
5371  0DC7
5372  0DC8
5373  0DC9
5374  0DCA
5375  0DCB
5376  0DCC
5377  0DCD
5378  0DCE
5379  0DCF
5380  0DD0
5381  0DD1
5382  0DD2
5383  0DD3
5384  0DD4
5385  0DD5
5386  0DD6
5387  0DD7
5388  0DD8
5389  0DD9
5390  0DDA
5391  0DDB
5392  0DDC
5393  0DDD
5394  0DDE
5395  0DDF
5396  0DE0
5397  0DE1
5398  0DE2
5399  0DE3
5400  0DE4
5401  0DE5
5402  0DE6
5403  0DE7
5404  0DE8
5405  0DE9
5406  0DEA
5407  0DEB
5408  0DEC
5409  0DED
5410  0DEE
5411  0DEF
5412  0DF0
5413  0DF1
5414  0DF2
5415  0DF3
5416  0DF4
5417  0DF5
5418  0DF6
5419  0DF7
5420  0DF8
5421  0DF9
5422  0DFA
5423  0DFB
5424  0DFC
5425  0DFD
5426  0DFE
5427  0DFF
5428  0E00
5429  0E01
5430  0E02
5431  0E03
5432  0E04
5433  0E05
5434  0E06
5435  0E07
5436  0E08
5437  0E09
5438  0E0A
5439  0E0B
5440  0E0C
5441  0E0D
5442  0E0E
5443  0E0F
5444  0E10
5445  0E11
5446  0E12
5447  0E13
5448  0E14
5449  0E15
5450  0E16
5451  0E17
5452  0E18
5453  0E19
5454  0E1A
5455  0E1B
5456  0E1C
5457  0E1D
5458  0E1E
5459  0E1F
5460  0E20
5461  0E21
5462  0E22
5463  0E23
5464  0E24
5465  0E25
5466  0E26
5467  0E27
5468  0E28
5469  0E29
5470  0E2A
5471  0E2B
5472  0E2C
5473  0E2D
5474  0E2E
5475  0E2F
5476  0E30
5477  0E31
5478  0E32
5479  0E33
5480  0E34
5481  0E35
5482  0E36
5483  0E37
5484  0E38
5485  0E39
5486  0E3A
5487  0E3B
5488  0E3C
5489  0E3D
5490  0E3E
5491  0E3F
5492  0E40
5493  0E41
5494  0E42
5495  0E43
5496  0E44
5497  0E45
5498  0E46
5499  0E47
5500  0E48
5501  0E49
5502  0E4A
5503  0E4B
5504  0E4C
5505  0E4D
5506  0E4E
5507  0E4F
5508  0E50
5509  0E51
5510  0E52
5511  0E53
5512  0E54
5513  0E55
5514  0E56
5515  0E57
5516  0E58
5517  0E59
5518  0E5A
5519  0E5B
5520  0E5C
5521  0E5D
5522  0E5E
5523  0E5F
5524  0E60
5525  0E61
5526  0E62
5527  0E63
5528  0E64
5529  0E65
5530  0E66
5531  0E67
5532  0E68
5533  0E69
5534  0E6A
5535  0E6B
5536  0E6C
5537  0E6D
5538  0E6E
5539  0E6F
5540  0E70
5541  0E71
5542  0E72
5543  0E73
5544  0E74
5545  0E75
5546  0E76
5547  0E77
5548  0E78
5549  0E79
5550  0E7A
5551  0E7B
5552  0E7C
5553  0E7D
5554  0E7E
5555  0E7F
5556  0E80
5557  0E81
5558  0E82
5559  0E83
5560  0E84
5561  0E85
5562  0E86
5563  0E87
5564  0E88
5565  0E89
5566  0E8A
5567  0E8B
5568  0E8C
5569  0E8D
5570  0E8E
5571  0E8F
5572  0E90
5573  0E91
5574  0E92
5575  0E93
5576  0E94
5577  0E95
5578  0E96
5579  0E97
5580  0E98
5581  0E99
5582  0E9A
5583  0E9B
5584  0E9C
5585  0E9D
5586  0E9E
5587  0E9F
5588  0EA0
5589  0EA1
5590  0EA2
5591  0EA3
5592  0EA4
5593  0EA5
5594  0EA6
5595  0EA7
5596  0EA8
5597  0EA9
5598  0EAA
5599  0EAB
5600  0EAC
5601  0EAD
5602  0EAE
5603  0EAF
5604  0EB0
5605  0EB1
5606  0EB2
5607  0EB3
5608  0EB4
5609  0EB5
5610  0EB6
5611  0EB7
5612  0EB8
5613  0EB9
5614  0EBA
5615  0EBB
5616  0EBC
5617  0EBD
5618  0EBE
5619  0EBF
5620  0EC0
5621  0EC1
5622  0EC2
5623  0EC3
5624  0EC4
5625  0EC5
5626  0EC6
5627  0EC7
5628  0EC8
5629  0EC9
5630  0ECA
5631  0ECB
5632  0ECC
5633  0ECD
5634  0ECE
5635  0ECF
5636  0ED0
5637  0ED1
5638  0ED2
5639  0ED3
5640  0ED4
5641  0ED5
5642  0ED6
5643  0ED7
5644  0ED8
5645  0ED9
5646  0EDA
5647  0EDB
5648  0EDC
5649  0EDD
5650  0EDE
5651  0EDF
5652  0EE0
5653  0EE1
5654  0EE2
5655  0EE3
5656  0EE4
5657  0EE5
5658  0EE6
5659  0EE7
5660  0EE8
5661  0EE9
5662  0EEA
5663  0EEB
5664  0EEC
5665  0EED
5666  0EEE
5667  0EEF
5668  0EF0
5669  0EF1
5670  0EF2
5671  0EF3
5672  0EF4
5673  0EF5
5674  0EF6
5675  0EF7
5676  0EF8
5677  0EF9
5678  0EFA
5679  0EFB
5680  0EFC
5681  0EFD
5682  0EFE
5683  0EFF
5684  0F00
5685  0F01
5686  0F02
5687  0F03
5688  0F04
5689  0F05
5690  0F06
5691  0F07
5692  0F08
5693  0F09
5694  0F0A
5695  0F0B
5696  0F0C
5697  0F0D
5698  0F0E
5699  0F0F
5700  0F10
5701  0F11
5702  0F12
5703  0F13
5704  0F14
5705  0F15
5706  0F16
5707  0F17
5708  0F18
5709  0F19
5710  0F1A
5711  0F1B
5712  0F1C
5713  0F1D
5714  0F1E
5715  0F1F
5716  0F20
5717  0F21
5718  0F22
5719  0F23
5720  0F24
5721  0F25
5722  0F26
5723  0F27
5724  0F28
5725  0F29
5726  0F2A
5727  0F2B
5728  0F2C
5729  0F2D
5730  0F2E
5731  0F2F
5732  0F30
5733  0F31
5734  0F32
5735  0F33
5736  0F34
5737  0F35
5738  0F36
5739  0F37
5740  0F38
5741  0F39
5742  0F3A
5743  0F3B
5744  0F3C
5745  0F3D
5746  0F3E
5747  0F3F
5748  0F40
5749  0F41
5750  0F42
5751  0F43
5752  0F44
5753  0F45
5754  0F46
5755  0F47
5756  0F48
5757  0F49
5758  0F4A
5759  0F4B
5760  0F4C
5761  0F4D
5762  0F4E
5763  0F4F
5764  0F50
5765  0F51
5766  0F52
5767  0F53
5768  0F54
5769  0F55
5770  0F56
5771  0F57
5772  0F58
5773  0F59
5774  0F5A
5775  0F5B
5776  0F5C
5777  0F5D
5778  0F5E
5779  0F5F
5780  0F60
5781  0F61
5782  0F62
5783  0F63
5784  0F64
5785  0F65
5786  0F66
5787  0F67
5788  0F68
5789  0F69
5790  0F6A
5791  0F6B
5792  0F6C
5793  0F6D
5794  0F6E
5795  0F6F
5796  0F70
5797  0F71
5798  0F72
5799  0F73
5800  0F74
5801  0F75
5802  0F76
5803  0F77
5804  0F78
5805  0F79
5806  0F7A
5807  0F7B
5808  0F7C
5809  0F7D
5810  0F7E
5811  0F7F
5812  0F80
5813  0F81
5814  0F82
5815  0F83
5816  0F84
5817  0F85
5818  0F86
5819  0F87
5820  0F88
5821  0F89
5822  0F8A
5823  0F8B
5824  0F8C
5825  0F8D
5826  0F8E
5827  0F8F
5828  0F90
5829  0F91
5830  0F92
5831  0F93
5832  0F94
5833  0F95
5834  0F96
5835  0F97
5836  0F98
5837  0F99
5838  0F9A
5839  0F9B
5840  0F9C
5841  0F9D
5842  0F9E
5843  0F9F
5844  0FA0
5845  0FA1
5846  0FA2
5847  0FA3
5848  0FA4
5849  0FA5
5850  0FA6
5851  0FA7
5852  0FA8
5853  0FA9
5854  0FAA
5855  0FAB
5856  0FAC
5857  0FAD
5858  0FAE
5859  0FAF
5860  0FB0
5861  0FB1
5862  0FB2
5863  0FB3
5864  0FB4
5865  0FB5
5866  0FB6
5867  0FB7
5868  0FB8
5869  0FB9
5870  0FBA
5871  0FBB
5872  0FBC
5873  0FBD
5874  0FBE
5875  0FBF
5876  0FC0
5877  0FC1
5878  0FC2
5879  0FC3
5880  0FC4
5881  0FC5
5882  0FC6
5883  0FC7
5884  0FC8
5885  0FC9
5886  0FCA
5887  0FCB
5888  0FCC
5889  0FCD
5890  0FCE
5891  0FCF
5892  0FD0
5893  0FD1
5894  0FD2
5895  0FD3
5896  0FD4
5897  0FD5
5898  0FD6
5899  0FD7
5900  0FD8
5901  0FD9
5902  0FDA
5903  0FDB
5904  0FDC
5905  0FDD
5906  0FDE
5907  0FDF
5908  0FE0
5909  0FE1
5910  0FE2
5911  0FE3
5912  0FE4
5913  0FE5
5914  0FE6
5915  0FE7
5916  0FE8
5917  0FE9
5918  0FEA
5919  0FEB
5920  0FEC
5921  0FED
5922  0FEE
5923  0FEF
5924  0FF0
5925  0FF1
5926  0FF2
5927  0FF3
5928  0FF4
5929  0FF5
5930  0FF6
5931  0FF7
5932  0FF8
5933  0FF9
5934  0FFA
5935  0FFB
5936  0FFC
5937  0FFD
5938  0FFE
5939  0FFF
5940  1000
5941  1001
5942  1002
5943  1003
5944  1004
5945  1005
5946  1006
5947  1007
5948  1008
5949  1009
5950  100A
5951  100B
5952  100C
5953  100D
5954  100E
5955  100F
5956  1010
5957  1011
5958  1012
5959  1013
5960  1014
5961  1015
5962  1016
5963  1017
5964  1018
5965  1019
5966  101A
5967  101B
5968  101C
5969  101D
5970  101E
5971  101F
5972  1020
5973  1021
5974  1022
5975  1023
5976  1024
5977  1025
5978  1026
5979  1027
5980  1028
5981  1029
5982  102A
5983  102B
5984  102C
5985  102D
5986  102E
5987  102F
5988  1030
5989  1031
5990  1032
5991  1033
5992  1034
5993  1035
5994  1036
5995  1037
5996  1038
5997  1039
5998  103A
5999  103B
6000  103C
6001  103D
6002  103E
6003  103F
6004  1040
6005  1041
6006  1042
6007  1043
6008  1044
6009  1045
6010  1046
6011  1047
6012  1048
6013  1049
6014  104A
6015  104B
6016  104C
6017  104D
6018  104E
6019  104F
6020  1050
6021  1051
6022  1052
6023  1053
6024  1054
6025  1055
6026  1056
6027  1057
6028  1058
6029  1059
6030  105A
6031  105B
6032  105C
6033  105D
6034  105E
6035  105F
6036  1060
6037  1061
6038  1062
6039  1063
6040  1064
6041  1065
6042  1066
6043  1067
6044  1068
6045  1069
6046  106A
6047  106B
6048  106C
6049  106D
6050  106E
6051  106F
6052  1070
6053  1071
6054  1072
6055  1073
6056  1074
6057  1075
6058  1076
6059  1077
6060  1078
6061  1079
6062  107A
6063  107B
6064  107C
6065  107D
6066  107E
6067  107F
6068  1080
6069  1081
6070  1082
6071  1083
6072  1084
6073  1085
6074  1086
6075  1087
6076  1088
6077  1089
6078  108A
6079  108B
6080  108C
6081  108D
6082  108E
6083  108F
6084  1090
6085  1091
6086  1092
6087  1093
6088  1094
6089  1095
6090  1096
6091  1097
6092  1098
6093  1099
6094  109A
6095  109B
6096  109C
6097  109D
6098  109E
6099  109F
6100  10A0
6101  10A1
6102  10A2
6103  10A3
6104  10A4
6105  10A5
6106  10A6
6107  10A7
6108  10A8
6109  10A9
6110  10AA
6111  10AB
6112  10AC
6113  10AD
6114  10AE
6115  10AF
6116  10B0
6117  10B1
6118  10B2
6119  10B3
6120  10B4
6121  10B5
6122  10B6
6123  10B7
6124  10B8
6125  10B9
6126  10BA
6127  10BB
6128  10BC
6129  10BD
6130  10BE
6131  10BF
6132  10C0
6133  10C1
6134  10C2
6135  10C3
6136  10C4
6137  10C5
6138  10C6
6139  10C7
6140  10C8
6141  10C9
6142  10CA
6143  10CB
6144  10CC
6145  10CD
6146  10CE
6147  10CF
6148  10D0
6149  10D1
6150  10D2
6151  10D3
6152  10D4
6153  10D5
6154  10D6
6155  10D7
6156  10D8
6157  10D9
6158  10DA
6159  10DB
6160  10DC
6161  10DD
6162  10DE
6163  10DF
6164  10E0
6165  10E1
6166  10E2
6167  10E3
6168  10E4
6169  10E5
6170  10E6
6171  10E7
6172  10E8
6173  10E9
6174  10EA
6175  10EB
6176  10EC
6177  10ED
6178  10EE
6179  10EF
6180  10F0
6181  10F1
6182  10F2
6183  10F3
6184  10F4
6185  10F5
6186  10F6
6187  10F7
6188  10F8
6189  10F9
6190  10FA
6191  10FB
6192  10FC
6193  10FD
6194  10FE
6195  10FF
6196  1100
6197  1101
6198  1102
6199  1103
6200  1104
6201  1105
6202  1106
6203  1107
6204  1108
6205  1109
6206  110A
6207  110B
6208  110C
6209  110D
6210  110E
6211  110F
6212  1110
6213  1111
6214  1112
6215  1113
6216  1114
6217  1115
6218  1116
6219  1117
6220  1118
6221  1119
6222  111A
6223  111B
6224  111C
6225  111D
6226  111E
6227  111F
6228  1120
6229  1121
6230  1122
6231  1123
6232  1124
6233  1125
6234  1126
6235  1127
6236  1128
6237  1129
6238  112A
6239  112B
6240  112C
6241  112D
6242  112E
6243  112F
6244  1130
6245  1131
6246  1132
6247  1133
6248  1134
6249  1135
6250  1136
6251  1137
6252  1138
6253  1139
6254  113A
6255  113B
6256  113C
6257  113D
6258  113E
6259  113F
6260  1140
6261  1141
6262  1142
6263  1143
6264  1144
6265  1145
6266  1146
6267  1147
6268  1148
6269  1149
6270  114A
6271  114B
6272  114C
6273  114D
6274  114E
6275  114F
6276  1150
6277  1151
6278  1152
6279  1153
6280  1154
6281  1155
6282  1156
6283  1157
6284  1158
6285  1159
6286  115A
6287  115B
6288  115C
6289  115D
6290  115E
6291  115F
6292  1160
6293  1161
6294  1162
6295  1163
6296  1164
6297  1165
6298  1166
6299  1167
6300  1168
6301  1169
6302  116A
6303  116B
6304  116C
6305  116D
6306  116E
6307  116F
6308  1170
6309  1171
6310  1172
6311  1173
6312  1174
6313  1175
6314  1176
6315  1177
6316  1178
6317  1179
6318  117A
6319  117B
6320  117C
6321  117D
6322  117E
6323  117F
6324  1180
6325  1181
6326  1182
6327  1183
6328  1184
6329  1185
6330  1186
6331  1187
6332  1188
6333  1189
6334  118A
6335  118B
6336  118C
6337  118D
6338  118E
6339  118F
6340  1190
6341  1191
6342  1192
6343  1193
6344  1194
6345  1195
6346  1196
6347  1197
6348  1198
6349  1199
6350  119A
6351  119B
6352  119C
6353  119D
6354  119E
6355  119F
6356  11A0
6357  11A1
6358  11A2
6359  11A3
6360  11A4
6361  11A5
6362  11A6
6363  11A7
6364  11A8
6365  11A9
6366  11AA
6367  11AB
6368  11AC
6369  11AD
6370  11AE
6371  11AF
6372  11B0
6373  11B1
6374  11B2
6375  11B3
6376  11B4
6377  11B5
6378  11B6
6379  11B7
6380  11B8
6381  11B9
6382  11BA
6383  11BB
6384  11BC
6385  11BD
6386  11BE
6387  11BF
6388  11C0
6389  11C1
6390  11C2
6391  11C3
6392  11C4
6393  11C5
6394  11C6
6395  11C7
6396  11C8
6397  11C9
6398  11CA
6399  11CB
6400  11CC
6401  11CD
6402  11CE
6403  11CF
6404  11D0
6405  11D1
6406  11D2
6407  11D3
6408  11D4
6409  11D5
6410  11D6
6411  11D7
6412  11D8
6413  11D9
6414  11DA
6415  11DB
6416  11DC
6417  11DD
6418  11DE
6419  11DF
6420  11E0
6421  11E1
6422  11E2
6423  11E3
6424  11E4
6425  11E5
6426  11E6
6427  11E7
6428  11E8
6429  11E9
6430  11EA
6431  11EB
6432  11EC
6433  11ED
6434  11EE
6435  11EF
6436  11F0
6437  11F1
6438  11F2
6439  11F3
6440  11F4
6441  11F5
6442  11F6
6443  11F7
6444  11F8
6445  11F9
6446  11FA
6447  11FB
6448  11FC
6449  11FD
6450  11FE
6451  11FF
6452  1200
6453  1201
6454  1202
6455  1203
6456  1204
6457  1205
6458  1206
6459  1207
6460  1208
6461  1209
6462  120A
6463  120B
6464  120C
6465  120D
6466  120E
6467  120F
6468  1210
6469  1211
6470  1212
6471  1213
6472  1214
6473  1215
6474  1216
6475  1217
6476  1218
6477  1219
6478  121A
6479  121B
6480  121C
6481  121D
6482  121E
6483  121F
6484  1220
6485  1221
6486  1222
6487  1223
6488  1224
6489  1225
6490  1226
6491  1227
6492  1228
6493  1229
6494  122A
6495  122B
6496  122C
6497  122D
6498  122E
6499  122F
6500  1230
6501  1231
6502  1232
6503  1233
6504  1234
6505  1235
6506  1236
6507  1237
6508  1238
6509  1239
6510  123A
6511  123B
6512  123C
6513  123D
6514  123E
6515  123F
6516  1240
6517  1241
6518  1242
6519  1243
6520  1244
6521  1245
6522  1246
6523  1247
6524  1248
6525  1249
6526  124A
6527  124B
6528  124C
6529  124D
6530  124E
6531  124F
6532  1250
6533  1251
6534  1252
6535  1253
6536  1254
6537  1255
6538  1256
6539  1257
6540  1258
6541  1259
6542  125A
6543  125B
6544  125C
6545  125D
6546  125E
6547  125F
6548  1260
6549  1261
6550  1262
6551  1263
6552  1264
6553  1265
6554  1266
6555  1267
6556  1268
6557  1269
6558  126A
6559  126B
6560  126C
6561  126D
6562  126E
6563  126F
6564  1270
6565  1271
6566  1272
6567  1273
6568  1274
6569  1275
6570  1276
6571  1277
6572  1278
6573  1279
6574  127A
6575  127B
6576  127C
6577  127D
6578  127E
6579  127F
6580  1280
6581  1281
6582  1282
6583  1283
6584  1284
6585  1285
6586  1286
6587  1287
6588  1288
6589  1289
6590  128A
6591  128B
6592  128C
6593  128D
6594  128E
6595  128F
6596  1290
6597  1291
6598  1292
6599  1293
6600  1294
6601  1295
6602  1296
6603  1297
6604  1298
6605  1299
6606  129A
6607  129B
6608  129C
6609  129D
6610  129E
6611  129F
6612  12A0
6613  12A1
6614  12A2
6615  12A3
6616  12A4
6617  12A5
6618  12A6
6619  12A7
6620  12A8
6621  12A9
6622  12AA
6623  12AB
6624  12AC
6625  12AD
6626  12AE
6627  12AF
6628  12B0
6629  12B1
6630  12B2
6631  12B3
6632  12B4
6633  12B5
6634  12B6
6635  12B7
6636  12B8
6637  12B9
6638  12BA
6639  12BB
6640  12BC
6641  12BD
6642  12BE
6643  12BF
6644  12C0
6645  12C1
6646  12C2
6647  12C3
6648  12C4
6649  12C5
6650  12C6
6651  12C7
6652  12C8
6653  12C9
6654  12CA
6655  12CB
6656  12CC
6657  12CD
6658  12CE
6659  12CF
6660  12D0
6661  12D1
6662  12D2
6663  12D3
6664  12D4
6665  12D5
6666  12D6
6667  12D7
6668  12D8
6669  12D9
6670  12DA
6671  12DB
6672  12DC
6673  12DD
6674  12DE
6675  12DF
6676  12E0
6677  12E1
6678  12E2
6679  12E3
6680  12E4
6681  12E5
6682  12E6
6683  12E7
6684  12E8
6685  12E9
6686  12EA
6687  12EB
6688  12EC
6689  12ED
6690  12EE
6691  12EF
6692  12F0
6693  12F1
6694  12F2
6695  12F3
6696  12F4
6697  12F5
6698  12F6
6699  12F7
6700  12F8
6701  12F9
6702  12FA
6703  12FB
6704  12FC
6705  12FD
6706  12FE
6707  12FF
6708  1300
6709  1301
6710  1302
6711  1303
6712  1304
6713  1305
6714  1306
6715  1307
6716  1308
6717  1309
6718  130A
6719  130B
6720  130C
6721  130D
6722  130E
6723  130F
6724  1310
6725  1311
6726  1312
6727  1313
6728  1314
6729  1315
6730  1316
6731  1317
6732  1318
6733  1319
6734  131A
6735  131B
6736  131C
6737  131D
6738  131E
6739  131F
6740  1320
6741  1321
6742  1322
6743  1323
6744  1324
6745  1325
6746  1326
6747  1327
6748  1328
6749  1329
6750  132A
6751  132B
6752  132C
6753  132D
6754  132E
6755  132F
6756  1330
6757  1331
6758  1332
6759  1333
6760  1334
6761  1335
6762  1336
6763  1337
6764  1338
6765  1339
6766  133A
6767  133B
6768  133C
6769  133D
6770  133E
6771  133F
6772  1340
6773  1341
6774  1342
6775  1343
6776  1344
6777  1345
6778  1346
6779  1347
6780  1348
6781  1349
6782  134A
6783  134B
6784  134C
6785  134D
6786  134E
6787  134F
6788  1350
6789  1351
6790  1352
6791  1353
6792  1354
6793  1355
6794  1356
6795  1357
6796  1358
6797  1359
6798  135A
6799  135B
6800  135C
6801  135D
6802  135E
6803  135F
6804  1360
6805  1361
6806  1362
6807  1363
6808  1364
6809  1365
6810  1366
6811  1367
6812  1368
6813  1369
6814  136A
6815  136B
6816  136C
6817  136D
6818  136E
6819  136F
6820  1370
6821  1371
6822  1372
6823  1373
6824  1374
6825  1375
6826  1376
6827  1377
6828  1378
6829  1379
6830  137A
6831  137B
6832  137C
6833  137D
6834  137E
6835  137F
6836  1380
6837  1381
6838  1382
6839  1383
6840  1384
6841  1385
006842  000287        
006843  000288      var vIAngularMeter0[WIDGET_RAM_SPACE] ;
006844  000289      var vIAngularMeter1[WIDGET_RAM_SPACE] ;
006845  000290      var vIAngularMeter3[WIDGET_RAM_SPACE] ;
006846  000291      var vILedDigits1[WIDGET_RAM_SPACE+2] ;
006847  000292      var vILedDigits2[WIDGET_RAM_SPACE+2] ;
006848  000293      var vILedDigits3[WIDGET_RAM_SPACE+2] ;
006849  000294      var vIAngularMeter2[WIDGET_RAM_SPACE] ;
006850  000295      var vILedDigits4[WIDGET_RAM_SPACE+2] ;
006851  000296      var vILedDigits6[WIDGET_RAM_SPACE+2] ;
006852  000297      var vILedDigits7[WIDGET_RAM_SPACE+2] ;
006853  000298      var vILedDigits8[WIDGET_RAM_SPACE+2] ;
006854  000299      var vILedDigits5[WIDGET_RAM_SPACE+2] ;
006855  000300      var vILedDigits9[WIDGET_RAM_SPACE+2] ;
006856  000301      var vILedDigits0[WIDGET_RAM_SPACE+2] ;
006857  000302  var stringsCV[34] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], hstrings ;
6858  0A0A
6859  0A0B
6860  0A0C
6861  0A0D
6862  0A0E
6863  0A0F
6864  0A10
6865  0A11
6866  0A12
6867  0A13
6868  0A14
6869  0A15
6870  0A16
6871  0A17
6872  0A18
6873  0A19
6874  0A1A
6875  0A1B
6876  0A1C
6877  0A1D
6878  0A1E
6879  0A1F
6880  0A20
6881  0A21
6882  0A22
6883  0A23
6884  0A24
6885  0A25
6886  0A26
6887  0A27
6888  0A28
6889  0A29
6890  0A2A
6891  0A2B
6892  0A2C
6893  0A2D
6894  0A2E
6895  0A2F
6896  0A30
6897  0A31
6898  0A32
6899  0A33
6900  0A34
6901  0A35
6902  0A36
6903  0A37
6904  0A38
6905  0A39
6906  0A3A
6907  0A3B
6908  0A3C
6909  0A3D
6910  0A3E
6911  0A3F
6912  0A40
6913  0A41
6914  0A42
6915  0A43
6916  0A44
6917  0A45
6918  0A46
6919  0A47
6920  0A48
6921  0A49
6922  0A4A
6923  0A4B
6924  0A4C
6925  0A4D
006926  000303  // Start P2.inc
006927  000304  var vObjects[MaxIntObjects+1] ;              // address of RAM objects
006928  000305  var GObjectIdx, GObjectFunc, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings ;
006929  000306  var oObjects[MaxTotObjects+1] ;                 // address of objects
006930  000307  var CurrentForm, oldn, ImageTouched ;
006931  000308  var TouchXpos, TouchYpos ;
006932  000309  var GObjectType, TouchState, CurInputData, pInputIndex ;
006933  000310  var comRX[40], cmd[CMDLenMAX] ;
006934  000311        
006935  000312  var InputCS, OutputCS ;
006936  000313        
006937  000314  // > ? Constant/Global/Data ? <
006938  000315        
006939  000316  func addressInternalWidget(var idx var iponly)
006940  000317      var i, j ;
006941  000318  //to(COM0) ; print("Address Int ", idx, " ") ; pause(2) ;
006942  000319      GObjectIdx := xobj2iobj[idx] ;
006943  000320      GObjectType := (GObjectIdx>>8) ;                          // extract object type
006944  000321      i := oObjects[GObjectType] ;                              // i is address of list of all objects of this type
006945  000322      GObjectIdx &= 0xff ;
006946  000323      //GObjectIdx *= 2 ;
006947  000324      j := GObjectIdx * 2 ;
006948  000325      GObjectDATA := i[j + 2] ;                                 // address of this object
006949  000326      i := vObjects[GObjectType-tiAngularMeter] ;               // i is address of list of all ram objects of his type
006950  000327      GObjectRAM := i[j] ;                                      // address of this objects' ram
006951  000328      i := GObjectType-tiAngularMeter ;
006952  000329      GObjectFunc := gfxInternals[i] ; // address function
006953  000330      GObjectParms := gfxIntParms[i] ;
006954  000331      GObjectStrings := gfxIntStrings[i] ;
006955  000332  //to(COM0) ; print([HEX4] GObjectFunc, " ", [HEX4] GObjectRAM, " ", [HEX4] GObjectDATA, " ", GObjectType, " ", GObjectIdx, "\r\n") ;
006956  000333  //    GObjectFunc(0, GObjectRAM, GObjectDATA) ;
006957  000334  endfunc
006958  000335        
006959  000336  func seroutCS(var op)
006960  000337      serout(op) ;
006961  000338      OutputCS ^= op ;
006962  000339  endfunc
006963  000340        
006964  000341  func nak0()
006965  000342      serout(NAK) ;
006966  000343      InputCS := 0 ;
006967  000344  endfunc
006968  000345        
006969  000346  func seroutOcs()
006970  000347      serout(OutputCS) ;
006971  000348      OutputCS := 0 ;
006972  000349  endfunc
006973  000350        
006974  000351  func SendReport(var id, var objt, var objn, var val)
006975  000352      seroutCS(id) ;
006976  000353      seroutCS(objt) ;
006977  000354      seroutCS(objn) ;
006978  000355      seroutCS(val >> 8) ; // first 8 bits
006979  000356      seroutCS(val) ;
006980  000357      seroutOcs() ;
006981  000358  endfunc
006982  000359        
006983  000360        
006984  000361  func ReadObject(var ObjectType, var ObjectIdx)
006985  000362      var j, k, Objects ;
006986  000363      if ((ObjectType >= tiLedDigitsH) && (ObjectType <= tiLinearInput))
006987  000364          j := ObjectIdx *2 ;
006988  000365          k := vObjects[ObjectType-tiAngularMeter] ;               // k is address of list of all ram objects of his type
006989  000366          k := k[j] ;                                              // k is address of this objects' ram
006990  000367          if (ObjectType == tiLedDigit)
006991  000368              k := k[0] ;
006992  000369          else 
006993  000370              k := k[WIDGET_VAL1] ;
006994  000371          endif
006995  000372  //gfx_MoveTo(0,0); txt_Opacity(OPAQUE) ; print(ObjectType, " ", ObjectIdx, " ", k," ") ;
006996  000373      else
006997  000374      Objects := *(oObjects+ObjectType) ;
006998  000375        
006999  000376      j := 2 + ObjectIdx * 2 + Objects ;
007000  000377       if (ObjectType == tForm)
007001  000378          k := CurrentForm ;
007002  000379      else if (ObjectType == tStrings)
007003  000380          k := stringsCV[ObjectIdx];
007004  000381          else
007005  000382          k := img_GetWord(hndl, *j, IMAGE_INDEX);
007006  000383          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
007007  000384                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
007008  000385      endif
007009  000386      endif
007010  000387      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
007011  000388  endfunc
007012  000389        
007013  000390  var wp ;
007014  000391        
007015  000392        
007016  000393  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
007017  000394      var i, j, k, Objects ;
007018  000395  //    ObjectType &= 0x3f ; Why was his there? Anibuttons? Complex cascades?
007019  000396      if (ObjectType == tForm)
007020  000397          ActivateForm(ObjectIdx) ;
007021  000398          return ;
007022  000399      endif
007023  000400      Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
007024  000401      i := *(Objects) ;
007025  000402      if ((ObjectType >= tiAngularMeter) && (ObjectType <= tiLinearInput))
007026  000403          i := oObjects[ObjectType] ;                              // f is address of list of all objects of this type
007027  000404          j := ObjectIdx *2 ;
007028  000405          i := i[j + 2] ;                         // f is address of this object
007029  000406          k := vObjects[ObjectType-tiAngularMeter] ;               // a is address of list of all ram objects of his type
007030  000407          k := k[j] ;                             // a is address of this objects' ram
007031  000408              j := ObjectType-tiAngularMeter ;
007032  000409              Objects := gfxInternals[j] ;           // locate function address   
007033  000410              Objects(NewVal, k, i) ; 
007034  000411          return ;
007035  000412      endif
007036  000413      switch (ObjectType)
007037  000414          case tWinButton :
007038  000415              j := InputControls[oWinButtons[ObjectIdx+1]] ;
007039  000416              break ;
007040  000417          case tUserButton :
007041  000418              j := InputControls[oUserButtons[ObjectIdx+1]] ;
007042  000419              break ;
007043  000420          default : j := -1 ;
007044  000421      endswitch
007045  000422        
007046  000423      if (j != -1)
007047  000424          k := img_GetWord(hndl, i , IMAGE_INDEX) ;
007048  000425              NewVal := NewVal << 1 ;
007049  000426              if (OVF())      // button group index change
007050  000427                  if (*(j+InputData+Ofs_IPD_P1))
007051  000428                      k &= 1 ;    // mask off old group index for momentary
007052  000429                  else
007053  000430                      k &= 3 ;    // mask off old group index for toggle
007054  000431                  endif
007055  000432              else            // normal set
007056  000433                  if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
007057  000434                  k &= 0xfffc ;    // retain only group index for state set
007058  000435              endif
007059  000436              NewVal |= k ;
007060  000437  //        endif
007061  000438          endif
007062  000439        
007063  000440          if (ObjectType == tStrings)
007064  000441              PrintStrings(ObjectIdx, NewVal, 0);
007065  000442              return ;
007066  000443          endif
007067  000444      img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
007068  000445      img_Show(hndl, i) ; // will only display if form is current
007069  000446      return ; // compiler bug circumvention!
007070  000447  endfunc
007071  000448        
007072  000449  func TurnOffButtons(var group)
007073  000450      var j, k, l, m, n, o, p;
007074  000451      m := GObjectIdx ;     // save as will be clobbered
007075  000452      n := GObjectType ;     // save as will be clobbered
007076  000453      for (j := 0; j < nInputs; j++)
007077  000454          k := j*IPDatasize ;
007078  000455          if (*(InputData+k+Ofs_IPD_P2) == group)
007079  000456              l := -1 ;
007080  000457               if (*(InputData+k) == tWinButton)
007081  000458                  l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007082  000459                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
007083  000460                  img_Show(hndl, l);      // only shows on current form
007084  000461        
007085  000462              else if (*(InputData+k) == tUserButton)
007086  000463                  l := oUserButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007087  000464                  img_SetWord(hndl, l, IMAGE_INDEX, img_GetWord(hndl, l, IMAGE_INDEX) & 0xfffc );
007088  000465                  img_Show(hndl, l);      // only shows on current form
007089  000466              endif
007090  000467          endif
007091  000468      next
007092  000469      GObjectIdx := m ;     // Restore
007093  000470      GObjectType := n ;    // Restore
007094  000471  endfunc
007095  000472        
007096  000473        
007097  000474        
007098  000475        
007099  000476  func ActivateForm(var newform)
007100  000477      var i, j, *p ;
007101  000478        
007102  000479          widget_Disable(wp, ALL) ;
007103  000480      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
007104  000481          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
007105  000482              if (img_GetWord(hndl, i, IMAGE_TAG))
007106  000483                  img_Disable(hndl,i) ;
007107  000484              endif
007108  000485          next
007109  000486      endif
007110  000487      CurrentForm := newform ;
007111  000488      // display newform image or clear to image color
007112  000489      if (FormBGcolors[CurrentForm] != ColorBGimage)
007113  000490          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
007114  000491          gfx_Cls() ;
007115  000492          DoGFXObjects() ;                                    // display GFX 'widgets'
007116  000493      endif
007117  000494        
007118  000495      // enable inputs
007119  000496      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
007120  000497          j := img_GetWord(hndl, i, IMAGE_TAG) ;
007121  000498          if (j)
007122  000499              j-- ;
007123  000500              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
007124  000501              //if (j != tKeyboard)
007125  000502              if (((j <= tWinButton) || (j >= t4Dbutton)) && (j != tSmartGauge) )               // enable inputs
007126  000503                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
007127  000504              endif
007128  000505              img_Show(hndl,i) ; // show initialy, if required
007129  000506              if (j == tForm)
007130  000507                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
007131  000508              endif
007132  000509          endif
007133  000510      next
007134  000511        
007135  000512      // enable inputs
007136  000513         var a, f ; 
007137  000524  */
007138  000525      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007139  000526          addressInternalWidget(i, 0) ;
007140  000527          widget_Enable(wp,i) ;
007141  000528          if (GObjectType != tiLabelB) widget_ClearAttributes(wp,i,WIDGET_F_INITIALISED) ; // don't clear initialised for tiLabelB
007142  000529                  j := GObjectRAM[WIDGET_VAL1] ;
007143  000530                  GObjectFunc(j, GObjectRAM, GObjectDATA) ; 
007144  000531      next
007145  000532      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007146  000533          if (InternalInputControls[i] != -1)
007147  000534              widget_SetAttributes(wp,i,WIDGET_F_TOUCH_ENABLE) ;
007148  000535          endif
007149  000536      next
007150  000537        
007151  000538      for (i := 0; i < nStrings; i++)
007152  000539          if (stringsCV[i] != -1)
007153  000540              WriteObject(tStrings, i, stringsCV[i]) ;
007154  000541          endif
007155  000542      next
007156  000543        
007157  000544  endfunc
007158  000545        
007159  000546  func UpdateObjects(var newval)
007160  000547      var IPidx, otherOBJ, oldvalue ;
007161  000548      if (GObjectType < tiLedDigitsH)
007162  000549          oldvalue := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ;
007163  000550      else
007164  000551          oldvalue := GObjectRAM[WIDGET_VAL1] ;
007165  000552      endif
007166  000553      if ( ( oldvalue != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
007167  000554        
007168  000555      if (GObjectType < tiLedDigitsH)
007169  000556          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
007170  000557              img_Show(hndl, *(pInputIndex));      // only shows on current form
007171  000558      else
007172  000559          WriteObject(GObjectType, GObjectIdx, newval) ;
007173  000560      endif
007174  000561          if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
007175  000562              if (*(CurInputData+Ofs_IPD_P1))
007176  000563                  newval &= 1;
007177  000564              else
007178  000565                  newval &= 3;
007179  000566              endif
007180  000567              if (newval > 1) newval := 1;
007181  000568          endif
007182  000569          IPidx := *(CurInputData+TouchState) ;
007183  000570          while(IPidx != 0)
007184  000571              otherOBJ := IPidx + InputData;
007185  000572              if (*(otherOBJ) == OT_REPORT)
007186  000573                  SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
007187  000574              else if (*(otherOBJ) == OT_MAGIC)
007188  000575                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
007189  000576                  IPidx(newval) ;
007190  000577  //            else if (TouchState == *(otherOBJ+Ofs_IPD_P4))  // test prior to Workshop 6.5.0.0
007191  000578              else if ((TouchState == *(otherOBJ+Ofs_IPD_P4)) || (*(CurInputData+Ofs_IPD_P1) && ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))))
007192  000579                  if (*(otherOBJ) == OT_ACTIVATE)
007193  000580                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
007194  000581                      GObjectType := tForm ;
007195  000582                  else if (*(otherOBJ) == OT_SETCONST)
007196  000583                      newval := *(otherOBJ+Ofs_IPD_P3) ;
007197  000584                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007198  000585                  else if (*(otherOBJ) == OT_SETANOTHER)
007199  000586                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007200  000587                  else if (*(otherOBJ) == OT_PREVFRAME)
007201  000588                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
007202  000589                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
007203  000590                      endif
007204  000591                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007205  000592                  else if (*(otherOBJ) == OT_NEXTFRAME)
007206  000593                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
007207  000594                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
007208  000595                      endif
007209  000596                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007210  000597                  else if (*(otherOBJ) == OT_PREVSTRING)
007211  000598                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)])
007212  000599                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]-1) ;
007213  000600                      endif
007214  000601                  else if (*(otherOBJ) == OT_NEXTSTRING)
007215  000602                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)] < *(otherOBJ+Ofs_IPD_P3)) // fix IPD_P2 not filled in yet
007216  000603                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]+1) ;
007217  000604                      endif
007218  000605                  endif
007219  000606              endif
007220  000607              IPidx := *(otherOBJ+TouchState) ;
007221  000608          wend
007222  000609      endif
007223  000610  endfunc
007224  000611        
007225  000612  // End P2.inc
007226  000613  func DoGFXObjects()
007227  000614  endfunc
007228  000615        
007229  000616  // Start P3.inc
007230  000617  func main()
007231  000618      var comTX[50], cmdi, i, j, TouchStatus ;
007232  000619        
007233  000620        
007234  000621      gfx_ScreenMode(LANDSCAPE) ;
007235  000622        
007236  000623      media_InitFlash(FLASH_ADDR_DEF_COMMAND) ;
007237  000624        
007238  000625        
007239  000626  //    gfx_MoveTo(0, 0);
007240  000627  //    print(mem_Heap()," ") ;
007241  000628  //    gfx_TransparentColour(0x0020);
007242  000629  //    gfx_Transparency(ON);
007243  000630        
007244  000631        
007245  000632      // open image control
007246  000633      hndl := file_LoadImageControl(0, 0, 3);
007247  000634        
007248  000635      // init 'constants'
007249  000636  // End P3.inc
007250  000637        
007251  000638      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
007252  000639      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
007253  000640      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
007254  000641      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
007255  000642      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
007256  000643      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
007257  000644      oObjects[tWinButton] := oWinButtons ;
007258  000645      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
007259  000646      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
007260  000647      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
007261  000648      oObjects[tForm] := oForms ;
007262  000649      oObjects[tGauge] := oGauges ;
007263  000650      oObjects[tImage] := oImages ;
007264  000651      oObjects[tKeyboard] := oDipSwitchs ; // dummy as no object there
007265  000652      oObjects[tLed] := oDipSwitchs ; // dummy as no object there
007266  000653      oObjects[tLeddigits] := oDipSwitchs ; // dummy as no object there
007267  000654      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
007268  000655      oObjects[tStrings] := oStringss ;
007269  000656      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
007270  000657      oObjects[tUserled] := oUserleds ;
007271  000658      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
007272  000659      oObjects[tStaticText] := oDipSwitchs ; // dummy as no object there
007273  000660      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
007274  000661      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
007275  000662      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
007276  000663      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
007277  000664      oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
007278  000665      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
007279  000666      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
007280  000667      oObjects[t4Dbutton] := oDipSwitchs ; // dummy as no object there
007281  000668      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
007282  000669      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
007283  000670      oObjects[tUserButton] := oUserButtons ;
007284  000671      oObjects[tMagicObject] := oDipSwitchs ; // dummy as no object there
007285  000672      oObjects[tSmartGauge] := oDipSwitchs ; // dummy as no object there
007286  000673      oObjects[tSmartSlider] := oDipSwitchs ; // dummy as no object there
007287  000674      oObjects[tSmartKnob] := oDipSwitchs ; // dummy as no object there
007288  000675      oObjects[tiLedDigitsH] := oDipSwitchs ; // dummy as no object there
007289  000676      oObjects[tiAngularMeter] := oiAngularMeters ;
007290  000677      oObjects[tiGauge] := oDipSwitchs ; // dummy as no object there
007291  000678      oObjects[tiLabelB] := oDipSwitchs ; // dummy as no object there
007292  000679      oObjects[tiUserGauge] := oDipSwitchs ; // dummy as no object there
007293  000680      oObjects[tiMediaGauge] := oDipSwitchs ; // dummy as no object there
007294  000681      oObjects[tiMediaThermometer] := oDipSwitchs ; // dummy as no object there
007295  000682      oObjects[tiLed] := oDipSwitchs ; // dummy as no object there
007296  000683      oObjects[tiMediaLed] := oDipSwitchs ; // dummy as no object there
007297  000684      oObjects[tiLedDigits] := oiLedDigitss ;
007298  000685      oObjects[tiNeedle] := oDipSwitchs ; // dummy as no object there
007299  000686      oObjects[tiRuler] := oDipSwitchs ; // dummy as no object there
007300  000687      oObjects[tiLedDigit] := oDipSwitchs ; // dummy as no object there
007301  000688      oObjects[tiButtonD] := oDipSwitchs ; // dummy as no object there
007302  000689      oObjects[tiButtonE] := oDipSwitchs ; // dummy as no object there
007303  000690      oObjects[tiMediaButton] := oDipSwitchs ; // dummy as no object there
007304  000691      oObjects[tiToggleInput] := oDipSwitchs ; // dummy as no object there
007305  000692      oObjects[tiDial] := oDipSwitchs ; // dummy as no object there
007306  000693      oObjects[tiMediaRotary] := oDipSwitchs ; // dummy as no object there
007307  000694      oObjects[tiRotaryInput] := oDipSwitchs ; // dummy as no object there
007308  000695      oObjects[tiSwitch] := oDipSwitchs ; // dummy as no object there
007309  000696      oObjects[tiSwitchB] := oDipSwitchs ; // dummy as no object there
007310  000697      oObjects[tiSliderE] := oDipSwitchs ; // dummy as no object there
007311  000698      oObjects[tiMediaSlider] := oDipSwitchs ; // dummy as no object there
007312  000699      oObjects[tiSliderH] := oDipSwitchs ; // dummy as no object there
007313  000700      oObjects[tiSliderG] := oDipSwitchs ; // dummy as no object there
007314  000701      oObjects[tiSliderF] := oDipSwitchs ; // dummy as no object there
007315  000702      oObjects[tiSliderD] := oDipSwitchs ; // dummy as no object there
007316  000703      oObjects[tiSliderC] := oDipSwitchs ; // dummy as no object there
007317  000704      oObjects[tiLinearInput] := oDipSwitchs ; // dummy as no object there
007318  000705      vObjects[0] := oiviAngularMeter ;
007319  000706      vObjects[8] := oiviLedDigits ;
007320  000707  // Start P4.inc
007321  000708      wp := widget_Create(14) ;
007322  000709      for (i := 0; i < 14; i++)
007323  000710  	addressInternalWidget(i, 0) ;
007324  000711          if (GObjectType != tiLedDigit) widget_Add(wp, i, GObjectRAM) ;    // don't add tiLedDigit objects as they are only 1 word long
007325  000712      next
007326  000713        
007327  000714      // init comms
007328  000715      com_Init(comRX,CMDLenMAX,0);
007329  000716      com_SetBaud(COM0,19886);
007330  000717      com_TXbuffer(comTX, 100, 0);
007331  000718      // tag 'real' objects
007332  000719      for (i := 0; i <= MaxTotObjects; i++)
007333  000720          if (   (i != tSounds)
007334  000721              && (i != tTimer)
007335  000722              && (i != tPinOutput)
007336  000723              && (i != tMagicObject)
007337  000724              && (i != tPinInput) )
007338  000725              TouchXpos := oObjects[i] ;
007339  000726              TouchYpos := *(TouchXpos) ;
007340  000727              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
007341  000728                  oldn := *(TouchXpos+ImageTouched*2) ;
007342  000729                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
007343  000730                  if (oldn != -1)
007344  000731                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
007345  000732                      img_Disable(hndl, oldn) ;
007346  000733                  endif
007347  000734              next
007348  000735          endif
007349  000736      next
007350  000737        
007351  000738      // display initial form
007352  000739      CurrentForm := -1 ;
007353  000740  // End P4.inc
007354  000741  // Start P5.inc
007355  000742      ActivateForm(0) ; // need to change this according to first actual form
007356  000743        
007357  000744  // End P5.inc
007358  000745  // Start P6.inc px44
007359  000746      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
007360  000747      oldn := -1 ;
007361  000748      repeat
007362  000749        
007363  000750          // check comms for command, how to NAK invalid command
007364  000751          if (com_Count() != 0)
007365  000752              i := serin() ;
007366  000753              InputCS ^= i ;               // update checksum
007367  000754              if (   (cmdi > 2)
007368  000755                  && (cmd[0] == WRITE_STRU) )
007369  000756                  j := (cmdi-1) >> 1 + 2 ;
007370  000757                  if (j == CMDLenMAX)    // max length exceeded
007371  000758                      nak0() ;
007372  000759                      cmdi := -1 ;
007373  000760                  else if (cmdi & 1)
007374  000761                      cmd[j] := i ;
007375  000762                      if (cmd[2] == 0)    // if string complete
007376  000763                          if (InputCS)
007377  000764                              nak0() ;
007378  000765                          else
007379  000766                              if (cmd[0] == WRITE_STRU)
007380  000767                              cmd[j] := 0 ;                     // terminate it
007381  000768                              PrintStrings(cmd[1], &cmd[3], 1) ;
007382  000769                              serout(ACK) ;
007383  000770                              else
007384  000771                              endif
007385  000772                          endif
007386  000773                          cmdi := -1 ;
007387  000774                      endif
007388  000775                  else
007389  000776                      cmd[j] := cmd[j] << 8 + i ;
007390  000777                      cmd[2]-- ;          // dec length
007391  000778                  endif
007392  000779                  cmdi++ ;
007393  000780              else // not unicode string
007394  000781                  cmd[cmdi++] := i ;
007395  000782                   if ((cmd[0] == WRITE_STR) || (cmd[0] == WRITE_LABEL) )                  // Ansi String or Label
007396  000783                      if (cmdi == CMDLenMAX)      // max length exceeded
007397  000784                          nak0() ;
007398  000785                          cmdi := 0 ;
007399  000786                      else if (cmdi > 2)
007400  000787                          if (cmd[2] == -1)
007401  000788                              if (InputCS)
007402  000789                                  nak0() ;
007403  000790                              else
007404  000791                                  if ((cmd[0] == WRITE_STR) || (cmd[0] == WRITE_LABEL))
007405  000792                                  cmd[cmdi-1] := 0 ;                     // terminate it
007406  000793                                  PrintStrings(cmd[1], &cmd[3], 1) ;
007407  000794                                  serout(ACK) ;
007408  000795                                  else
007409  000796                                  endif
007410  000797                              endif
007411  000798                              cmdi := 0 ;
007412  000799                          else
007413  000800                              cmd[2]-- ;          // dec length
007414  000801                          endif
007415  000802                      endif
007416  000803                  else if (   (cmd[0] == READ_OBJ)
007417  000804                           && (cmdi == 4)         )
007418  000805                      if (InputCS)
007419  000806                          nak0() ;
007420  000807                      else
007421  000808                          ReadObject(cmd[1], cmd[2]) ;
007422  000809                      endif
007423  000810                      cmdi := 0 ;
007424  000811                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
007425  000812                           && (cmdi == 6)          )
007426  000813                      if (InputCS)
007427  000814                          nak0() ;
007428  000815                      else
007429  000816                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
007430  000817                          serout(ACK) ;
007431  000818                      endif
007432  000819                      cmdi := 0 ;
007433  000820                  else if (   (cmd[0] == WRITE_CONTRAST)
007434  000821                           && (cmdi == 3)         )
007435  000822                      if (InputCS)
007436  000823                          nak0() ;
007437  000824                      else
007438  000825                          gfx_Contrast(cmd[1]) ;
007439  000826                          serout(ACK) ;
007440  000827                      endif
007441  000828                      cmdi := 0 ;
007442  000829                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
007443  000830                      nak0() ;
007444  000831                      cmdi := 0 ;
007445  000832                  endif
007446  000833              endif   // not unicode string
007447  000834          endif   // a character is available
007448  000835        
007449  000836        
007450  000837      // touch code processing
007451  000838        
007452  000839          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
007453  000840          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
007454  000841              ImageTouched := img_Touched(hndl,-1) ;
007455  000842              if (ImageTouched == -1)
007456  000843                  ImageTouched := widget_Touched(wp, ALL) ;
007457  000844                  if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
007458  000845              endif
007459  000846              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
007460  000847                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
007461  000848              endif
007462  000849              if (TouchStatus != TOUCH_RELEASED)        // if not released
007463  000850                  if (oldn != -1)
007464  000851                      ImageTouched := oldn ;
007465  000852                  else
007466  000853                      if (oldn != ImageTouched)
007467  000854                  oldn := ImageTouched ;
007468  000855                          TouchStatus := TOUCH_PRESSED ;
007469  000856                      endif
007470  000857                  endif
007471  000858                  TouchXpos  := touch_Get(TOUCH_GETX);
007472  000859                  TouchYpos  := touch_Get(TOUCH_GETY);
007473  000860                  TouchState := Ofs_IPD_DOWN ;
007474  000861              else
007475  000862                  ImageTouched := oldn ;                     // simulate release of what we touched
007476  000863                  oldn := -1 ;                    // prevent double release
007477  000864                  TouchState := Ofs_IPD_RELEASE ;
007478  000865              endif
007479  000866              if (TouchStatus == TOUCH_PRESSED)
file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.ImgData\MagicTouch.inc

007480  000867  #inherit "MagicTouch.inc"
007481  000867  #inherit "MagicTouch.inc"
007482  000001  //
007483  000002  // Added 2/14/2023 4:58:40 PM
007484  000003  //
007485  000004  // Use 'ImageTouched' to detect 'current' object compare to values such as iWinbutton0
007486  000005  // to determine the object for which a touch has just been detected.
007487  000006  //
007488  000007        
007489  000008  //ActivateForm(1); // Change to Form 1
007490  000868              endif
007491  000869              if (ImageTouched >= 0)
007492  000870                          CurInputData := InputControls[ImageTouched] + InputData;
007493  000871                          GObjectType := *(CurInputData) ;
007494  000872                          if (GObjectType == tSmartSlider)
007495  000873                              i := tTrackbar ; // GSlider ;
007496  000874                          else if (GObjectType == tSmartKnob)
007497  000875                              i := tKnob ;
007498  000876                          else if (GObjectType >= t4Dbutton) 
007499  000877                              i := GObjectType - 23 ; // adjust to ensure next in gosub
007500  000878                          else 
007501  000879                              i := GObjectType ;
007502  000880                          endif
007503  000881                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007504  000882                          ImageTouched := -1 ; // show processed here
007505  000883              endif
007506  000884              if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
007507  000885              if (ImageTouched >= 0)
007508  000886  //print(ImageTouched," ") ;
007509  000887  //                        CurInputData := InternalInputControls[ImageTouched] + InternalInputData;
007510  000888                          CurInputData := InternalInputControls[ImageTouched] + InputData;
007511  000889  //                        GObjectType := *(CurInputData) ;
007512  000890  //                        i := GObjectType ;
007513  000891  //                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
007514  000892  //                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007515  000893                          addressInternalWidget(ImageTouched, 0) ;
007516  000894  //                        i := xobj2iiobj[ImageTouched] ;                            // address object type and hash from ram index
007517  000895  //                        GObjectIdx := i & 0xff ;
007518  000896  //                        GObjectType := (i>>8) ;                                   // extract object type
007519  000897                          if (GObjectType <= tiToggleInput) 
007520  000898                              i := 0 ;
007521  000899                          else if (GObjectType <= tiRotaryInput) 
007522  000900                              i := 1 ;
007523  000901                          else if (GObjectType <= tiSwitchB) 
007524  000902                              i := 2 ;
007525  000903                          else 
007526  000904                              i := 3 ;
007527  000905                          endif
007528  000906  //to(COM0) ; print(i, "\r\n") ;  
007529  000907        
007530  000908                          gosub (i), (ciButton, ciDial, ciSwitch, ciSlider) ;
007531  000909        
007532  000910        
007533  000911  //            ImageTouched := widget_Touched(wp, ALL) ;
007534  000912              endif
007535  000913          endif
007536  000914   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
007537  000915        
007538  000916          sys_EventsResume() ;
007539  000917      forever
007540  000918        
007541  000919  ciSwitch:
007542  000920  cDipswitch:
007543  000921        
007544  000922  cKnob:
007545  000923  ciDial:
007546  000924        
007547  000925  cRockerswitch:
007548  000926        
007549  000927  cRotaryswitch:
007550  000928        
007551  000929  cSlider:
007552  000930  cTrackbar:
007553  000931  ciSlider:
007554  000932        
007555  000933  ciButton:
007556  000934        
007557  000935  c4DButton:
007558  000936  cUserButton:
007559  000937  cWinbutton:
007560  000938      pInputIndex := oObjects[GObjectType]  + *(CurInputData+Ofs_IPD_OBJVIDX) ;
007561  000939      i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
007562  000940  CommonButtons:
007563  000941      if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
007564  000942          if (TouchStatus == TOUCH_RELEASED)
007565  000943              i &= 0xfffe ;
007566  000944              TouchState == Ofs_IPD_DOWN ;
007567  000945          else
007568  000946              i |= 1 ;
007569  000947              TouchState == Ofs_IPD_RELEASE ;
007570  000948          endif
007571  000949      else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
007572  000950          if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
007573  000951              if ((i & 3) == 3)
007574  000952                  i &= 0xfffc ;
007575  000953              else
007576  000954                  i++ ;
007577  000955              endif
007578  000956          else
007579  000957              i |= 1 ;                                      // make down regardless of current state
007580  000958          endif
007581  000959      else                        // group action, up all other buttons on touch press, reports 0 for button down
007582  000960          if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
007583  000961              TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
007584  000962          endif
007585  000963          if (GObjectType < tiLedDigits)
007586  000964              i := (i & 0xfffc) | 2 ;         // uSD button, four, grouping and blocking states
007587  000965          else
007588  000966              i := 1 ;                        // Internal button two states
007589  000967          endif
007590  000968      endif
007591  000969        
007592  000970      UpdateObjects(i) ;
007593  000971  endsub ;
007594  000972        
007595  000973  cAniButton:
007596  000974        
007597  000975  cColorPicker:
007598  000976        
007599  000977  endfunc
007600  000978  // End P6.inc
Notice: variable 'GObjectRAM' is being indexed (line 551 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'IPidx' requires 1 argument (line 576 file:SprinterGauge.4DGenieS)
Notice: variable 'GObjectRAM' is being indexed (line 529 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'GObjectFunc' requires 3 arguments (line 530 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 477 file:SprinterGauge.4DGenieS)
Notice: local var 'a' in func 'ActivateForm' is never used (line 513 file:SprinterGauge.4DGenieS)
Notice: local var 'f' in func 'ActivateForm' is never used (line 513 file:SprinterGauge.4DGenieS)
Notice: local var 'o' in func 'TurnOffButtons' is never used (line 450 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'TurnOffButtons' is never used (line 450 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 405 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 407 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'Objects' requires 3 arguments (line 410 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 366 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 368 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 370 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 325 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 327 file:SprinterGauge.4DGenieS)
Notice: function argument 'iponly' in func 'addressInternalWidget' is never used (line 316 file:SprinterGauge.4DGenieS)


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXFLASH                           128  0x00000080 (const dword)  (not used)
__MAXMEM                           30290  0x00007652 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             4  0x00000004 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 12)
ActivateForm                        5629  0x000015fd (User func) args[1] r=0  (usage 9)
addressInternalWidget               7135  0x00001bdf (User func) args[2] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (usage 6)
ANALOGUE                               2  0x00000002 (const dword)  (not used)
ANGULAR_bgcol                         66  0x00000042 (const dword)  (not used)
ANGULAR_c1                            24  0x00000018 (const dword)  (not used)
ANGULAR_c2                            26  0x0000001a (const dword)  (not used)
ANGULAR_c3                            28  0x0000001c (const dword)  (not used)
ANGULAR_capcol                        46  0x0000002e (const dword)  (not used)
ANGULAR_capfnt                        44  0x0000002c (const dword)  (not used)
ANGULAR_capofsx                       48  0x00000030 (const dword)  (not used)
ANGULAR_capofsy                       50  0x00000032 (const dword)  (not used)
ANGULAR_Caption                       52  0x00000034 (const dword)  (not used)
ANGULAR_cxx                           62  0x0000003e (const dword)  (not used)
ANGULAR_cyx                           64  0x00000040 (const dword)  (not used)
ANGULAR_F_BG_TRANSPARENT             N/A         N/A (macro)   0x0002   (not used)
ANGULAR_F_LABEL_STRINGS              N/A         N/A (macro)   0x0001   (not used)
ANGULAR_F_TEXT_PCT_COLOUR            N/A         N/A (macro)   0x0008   (not used)
ANGULAR_F_TICK_PCT_COLOUR            N/A         N/A (macro)   0x0004   (not used)
ANGULAR_flags                         42  0x0000002a (const dword)  (not used)
ANGULAR_h                             60  0x0000003c (const dword)  (not used)
ANGULAR_incro                         30  0x0000001e (const dword)  (not used)
ANGULAR_labcol                        36  0x00000024 (const dword)  (not used)
ANGULAR_labfnt                        34  0x00000022 (const dword)  (not used)
ANGULAR_labofs                        38  0x00000026 (const dword)  (not used)
ANGULAR_labs                          32  0x00000020 (const dword)  (not used)
ANGULAR_labstr                        40  0x00000028 (const dword)  (not used)
ANGULAR_maxa                          70  0x00000046 (const dword)  (not used)
ANGULAR_maxv                          74  0x0000004a (const dword)  (not used)
ANGULAR_mina                          68  0x00000044 (const dword)  (not used)
ANGULAR_minv                          72  0x00000048 (const dword)  (not used)
ANGULAR_p1                            20  0x00000014 (const dword)  (not used)
ANGULAR_p2                            22  0x00000016 (const dword)  (not used)
ANGULAR_ri                             2  0x00000002 (const dword)  (not used)
ANGULAR_ro                             0  0x00000000 (const dword)  (not used)
ANGULAR_tc                            18  0x00000012 (const dword)  (not used)
ANGULAR_tcks                           4  0x00000004 (const dword)  (not used)
ANGULAR_tiszl                         12  0x0000000c (const dword)  (not used)
ANGULAR_tiszs                         14  0x0000000e (const dword)  (not used)
ANGULAR_tkl                            6  0x00000006 (const dword)  (not used)
ANGULAR_toszl                          8  0x00000008 (const dword)  (not used)
ANGULAR_toszs                         10  0x0000000a (const dword)  (not used)
ANGULAR_tw                            16  0x00000010 (const dword)  (not used)
ANGULAR_w                             58  0x0000003a (const dword)  (not used)
ANGULAR_x                             54  0x00000036 (const dword)  (not used)
ANGULAR_y                             56  0x00000038 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                          24  0x00000018 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 114)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BREAK                              65533  0x0000fffd (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON4_BC0                           12  0x0000000c (const dword)  (not used)
BUTTON4_BC1                           14  0x0000000e (const dword)  (not used)
BUTTON4_BR1                           28  0x0000001c (const dword)  (not used)
BUTTON4_BR2                           30  0x0000001e (const dword)  (not used)
BUTTON4_BRG                           32  0x00000020 (const dword)  (not used)
BUTTON4_CAP                           26  0x0000001a (const dword)  (not used)
BUTTON4_FC0                           28  0x0000001c (const dword)  (not used)
BUTTON4_FC1                           30  0x0000001e (const dword)  (not used)
BUTTON4_FST                           32  0x00000020 (const dword)  (not used)
BUTTON4_FSZ                           34  0x00000022 (const dword)  (not used)
BUTTON4_IB1                           16  0x00000010 (const dword)  (not used)
BUTTON4_IB2                           18  0x00000012 (const dword)  (not used)
BUTTON4_IG0                           20  0x00000014 (const dword)  (not used)
BUTTON4_IG1                           22  0x00000016 (const dword)  (not used)
BUTTON4_OB1                            6  0x00000006 (const dword)  (not used)
BUTTON4_OB2                            8  0x00000008 (const dword)  (not used)
BUTTON4_OBG                           10  0x0000000a (const dword)  (not used)
BUTTON4_rad                            4  0x00000004 (const dword)  (not used)
BUTTON4_TPC                           24  0x00000018 (const dword)  (not used)
BUTTON4_XP                             0  0x00000000 (const dword)  (not used)
BUTTON4_YP                             2  0x00000002 (const dword)  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHECKUPDATE_INVALIDFILE                5  0x00000005 (const dword)  (not used)
CHECKUPDATE_NEWFILE                    1  0x00000001 (const dword)  (not used)
CHECKUPDATE_NOFILE                     4  0x00000004 (const dword)  (not used)
CHECKUPDATE_OLDFILE                    2  0x00000002 (const dword)  (not used)
CHECKUPDATE_QUERY                      1  0x00000001 (const dword)  (not used)
CHECKUPDATE_UPDATEALWAYS               3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATEDONE                 3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATENEWER                2  0x00000002 (const dword)  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
ciButton                          UNRESOLVED  (not used)
ciDial                            UNRESOLVED  (not used)
ciSlider                          UNRESOLVED  (not used)
ciSwitch                          UNRESOLVED  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  694  0x000002b6 (mem) word[80] (global)  (usage 90)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 12)
ColorBGimage                          32  0x00000020 (const dword)  (usage 6)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_InitBrk                        -427  0xfffffe55 (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferBrk                    -426  0xfffffe56 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_InitBrk                         -417  0xfffffe5f (PmmC func) args[3] r=0  (not used)
com_Mode                            -400  0xfffffe70 (PmmC func) args[4] r=1  (not used)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferBrk                     -416  0xfffffe60 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                                614  0x00000266 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
crc_CSUM_8                          -403  0xfffffe6d (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         610  0x00000262 (mem) word (global)  (usage 30)
CurrentForm                          596  0x00000254 (mem) word (global)  (usage 54)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIAL_bevColour                        28  0x0000001c (const dword)  (not used)
DIAL_bevColour2                       30  0x0000001e (const dword)  (not used)
DIAL_bevSize                          26  0x0000001a (const dword)  (not used)
DIAL_bgcolour                         22  0x00000016 (const dword)  (not used)
DIAL_capcol                           72  0x00000048 (const dword)  (not used)
DIAL_capfnt                           70  0x00000046 (const dword)  (not used)
DIAL_capofsx                          74  0x0000004a (const dword)  (not used)
DIAL_capofsy                          76  0x0000004c (const dword)  (not used)
DIAL_caption                          78  0x0000004e (const dword)  (not used)
DIAL_colour                           24  0x00000018 (const dword)  (not used)
DIAL_cx                                8  0x00000008 (const dword)  (not used)
DIAL_cy                               10  0x0000000a (const dword)  (not used)
DIAL_F_BG_TRANSPARENT                N/A         N/A (macro)   0x0002   (not used)
DIAL_F_HANDLE_CIRCLE                 N/A         N/A (macro)   0x0000   (not used)
DIAL_F_HANDLE_LINE                   N/A         N/A (macro)   0x0030   (not used)
DIAL_F_HANDLE_RECTANGLE              N/A         N/A (macro)   0x0020   (not used)
DIAL_F_HANDLE_STYLE                  N/A         N/A (macro)   0x00f0   (not used)
DIAL_F_HANDLE_TRIANGLE               N/A         N/A (macro)   0x0010   (not used)
DIAL_F_INDICATOR_CIRCLE              N/A         N/A (macro)   0x0000   (not used)
DIAL_F_INDICATOR_LINE                N/A         N/A (macro)   0x0300   (not used)
DIAL_F_INDICATOR_RECTANGLE           N/A         N/A (macro)   0x0200   (not used)
DIAL_F_INDICATOR_STYLE               N/A         N/A (macro)   0x0f00   (not used)
DIAL_F_INDICATOR_TRIANGLE            N/A         N/A (macro)   0x0100   (not used)
DIAL_F_LABEL_STRINGS                 N/A         N/A (macro)   0x0001   (not used)
DIAL_flags                            80  0x00000050 (const dword)  (not used)
DIAL_h                                 6  0x00000006 (const dword)  (not used)
DIAL_handlecolour                     54  0x00000036 (const dword)  (not used)
DIAL_handlelength                     58  0x0000003a (const dword)  (not used)
DIAL_handlesize                       56  0x00000038 (const dword)  (not used)
DIAL_indc1h                           42  0x0000002a (const dword)  (not used)
DIAL_indc1l                           36  0x00000024 (const dword)  (not used)
DIAL_indc2h                           44  0x0000002c (const dword)  (not used)
DIAL_indc2l                           38  0x00000026 (const dword)  (not used)
DIAL_indc3h                           46  0x0000002e (const dword)  (not used)
DIAL_indc3l                           40  0x00000028 (const dword)  (not used)
DIAL_indlength                        52  0x00000034 (const dword)  (not used)
DIAL_indOffset                        48  0x00000030 (const dword)  (not used)
DIAL_indp1                            32  0x00000020 (const dword)  (not used)
DIAL_indp2                            34  0x00000022 (const dword)  (not used)
DIAL_indsize                          50  0x00000032 (const dword)  (not used)
DIAL_labcolour                        60  0x0000003c (const dword)  (not used)
DIAL_labcount                         66  0x00000042 (const dword)  (not used)
DIAL_labfont                          62  0x0000003e (const dword)  (not used)
DIAL_labofs                           64  0x00000040 (const dword)  (not used)
DIAL_labstr                           68  0x00000044 (const dword)  (not used)
DIAL_maxa                             16  0x00000010 (const dword)  (not used)
DIAL_maxv                             20  0x00000014 (const dword)  (not used)
DIAL_mina                             14  0x0000000e (const dword)  (not used)
DIAL_minv                             18  0x00000012 (const dword)  (not used)
DIAL_rad                              12  0x0000000c (const dword)  (not used)
DIAL_w                                 4  0x00000004 (const dword)  (not used)
DIAL_x                                 0  0x00000000 (const dword)  (not used)
DIAL_y                                 2  0x00000002 (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Busy                           -419  0xfffffe5d (PmmC func) args[0] r=1  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[2] r=1  (not used)
disp_Refresh                        -418  0xfffffe5e (PmmC func) args[0] r=0  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        4882  0x00001312 (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
EAST                                   3  0x00000003 (const dword)  (not used)
EAST_MIRRORED                          7  0x00000007 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
ffsEnd32kH                             4  0x00000004 (const dword)  (not used)
ffsEnd32kL                         32768  0x00008000 (const dword)  (not used)
ffsEnd4kH                              4  0x00000004 (const dword)  (not used)
ffsEnd4kL                          32768  0x00008000 (const dword)  (not used)
ffsEnd64kH                             5  0x00000005 (const dword)  (not used)
ffsEnd64kL                             0  0x00000000 (const dword)  (not used)
ffsEndUnits32k                         9  0x00000009 (const dword)  (not used)
ffsEndUnits4k                         72  0x00000048 (const dword)  (not used)
ffsEndUnits64k                         5  0x00000005 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_CheckUpdate                    -344  0xfffffea8 (PmmC func) args[2] r=1  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (not used)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
file_MountSpeed                     -382  0xfffffe82 (PmmC func) args[1] r=1  (not used)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_RunSpeed                       -408  0xfffffe68 (PmmC func) args[3] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
FLASH_ADDR_ALWAYS_4BYTE            65534  0x0000fffe (const dword)  (not used)
FLASH_ADDR_DEF_COMMAND             65535  0x0000ffff (const dword)  (usage 3)
flash_Block32Erase                  -398  0xfffffe72 (PmmC func) args[0] r=1  (not used)
flash_Block64Erase                  -157  0xffffff63 (PmmC func) args[0] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_Sector4Erase                  -399  0xfffffe71 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                        2491  0x000009bbFormBGcolors                        2491  0x000009bb (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 8)
FormBGcolors                      UNRESOLVED  (usage 4)
FormEndIndex                         865  0x00000361FormEndIndex                         865  0x00000361 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
FormStartIndex                       857  0x00000359FormStartIndex                       857  0x00000359 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 7)
FormStartIndex                    UNRESOLVED  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAUGE_COLOR                           18  0x00000012 (const dword)  (not used)
GAUGE_F_HORZ                         N/A         N/A (macro)    0x0002   (not used)
GAUGE_F_TOPRIGHT                     N/A         N/A (macro)    0x0001   (not used)
GAUGE_FLAGS                           36  0x00000024 (const dword)  (not used)
GAUGE_H                                6  0x00000006 (const dword)  (not used)
GAUGE_MAXV                            12  0x0000000c (const dword)  (not used)
GAUGE_MINV                            10  0x0000000a (const dword)  (not used)
GAUGE_P1                              34  0x00000022 (const dword)  (not used)
GAUGE_P1H                             22  0x00000016 (const dword)  (not used)
GAUGE_P1L                             20  0x00000014 (const dword)  (not used)
GAUGE_P2                              32  0x00000020 (const dword)  (not used)
GAUGE_P2H                             26  0x0000001a (const dword)  (not used)
GAUGE_P2L                             24  0x00000018 (const dword)  (not used)
GAUGE_P3H                             30  0x0000001e (const dword)  (not used)
GAUGE_P3L                             28  0x0000001c (const dword)  (not used)
GAUGE_SPACING                         16  0x00000010 (const dword)  (not used)
GAUGE_T                                8  0x00000008 (const dword)  (not used)
GAUGE_TICKH                           14  0x0000000e (const dword)  (not used)
GAUGE_W                                4  0x00000004 (const dword)  (not used)
GAUGE_X                                0  0x00000000 (const dword)  (not used)
GAUGE_Y                                2  0x00000002 (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_AngularMeter                    -312  0xfffffec8 (PmmC func) args[3] r=0  (usage 3)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
gfx_BlitSprite                      -304  0xfffffed0 (PmmC func) args[6] r=0  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
gfx_Button4                         -340  0xfffffeac (PmmC func) args[3] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 6)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 3)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 3)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dial                            -315  0xfffffec5 (PmmC func) args[3] r=0  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Gauge                           -316  0xfffffec4 (PmmC func) args[3] r=0  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -346  0xfffffea6 (PmmC func) args[7] r=0  (not used)
gfx_GradientColor                   -405  0xfffffe6b (PmmC func) args[6] r=1  (not used)
gfx_GradientShape                   -404  0xfffffe6c (PmmC func) args[19] r=0  (not used)
gfx_GradTriangleFilled              -406  0xfffffe6a (PmmC func) args[12] r=0  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
gfx_Led                             -341  0xfffffeab (PmmC func) args[3] r=0  (not used)
gfx_LedDigit                        -319  0xfffffec1 (PmmC func) args[6] r=0  (not used)
gfx_LedDigits                       -318  0xfffffec2 (PmmC func) args[3] r=0  (usage 3)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_Needle                          -314  0xfffffec6 (PmmC func) args[3] r=0  (not used)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_Panel2                          -313  0xfffffec7 (PmmC func) args[10] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
gfx_ReadGRAMarea                    -305  0xfffffecf (PmmC func) args[5] r=1  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 6)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_RingSegment                     -311  0xfffffec9 (PmmC func) args[7] r=0  (not used)
gfx_RoundGradient                   -317  0xfffffec3 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -320  0xfffffec0 (PmmC func) args[6] r=0  (not used)
gfx_RulerGauge                      -343  0xfffffea9 (PmmC func) args[3] r=0  (not used)
gfx_Scale                           -342  0xfffffeaa (PmmC func) args[2] r=0  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
gfx_Slider5                         -337  0xfffffeaf (PmmC func) args[3] r=0  (not used)
gfx_SpriteSet                       -303  0xfffffed1 (PmmC func) args[3] r=0  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
gfx_Surround                        -338  0xfffffeae (PmmC func) args[7] r=0  (not used)
gfx_Switch                          -339  0xfffffead (PmmC func) args[3] r=0  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
gfx_WriteGRAMarea                   -306  0xfffffece (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
gfx_XYlinToVal                      -380  0xfffffe84 (PmmC func) args[7] r=1  (not used)
gfx_XYrotToVal                      -379  0xfffffe85 (PmmC func) args[7] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
gfxInternals                           7  0x00000007gfxInternals                           7  0x00000007 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
gfxIntParms                           65  0x00000041gfxIntParms                           65  0x00000041 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
gfxIntStrings                        123  0x0000007bgfxIntStrings                        123  0x0000007b (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectDATA                          454  0x000001c6 (mem) word (global)  (usage 6)
GObjectFunc                          450  0x000001c2 (mem) word (global)  (usage 6)
GObjectIdx                           448  0x000001c0 (mem) word (global)  (usage 21)
GObjectParms                         456  0x000001c8 (mem) word (global)  (usage 3)
GObjectRAM                           452  0x000001c4 (mem) word (global)  (usage 15)
GObjectStrings                       458  0x000001ca (mem) word (global)  (usage 3)
GObjectType                          606  0x0000025e (mem) word (global)  (usage 90)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (usage 12)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 102)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
hstrings                             390  0x00000186 (mem) word (global)Notice: global var 'hstrings' is never used
  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C1_Close                          -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C1_Nack                           -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C1_Putn                           -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -361  0xfffffe97 (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -367  0xfffffe91 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -365  0xfffffe93 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -349  0xfffffea3 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -373  0xfffffe8b (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -371  0xfffffe8d (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -369  0xfffffe8f (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -363  0xfffffe95 (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
I2C2_Putn                           -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -375  0xfffffe89 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -357  0xfffffe9b (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -355  0xfffffe9d (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -351  0xfffffea1 (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -359  0xfffffe99 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -362  0xfffffe96 (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -368  0xfffffe90 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -366  0xfffffe92 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -350  0xfffffea2 (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -374  0xfffffe8a (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -372  0xfffffe8c (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -370  0xfffffe8e (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -364  0xfffffe94 (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
I2C3_Putn                           -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -376  0xfffffe88 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -358  0xfffffe9a (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -356  0xfffffe9c (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -360  0xfffffe98 (PmmC func) args[1] r=1  (not used)
I2C_CLOCK_STRETCHING               32768  0x00008000 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2CS_Close                          -410  0xfffffe66 (PmmC func) args[0] r=0  (not used)
I2CS_Count                          -412  0xfffffe64 (PmmC func) args[0] r=1  (not used)
I2CS_Open                           -409  0xfffffe67 (PmmC func) args[6] r=0  (not used)
I2CS_Overflow                       -415  0xfffffe61 (PmmC func) args[0] r=1  (not used)
I2CS_Read                           -413  0xfffffe63 (PmmC func) args[0] r=1  (not used)
I2CS_Release                        -414  0xfffffe62 (PmmC func) args[0] r=0  (not used)
I2CS_Write                          -411  0xfffffe65 (PmmC func) args[1] r=0  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 3)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                          34  0x00000022 (const dword)  (not used)
iFontIFont0                           24  0x00000018 (const ??? 0)  (not used)
iFontStrings10                        26  0x0000001a (const ??? 0)  (usage 40)
iFontStrings2                         25  0x00000019 (const ??? 0)  (usage 16)
iFontStrings8                         27  0x0000001b (const ??? 0)  (usage 12)
iFormEndIndex                        881  0x00000371iFormEndIndex                        881  0x00000371 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iFormStartIndex                      873  0x00000369iFormStartIndex                      873  0x00000369 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iGauge0                                1  0x00000001 (const ??? 0)  (usage 3)
iGauge1                               10  0x0000000a (const ??? 0)  (usage 3)
iGauge2                               11  0x0000000b (const ??? 0)  (usage 3)
iGauge3                               12  0x0000000c (const ??? 0)  (usage 3)
iIAngularMeter0                        0  0x00000000 (const ??? 0)  (not used)
IIAngularMeter0                      237  0x000000edIIAngularMeter0                      237  0x000000ed (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter1                        1  0x00000001 (const ??? 0)  (not used)
IIAngularMeter1                      338  0x00000152IIAngularMeter1                      338  0x00000152 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter2                        6  0x00000006 (const ??? 0)  (not used)
IIAngularMeter2                      603  0x0000025bIIAngularMeter2                      603  0x0000025b (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter3                        2  0x00000002 (const ??? 0)  (not used)
IIAngularMeter3                      438  0x000001b6IIAngularMeter3                      438  0x000001b6 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits0                          13  0x0000000d (const ??? 0)  (not used)
IILedDigits0                         835  0x00000343IILedDigits0                         835  0x00000343 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits1                           3  0x00000003 (const ??? 0)  (not used)
IILedDigits1                         537  0x00000219IILedDigits1                         537  0x00000219 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits2                           4  0x00000004 (const ??? 0)  (not used)
IILedDigits2                         559  0x0000022fIILedDigits2                         559  0x0000022f (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits3                           5  0x00000005 (const ??? 0)  (not used)
IILedDigits3                         581  0x00000245IILedDigits3                         581  0x00000245 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits4                           7  0x00000007 (const ??? 0)  (not used)
IILedDigits4                         703  0x000002bfIILedDigits4                         703  0x000002bf (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits5                          11  0x0000000b (const ??? 0)  (not used)
IILedDigits5                         791  0x00000317IILedDigits5                         791  0x00000317 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits6                           8  0x00000008 (const ??? 0)  (not used)
IILedDigits6                         725  0x000002d5IILedDigits6                         725  0x000002d5 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits7                           9  0x00000009 (const ??? 0)  (not used)
IILedDigits7                         747  0x000002ebIILedDigits7                         747  0x000002eb (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits8                          10  0x0000000a (const ??? 0)  (not used)
IILedDigits8                         769  0x00000301IILedDigits8                         769  0x00000301 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits9                          12  0x0000000c (const ??? 0)  (not used)
IILedDigits9                         813  0x0000032dIILedDigits9                         813  0x0000032d (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iImage0                                0  0x00000000 (const ??? 0)  (usage 3)
iImage1                                2  0x00000002 (const ??? 0)  (usage 3)
iImage10                              13  0x0000000d (const ??? 0)  (usage 3)
iImage3                                3  0x00000003 (const ??? 0)  (usage 3)
iImage4                                4  0x00000004 (const ??? 0)  (usage 3)
iImage5                                6  0x00000006 (const ??? 0)  (usage 3)
iImage6                                5  0x00000005 (const ??? 0)  (usage 3)
iImage7                                7  0x00000007 (const ??? 0)  (usage 3)
iImage8                                8  0x00000008 (const ??? 0)  (usage 3)
iImage9                                9  0x00000009 (const ??? 0)  (usage 3)
ILINEARIP_COLOR1                      12  0x0000000c (const dword)  (not used)
ILINEARIP_COLOR2                      14  0x0000000e (const dword)  (not used)
ILINEARIP_COLOR3                      16  0x00000010 (const dword)  (not used)
ILINEARIP_COLOR4                      18  0x00000012 (const dword)  (not used)
ILINEARIP_COLOR5                      20  0x00000014 (const dword)  (not used)
ILINEARIP_COLOR6                      22  0x00000016 (const dword)  (not used)
ILINEARIP_H                            6  0x00000006 (const dword)  (not used)
ILINEARIP_INDEX                        8  0x00000008 (const dword)  (not used)
ILINEARIP_MAXVAL                      42  0x0000002a (const dword)  (not used)
ILINEARIP_MINVAL                      44  0x0000002c (const dword)  (not used)
ILINEARIP_OFFSET_BR                   46  0x0000002e (const dword)  (not used)
ILINEARIP_OFFSET_TL                   48  0x00000030 (const dword)  (not used)
ILINEARIP_ORIENTATION                 10  0x0000000a (const dword)  (not used)
ILINEARIP_TEXT1                       36  0x00000024 (const dword)  (not used)
ILINEARIP_TEXT2                       38  0x00000026 (const dword)  (not used)
ILINEARIP_TEXT3                       40  0x00000028 (const dword)  (not used)
ILINEARIP_VALUE1                      24  0x00000018 (const dword)  (not used)
ILINEARIP_VALUE2                      26  0x0000001a (const dword)  (not used)
ILINEARIP_VALUE3                      28  0x0000001c (const dword)  (not used)
ILINEARIP_VALUE4                      30  0x0000001e (const dword)  (not used)
ILINEARIP_VALUE5                      32  0x00000020 (const dword)  (not used)
ILINEARIP_VALUE6                      34  0x00000022 (const dword)  (not used)
ILINEARIP_W                            4  0x00000004 (const dword)  (not used)
ILINEARIP_X                            0  0x00000000 (const dword)  (not used)
ILINEARIP_Y                            2  0x00000002 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 45)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
ImageTouched                         600  0x00000258 (mem) word (global)  (usage 72)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
img_FileCheckUpdate                 -397  0xfffffe73 (PmmC func) args[3] r=1  (not used)
img_FileExec                        -394  0xfffffe76 (PmmC func) args[3] r=1  (not used)
img_FileGetC                        -388  0xfffffe7c (PmmC func) args[2] r=1  (usage 3)
img_FileGetS                        -390  0xfffffe7a (PmmC func) args[4] r=1  (not used)
img_FileGetW                        -389  0xfffffe7b (PmmC func) args[2] r=1  (usage 3)
img_FileIndex                       -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_FileLoadFunction                -392  0xfffffe78 (PmmC func) args[2] r=1  (not used)
img_FilePlayWAV                     -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
img_FileRead                        -383  0xfffffe81 (PmmC func) args[4] r=1  (not used)
img_FileRewind                      -391  0xfffffe79 (PmmC func) args[2] r=1  (not used)
img_FileRun                         -393  0xfffffe77 (PmmC func) args[3] r=1  (not used)
img_FileSeek                        -384  0xfffffe80 (PmmC func) args[4] r=1  (usage 3)
img_FileSize                        -387  0xfffffe7d (PmmC func) args[4] r=1  (not used)
img_FileTell                        -386  0xfffffe7e (PmmC func) args[4] r=1  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
img_FunctionCall                    -401  0xfffffe6f (PmmC func) args[7] r=1  (not used)
img_FunctionFreeCache               -402  0xfffffe6e (PmmC func) args[1] r=0  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 39)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 15)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 18)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
img_TxtFontID                       -396  0xfffffe74 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
InputControls                        889  0x00000379InputControls                        889  0x00000379 (mem) word[24] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
InputCS                              854  0x00000356 (mem) word (global)  (usage 21)
InputData                            965  0x000003c5InputData                            965  0x000003c5 (mem) word[198] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 33)
InternalInputControls                937  0x000003a9InternalInputControls                937  0x000003a9 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
intflash_Copy                       -422  0xfffffe5a (PmmC func) args[3] r=1  (not used)
intflash_FunctionCall               -424  0xfffffe58 (PmmC func) args[7] r=1  (not used)
intflash_FunctionFreeCache          -425  0xfffffe57 (PmmC func) args[1] r=0  (not used)
intflash_GetByte                    -420  0xfffffe5c (PmmC func) args[1] r=1  (not used)
intflash_GetWord                    -421  0xfffffe5b (PmmC func) args[1] r=1  (not used)
intflash_WriteBlock                 -423  0xfffffe59 (PmmC func) args[2] r=1  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO10_PIN                              10  0x0000000a (const dword)  (not used)
IO11_PIN                              11  0x0000000b (const dword)  (not used)
IO12_PIN                              12  0x0000000c (const dword)  (not used)
IO13_PIN                              13  0x0000000d (const dword)  (not used)
IO14_PIN                              14  0x0000000e (const dword)  (not used)
IO15_PIN                              15  0x0000000f (const dword)  (not used)
IO16_PIN                              16  0x00000010 (const dword)  (not used)
IO17_PIN                              17  0x00000011 (const dword)  (not used)
IO18_PIN                              18  0x00000012 (const dword)  (not used)
IO19_PIN                              19  0x00000013 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IO6_PIN                                6  0x00000006 (const dword)  (not used)
IO7_PIN                                7  0x00000007 (const dword)  (not used)
IO8_PIN                                8  0x00000008 (const dword)  (not used)
IO9_PIN                                9  0x00000009 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
IROTARYIP_COLOR1                      10  0x0000000a (const dword)  (not used)
IROTARYIP_COLOR2                      12  0x0000000c (const dword)  (not used)
IROTARYIP_COLOR3                      14  0x0000000e (const dword)  (not used)
IROTARYIP_COLOR4                      16  0x00000010 (const dword)  (not used)
IROTARYIP_COLOR5                      18  0x00000012 (const dword)  (not used)
IROTARYIP_COLOR6                      20  0x00000014 (const dword)  (not used)
IROTARYIP_H                            6  0x00000006 (const dword)  (not used)
IROTARYIP_INDEX                        8  0x00000008 (const dword)  (not used)
IROTARYIP_MAXANGLE                    40  0x00000028 (const dword)  (not used)
IROTARYIP_MAXVALUE                    42  0x0000002a (const dword)  (not used)
IROTARYIP_MINANGLE                    44  0x0000002c (const dword)  (not used)
IROTARYIP_MINVALUE                    46  0x0000002e (const dword)  (not used)
IROTARYIP_TEXT1                       34  0x00000022 (const dword)  (not used)
IROTARYIP_TEXT2                       36  0x00000024 (const dword)  (not used)
IROTARYIP_TEXT3                       38  0x00000026 (const dword)  (not used)
IROTARYIP_VALUE1                      22  0x00000016 (const dword)  (not used)
IROTARYIP_VALUE2                      24  0x00000018 (const dword)  (not used)
IROTARYIP_VALUE3                      26  0x0000001a (const dword)  (not used)
IROTARYIP_VALUE4                      28  0x0000001c (const dword)  (not used)
IROTARYIP_VALUE5                      30  0x0000001e (const dword)  (not used)
IROTARYIP_VALUE6                      32  0x00000020 (const dword)  (not used)
IROTARYIP_W                            4  0x00000004 (const dword)  (not used)
IROTARYIP_X                            0  0x00000000 (const dword)  (not used)
IROTARYIP_Y                            2  0x00000002 (const dword)  (not used)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStrings0                           1361  0x00000551iStrings0                           1361  0x00000551 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings1                           1389  0x0000056diStrings1                           1389  0x0000056d (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings10                          1641  0x00000669iStrings10                          1641  0x00000669 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings11                          1669  0x00000685iStrings11                          1669  0x00000685 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings12                          1697  0x000006a1iStrings12                          1697  0x000006a1 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings13                          1725  0x000006bdiStrings13                          1725  0x000006bd (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings14                          1753  0x000006d9iStrings14                          1753  0x000006d9 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings15                          1781  0x000006f5iStrings15                          1781  0x000006f5 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings16                          1809  0x00000711iStrings16                          1809  0x00000711 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings17                          1837  0x0000072diStrings17                          1837  0x0000072d (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings18                          1865  0x00000749iStrings18                          1865  0x00000749 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings19                          1893  0x00000765iStrings19                          1893  0x00000765 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings2                           1417  0x00000589iStrings2                           1417  0x00000589 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings20                          1921  0x00000781iStrings20                          1921  0x00000781 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings21                          1949  0x0000079diStrings21                          1949  0x0000079d (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings22                          1977  0x000007b9iStrings22                          1977  0x000007b9 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings23                          2005  0x000007d5iStrings23                          2005  0x000007d5 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings24                          2033  0x000007f1iStrings24                          2033  0x000007f1 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings25                          2061  0x0000080diStrings25                          2061  0x0000080d (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings26                          2089  0x00000829iStrings26                          2089  0x00000829 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings27                          2117  0x00000845iStrings27                          2117  0x00000845 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings28                          2145  0x00000861iStrings28                          2145  0x00000861 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings29                          2173  0x0000087diStrings29                          2173  0x0000087d (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings3                           1445  0x000005a5iStrings3                           1445  0x000005a5 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings30                          2201  0x00000899iStrings30                          2201  0x00000899 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings31                          2229  0x000008b5iStrings31                          2229  0x000008b5 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings32                          2257  0x000008d1iStrings32                          2257  0x000008d1 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings33                          2285  0x000008ediStrings33                          2285  0x000008ed (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings4                           1473  0x000005c1iStrings4                           1473  0x000005c1 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings5                           1501  0x000005ddiStrings5                           1501  0x000005dd (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings6                           1529  0x000005f9iStrings6                           1529  0x000005f9 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings7                           1557  0x00000615iStrings7                           1557  0x00000615 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings8                           1585  0x00000631iStrings8                           1585  0x00000631 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings9                           1613  0x0000064diStrings9                           1613  0x0000064d (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iTextStrings                          28  0x0000001c (const ??? 0)  (usage 9)
ITOGGLEIP_COLOR1                      10  0x0000000a (const dword)  (not used)
ITOGGLEIP_COLOR2                      12  0x0000000c (const dword)  (not used)
ITOGGLEIP_COLOR3                      14  0x0000000e (const dword)  (not used)
ITOGGLEIP_COLOR4                      16  0x00000010 (const dword)  (not used)
ITOGGLEIP_COLOR5                      18  0x00000012 (const dword)  (not used)
ITOGGLEIP_COLOR6                      20  0x00000014 (const dword)  (not used)
ITOGGLEIP_H                            6  0x00000006 (const dword)  (not used)
ITOGGLEIP_INDEX                        8  0x00000008 (const dword)  (not used)
ITOGGLEIP_MATRIX                      40  0x00000028 (const dword)  (not used)
ITOGGLEIP_MOMENTARY                   42  0x0000002a (const dword)  (not used)
ITOGGLEIP_TEXT1                       34  0x00000022 (const dword)  (not used)
ITOGGLEIP_TEXT2                       36  0x00000024 (const dword)  (not used)
ITOGGLEIP_TEXT3                       38  0x00000026 (const dword)  (not used)
ITOGGLEIP_VALUE1                      22  0x00000016 (const dword)  (not used)
ITOGGLEIP_VALUE2                      24  0x00000018 (const dword)  (not used)
ITOGGLEIP_VALUE3                      26  0x0000001a (const dword)  (not used)
ITOGGLEIP_VALUE4                      28  0x0000001c (const dword)  (not used)
ITOGGLEIP_VALUE5                      30  0x0000001e (const dword)  (not used)
ITOGGLEIP_VALUE6                      32  0x00000020 (const dword)  (not used)
ITOGGLEIP_W                            4  0x00000004 (const dword)  (not used)
ITOGGLEIP_X                            0  0x00000000 (const dword)  (not used)
ITOGGLEIP_Y                            2  0x00000002 (const dword)  (not used)
iUserbutton0                          16  0x00000010 (const ??? 0)  (usage 3)
iUserbutton1                          14  0x0000000e (const ??? 0)  (usage 3)
iUserbutton2                          20  0x00000014 (const ??? 0)  (usage 3)
iUserbutton3                          18  0x00000012 (const ??? 0)  (usage 3)
iUserbutton4                          21  0x00000015 (const ??? 0)  (usage 3)
iUserbutton5                          17  0x00000011 (const ??? 0)  (usage 3)
iUserbutton8                          19  0x00000013 (const ??? 0)  (usage 3)
IUSERGAUGE_COLOR1                     10  0x0000000a (const dword)  (not used)
IUSERGAUGE_COLOR2                     12  0x0000000c (const dword)  (not used)
IUSERGAUGE_COLOR3                     14  0x0000000e (const dword)  (not used)
IUSERGAUGE_COLOR4                     16  0x00000010 (const dword)  (not used)
IUSERGAUGE_COLOR5                     18  0x00000012 (const dword)  (not used)
IUSERGAUGE_COLOR6                     20  0x00000014 (const dword)  (not used)
IUSERGAUGE_H                           6  0x00000006 (const dword)  (not used)
IUSERGAUGE_INDEX                       8  0x00000008 (const dword)  (not used)
IUSERGAUGE_TEXT1                      34  0x00000022 (const dword)  (not used)
IUSERGAUGE_TEXT2                      36  0x00000024 (const dword)  (not used)
IUSERGAUGE_TEXT3                      38  0x00000026 (const dword)  (not used)
IUSERGAUGE_VALUE1                     22  0x00000016 (const dword)  (not used)
IUSERGAUGE_VALUE2                     24  0x00000018 (const dword)  (not used)
IUSERGAUGE_VALUE3                     26  0x0000001a (const dword)  (not used)
IUSERGAUGE_VALUE4                     28  0x0000001c (const dword)  (not used)
IUSERGAUGE_VALUE5                     30  0x0000001e (const dword)  (not used)
IUSERGAUGE_VALUE6                     32  0x00000020 (const dword)  (not used)
IUSERGAUGE_W                           4  0x00000004 (const dword)  (not used)
IUSERGAUGE_X                           0  0x00000000 (const dword)  (not used)
IUSERGAUGE_Y                           2  0x00000002 (const dword)  (not used)
iUserled0                             15  0x0000000f (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton0                           22  0x00000016 (const ??? 0)  (usage 3)
iWinbutton1                           23  0x00000017 (const ??? 0)  (usage 3)
JOY_BTNA                               6  0x00000006 (const dword)  (not used)
JOY_BTNB                               5  0x00000005 (const dword)  (not used)
JOY_DOWN                               3  0x00000003 (const dword)  (not used)
JOY_FIRE                               5  0x00000005 (const dword)  (not used)
JOY_LEFT                               2  0x00000002 (const dword)  (not used)
JOY_RELEASED                           0  0x00000000 (const dword)  (not used)
JOY_RIGHT                              4  0x00000004 (const dword)  (not used)
JOY_UP                                 1  0x00000001 (const dword)  (not used)
joystick                            -310  0xfffffeca (PmmC func) args[1] r=1  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                 2499  0x000009c3kKeyboardKeystrokes                 2499  0x000009c3 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LED1_cbe                              10  0x0000000a (const dword)  (not used)
LED1_cbs                               8  0x00000008 (const dword)  (not used)
LED1_cOff                             16  0x00000010 (const dword)  (not used)
LED1_cOn                              14  0x0000000e (const dword)  (not used)
LED1_cs                               12  0x0000000c (const dword)  (not used)
LED1_h                                 6  0x00000006 (const dword)  (not used)
LED1_iBr                              18  0x00000012 (const dword)  (not used)
LED1_iLr                              22  0x00000016 (const dword)  (not used)
LED1_oBr                              20  0x00000014 (const dword)  (not used)
LED1_oLr                              24  0x00000018 (const dword)  (not used)
LED1_sh                               26  0x0000001a (const dword)  (not used)
LED1_w                                 4  0x00000004 (const dword)  (not used)
LED1_x                                 0  0x00000000 (const dword)  (not used)
LED1_y                                 2  0x00000002 (const dword)  (not used)
LEDDIGIT_F_DP_COMMA                  N/A         N/A (macro)   0x0400   (not used)
LEDDIGIT_F_DP_ON                     N/A         N/A (macro)   0x0200   (not used)
LEDDIGIT_F_SET_SEGMENTS              N/A         N/A (macro)   0x1000   (not used)
LEDDIGIT_F_SHOW_DP                   N/A         N/A (macro)   0x0800   (not used)
LEDDIGITS_decimals                    10  0x0000000a (const dword)  (not used)
LEDDIGITS_digits                       8  0x00000008 (const dword)  (not used)
LEDDIGITS_digsize                     14  0x0000000e (const dword)  (not used)
LEDDIGITS_F_DP_COMMA                 N/A         N/A (macro)   0x0040   (not used)
LEDDIGITS_F_DP_DOT                   N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_FIXED                    N/A         N/A (macro)   0x0002   (not used)
LEDDIGITS_F_FLOAT                    N/A         N/A (macro)   0x0008   (not used)
LEDDIGITS_F_FLOATFORMATS             N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_GENERAL                  N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_INT16                    N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_INT32                    N/A         N/A (macro)   0x0004   (not used)
LEDDIGITS_F_LEADING0                 N/A         N/A (macro)   0x0020   (not used)
LEDDIGITS_F_LEADINGb                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_SCIENTIFIC               N/A         N/A (macro)   0x0001   (not used)
LEDDIGITS_F_SIGNED                   N/A         N/A (macro)   0x0010   (not used)
LEDDIGITS_F_TYPES                    N/A         N/A (macro)   0x000c   (not used)
LEDDIGITS_F_UNSIGNED                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_flags                       20  0x00000014 (const dword)  (not used)
LEDDIGITS_gap                         12  0x0000000c (const dword)  (not used)
LEDDIGITS_h                            6  0x00000006 (const dword)  (not used)
LEDDIGITS_offcolour                   18  0x00000012 (const dword)  (not used)
LEDDIGITS_oncolour                    16  0x00000010 (const dword)  (not used)
LEDDIGITS_w                            4  0x00000004 (const dword)  (not used)
LEDDIGITS_x                            0  0x00000000 (const dword)  (not used)
LEDDIGITS_y                            2  0x00000002 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIAngularMeter0                      333  0x0000014dLIAngularMeter0                      333  0x0000014d (mem) byte[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter0                   UNRESOLVED  (usage 2)
LIAngularMeter1                      434  0x000001b2LIAngularMeter1                      434  0x000001b2 (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter1                   UNRESOLVED  (usage 2)
LIAngularMeter2                      699  0x000002bbLIAngularMeter2                      699  0x000002bb (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter2                   UNRESOLVED  (usage 2)
LIAngularMeter3                      534  0x00000216LIAngularMeter3                      534  0x00000216 (mem) byte[3] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter3                   UNRESOLVED  (usage 2)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                2618  0x00000a3a (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxIntObjects                         27  0x0000001b (const dword)  (usage 3)
MaxTotObjects                         67  0x00000043 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_Init4                         -407  0xfffffe69 (const dword)  (not used)
media_InitFlash                     -407  0xfffffe69 (PmmC func) args[1] r=1  (usage 6)
media_InitSpeed                     -381  0xfffffe83 (PmmC func) args[1] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                7100  0x00001bbc (User func) args[0] r=0  (usage 24)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NEEDLE_bgcol                          12  0x0000000c (const dword)  (not used)
NEEDLE_ccol                           36  0x00000024 (const dword)  (not used)
NEEDLE_colour                         32  0x00000020 (const dword)  (not used)
NEEDLE_crad                           34  0x00000022 (const dword)  (not used)
NEEDLE_cxx                             8  0x00000008 (const dword)  (not used)
NEEDLE_cyx                            10  0x0000000a (const dword)  (not used)
NEEDLE_extra                          30  0x0000001e (const dword)  (not used)
NEEDLE_F_DOUBLETRIANGLE                4  0x00000004 (const dword)  (not used)
NEEDLE_F_LINE                          0  0x00000000 (const dword)  (not used)
NEEDLE_F_POINTRECTANGLE                2  0x00000002 (const dword)  (not used)
NEEDLE_F_RECTANGLE                     1  0x00000001 (const dword)  (not used)
NEEDLE_F_ROUNDEDRECTANGLE              5  0x00000005 (const dword)  (not used)
NEEDLE_F_TRIANGLE                      3  0x00000003 (const dword)  (not used)
NEEDLE_h                               6  0x00000006 (const dword)  (not used)
NEEDLE_icol                           40  0x00000028 (const dword)  (not used)
NEEDLE_irad                           38  0x00000026 (const dword)  (not used)
NEEDLE_len                            22  0x00000016 (const dword)  (not used)
NEEDLE_maxa                           16  0x00000010 (const dword)  (not used)
NEEDLE_maxv                           20  0x00000014 (const dword)  (not used)
NEEDLE_mina                           14  0x0000000e (const dword)  (not used)
NEEDLE_minv                           18  0x00000012 (const dword)  (not used)
NEEDLE_offs                           26  0x0000001a (const dword)  (not used)
NEEDLE_rad                            28  0x0000001c (const dword)  (not used)
NEEDLE_style                          24  0x00000018 (const dword)  (not used)
NEEDLE_w                               4  0x00000004 (const dword)  (not used)
NEEDLE_x                               0  0x00000000 (const dword)  (not used)
NEEDLE_y                               2  0x00000002 (const dword)  (not used)
nInputs                               18  0x00000012 (const dword)  (usage 3)
nObjects                              24  0x00000018 (const dword)  (not used)
NORTH                                  0  0x00000000 (const dword)  (not used)
NORTH_MIRRORED                         4  0x00000004 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
nStrings                              34  0x00000022 (const dword)  (usage 3)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                         2313  0x00000909oDipSwitchs                         2313  0x00000909 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 174)
OFF                                    0  0x00000000 (const dword)  (usage 3)
oForms                              2321  0x00000911oForms                              2321  0x00000911 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (not used)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (not used)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (not used)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (not used)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (not used)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 6)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 12)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 18)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 48)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 9)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 3)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 9)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 18)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 9)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (usage 3)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (usage 6)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (usage 3)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (usage 3)
Ofs_String_Form                       24  0x00000018 (const dword)  (usage 3)
Ofs_String_GciFSFontIdx               26  0x0000001a (const dword)  (usage 3)
Ofs_String_Size                        4  0x00000004 (const dword)  (usage 3)
Ofs_String_StartH                      0  0x00000000 (const dword)  (usage 3)
Ofs_String_StartL                      2  0x00000002 (const dword)  (usage 3)
Ofs_String_Transparent                20  0x00000014 (const dword)  (usage 3)
Ofs_String_x1                          6  0x00000006 (const dword)  (usage 12)
Ofs_String_x2                         10  0x0000000a (const dword)  (usage 9)
Ofs_String_y1                          8  0x00000008 (const dword)  (usage 12)
Ofs_String_y2                         12  0x0000000c (const dword)  (usage 9)
oGauges                             2331  0x0000091boGauges                             2331  0x0000091b (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiAngularMeters                     2459  0x0000099boiAngularMeters                     2459  0x0000099b (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiLedDigitss                        2469  0x000009a5oiLedDigitss                        2469  0x000009a5 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oImages                             2341  0x00000925oImages                             2341  0x00000925 (mem) word[12] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviAngularMeter                     181  0x000000b5oiviAngularMeter                     181  0x000000b5 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviLedDigits                        189  0x000000bdoiviLedDigits                        189  0x000000bd (mem) word[10] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 598  0x00000256 (mem) word (global)  (usage 42)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 3)
oObjects                             460  0x000001cc (mem) word[68] (global)  (usage 219)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oStringss                           2365  0x0000093doStringss                           2365  0x0000093d (mem) word[35] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 4)
oStringss                         UNRESOLVED  (usage 2)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 3)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 3)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (usage 3)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (usage 3)
OT_REPORT                            100  0x00000064 (const dword)  (usage 30)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 3)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
oUserButtons                        2439  0x00000987oUserButtons                        2439  0x00000987 (mem) word[10] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
oUserleds                           2435  0x00000983oUserleds                           2435  0x00000983 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OutputCS                             856  0x00000358 (mem) word (global)  (usage 9)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (usage 3)
OW_Read                             -299  0xfffffed5 (PmmC func) args[1] r=1  (not used)
OW_Read9                            -300  0xfffffed4 (PmmC func) args[1] r=1  (not used)
OW_Reset                            -298  0xfffffed6 (PmmC func) args[1] r=1  (not used)
OW_Write                            -301  0xfffffed3 (PmmC func) args[2] r=0  (not used)
oWinButtons                         2315  0x0000090boWinButtons                         2315  0x0000090b (mem) word[3] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL2_FILLED                      32768  0x00008000 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (not used)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
pInputIndex                          612  0x00000264 (mem) word (global)  (usage 15)
PIXXI                                  4  0x00000004 (const dword)  (usage 3)
PIXXI44_FUNCTIONS                      0  0x00000000 (const ??? 0)  (not used)
PIXXI_44_CHIP                          5  0x00000005 (const ??? 0)  (not used)
pixxiLCD_39P4CT                        0  0x00000000 (const ??? 0)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PrintStrings                        7270  0x00001c66 (User func) args[3] r=0  (usage 9)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 6)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (not used)
putstrCentred                       -321  0xfffffebf (PmmC func) args[3] r=0  (not used)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          6800  0x00001a90 (User func) args[2] r=0  (usage 3)
RECT_HEIGHT                            3  0x00000003 (const dword)  (not used)
rect_Intersect                      -307  0xfffffecd (PmmC func) args[2] r=1  (not used)
RECT_LEFT                              0  0x00000000 (const dword)  (not used)
RECT_TOP                               1  0x00000001 (const dword)  (not used)
RECT_WIDTH                             2  0x00000002 (const dword)  (not used)
rect_Within                         -308  0xfffffecc (PmmC func) args[2] r=1  (not used)
RED                                63488  0x0000f800 (const dword)  (usage 21)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 3)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                   2501  0x000009c5rKeyboardRoutines                   2501  0x000009c5 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RULERGAUGE_F_ORIENT_VERT               2  0x00000002 (const dword)  (not used)
RULERGAUGE_F_TICKS_BOTTOM              0  0x00000000 (const dword)  (not used)
RULERGAUGE_F_TICKS_TOP                 1  0x00000001 (const dword)  (not used)
RULERGAUGE_HC                         24  0x00000018 (const dword)  (not used)
RULERGAUGE_height                      6  0x00000006 (const dword)  (not used)
RULERGAUGE_IC                         30  0x0000001e (const dword)  (not used)
RULERGAUGE_LC                         22  0x00000016 (const dword)  (not used)
RULERGAUGE_majorTickSize              16  0x00000010 (const dword)  (not used)
RULERGAUGE_MC                         26  0x0000001a (const dword)  (not used)
RULERGAUGE_medium                     18  0x00000012 (const dword)  (not used)
RULERGAUGE_minorTicks                 12  0x0000000c (const dword)  (not used)
RULERGAUGE_minorTickSize              14  0x0000000e (const dword)  (not used)
RULERGAUGE_options                    32  0x00000020 (const dword)  (not used)
RULERGAUGE_range                       8  0x00000008 (const dword)  (not used)
RULERGAUGE_TC                         28  0x0000001c (const dword)  (not used)
RULERGAUGE_threshold                  20  0x00000014 (const dword)  (not used)
RULERGAUGE_ticks                      10  0x0000000a (const dword)  (not used)
RULERGAUGE_width                       4  0x00000004 (const dword)  (not used)
RULERGAUGE_XP                          0  0x00000000 (const dword)  (not used)
RULERGAUGE_YP                          2  0x00000002 (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCALE_BC                              20  0x00000014 (const dword)  (not used)
SCALE_BR                             N/A         N/A (macro)    0x0002   (not used)
SCALE_CenterGap                       26  0x0000001a (const dword)  (not used)
SCALE_CENTRE                         N/A         N/A (macro)    0x0003   (not used)
SCALE_END_ALIGN                      N/A         N/A (macro)    0x0020   (not used)
SCALE_FONT                            24  0x00000018 (const dword)  (not used)
SCALE_HIDE_ZERO                      N/A         N/A (macro)    0x0000   (not used)
SCALE_HORZ                           N/A         N/A (macro)    0x0000   (not used)
SCALE_length                           4  0x00000004 (const dword)  (not used)
SCALE_max                              8  0x00000008 (const dword)  (not used)
SCALE_min                              6  0x00000006 (const dword)  (not used)
SCALE_NO_END_ALIGN                   N/A         N/A (macro)    0x0000   (not used)
SCALE_NONE                           N/A         N/A (macro)    0x0000   (not used)
SCALE_SHOW_ZERO                      N/A         N/A (macro)    0x0040   (not used)
SCALE_TC                              18  0x00000012 (const dword)  (not used)
SCALE_ticklength                      12  0x0000000c (const dword)  (not used)
SCALE_ticklengthMinor                 16  0x00000010 (const dword)  (not used)
SCALE_ticks                           10  0x0000000a (const dword)  (not used)
SCALE_TICKS_BOTH                     N/A         N/A (macro)    0x000c   (not used)
SCALE_TICKS_BR                       N/A         N/A (macro)    0x0008   (not used)
SCALE_TICKS_NONE                     N/A         N/A (macro)    0x0000   (not used)
SCALE_TICKS_TL                       N/A         N/A (macro)    0x0004   (not used)
SCALE_ticksMinor                      14  0x0000000e (const dword)  (not used)
SCALE_TL                             N/A         N/A (macro)    0x0001   (not used)
SCALE_type                            28  0x0000001c (const dword)  (not used)
SCALE_VERT                           N/A         N/A (macro)    0x0010   (not used)
SCALE_XC                              22  0x00000016 (const dword)  (not used)
SCALE_XP                               0  0x00000000 (const dword)  (not used)
SCALE_YP                               2  0x00000002 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
SendReport                          7033  0x00001b79 (User func) args[4] r=0  (usage 6)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 21)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                            7116  0x00001bcc (User func) args[1] r=0  (usage 15)
seroutOcs                           7083  0x00001bab (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (usage 12)
SLIDER5_base_color                    14  0x0000000e (const dword)  (not used)
SLIDER5_F_ORIENT_VERT                N/A         N/A (macro)     0x0001    /* Switch orientation (0 - horizontal, 1 - vertical) */   (not used)
SLIDER5_F_PROGRESSBAR                N/A         N/A (macro)     0x0008    /* Progress Bar mode */   (not used)
SLIDER5_F_TICKS                      N/A         N/A (macro)     0x0002    /* Enable Marker Ticks*/   (not used)
SLIDER5_F_VALUE_IND                  N/A         N/A (macro)     0x0004    /* Enable slider value indicator */   (not used)
SLIDER5_font_c                        38  0x00000026 (const dword)  (not used)
SLIDER5_font_s                        36  0x00000024 (const dword)  (not used)
SLIDER5_knob_f_c_1                    46  0x0000002e (const dword)  (not used)
SLIDER5_knob_f_c_2                    48  0x00000030 (const dword)  (not used)
SLIDER5_knob_f_g                      50  0x00000032 (const dword)  (not used)
SLIDER5_knob_o_c_1                    40  0x00000028 (const dword)  (not used)
SLIDER5_knob_o_c_2                    42  0x0000002a (const dword)  (not used)
SLIDER5_knob_o_g                      44  0x0000002c (const dword)  (not used)
SLIDER5_len                            4  0x00000004 (const dword)  (not used)
SLIDER5_max_val                       12  0x0000000c (const dword)  (not used)
SLIDER5_min_val                       10  0x0000000a (const dword)  (not used)
SLIDER5_num_ticks_L_1                 24  0x00000018 (const dword)  (not used)
SLIDER5_num_ticks_L_2                 26  0x0000001a (const dword)  (not used)
SLIDER5_options                        8  0x00000008 (const dword)  (not used)
SLIDER5_thk                            6  0x00000006 (const dword)  (not used)
SLIDER5_tick_maj_c                    30  0x0000001e (const dword)  (not used)
SLIDER5_tick_maj_l                    28  0x0000001c (const dword)  (not used)
SLIDER5_tick_min_c                    34  0x00000022 (const dword)  (not used)
SLIDER5_tick_min_l                    32  0x00000020 (const dword)  (not used)
SLIDER5_total_tick_B_R                22  0x00000016 (const dword)  (not used)
SLIDER5_total_tick_T_L                20  0x00000014 (const dword)  (not used)
SLIDER5_track_color                   18  0x00000012 (const dword)  (not used)
SLIDER5_track_empty                   16  0x00000010 (const dword)  (not used)
SLIDER5_x_pos                          0  0x00000000 (const dword)  (not used)
SLIDER5_y_pos                          2  0x00000002 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Freq                            -302  0xfffffed2 (PmmC func) args[2] r=1  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_RTTTL                           -309  0xfffffecb (PmmC func) args[1] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SOUND                                  3  0x00000003 (const dword)  (not used)
SOUTH                                  1  0x00000001 (const dword)  (not used)
SOUTH_MIRRORED                         5  0x00000005 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
Strings0Count                          1  0x00000001 (const dword)  (not used)
Strings0Size                          22  0x00000016 (const dword)  (usage 3)
Strings0StartH                         0  0x00000000 (const dword)  (usage 3)
Strings0StartL                       512  0x00000200 (const dword)  (usage 3)
Strings10Count                         1  0x00000001 (const dword)  (not used)
Strings10Size                          6  0x00000006 (const dword)  (usage 3)
Strings10StartH                        0  0x00000000 (const dword)  (usage 3)
Strings10StartL                     3072  0x00000c00 (const dword)  (usage 3)
Strings11Count                         1  0x00000001 (const dword)  (not used)
Strings11Size                         15  0x0000000f (const dword)  (usage 3)
Strings11StartH                        0  0x00000000 (const dword)  (usage 3)
Strings11StartL                     3584  0x00000e00 (const dword)  (usage 3)
Strings12Count                         1  0x00000001 (const dword)  (not used)
Strings12Size                         17  0x00000011 (const dword)  (usage 3)
Strings12StartH                        0  0x00000000 (const dword)  (usage 3)
Strings12StartL                     4096  0x00001000 (const dword)  (usage 3)
Strings13Count                         1  0x00000001 (const dword)  (not used)
Strings13Size                          7  0x00000007 (const dword)  (usage 3)
Strings13StartH                        0  0x00000000 (const dword)  (usage 3)
Strings13StartL                     9216  0x00002400 (const dword)  (usage 3)
Strings14Count                         1  0x00000001 (const dword)  (not used)
Strings14Size                         16  0x00000010 (const dword)  (usage 3)
Strings14StartH                        0  0x00000000 (const dword)  (usage 3)
Strings14StartL                     9728  0x00002600 (const dword)  (usage 3)
Strings15Count                         1  0x00000001 (const dword)  (not used)
Strings15Size                         13  0x0000000d (const dword)  (usage 3)
Strings15StartH                        0  0x00000000 (const dword)  (usage 3)
Strings15StartL                     4608  0x00001200 (const dword)  (usage 3)
Strings16Count                         1  0x00000001 (const dword)  (not used)
Strings16Size                         13  0x0000000d (const dword)  (usage 3)
Strings16StartH                        0  0x00000000 (const dword)  (usage 3)
Strings16StartL                     5120  0x00001400 (const dword)  (usage 3)
Strings17Count                         1  0x00000001 (const dword)  (not used)
Strings17Size                          5  0x00000005 (const dword)  (usage 3)
Strings17StartH                        0  0x00000000 (const dword)  (usage 3)
Strings17StartL                    11264  0x00002c00 (const dword)  (usage 3)
Strings18Count                         1  0x00000001 (const dword)  (not used)
Strings18Size                          5  0x00000005 (const dword)  (usage 3)
Strings18StartH                        0  0x00000000 (const dword)  (usage 3)
Strings18StartL                     5632  0x00001600 (const dword)  (usage 3)
Strings19Count                         1  0x00000001 (const dword)  (not used)
Strings19Size                          5  0x00000005 (const dword)  (usage 3)
Strings19StartH                        0  0x00000000 (const dword)  (usage 3)
Strings19StartL                     6144  0x00001800 (const dword)  (usage 3)
Strings1Count                          1  0x00000001 (const dword)  (not used)
Strings1Size                          12  0x0000000c (const dword)  (usage 3)
Strings1StartH                         0  0x00000000 (const dword)  (usage 3)
Strings1StartL                     15872  0x00003e00 (const dword)  (usage 3)
Strings20Count                         1  0x00000001 (const dword)  (not used)
Strings20Size                          5  0x00000005 (const dword)  (usage 3)
Strings20StartH                        0  0x00000000 (const dword)  (usage 3)
Strings20StartL                     6656  0x00001a00 (const dword)  (usage 3)
Strings21Count                         1  0x00000001 (const dword)  (not used)
Strings21Size                          7  0x00000007 (const dword)  (usage 3)
Strings21StartH                        0  0x00000000 (const dword)  (usage 3)
Strings21StartL                     7168  0x00001c00 (const dword)  (usage 3)
Strings22Count                         1  0x00000001 (const dword)  (not used)
Strings22Size                         13  0x0000000d (const dword)  (usage 3)
Strings22StartH                        0  0x00000000 (const dword)  (usage 3)
Strings22StartL                     7680  0x00001e00 (const dword)  (usage 3)
Strings23Count                         1  0x00000001 (const dword)  (not used)
Strings23Size                          7  0x00000007 (const dword)  (usage 3)
Strings23StartH                        0  0x00000000 (const dword)  (usage 3)
Strings23StartL                     8192  0x00002000 (const dword)  (usage 3)
Strings24Count                         1  0x00000001 (const dword)  (not used)
Strings24Size                         12  0x0000000c (const dword)  (usage 3)
Strings24StartH                        0  0x00000000 (const dword)  (usage 3)
Strings24StartL                     8704  0x00002200 (const dword)  (usage 3)
Strings25Count                         1  0x00000001 (const dword)  (not used)
Strings25Size                          7  0x00000007 (const dword)  (usage 3)
Strings25StartH                        0  0x00000000 (const dword)  (usage 3)
Strings25StartL                    10240  0x00002800 (const dword)  (usage 3)
Strings26Count                         1  0x00000001 (const dword)  (not used)
Strings26Size                         17  0x00000011 (const dword)  (usage 3)
Strings26StartH                        0  0x00000000 (const dword)  (usage 3)
Strings26StartL                    10752  0x00002a00 (const dword)  (usage 3)
Strings27Count                         1  0x00000001 (const dword)  (not used)
Strings27Size                          3  0x00000003 (const dword)  (usage 3)
Strings27StartH                        0  0x00000000 (const dword)  (usage 3)
Strings27StartL                    12800  0x00003200 (const dword)  (usage 3)
Strings28Count                         1  0x00000001 (const dword)  (not used)
Strings28Size                         10  0x0000000a (const dword)  (usage 3)
Strings28StartH                        0  0x00000000 (const dword)  (usage 3)
Strings28StartL                    13312  0x00003400 (const dword)  (usage 3)
Strings29Count                         1  0x00000001 (const dword)  (not used)
Strings29Size                          5  0x00000005 (const dword)  (usage 3)
Strings29StartH                        0  0x00000000 (const dword)  (usage 3)
Strings29StartL                    14336  0x00003800 (const dword)  (usage 3)
Strings2Count                          1  0x00000001 (const dword)  (not used)
Strings2Size                          17  0x00000011 (const dword)  (usage 3)
Strings2StartH                         0  0x00000000 (const dword)  (usage 3)
Strings2StartL                         0  0x00000000 (const dword)  (usage 3)
Strings30Count                         1  0x00000001 (const dword)  (not used)
Strings30Size                          5  0x00000005 (const dword)  (usage 3)
Strings30StartH                        0  0x00000000 (const dword)  (usage 3)
Strings30StartL                    14848  0x00003a00 (const dword)  (usage 3)
Strings31Count                         1  0x00000001 (const dword)  (not used)
Strings31Size                         13  0x0000000d (const dword)  (usage 3)
Strings31StartH                        0  0x00000000 (const dword)  (usage 3)
Strings31StartL                    15360  0x00003c00 (const dword)  (usage 3)
Strings32Count                         1  0x00000001 (const dword)  (not used)
Strings32Size                          7  0x00000007 (const dword)  (usage 3)
Strings32StartH                        0  0x00000000 (const dword)  (usage 3)
Strings32StartL                    16384  0x00004000 (const dword)  (usage 3)
Strings33Count                         1  0x00000001 (const dword)  (not used)
Strings33Size                         13  0x0000000d (const dword)  (usage 3)
Strings33StartH                        0  0x00000000 (const dword)  (usage 3)
Strings33StartL                    16896  0x00004200 (const dword)  (usage 3)
Strings3Count                          1  0x00000001 (const dword)  (not used)
Strings3Size                           5  0x00000005 (const dword)  (usage 3)
Strings3StartH                         0  0x00000000 (const dword)  (usage 3)
Strings3StartL                     11776  0x00002e00 (const dword)  (usage 3)
Strings4Count                          1  0x00000001 (const dword)  (not used)
Strings4Size                           6  0x00000006 (const dword)  (usage 3)
Strings4StartH                         0  0x00000000 (const dword)  (usage 3)
Strings4StartL                      1024  0x00000400 (const dword)  (usage 3)
Strings5Count                          1  0x00000001 (const dword)  (not used)
Strings5Size                           6  0x00000006 (const dword)  (usage 3)
Strings5StartH                         0  0x00000000 (const dword)  (usage 3)
Strings5StartL                      1536  0x00000600 (const dword)  (usage 3)
Strings6Count                          1  0x00000001 (const dword)  (not used)
Strings6Size                          12  0x0000000c (const dword)  (usage 3)
Strings6StartH                         0  0x00000000 (const dword)  (usage 3)
Strings6StartL                     12288  0x00003000 (const dword)  (usage 3)
Strings7Count                          1  0x00000001 (const dword)  (not used)
Strings7Size                          14  0x0000000e (const dword)  (usage 3)
Strings7StartH                         0  0x00000000 (const dword)  (usage 3)
Strings7StartL                      2048  0x00000800 (const dword)  (usage 3)
Strings8Count                          1  0x00000001 (const dword)  (not used)
Strings8Size                          13  0x0000000d (const dword)  (usage 3)
Strings8StartH                         0  0x00000000 (const dword)  (usage 3)
Strings8StartL                     13824  0x00003600 (const dword)  (usage 3)
Strings9Count                          1  0x00000001 (const dword)  (not used)
Strings9Size                           7  0x00000007 (const dword)  (usage 3)
Strings9StartH                         0  0x00000000 (const dword)  (usage 3)
Strings9StartL                      2560  0x00000a00 (const dword)  (usage 3)
stringsCV                            322  0x00000142 (mem) word[34] (global)  (usage 27)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
SWITCH1_cOff                          20  0x00000014 (const dword)  (not used)
SWITCH1_cOn                           18  0x00000012 (const dword)  (not used)
SWITCH1_dshd                          12  0x0000000c (const dword)  (not used)
SWITCH1_F_ORIENT_VERT                N/A         N/A (macro)   0x0001  /* switch orientation (0: Horizontal, 1: Vertical) */   (not used)
SWITCH1_fcOff                         32  0x00000020 (const dword)  (not used)
SWITCH1_fcOn                          30  0x0000001e (const dword)  (not used)
SWITCH1_flg                            8  0x00000008 (const dword)  (not used)
SWITCH1_fnt                           26  0x0000001a (const dword)  (not used)
SWITCH1_fsz                           28  0x0000001c (const dword)  (not used)
SWITCH1_len                            4  0x00000004 (const dword)  (not used)
SWITCH1_lshd                          10  0x0000000a (const dword)  (not used)
SWITCH1_oBz                           14  0x0000000e (const dword)  (not used)
SWITCH1_tBz                           16  0x00000010 (const dword)  (not used)
SWITCH1_thk                            6  0x00000006 (const dword)  (not used)
SWITCH1_tOff                          24  0x00000018 (const dword)  (not used)
SWITCH1_tOn                           22  0x00000016 (const dword)  (not used)
SWITCH1_x                              0  0x00000000 (const dword)  (not used)
SWITCH1_y                              2  0x00000002 (const dword)  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_Driver                          -297  0xfffffed7 (PmmC func) args[0] r=0  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_PmmC                            -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 18)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 3)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tiAngularMeter                        39  0x00000027 (const dword)  (usage 21)
tiButtonD                             51  0x00000033 (const dword)  (usage 3)
tiButtonE                             52  0x00000034 (const dword)  (usage 3)
tiDial                                55  0x00000037 (const dword)  (usage 3)
tiGauge                               40  0x00000028 (const dword)  (usage 3)
tiLabelB                              41  0x00000029 (const dword)  (usage 6)
tiLed                                 45  0x0000002d (const dword)  (usage 3)
tiLedDigit                            50  0x00000032 (const dword)  (usage 9)
tiLedDigits                           47  0x0000002f (const dword)  (usage 6)
tiLedDigitsH                          38  0x00000026 (const dword)  (usage 12)
tiLinearInput                         67  0x00000043 (const dword)  (usage 9)
tImage                                12  0x0000000c (const dword)  (usage 3)
tiMediaButton                         53  0x00000035 (const dword)  (usage 3)
tiMediaGauge                          43  0x0000002b (const dword)  (usage 3)
tiMediaLed                            46  0x0000002e (const dword)  (usage 3)
tiMediaRotary                         56  0x00000038 (const dword)  (usage 3)
tiMediaSlider                         61  0x0000003d (const dword)  (usage 3)
tiMediaThermometer                    44  0x0000002c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tiNeedle                              48  0x00000030 (const dword)  (usage 3)
tiRotaryInput                         57  0x00000039 (const dword)  (usage 6)
tiRuler                               49  0x00000031 (const dword)  (usage 3)
tiSliderC                             66  0x00000042 (const dword)  (usage 3)
tiSliderD                             65  0x00000041 (const dword)  (usage 3)
tiSliderE                             60  0x0000003c (const dword)  (usage 3)
tiSliderF                             64  0x00000040 (const dword)  (usage 3)
tiSliderG                             63  0x0000003f (const dword)  (usage 3)
tiSliderH                             62  0x0000003e (const dword)  (usage 3)
tiSwitch                              58  0x0000003a (const dword)  (usage 3)
tiSwitchB                             59  0x0000003b (const dword)  (usage 6)
tiToggleInput                         54  0x00000036 (const dword)  (usage 6)
tiUserGauge                           42  0x0000002a (const dword)  (usage 3)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 6)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 3)
tMagicObject                          34  0x00000022 (const dword)  (usage 6)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 12)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 18)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           608  0x00000260 (mem) word (global)  (usage 24)
TouchXpos                            602  0x0000025a (mem) word (global)  (usage 12)
TouchYpos                            604  0x0000025c (mem) word (global)  (usage 9)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSmartGauge                           35  0x00000023 (const dword)  (usage 6)
tSmartKnob                            37  0x00000025 (const dword)  (usage 6)
tSmartSlider                          36  0x00000024 (const dword)  (usage 6)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 18)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 6)
TurnOffButtons                      6164  0x00001814 (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 39)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 27)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (usage 3)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 3)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 3)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 3)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (usage 3)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (usage 3)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                           -345  0xfffffea7 (PmmC func) args[3] r=1  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 3)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       4883  0x00001313 (User func) args[1] r=0  (usage 3)
USD_ENABLE                            25  0x00000019 (const dword)  (not used)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
vIAngularMeter0                        2  0x00000002 (mem) word[10] (global)  (usage 3)
vIAngularMeter1                       22  0x00000016 (mem) word[10] (global)  (usage 3)
vIAngularMeter2                      134  0x00000086 (mem) word[10] (global)  (usage 3)
vIAngularMeter3                       42  0x0000002a (mem) word[10] (global)  (usage 3)
vILedDigits0                         298  0x0000012a (mem) word[12] (global)  (usage 3)
vILedDigits1                          62  0x0000003e (mem) word[12] (global)  (usage 3)
vILedDigits2                          86  0x00000056 (mem) word[12] (global)  (usage 3)
vILedDigits3                         110  0x0000006e (mem) word[12] (global)  (usage 3)
vILedDigits4                         154  0x0000009a (mem) word[12] (global)  (usage 3)
vILedDigits5                         250  0x000000fa (mem) word[12] (global)  (usage 3)
vILedDigits6                         178  0x000000b2 (mem) word[12] (global)  (usage 3)
vILedDigits7                         202  0x000000ca (mem) word[12] (global)  (usage 3)
vILedDigits8                         226  0x000000e2 (mem) word[12] (global)  (usage 3)
vILedDigits9                         274  0x00000112 (mem) word[12] (global)  (usage 3)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
vObjects                             392  0x00000188 (mem) word[28] (global)  (usage 15)
WEST                                   2  0x00000002 (const dword)  (not used)
WEST_MIRRORED                          6  0x00000006 (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (usage 78)
WHITE                              65535  0x0000ffff (const dword)  (usage 66)
WHITESMOKE                         63422  0x0000f7be (const dword)  (usage 18)
widget_Add                          -323  0xfffffebd (PmmC func) args[3] r=1  (usage 3)
widget_ClearAttributes              -334  0xfffffeb2 (PmmC func) args[3] r=1  (usage 3)
widget_Create                       -322  0xfffffebe (PmmC func) args[1] r=1  (usage 3)
WIDGET_DECIMALS                       11  0x0000000b (const dword)  (not used)
WIDGET_DELAY                          10  0x0000000a (const dword)  (not used)
widget_Delete                       -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
widget_Disable                      -331  0xfffffeb5 (PmmC func) args[2] r=1  (usage 3)
widget_Enable                       -330  0xfffffeb6 (PmmC func) args[2] r=1  (usage 3)
WIDGET_F_DISABLED                   2048  0x00000800 (const dword)  (not used)
WIDGET_F_FLASH                      1024  0x00000400 (const dword)  (not used)
WIDGET_F_INITIALISED                8192  0x00002000 (const dword)  (usage 3)
WIDGET_F_INTERNAL                  16384  0x00004000 (const dword)  (not used)
WIDGET_F_RESERVED                    960  0x000003c0 (const dword)  (not used)
WIDGET_F_TOUCH_ENABLE              32768  0x00008000 (const dword)  (usage 3)
WIDGET_F_UNDRAW_ONLY                4096  0x00001000 (const dword)  (not used)
WIDGET_FLAGS                           6  0x00000006 (const dword)  (not used)
widget_FontID                       -336  0xfffffeb0 (PmmC func) args[1] r=1  (not used)
WIDGET_FRAMES                         11  0x0000000b (const dword)  (not used)
widget_GetWord                      -328  0xfffffeb8 (PmmC func) args[3] r=1  (not used)
WIDGET_HEIGHT                          3  0x00000003 (const dword)  (not used)
WIDGET_HI_WORD                         5  0x00000005 (const dword)  (not used)
WIDGET_LO_WORD                         4  0x00000004 (const dword)  (not used)
widget_LoadFlash                    -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
WIDGET_RAM_SPACE                      10  0x0000000a (const dword)  (usage 42)
widget_Realloc                      -327  0xfffffeb9 (PmmC func) args[2] r=1  (not used)
widget_SetAttributes                -333  0xfffffeb3 (PmmC func) args[3] r=1  (usage 3)
widget_Setposition                  -329  0xfffffeb7 (PmmC func) args[4] r=1  (not used)
widget_SetWord                      -332  0xfffffeb4 (PmmC func) args[4] r=1  (not used)
widget_Show                         -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
WIDGET_TAG                             7  0x00000007 (const dword)  (not used)
WIDGET_TAG2                            8  0x00000008 (const dword)  (not used)
widget_Touched                      -335  0xfffffeb1 (PmmC func) args[2] r=1  (usage 3)
WIDGET_VAL1                            9  0x00000009 (const dword)  (usage 9)
WIDGET_VAL2                           10  0x0000000a (const dword)  (not used)
WIDGET_WIDTH                           2  0x00000002 (const dword)  (not used)
WIDGET_XOTHER                          4  0x00000004 (const dword)  (not used)
WIDGET_XPOS                            0  0x00000000 (const dword)  (not used)
WIDGET_YOTHER                          5  0x00000005 (const dword)  (not used)
WIDGET_YPOS                            1  0x00000001 (const dword)  (not used)
wp                                   858  0x0000035a (mem) word (global)  (usage 21)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_LABEL                           12  0x0000000c (const dword)  (usage 6)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_STR                              2  0x00000002 (const dword)  (usage 6)
WRITE_STRU                             3  0x00000003 (const dword)  (usage 6)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         6391  0x000018f7 (User func) args[3] r=0  (usage 27)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
xobj2iobj                            209  0x000000d1xobj2iobj                            209  0x000000d1 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
XYLIN_X                                1  0x00000001 (const dword)  (not used)
XYLIN_Y                                0  0x00000000 (const dword)  (not used)
XYROT_EAST                             0  0x00000000 (const dword)  (not used)
XYROT_SOUTH                            1  0x00000001 (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
