file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\pixxiLCD-39P4CT.fnc

000001  000001  #platform "pixxiLCD-39P4CT"
000002  000001  #platform "pixxiLCD-39P4CT"
000003  000008  */
000004  000009      #constant pixxiLCD_39P4CT
000005  000009      #constant pixxiLCD_39P4CT
000006  000010        
000007  000011      #IFNOT EXISTS PIXXI44_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PIXXI44functions.fnc

000008  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000009  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PIXXI44_FUNCTIONS
000014  000004  #constant PIXXI44_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000019  #END
000019  000020        
000020  000021  #CONST
000021  000027  #END
000022  000028        
000023  000029        
000024  000030  #CONST
000025  000044  #END
000026  000045        
000027  000046        
000028  000047  #CONST
000029  000212  #END
000030  000213        
000031  000214        
000032  000215  // baud divisor rates for setbaud(n);
000033  000216  #CONST
000034  000238  #END
000035  000239        
000036  000240        
000037  000241        
000038  000242        
000039  000247  */
000040  000248        
000041  000249        
000042  000250  //==============================================//
000043  000251  // EVE bios functions                           //
000044  000252  //==============================================//
000045  000253                                                  //
000046  000254  func serin(), 1;                // read a byte from COM0
000047  000255  // Syntax: serin();
000048  000256  // Usage : char := serin();
000049  000257  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000258  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000259  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000260  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000261  //     : Returns: -1 if no character is available
000054  000262  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000263  //     : Returns: positive value 0 to 255 for a valid character received
000056  000264        
000057  000265  func putch("char"), 0;                // write single char to current output device
000058  000266  // Syntax: putch("char");
000059  000267  // Usage : putch("A");
000060  000268  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000269  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000270  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000271  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000272  //     : The arguments can be a variable, array element, expression or constant
000065  000273        
000066  000274  func serout("char"), 0;                // write a byte to COM0
000067  000275  // Syntax: serout1("char");
000068  000276  // Usage : serout1(ch);
000069  000277  // Notes : send character to COM1
000070  000278        
000071  000279  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000280  // Syntax: setbaud(baud_number);
000073  000281  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000282  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000283  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000284  //       : this is used as a table pointer to get the baud rate divisor
000077  000285  //       : value for one of the 20 selected baud rates, control is then
000078  000286  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000287  //       : The pre-defined constants equate to a value of 0-19.
000080  000288  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000289  //       : will occur.
000082  000290        
000083  000291  func to("device"), 1;                // output device redirection
000084  000292  // Syntax: to(outstream);
000085  000293  // Usage : to(APPEND); putstr("TWO ");
000086  000294  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000295  //     :
000088  000296  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000297  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000298  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000299  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000300  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000301  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000302  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000303  //     : sequential data to a media stream.
000096  000304  //     :
000097  000305  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000306  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000307  //     :                            appended to user memory if previous redirection was to an array.
000100  000308  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000309  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000310  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000311  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000312  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000313        
000106  000314        
000107  000315  func pause("milliseconds"), 0;            // blocking delay
000108  000316  // Syntax: pause(milliseconds);
000109  000317  // Usage : pause(1000);                //pause for 1 second
000110  000318  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000319        
000112  000320  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000321  // Syntax: putnum(format, value);
000114  000322  // Usage : var := putnum(HEX, val);
000115  000323  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000324  //     : Format: A constant that specifies the number format
000117  000325  //     : Value : The number to be printed
000118  000326  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000327  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000328  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000329  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000330  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000331  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000332  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000333  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000334  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000335  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000336  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000337  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000338  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000339  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000340  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000341  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000342  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000343  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000344  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000345  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000346  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000347  //     : | | | | V V V
000140  000348  //     : | | | | | | |
000141  000349  //     : | | | | | |
000142  000350  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000351  //     : | | | | digit count |
000144  000352  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000353  //     : | | | |
000146  000354  //     : | | | |
000147  000355  //     : | | | |
000148  000356  //     : | | | |
000149  000357  //     : | | | |
000150  000358  //     : | | | |______ 1 = leading zeros included
000151  000359  //     : | | | 0 = leading zeros suppressed
000152  000360  //     : | | |
000153  000361  //     : | | |
000154  000362  //     : | | |_______ 1 = leading zero blanking
000155  000363  //     : | |
000156  000364  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000365  //     : |
000158  000366  //     : |______ 1 = space before unsigned number
000159  000367        
000160  000368        
000161  000369  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000370        
000163  000371  func putstr("string"), 1;                       // print string to current output device
000164  000372  // Syntax: putstr(pointer);
000165  000373  // Usage : putstr("HELLO\n");
000166  000374  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000375  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000376  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000377  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000378  //       : using the to(...); function.
000171  000379  //       : A string constant is automatically terminated with a zero.
000172  000380  //       : A string in a data statement is not automatically terminated with a zero.
000173  000381  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000382  //       : element packs 1 or 2 characters.
000175  000383        
000176  000384        
000177  000385  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000386  // Syntax: strlen("varAddress);
000179  000387  // Usage : strlen("HELLO\n");
000180  000388  // Notes : gives the length of a string that is packed into regular var array
000181  000389  //       : Use str_Length(ptr)  for string pointer mode
000182  000390        
000183  000391        
000184  000392  //==============================================//
000185  000393  // Memory Access Function Prototypes            //
000186  000394  //==============================================//
000187  000395                                                  //
000188  000396  func peekW("address"), 1;                       // read a word from system memory
000189  000397  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000398  // refer to address map of internal variables   //
000191  000399  //==============================================//
000192  000400  // Math Functions                               //
000193  000401  //==============================================//
000194  000402                                                  //
000195  000403  func ABS("value"), 1;                           // return a positive number
000196  000404  // Syntax: ABS(value);
000197  000405  // Usage : var := ABS(arg);
000198  000406  // Notes : Returns the absolute value of an argument
000199  000407        
000200  000408  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000409  // Syntax: MIN(value1, value2);
000202  000410  // Usage : var := MIN(arg1, arg2);
000203  000411  // Notes : Returns the minimum of 2 arguments
000204  000412        
000205  000413  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000414  // Syntax: MAX(value1, value2);
000207  000415  // Usage : var := MAX(arg1, arg2);
000208  000416  // Notes : Returns the maximum of 2 arguments
000209  000417        
000210  000418  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000419  // Syntax: SWAP(&var1, &var2);
000212  000420  // Usage : SWAP(&var1, &var2);
000213  000421  // Notes : Swaps the contents of 2 variables or memory locations
000214  000422        
000215  000423  func SIN("angle"), 1;                           // return SIN of angle
000216  000424  // Syntax: SIN(angle);
000217  000425  // Usage : var := SIN(arg);
000218  000426  // Notes : Returns the sine in radians of an argument in degrees
000219  000427  //       : the returned value range is from 127 to -127. The real
000220  000428  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000429  //       : scaling must be done in user code.
000222  000430        
000223  000431  func COS("angle"), 1;                           // return COS of angle
000224  000432  // Syntax: COS(angle);
000225  000433  // Usage : var := COS(arg);
000226  000434  // Notes : Returns the cosine in radians of an argument in degrees
000227  000435  //       : the returned value range is from 127 to -127. The real
000228  000436  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000437  //       : scaling must be done in user code.
000230  000438        
000231  000439  func RAND(), 1;                                 // return a pseudo random number
000232  000440  // Syntax: RAND();
000233  000441  // Usage : var := RAND();
000234  000442  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000443  //       : The random number generator must first be seeded
000236  000444  //       : by using the SEED(number) function.
000237  000445        
000238  000446  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000447  // Syntax: SEED(number);
000240  000448  // Usage : SEED(arg);
000241  000449  // Notes : Seeds the random number generator.
000242  000450        
000243  000451  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000452  // Syntax: OVF();
000245  000453  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000454  //       : hiWord := OVF();
000247  000455  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000456        
000249  000457  func SQRT("number"), 1;                         // return square root of a number
000250  000458  // Syntax: SQRT(number);
000251  000459  // Usage : SQRT(arg);
000252  000460  // Notes : Returns the integer square root of a number.
000253  000461  //------------------------------------------------------------------//
000254  000462  //          Text Related Function Prototypes
000255  000463  //------------------------------------------------------------------//
000256  000464        
000257  000465  func txt_MoveCursor("line", "column"), 0;
000258  000466  // Syntax: txt_SetCursor(line, column);
000259  000467  // Usage : txt_SetCursor(arg1, arg2);
000260  000468  // Notes : Moves the text Cursor to a new screen position set by
000261  000469  //       : line,column parameters.
000262  000470        
000263  000471  func txt_Set("mode", "value"), 0;
000264  000472  // Syntax: txt_Set(mode, value);
000265  000473  // Usage : txt_Set(arg1, arg2);
000266  000474  // Returns : Original value before the change
000267  000475  // Notes : Sets various text related parameters used by other functions
000268  000476  //       : This allows the features to be set programatically with a
000269  000477  //       : single function call.It is strongly recommended to use the
000270  000478  //       : pre-defined constants rather than the mode numbers.
000271  000479  //       : NB:- Although it is often required to be able to set text
000272  000480  //       : functions with a single function call for graphics engine
000273  000481  //       : related functions, there is a complete set of single parameter
000274  000482  //       : shortcut functions that have exactly the same function as
000275  000483  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000484  //       :
000277  000485  //       : mode = TEXT_COLOUR (mode 0)
000278  000486  //       : txt_Set(TEXT_COLOUR, value);
000279  000487  //       : value = 0 to 0xFFFF, Black to White
000280  000488  //       : Sets the Text colour for the display
000281  000489  //       : Default = LIME.
000282  000490  //       :
000283  000491  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000492  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000493  //       : value = 0 to 0xFFFF, Black to White
000286  000494  //       : Sets the Text background colour for the display. Effective
000287  000495  //       : when text mode is Opaque.
000288  000496  //       : Default = BLACK.
000289  000497  //       :
000290  000498  //       : mode = FONT_ID (mode 2)
000291  000499  //       : txt_Set(FONT_ID, value);
000292  000500  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000501  //       : else this value is the name of a font included
000294  000502  //       : in a users program in a data statement.
000295  000503  //       : Default = FONT SIZE 3.
000296  000504  //       :
000297  000505  //       : mode = TEXT_WIDTH  (mode 3)
000298  000506  //       : txt_Set(TEXT_WIDTH, value);
000299  000507  //       : value = 1 to 16
000300  000508  //       : Sets the Text Width multiplier
000301  000509  //       : text will be printed magnified horizontally
000302  000510  //       : by this factor, Default = 1.
000303  000511  //       :
000304  000512  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000513  //       : txt_Set(TEXT_HEIGHT, value);
000306  000514  //       : value = 1 to 16
000307  000515  //       : Sets the Text Height multiplier
000308  000516  //       : text will be printed magnified vertically
000309  000517  //       : by this factor, Default = 1.
000310  000518  //       :
000311  000519  //       : mode = TEXT_XGAP  (mode 5)
000312  000520  //       : txt_Set(TEXT_XGAP, value);
000313  000521  //       : value = 1 to 32
000314  000522  //       : Sets the horizontal gap between characters
000315  000523  //       : The gap is in pixel units, Default = 0
000316  000524  //       :
000317  000525  //       : mode = TEXT_YGAP  (mode 6)
000318  000526  //       : txt_Set(TEXT_YGAP, value);
000319  000527  //       : value = 1 to 32
000320  000528  //       : Sets the vertical gap below characters
000321  000529  //       : The gap is in pixel units, Default = 0
000322  000530  //       :
000323  000531  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000532  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000533  //       : value = 0 to 255
000326  000534  //       : Sets the delay time (in ms) during character
000327  000535  //       : printing to give a 'teletype' like effect.
000328  000536  //       : Often used to attract attention to a string
000329  000537  //       : being printed which can often be missed if
000330  000538  //       : just suddenly appearing or changing.
000331  000539  //       : Default = 0 ms.
000332  000540  //       :
000333  000541  //       : mode = TEXT_OPACITY (mode 8)
000334  000542  //       : txt_Set(TEXT_OPACITY, value);
000335  000543  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000544  //       : value = OPAQUE (1) = Text Opaque
000337  000545  //       : Sets the Opacity/Transparency of the text
000338  000546  //       : Default = 0 or TRANSPARENT
000339  000547  //       :
000340  000548  //       : mode = TEXT_BOLD (mode 9)
000341  000549  //       : txt_Set(TEXT_BOLD, value);
000342  000550  //       : value = dont care
000343  000551  //       : Sets Bold Text mode for the next string or char
000344  000552  //       : The feature automatically resets after printing
000345  000553  //       : using putstr or print has completed
000346  000554  //       :
000347  000555  //       : mode = TEXT_ITALIC (mode 10)
000348  000556  //       : txt_Set(TEXT_ITALIC, value);
000349  000557  //       : value = dont care
000350  000558  //       : Sets Italic Text mode for the next string or char
000351  000559  //       : The feature automatically resets after printing
000352  000560  //       : using putstr or print has completed
000353  000561        
000354  000562  //       : mode = TEXT_INVERSE (mode 11)
000355  000563  //       : txt_Set(TEXT_INVERSE, value);
000356  000564  //       : value = dont care
000357  000565  //       : Sets Inverse Text mode for the next string or char
000358  000566  //       : The feature automatically resets after printing
000359  000567  //       : using putstr or print has completed
000360  000568  //       :
000361  000569  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000570  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000571  //       : value = dont care
000364  000572  //       : Sets Underlined Text mode for the next string or char
000365  000573  //       : The feature automatically resets after printing
000366  000574  //       : using putstr or print has completed
000367  000575  //       :
000368  000576  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000577  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000578  //       : value = bits are defined as:
000371  000579  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000580  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000581  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000582  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000583  //       : Allows a combination of text attributes to be defined together
000376  000584  //       : by 'or'ing the bits together.
000377  000585  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000586  //       : The feature automatically resets after printing
000379  000587  //       : using putstr or print has completed.
000380  000588  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000589  //       :
000382  000590  //       : mode = TEXT_WRAP (mode 14)
000383  000591  //       : txt_Set(TEXT_WRAP , value);
000384  000592  //       : Sets the position where text wrap will occur
000385  000593  //       : The feature automatically resets when screen
000386  000594  //       : mode is changed. If the value is set to 0,
000387  000595  //       : text wrap is turned off.
000388  000596  //       : of the current screen. Default value is 0
000389  000597  // Notes : The value is in pixel units.
000390  000598  //       :
000391  000599        
000392  000600  //       : txt_Set mode 15 reserved for future use
000393  000601  //       :
000394  000602        
000395  000603        
000396  000604        
000397  000605  //=====================================================//
000398  000606  // Single parameter short-cuts                         //
000399  000607  // for the txt_Set functions                           //
000400  000608  // These functions return the existing value before    //
000401  000609  // the change is made.                                 //
000402  000610  //=====================================================//
000403  000611  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000612  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000613  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000614  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000615  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000616  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000617  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000618  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000619  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000620  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000621  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000622  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000623  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000624  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000625  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000626  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000627        
000420  000628        
000421  000629  //------------------------------------------------------------------//
000422  000630  //                 Hardware Function Prototypes
000423  000631  //------------------------------------------------------------------//
000424  000632        
000425  000633  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000426  000634  // Syntax: pin_Set(mode, pin);
000427  000635  // Usage : pin_Set(arg1, arg2);
000428  000636  // Notes : Sets the appropriate pins to Inputs or Outputs
000429  000637  //       : returns true if the pin number is legal (usually ignored)
000430  000638  //       :
000431  000639  //       : "mode" is either INPUT or OUTPUT
000432  000640  //       :
000433  000641  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000434  000642  //       : of your PiXXi-44 processor.
000435  000643        
000436  000644  func pin_HI("pin"), 1;                    // set pin to logic '1'
000437  000645  // Syntax: pin_HI(pin);
000438  000646  // Usage : pin_HI(arg);
000439  000647  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000440  000648  //       : pin that was previously selected as an Output.
000441  000649  //       : returns true if the pin number is legal (usually ignored)
000442  000650  //       :
000443  000651  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000444  000652  //       : of your PiXXi-44 processor.
000445  000653        
000446  000654  func pin_LO("pin"), 1;                    // set pin to logic '0'
000447  000655  // Syntax: pin_LO(pin);
000448  000656  // Usage : pin_LO(arg);
000449  000657  // Notes : Outputs a logic "Low" (0V) on the appropriate
000450  000658  //       : pin that was previously selected as an Output.
000451  000659  //       : returns true if the pin number is legal (usually ignored)
000452  000660  //       :
000453  000661  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000454  000662  //       : of your PiXXi-44 processor.
000455  000663        
000456  000664  func pin_Read("pin"), 1;                // read pin, logic or analogue
000457  000665  // Syntax	: pin_Read(pin);
000458  000666  // Usage	: arg1 := pin_Read(arg2);
000459  000667  // Notes	: Reads the logic state of the appropriate
000460  000668  // 	: pin that was previously selected as an Input.
000461  000669  // 	:
000462  000670  // 	: "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000463  000671  // 	: of your PiXXi-44 processor.
000464  000672  // 	: Returns 0 or 1 for a digital input
000465  000673  // 	: Returns 0..4095 for an analogue input
000466  000674        
000467  000675  //------------------------------------------------------------------//
000468  000676  //                 P1 module BUS I/O control
000469  000677  //------------------------------------------------------------------//
000470  000678        
000471  000679  func bus_In(), 1;
000472  000680  // Syntax: bus_In();
000473  000681  // Usage : arg1 := bus_In();
000474  000682  // Notes : Read the 7bit wide bus into the lower 7 bits of arg1.
000475  000683  //       : The upper 9 bits of arg1 are set to 0.
000476  000684  //       : Only available in Mode 2 (4-Wire SPI)
000477  000685  //       : 
000478  000686  //       : BUS_0 is IO12_PIN
000479  000687  //       : BUS_1 is IO13_PIN
000480  000688  //       : BUS_2 is IO14_PIN
000481  000689  //       : BUS_3 is IO15_PIN
000482  000690  //       : BUS_4 is IO16_PIN
000483  000691  //       : BUS_5 is IO17_PIN
000484  000692  //       : BUS_6 is IO18_PIN
000485  000693  //       : BUS_7 is N/A
000486  000694        
000487  000695  func bus_Out("var"), 0;
000488  000696  // Syntax: bus_Out(var);
000489  000697  // Usage : bus_Out(arg1);
000490  000698  // Notes : The lower 7 bits of arg1 are placed on the 7bit wide bus.
000491  000699  //       : The upper 9 bits of arg1 are ignored.
000492  000700  //       : NB:- any BUS pins that are set to inputs are not affected.
000493  000701  //       : Only available in Mode 2 (4-Wire SPI)
000494  000702  //       :
000495  000703  //       : BUS_0 is pin 27 of J1
000496  000704  //       : BUS_1 is pin 25 of J1
000497  000705  //       : BUS_2 is pin 23 of J1
000498  000706  //       : BUS_3 is pin 21 of J1
000499  000707  //       : BUS_4 is pin 19 of J1
000500  000708  //       : BUS_5 is pin 17 of J1
000501  000709  //       : BUS_6 is pin 13 of J2
000502  000710  //       : BUS_7 is pin 11 of J2
000503  000711        
000504  000712  func bus_Set("var"), 0;
000505  000713  // Syntax: bus_Set(var);
000506  000714  // Usage : bus_Set(arg1);
000507  000715  // Notes : Not available on the Pixxi Chips
000508  000716        
000509  000717  func bus_Write("var"), 0;
000510  000718  // Syntax: bus_Write(var);
000511  000719  // Usage : bus_Write(arg1);
000512  000720  // Notes : Not available on the Pixxi Chips
000513  000721        
000514  000722  func bus_Read(), 1;
000515  000723  // Syntax: bus_Read();
000516  000724  // Usage : arg1 := bus_Read();
000517  000725  // Notes : Not available on the Pixxi Chips
000518  000726        
000519  000727        
000520  000728  //------------------------------------------------------------------//
000521  000729  //   Graphics Functions
000522  000730  //------------------------------------------------------------------//
000523  000731  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000524  000732  // Syntax: gfx_Set(mode, value);
000525  000733  // Usage : gfx_Set(arg1, arg2);
000526  000734  // Notes : Sets various graphics parameters used by other functions
000527  000735  //       : This allows the features to be set programatically with a
000528  000736  //       : single function call.It is strongly recommended to use the
000529  000737  //       : pre-defined constants rather than the mode numbers.
000530  000738  //       : NB:- Although it is often required to be able to set graphics
000531  000739  //       : functions with a single function call for graphics engine
000532  000740  //       : related functions, there is a complete set of single parameter
000533  000741  //       : shortcut functions that have exactly the same function as
000534  000742  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000535  000743  //       :
000536  000744  //       : mode = PEN_SIZE (mode 16)
000537  000745  //       : gfx_Set(PEN_SIZE, value);
000538  000746  //       : value = SOLID (value 0) rectangle and circle objects are solid
000539  000747  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000540  000748  //       : Sets the mode of the Pen used by most graphics objects
000541  000749  //       :
000542  000750  //       : mode = BACKGROUND_COLOUR (mode 17)
000543  000751  //       : gfx_Set(BACKGROUND_COLOUR, value);
000544  000752  //       : value = 0 to 0xFFFF, Black to White
000545  000753  //       : Sets the Background colour of the screen
000546  000754  //       :
000547  000755  //       : mode = OBJECT_COLOUR (mode 18)
000548  000756  //       : gfx_Set(OBJECT_COLOUR, value);
000549  000757  //       : value = 0 to 0xFFFF, Black to White
000550  000758  //       : Sets the Object colour used in various functions
000551  000759  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000552  000760  //       :
000553  000761  //       : mode = CLIPPING (mode 19)
000554  000762  //       : gfx_Set(CLIPPING, value);
000555  000763  //       : value = OFF (value 0) Clipping disabled
000556  000764  //       : value = ON (value 1) Clipping enabled
000557  000765  //       : Enables/Disables the Clipping feature
000558  000766  //       :
000559  000767  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000560  000768  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000561  000769  //       : value = 0 to 0xFFFF Black to White
000562  000770  //       : Sets Bitmap, Image or Animation Transparency Colour.
000563  000771  //       : NB not implemented
000564  000772  //       :
000565  000773  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000566  000774  //       : gfx_Set(5, value);
000567  000775  //       : value = OFF (value 0) Transparency disabled
000568  000776  //       : value = ON (value 1) Transparency enabled
000569  000777  //       : Enables/Disables the Transparency feature
000570  000778  //       : NB not implemented
000571  000779  //       :
000572  000780  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000573  000781  //       : gfx_Set(FRAME_DELAY, value);
000574  000782  //       : value = 0 to 65535 ms
000575  000783  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000576  000784  //       : over-ride the embedded frame delay of the clip. After the event,
000577  000785  //       : the setting will auto disable and if further inter-frame delays need
000578  000786  //       : overriding the setting must be re-issued.
000579  000787  //       :
000580  000788  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000581  000789  //       : gfx_Set(SCREEN_MODE, value);
000582  000790  //       : value = LANDSCAPE   (value 0)
000583  000791  //       : value = LANDSCAPE_R (value 1)
000584  000792  //       : value = PORTRAIT    (value 2)
000585  000793  //       : value = PORTRAIT_R  (value 3)
000586  000794  //       :
000587  000795  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000588  000796  //       : gfx_Set(OUTLINE_COLOUR, value);
000589  000797  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000590  000798  //       : Sets the filled Rectangle or Circle objects outline colour
000591  000799  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000592  000800  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000593  000801  //       :
000594  000802  //       : Only supports variable contrast for uOLED Modules
000595  000803  //       : mode = CONTRAST (mode 25) : Contrast
000596  000804  //       : gfx_Set(CONTRAST, value);
000597  000805  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000598  000806  //       : when contrast=0, display is placed in low power mode.
000599  000807  //       : This function should be called with contrast=0 when
000600  000808  //       : powering down the module.
000601  000809  //       :
000602  000810  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000603  000811  //       : gfx_Set(LINE_PATTERN, value);
000604  000812  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000605  000813  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000606  000814  //       : a value of 0 turns the feature off
000607  000815  //       :
000608  000816  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000609  000817  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000610  000818  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000611  000819  //       : NB not implemented, default is COLOUR16
000612  000820  //       :
000613  000821  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000614  000822  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000615  000823  //       : sets the button and slider objects bevel width
000616  000824  //       :
000617  000825  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000618  000826  //       : gfx_Set(BEVEL_SHADOW , 5);
000619  000827  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000620  000828  //       :
000621  000829  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000622  000830  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000623  000831  //       : sets the origin of drawn objects to a position other than 0,0
000624  000832  //       :
000625  000833  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000626  000834  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000627  000835  //       : sets the origin of drawn objects to a position other than 0,0
000628  000836        
000629  000837        
000630  000838  func gfx_Cls(), 0;                    // clear the screen
000631  000839  // Syntax: gfx_Cls();
000632  000840  // Usage : gfx_Cls();
000633  000841  // Notes : Clears the screen with current background colour
000634  000842        
000635  000843  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000636  000844  // Syntax: gfx_MoveTo(x, y);
000637  000845  // Usage : gfx_MoveTo(arg1, arg2);
000638  000846  // Notes : Moves the origin to a new x,y position
000639  000847        
000640  000848  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000641  000849  // Syntax: gfx_MoveRel(x, y);
000642  000850  // Usage : gfx_MoveRel(arg1, arg2);
000643  000851  // Notes : Moves the origin to a new x,y position
000644  000852  //       : relative to the current origing
000645  000853        
000646  000854  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000647  000855  // Syntax: gfx_LineTo(x1, y1);
000648  000856  // Usage : gfx_LineTo(arg1, arg2);
000649  000857  // Notes : Draws a Line from the origin x,y to x1,y1.
000650  000858  //       : The new origin is then set to x1, y1. Line colour needs
000651  000859  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000652  000860        
000653  000861  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000654  000862  // Syntax: gfx_LineRel(x1, y1);
000655  000863  // Usage : gfx_LineRel(arg1, arg2);
000656  000864  // Notes : Draws a Line from the origin x,y to x1,y1.
000657  000865  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000658  000866  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000659  000867        
000660  000868  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000661  000869  // Syntax: gfx_Line(x1, x2, y2, colr);
000662  000870  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000663  000871  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000664  000872        
000665  000873  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000666  000874  // Syntax: gfx_Line(x1, x2, y, colr);
000667  000875  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000668  000876  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000669  000877        
000670  000878  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000671  000879  // Syntax: gfx_Line(y1, y2, x, colr);
000672  000880  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000673  000881  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000674  000882        
000675  000883  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000676  000884  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000677  000885  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000678  000886  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000679  000887  //       : bottom corner (x2,y2) on the screen.
000680  000888        
000681  000889  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000682  000890  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000683  000891  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000684  000892  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000685  000893  //       : bottom corner (x2,y2) on the screen.
000686  000894        
000687  000895  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000688  000896  // Syntax: gfx_Circle(x, y, rad, colr);
000689  000897  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000690  000898  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000691  000899        
000692  000900  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000693  000901  // Syntax: gfx_Circle(x, y, rad, colr);
000694  000902  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000695  000903  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000696  000904        
000697  000905  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000698  000906  // Syntax: gfx_PutPixel(x, y, colr);
000699  000907  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000700  000908  // Notes : Plots a coloured pixel on the screen at x,y location
000701  000909        
000702  000910  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000703  000911  // Syntax: gfx_GetPixel(x, y);
000704  000912  // Usage : var := gfx_GetPixel(arg1, arg2);
000705  000913  // Notes : Reads and returns the colour value of a pixel at location x,y
000706  000914        
000707  000915  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000708  000916  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000709  000917  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000710  000918  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000711  000919  //       : Vertices must be specified in an anti-clockwise fashion
000712  000920        
000713  000921  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000714  000922  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000715  000923  // Usage : gfx_OrbitInit(&arg1, &arg2);
000716  000924  // Notes : Sets up the Orbit function parameters.
000717  000925  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000718  000926  //       : variables that get updated after calling gfx_Orbit(,,) function.
000719  000927  //       : The coordiantaes are calculated relative to the origin
000720  000928  //       : obtained by using the gfx_MoveTo(x, y) function.
000721  000929        
000722  000930  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000723  000931  // Syntax: gfx_Orbit(angle, distance);
000724  000932  // Usage : gfx_Orbit(arg1, arg2);
000725  000933  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000726  000934  //       : only known parameters are the angle and the distance from the current origin.
000727  000935        
000728  000936  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000729  000937  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000730  000938  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000731  000939  // Notes : This function is very similar to the Ploygon function
000732  000940  //       : with the exception of the 1st and the last vertices not joined.
000733  000941        
000734  000942  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000735  000943  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000736  000944  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000737  000945  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000738  000946  //       : Vertices must be minimum of 3 and can be specified in any fashion
000739  000947        
000740  000948  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000741  000949  // Syntax: gfx_Dot();
000742  000950  // Usage : gfx_Dot();
000743  000951  // Notes : Places a coloured dot at the origin
000744  000952        
000745  000953        
000746  000954  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000747  000955  // Syntax: gfx_Bullet();
000748  000956  // Usage : gfx_Bullet();
000749  000957  // Notes : Places a coloured circle at the origin
000750  000958  //       : filled or unfilled state is controlled by PenSize
000751  000959        
000752  000960  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000753  000961  // Syntax: gfx_IncX();
000754  000962  // Usage : var := gfx_IncX();
000755  000963  // Notes : Increments the x coordinate of the origin
000756  000964        
000757  000965  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000758  000966  // Syntax: gfx_IncY();
000759  000967  // Usage : var := gfx_IncY();
000760  000968  // Notes : Increments the y coordinate of the origin
000761  000969        
000762  000970  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000763  000971  // Syntax: gfx_BoxTo(x1, y1);
000764  000972  // Usage : gfx_BoxTo(arg1, arg2);
000765  000973  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000766  000974  //       : The new origin is then set to x1,y1. Rectangle colour needs
000767  000975  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000768  000976  //       : and the PenSize setting determines if Box is solid or outline.
000769  000977        
000770  000978  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000771  000979  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000772  000980  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000773  000981  // Notes : Specifies a clipping window region on the screen such that any objects
000774  000982  //       : and text placed onto the screen will be clipped and displayed only
000775  000983  //       : within that region. For the clipping window to take effect, "Clipping"
000776  000984  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000777  000985        
000778  000986        
000779  000987  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000780  000988  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000781  000989  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000782  000990  // *Notes:
000783  000991        
000784  000992  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000785  000993  // Syntax: gfx_SetClipRegion();
000786  000994  // Usage : var := gfx_SetClipRegion();
000787  000995  // *Notes:
000788  000996        
000789  000997  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000790  000998  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000791  000999  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000792  001000  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000793  001001  //       : with xradius = xrad and yradius = yrad.
000794  001002  //       : if PenSize = 0 Ellipse is Solid
000795  001003  //       : if PenSize = 1 Ellipse is Outline
000796  001004        
000797  001005        
000798  001006  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000799  001007  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000800  001008  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000801  001009  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000802  001010  //       : with xradius = xrad and yradius = yrad.
000803  001011        
000804  001012  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000805  001013  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000806  001014  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000807  001015  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000808  001016  //       : x,y arguments (top left corner). The size of the button depends on
000809  001017  //       : the font, width, height and length of the text.
000810  001018  //       : The button appearance will depend on the state parameter setting:
000811  001019  //       :         state = 0 : Button Pressed
000812  001020  //       :         state = 1 : Button Raised
000813  001021        
000814  001022  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000815  001023  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000816  001024  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000817  001025  // Notes : Draws a panel (groupbox) at screen location defined by
000818  001026  //       : x, y, width and height with colour "colour".
000819  001027  //       :         state = 0 : recessed
000820  001028  //       :         state = 1 : raised
000821  001029        
000822  001030  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000823  001031  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000824  001032  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000825  001033  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000826  001034  //       : Slider parameters are as follows:
000827  001035  //       :         mode = 0 : Slider recessed
000828  001036  //       :         mode = 1 : Slider raised
000829  001037  //       :         x1, y1 = top left corner
000830  001038  //       :         x2, y2 = bottom right corner
000831  001039  //       :         scale = n : sets the full scale range from 0 to n
000832  001040  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000833  001041  //       : returns:-
000834  001042        
000835  001043        
000836  001044  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000837  001045  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000838  001046  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000839  001047  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000840  001048  //       : and pastes it to another location determined by xd, yd.
000841  001049        
000842  001050  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000843  001051  // Syntax: gfx_RGBto565(red, green, blue);
000844  001052  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000845  001053  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000846  001054        
000847  001055  func gfx_332to565("COLOUR8BIT"), 1;
000848  001056  // Syntax: gfx_332to565(colour);
000849  001057  // Usage : gfx_332to565(arg);
000850  001058  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000851  001059        
000852  001060  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000853  001061  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000854  001062  // Usage : gfx_Selection(1, RED, YELLOW);
000855  001063  // Notes : Called prior to drawing a button, this function
000856  001064  //       : hilites the required text line on a multiline button.
000857  001065        
000858  001066  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000859  001067  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000860  001068  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000861  001069  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000862  001070  //       : Vertices must be specified in an anti-clockwise fashion
000863  001071        
000864  001072        
000865  001073  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000866  001074  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000867  001075  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
000868  001076  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000869  001077  //       : Vertices must be minimum of 3 and can be specified in any fashion
000870  001078        
000871  001079        
000872  001080  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
000873  001081  // Syntax: gfx_Offset(x, y);
000874  001082  // Usage : gfx_Offset(arg1, arg2);
000875  001083  // Notes : Set the screen offset
000876  001084        
000877  001085        
000878  001086        
000879  001087  func gfx_Get("mode"), 1;
000880  001088  // Syntax: gfx_Get(mode);
000881  001089  // Usage : arg1 := gfx_Get(arg);
000882  001090  // Notes : Returns various parameters to caller
000883  001091  //       :
000884  001092  //       : mode = X_MAX (mode 0) : current orientations maximum X value
000885  001093  //       : var := gfx_Get(X_MAX);
000886  001094  //       : Returns the maximum horizontal value of the display
000887  001095  //       :
000888  001096  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
000889  001097  //       : var := gfx_Get(Y_MAX);
000890  001098  //       : Returns the maximum vertical value of the display
000891  001099  //       :
000892  001100  //       : mode = LEFT_POS (mode 2) : Left location of last Object
000893  001101  //       : var := gfx_Get(LEFT_POS);
000894  001102  //       : Returns the left location of the last drawn object
000895  001103  //       : such as a slider or button or an image/video
000896  001104  //       :
000897  001105  //       : mode = TOP_POS (mode 3) : Top location of Object
000898  001106  //       : var := gfx_Get(TOP_POS);
000899  001107  //       : Returns the top location of the last drawn object
000900  001108  //       : such as a slider or button or an image/video
000901  001109  //       :
000902  001110  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
000903  001111  //       : var := gfx_Get(RIGHT_POS);
000904  001112  //       : Returns the right location of the last drawn object
000905  001113  //       : such as a slider or button or an image/video
000906  001114  //       :
000907  001115  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
000908  001116  //       : var := gfx_Get(BOTTOM_POS );
000909  001117  //       : Returns the bottom location of the last drawn object
000910  001118  //       : such as a slider or button or an image/video
000911  001119  //       :
000912  001120        
000913  001121        
000914  001122  //==================================================//
000915  001123  // Single parameter short-cuts                      //
000916  001124  // for the gfx_Set functions                        //
000917  001125  // These functions return the existing value before //
000918  001126  // the change is made.                              //
000919  001127  //==================================================//
000920  001128  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
000921  001129  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
000922  001130  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
000923  001131  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
000924  001132  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
000925  001133  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
000926  001134  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
000927  001135  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
000928  001136  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
000929  001137  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
000930  001138  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
000931  001139  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
000932  001140  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
000933  001141  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
000934  001142  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
000935  001143  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
000936  001144        
000937  001145        
000938  001146  //==================================================//
000939  001147  // uSD/FLASH Function Prototypes                    //
000940  001148  //==================================================//
000941  001149  func media_Video("x", "y"), 0;                      // display movie at position x y
000942  001150  // Syntax: media_Video(x, y);
000943  001151  // Usage : media_Video(arg1, arg2);
000944  001152  // Notes : Play a Video/Animation clip from the uSD card at screen location
000945  001153  //       : specified by x,y (top left corner). The location of the clip in the
000946  001154  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
000947  001155        
000948  001156  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
000949  001157  // Syntax: media_VideoFrame(Frame_number);
000950  001158  // Usage : arg1 := media_VideoFrame();
000951  001159  // Notes : After a pointer to a valid video has been set with media_SetSector,
000952  001160  //       : calling this function shows each fram sequentially, returning
000953  001161  //       : the number of frames remaining. The position of the image is
000954  001162  //     : at the current origin as set with gfx_MoveTo(...);
000955  001163        
000956  001164  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
000957  001165  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
000958  001166  // Usage : media_SetAdd(arg1, arg2);
000959  001167  // Notes : Set uSD internal Address pointer for bytewise access
000960  001168        
000961  001169  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
000962  001170  // Syntax: media_SetSector(SectHiWord, SectLoWord);
000963  001171  // Usage : media_SetSector(arg1, arg2);
000964  001172  // Notes : Set uSD internal Sector pointer for sector block access
000965  001173        
000966  001174  func media_RdSector("*destination"), 1;
000967  001175  // Syntax: media_RdSector(*destination);
000968  001176  // Usage : media_RdSector(rdblock);
000969  001177  // Notes : Reads and Returns 512 bytes (256 words) into a destination
000970  001178  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
000971  001179  //       : After the read the Sector pointer is automatically incremented by 1.
000972  001180  //       : Returns TRUE if uSD response was TRUE
000973  001181        
000974  001182  func media_WrSector("*source"), 1;
000975  001183  // Syntax: media_WrSector(*source);
000976  001184  // Usage : media_WrSector(wrblock);
000977  001185  // Notes : Writes 512 bytes (256 words) from a source memory block
000978  001186  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
000979  001187  //       : pointer is automatically incremented by 1.
000980  001188  //       : Returns TRUE if uSD response was TRUE
000981  001189        
000982  001190  func media_ReadByte(), 1;                // read a byte at the current stream position
000983  001191  // Syntax: media_RdByte();
000984  001192  // Usage : var := media_RdByte();
000985  001193  // Notes : Reads and Returns a single byte of data from the
000986  001194  //       : uSD card pointed to by the internal Address pointer.
000987  001195  //       : After the read the Address pointer is automatically
000988  001196  //       : incremented by 1.
000989  001197        
000990  001198  func media_ReadWord(), 1;                // read a word at the current stream position
000991  001199  // Syntax: media_ReadWord();
000992  001200  // Usage : var := media_ReadWord();
000993  001201  // *Notes : Reads and Returns a single word of data from the
000994  001202  //       : uSD card pointed to by the internal Address pointer.
000995  001203  //       : After the read the Address pointer is automatically
000996  001204  //       : incremented by 2.
000997  001205        
000998  001206  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
000999  001207  // Syntax: media_WriteByte(arg1);
001000  001208  // Usage : var := media_WriteByte(arg1);
001001  001209  // *Notes : Writes and Returns xxxxx
001002  001210  //       : After the write the Address pointer is automatically
001003  001211  //       : incremented by 1.
001004  001212        
001005  001213  func media_WriteWord("word"), 1;            // write a word to the current stream position
001006  001214  // Syntax: media_WriteWord(arg1);
001007  001215  // Usage : var := media_WriteWord(arg1);
001008  001216  // *Notes : Writes and Returns xxxxx
001009  001217  //       : After the write the Address pointer is automatically
001010  001218  //       : incremented by 2.
001011  001219        
001012  001220  func media_Image("x", "y"), 0;            // display image at position x y
001013  001221  // Syntax: media_Image(x, y);
001014  001222  // Usage : media_Image(arg1, arg2);
001015  001223  // Notes : Display an image from the uSD card at screen location
001016  001224  //       : specified by x,y (top left corner). The location of the
001017  001225  //       : Image in the uSD card must be specified by
001018  001226  //       : media_setSector(Image_Sector_Add) function.
001019  001227        
001020  001228  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001021  001229  // Syntax: media_Flush();
001022  001230  // Usage : var := media_Flush();
001023  001231  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001024  001232  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001025  001233        
001026  001234  func media_Init(), 1;                    // initialize uSD card
001027  001235  // Usage	: media_Init();
001028  001236  // Notes	: Initialise uSD CARD
001029  001237  // 	: Response: 0 = No Card
001030  001238  // 	:           1 = Card Initialised
001031  001239  // 	: Do not use this for systems with SPI Flash, use media_InitFlash() instead
001032  001240  // 	: init the Media.
001033  001241        
001034  001242        
001035  001243  //==============================================//
001036  001244  // Communications Function Prototypes           //
001037  001245  //==============================================//
001038  001246  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001039  001247  // Syntax: com_Init(buffer, bufsize, qualifier);
001040  001248  // Usage1: com_Init(mybuf, 20, 0);
001041  001249  // Usage2: com_Init(mybuf, 20, ':');
001042  001250  // Notes : initialize a serial capture buffer for the comms input
001043  001251  //       : The program must declare a var array as a circular buffer.
001044  001252  //       : Usage1 declares a circular buffer which will continually
001045  001253  //       : buffer characters.
001046  001254  //       : Usage2 must receive ':' before any characters will
001047  001255  //       : accumulate in the buffer.
001048  001256        
001049  001257  func com_Reset(), 0;                 // reset the comms receiver
001050  001258  // Syntax: com_Reset();
001051  001259  // Usage : com_Reset();
001052  001260  // Notes : reset comms to default polled mode
001053  001261        
001054  001262  func com_Count(), 1;                // return count of characters in receive buffer
001055  001263  // Syntax: com_Count();
001056  001264  // Usage : arg := com_Count();
001057  001265  // Notes : return count of buffered characters in buffer attachment
001058  001266        
001059  001267  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001060  001268  // Syntax: com_Full();
001061  001269  // Usage : if (com_Full() ,,,, go read buffer;
001062  001270  // Notes : return true if buffer full (not necessarily an error if
001063  001271  //       : buffer is sized to a packet size)
001064  001272        
001065  001273  func com_Error(), 1;                // return comms errors comms error occurred
001066  001274  // Syntax: com_Error();
001067  001275  // Usage : if (com_Error() ) ...... take recovery action;
001068  001276  // Notes : return non zero if any errors low level comms errors occured
001069  001277  // returns :
001070  001278  // bit0 = Receiver Overflow Error
001071  001279  // bit1 = Receiver Framing Error
001072  001280  // bit2 = Transmit Buffer Overflow
001073  001281        
001074  001282  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001075  001283  // Syntax: com_Sync();
001076  001284  // Usage : com_Sync();
001077  001285  // return true if sync character has been received in com_Init("...") mode
001078  001286        
001079  001287        
001080  001288  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001081  001289  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001082  001290  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001083  001291  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001084  001292  // Notes : initialize a serial buffer for the COM0 output.
001085  001293  //       : The program must declare a var array as a circular buffer.
001086  001294  //       : When a TX buffer is declared for comms, the transmission
001087  001295  //       : of characters becomes non blocking. The only time
001088  001296  //       : blocking will occur is if the buffer has insufficient space
001089  001297  //       : to accept the next character, in which case the function
001090  001298  //       : will wait for buffer space to become available. If the
001091  001299  //       : TX buffer is no longer required, just set the buffer pointer
001092  001300  //       : to zero, the size in this case doesnt matter and is ignored.
001093  001301  //       : The function can resize or reallocated to another buffer at
001094  001302  //       : any time. The buffer is flushed before any changes are made.
001095  001303  //       : "pin" designates an IO pin to control a bi-directional 
001096  001304  //       : control device for half duplex mode. "pin" will go HI at the
001097  001305  //       : start of a transmission, and will return low after the final
001098  001306  //       : byte is transmitted. If not required, just set "pin" to zero.
001099  001307        
001100  001308        
001101  001309  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001102  001310  // Syntax: com_TXcount();
001103  001311  // Usage : arg := com_Count();
001104  001312  // Notes : return count of characters remaining in COM0 transmit buffer
001105  001313  //       : that was previously allocated with com_TXbuffer(...);
001106  001314        
001107  001315        
001108  001316  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001109  001317  // Syntax: com_TXemptyEvent(function);
001110  001318  // Usage : arg := com_TXemptyEvent();
001111  001319  // Notes : If a comms TX buffer that was previously allocated with
001112  001320  //       : com_TXbuffer(...);, this function can be used to set up
001113  001321  //       : a function to be called when the COM0 TX buffer is empty.
001114  001322  //       : This is useful for either reloading the TX buffer, setting
001115  001323  //       : or clearing a pin to change the direction of eg a RS485
001116  001324  //       : line driver, or any other form of traffic control.
001117  001325  //       : The event function must not have any parameters.
001118  001326  //       : To disable the event, simply call com_TXemptyEvent(0).
001119  001327  //       : com_TXbuffer(...); also resets any active event.
001120  001328  //       : com_TXemptyEvent returns any previous event function
001121  001329  //       : address, or zero if there was no previous function.
001122  001330        
001123  001331        
001124  001332  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001125  001333  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001126  001334  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001127  001335  // Notes : Expecting that a comms TX buffer that was previously allocated with
001128  001336  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001129  001337  //       : the buffer being sent wile it is being loaded. Mormally, when
001130  001338  //       : using buffered comms, the transmit process will begin
001131  001339  //       : immediately. This is often undesirable for 2 reasons,
001132  001340  //       : 1] you may wish to build a packet then send it later
001133  001341  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001134  001342  //       : as the FIFO buffer is constantly trying to empty while
001135  001343  //       : you are busy tring to fill it.
001136  001344  // return -1 if function is called illegally when TX comms is not buffered.
001137  001345  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001138  001346  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001139  001347        
001140  001348        
001141  001349  //=============================================================//
001142  001350  // Auxilliary Communications Function Prototypes
001143  001351  //=============================================================//
001144  001352  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001145  001353  // Syntax: com_Init(buffer, bufsize, qualifier);
001146  001354  // Usage1: com_Init(mybuf, 20, 0);
001147  001355  // Usage2: com_Init(mybuf, 20, ':');
001148  001356  // Notes : initialize a serial capture buffer for the comms input
001149  001357  //       : The program must declare a var array as a circular buffer.
001150  001358  //       : Usage1 declares a circular buffer which will continually
001151  001359  //       : buffer characters.
001152  001360  //       : Usage2 must receive ':' before any characters will
001153  001361  //       : accumulate in the buffer.
001154  001362        
001155  001363  func com1_Reset(), 0;
001156  001364  // Syntax: com_Reset();
001157  001365  // Usage : com_Reset();
001158  001366  // Notes : reset comms receiver to default polled mode
001159  001367        
001160  001368  func com1_Count(), 1;
001161  001369  // Syntax: com_Count();
001162  001370  // Usage : arg := com_Count();
001163  001371  // Notes : return count of characters in receive buffer
001164  001372        
001165  001373  func com1_Full(), 1;
001166  001374  // Syntax: com_Full();
001167  001375  // Usage : if (com_Full() ,,,, go read buffer;
001168  001376  // Notes : return true if receive buffer full
001169  001377        
001170  001378  func com1_Error(), 1;
001171  001379  // Syntax: com_Error();
001172  001380  // Usage : if (com_Error() ) ...... take recovery action;
001173  001381  // Notes : return non zero if any level comms errors occured
001174  001382  // returns :
001175  001383  // bit0 = Receiver Overflow Error
001176  001384  // bit1 = Receiver Framing Error
001177  001385  // bit2 = Transmit Buffer Overflow
001178  001386        
001179  001387  func com1_Sync(), 1;
001180  001388  // Syntax: com_Sync();
001181  001389  // Usage : com_Sync();
001182  001390  // Notes : return true if sync character has been received in com_Init("...") mode
001183  001391        
001184  001392        
001185  001393  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001186  001394  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001187  001395  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001188  001396  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001189  001397  // Notes : initialize a serial buffer for the COM1 output.
001190  001398  //       : The program must declare a var array as a circular buffer.
001191  001399  //       : When a TX buffer is declared for comms, the transmission
001192  001400  //       : of characters becomes non blocking. The only time
001193  001401  //       : blocking will occur is if the buffer has insufficient space
001194  001402  //       : to accept the next character, in which case the function
001195  001403  //       : will wait for buffer space to become available. If the
001196  001404  //       : TX buffer is no longer required, just set the buffer pointer
001197  001405  //       : to zero, the size in this case doesnt matter and is ignored.
001198  001406  //       : The function can resize or reallocated to another buffer at
001199  001407  //       : any time. The buffer is flushed before any changes are made.
001200  001408  //       : "pin" designates an IO pin to control a bi-directional 
001201  001409  //       : control device for half duplex mode. "pin" will go HI at the
001202  001410  //       : start of a transmission, and will return low after the final
001203  001411  //       : byte is transmitted. If not required, just set "pin" to zero.
001204  001412        
001205  001413        
001206  001414  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001207  001415  // Syntax: com1_TXcount();
001208  001416  // Usage : arg := com1_Count();
001209  001417  // Notes : return count of characters remaining in COM1 transmit buffer
001210  001418  //       : that was previously allocated with com1_TXbuffer(...);
001211  001419        
001212  001420        
001213  001421  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001214  001422  // Syntax: com1_TXemptyEvent(function);
001215  001423  // Usage : arg := com1_TXemptyEvent();
001216  001424  // Notes : If a comms TX buffer that was previously allocated with
001217  001425  //       : com1_TXbuffer(...);, this function can be used to set up
001218  001426  //       : a function to be called when the COM1 TX buffer is empty.
001219  001427  //       : This is useful for either reloading the TX buffer, setting
001220  001428  //       : or clearing a pin to change the direction of eg a RS485
001221  001429  //       : line driver, or any other form of traffic control.
001222  001430  //       : The event function must not have any parameters.
001223  001431  //       : To disable the event, simply call com1_TXemptyEvent(0).
001224  001432  //       : com1_TXbuffer(...); also resets any active event.
001225  001433  //       : com1_TXemptyEvent returns any previous event function
001226  001434  //       : address, or zero if there was no previous function.
001227  001435        
001228  001436        
001229  001437  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001230  001438  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001231  001439  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001232  001440  // Notes : Expecting that a comms TX buffer that was previously allocated with
001233  001441  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001234  001442  //       : the buffer being sent wile it is being loaded. Mormally, when
001235  001443  //       : using buffered comms, the transmit process will begin
001236  001444  //       : immediately. This is often undesirable for 2 reasons,
001237  001445  //       : 1] you may wish to build a packet then send it later
001238  001446  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001239  001447  //       : as the FIFO buffer is constantly trying to empty while
001240  001448  //       : you are busy tring to fill it.
001241  001449  // return -1 if function is called illegally when TX comms is not buffered.
001242  001450  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001243  001451  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001244  001452        
001245  001453  func serin1(), 1;
001246  001454  // Syntax: serin1();
001247  001455  // Usage : char := serin1();
001248  001456  // Notes : return the next available character from COM1
001249  001457        
001250  001458  func serout1("char"), 0;
001251  001459  // Syntax: serout1("char");
001252  001460  // Usage : serout1(ch);
001253  001461  // Notes : send character to COM1
001254  001462        
001255  001463  func com_SetBaud("comport","baudrate/10"), 1;
001256  001464  // Syntax: com_SetBaud("comport","baudrate/10");
001257  001465  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001258  001466  // Notes : sets to any viable baud rate from 160 to 655350
001259  001467  // return true if baud rate was acceptable
001260  001468        
001261  001469        
001262  001470        
001263  001471  //==============================================//
001264  001472  // Display Access                               //
001265  001473  //==============================================//
001266  001474  func disp_Init(), 0;                            // initialize display with required tables
001267  001475  // Syntax: disp_Init();
001268  001476  // Usage : disp_Init();
001269  001477  // Notes : Initialises or reinitialises the display.
001270  001478  //       : Normally used after restoration of peripheral power
001271  001479  //       : and after DeepSleep.
001272  001480        
001273  001481  func disp_SetReg("register", "data"), 0;
001274  001482  // Syntax: display_SetReg(register, data);
001275  001483  // Usage : display_SetReg(arg1, arg2);
001276  001484  // Notes : Sets uLCD specific display driver registers. Refer
001277  001485  //       : to appropriate display driver data sheet.
001278  001486        
001279  001487  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001280  001488  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001281  001489  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001282  001490  // Notes : Prepares the GRAM area for user access.
001283  001491  //       : Data can now be written with disp_GRAM.
001284  001492  //       : GRAM will be set accordingly for the correct screen mode.
001285  001493  //       : the LO word of the 32 bit pixel count is returned. This is
001286  001494  //       : usually all that is needed unlse GRAM area exceeds 256^2
001287  001495  //       : A copy of the 32bit value can be found in
001288  001496  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001289  001497        
001290  001498  func disp_WrGRAM("colour"), 0;
001291  001499  // Syntax: display_WrGRAM(colour);
001292  001500  // Usage : display_WrGRAM(arg);
001293  001501  // Notes : Data can be written to the GRAM consecutively using
001294  001502  //       : this function once the GRAM access window has been setup.
001295  001503        
001296  001504  func disp_WriteControl("value"), 0;             // write a control byte to the display
001297  001505  func disp_WriteWord("value"), 0;                // write a word to the display
001298  001506        
001299  001507        
001300  001508  func disp_ReadWord("Command", "dummy"), 1;                        // read a word from the display
001301  001509  // Syntax	: disp_ReadWord(command, 1);
001302  001510  // Usage	: x:=disp_ReadWord(command, 1);
001303  001511  // Notes	: Read a word from the controller
001304  001512  // Eg: 	: print(disp_ReadWord(0), 0);        // select Ilitek ID register, read using 0 dummy reads, print ID
001305  001513  // 	: (Many displays are write only)
001306  001514  // 	: Some SPI displays required the command be given as part of the read sequence.
001307  001515  // 	: For displays that do not require this the value will be ignored.
001308  001516        
001309  001517                                                  //
001310  001518  //==============================================//
001311  001519  // unadorned SPI functions                      //
001312  001520  //==============================================//
001313  001521  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001314  001522  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001315  001523  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001316  001524  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001317  001525                                                  //
001318  001526  //==============================================//
001319  001527  // flash device specific functions              //
001320  001528  //==============================================//
001321  001529  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001322  001530  // Syntax: flash_SIG();
001323  001531  // Usage : flash_SIG();
001324  001532  // Notes	: Returns the Flash Signature returned from the 'FLASH WAKEUP RETURN SIG'
001325  001533  // 	: (0xAB) command.
001326  001534        
001327  001535  func flash_ID(), 1;                             // read ID code from FLASH device
001328  001536  // Syntax: flash_ID();
001329  001537  // Usage : flash_ID();
001330  001538  // Notes	: Returns the second(memory type) and third(memory capacity) bytes returned from the 
001331  001539  // 	: 'FLASH READ ID REG' (0x9F) command.
001332  001540        
001333  001541  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001334  001542        
001335  001543  func flash_Block64Erase(), 1;            // erase the required 64k flash block
001336  001544  // Syntax: flash_Block64Erase();
001337  001545  // Usage : flash_Block64Erase();
001338  001546  // Notes	: Erase the 64KB flash block including the currently set address
001339  001547  // 	: This uses the 0xD8 command.
001340  001548                                                  //
001341  001549                                                  //
001342  001550  //==============================================//
001343  001551  // string and character size function           //
001344  001552  //==============================================//
001345  001553  func charwidth("char"), 1;                      // return width of a character in pixel units
001346  001554  func charheight("char"), 1;                     // return height of a character in pixel units
001347  001555  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001348  001556  func strheight(), 1;                            // return height of a string in pixel units
001349  001557        
001350  001558        
001351  001559  //------------------------------------------------------------------//
001352  001560  //        I2C Function Prototypes
001353  001561  //------------------------------------------------------------------//
001354  001562  func I2C1_Open("speed"), 0;
001355  001563  // Syntax: I2C1_Open(speed),
001356  001564  // Usage : I2C1_Open(I2C_MED);
001357  001565  // Notes : configures the I2C1 module
001358  001566  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001359  001567        
001360  001568  func I2C1_Close(), 0;
001361  001569  // Syntax: I2C1_Close();
001362  001570  // Usage : I2C1_Close();
001363  001571  // Notes : disables the I2C1 module.
001364  001572        
001365  001573  func I2C1_Start(), 1;
001366  001574  // Syntax: I2C1_Start();
001367  001575  // Usage : I2C1_Start();
001368  001576  // Notes : generates a Start condition.
001369  001577  //       : returns true if successful (usually ignored)
001370  001578        
001371  001579  func I2C1_Stop(), 1;
001372  001580  // Syntax: I2C1_Stop();
001373  001581  // Usage : I2C1_Stop();
001374  001582  // Notes : generates a Stop condition.
001375  001583  //       : returns true if successful (usually ignored)
001376  001584        
001377  001585  func I2C1_Restart(), 1;
001378  001586  // Syntax: I2C1_Restart();
001379  001587  // Usage : I2C1_Restart();
001380  001588  // Notes : generates a Restart condition.
001381  001589  //       : returns true if successful (usually ignored)
001382  001590        
001383  001591  func I2C1_Read(), 1;
001384  001592  // Syntax: I2C1_Read();
001385  001593  // Usage : ch := I2C1_Read();
001386  001594  // Notes : reads a single byte from the I2C Bus.
001387  001595        
001388  001596  func I2C1_Write("byte"), 1;
001389  001597  // Syntax: I2C1_Write(byte);
001390  001598  // Usage : r := I2C1_Write(ch);
001391  001599  // Notes : is used to write a byte to the I2C bus.
001392  001600  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001393  001601        
001394  001602  func I2C1_Ack(), 0;
001395  001603  // Syntax: I2C1_Ack();
001396  001604  // Usage : I2C1_Ack();
001397  001605  // Notes : generates the acknowledge condition.
001398  001606        
001399  001607  func I2C1_Nack(), 0;
001400  001608  // Syntax: I2C1_Nack();
001401  001609  // Usage : I2C1_Nack();
001402  001610  // Notes : generates the negative acknowledge condition.
001403  001611        
001404  001612  func I2C1_AckStatus(), 0;
001405  001613  // Syntax: I2C1_AckStatus();
001406  001614  // Usage : r := I2C1_AckStatus();
001407  001615  // Notes : returns the ACK status from the device.
001408  001616        
001409  001617  func I2C1_AckPoll("control"), 1;
001410  001618  // Syntax: I2C1_AckPoll();
001411  001619  // Usage : r := I2C1_AckPoll(0xA0);
001412  001620  // Notes : waits for a device to return from ACK polling.
001413  001621        
001414  001622  func I2C1_Idle(), 0;
001415  001623  // Syntax: I2C1_Idle();
001416  001624  // Usage : I2C1_Idle();
001417  001625  // Notes : waits until the I2C Bus is Inactive.
001418  001626        
001419  001627  func I2C1_Gets("buffer", "size"), 1;
001420  001628  // Syntax: I2C1_Gets("buffer", "size");
001421  001629  // Usage : r := I2C1_Gets(mybuf, 16);
001422  001630  // Notes : only reads up to "size" characters into "buffer"
001423  001631  //       : Reads up to asciiz terminator including terminator
001424  001632        
001425  001633  func I2C1_Getn("buffer", "size"), 1;
001426  001634  // Syntax: I2C1_Gets("buffer", "size");
001427  001635  // Usage : r := I2C1_Gets(mybuf, 16);
001428  001636  // Notes : reads "size" bytes into "buffer"
001429  001637  //       :
001430  001638        
001431  001639  func I2C1_Puts("buffer"), 1;
001432  001640  // Syntax: I2C1_Puts("buffer");
001433  001641  // Usage : r := I2C1_Puts(mybuf);
001434  001642  // Notes : writes an asciiz string to the I2C device
001435  001643  //       : returns count of characters written
001436  001644        
001437  001645  func I2C1_Putn("buffer", "count"), 1;
001438  001646  // Syntax: I2C1_Putn("buffer","count");
001439  001647  // Usage : r := I2C1_Puts(mybuf,10);
001440  001648  // Notes : writes up to "size" bytes to the I2C device
001441  001649  //       : returns number of bytes written
001442  001650        
001443  001651        
001444  001652  //------------------------------------------------------------------//
001445  001653  //        Image Control Function Prototypes
001446  001654  //------------------------------------------------------------------//
001447  001655  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001448  001656  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001449  001657  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001450  001658  // Notes : set the position where the image will be displayed
001451  001659  //       : returns true if index was ok and function was successful.
001452  001660  //       : you may turn off an image so when img_Refresh is called,
001453  001661  //       : the image will not be shown
001454  001662        
001455  001663  func img_Enable("handle", "index"), 1;
001456  001664  // Syntax: img_Enable(handle, index);
001457  001665  // Usage : r := img_Enable(hImageList, imagenum);
001458  001666  // Notes : enable image in a image list
001459  001667  //       : returns true if index was ok and function was successful.
001460  001668  //       : this is the default state so when img_Refresh is called,
001461  001669  //       : all the images in the list will be shown
001462  001670  //       : if index is set to -1, all of the images are enabled
001463  001671        
001464  001672  func img_Disable("handle", "index"), 1;
001465  001673  // Syntax: img_Disable(handle, index);
001466  001674  // Usage : r := img_Disable(hImageList, imagenum);
001467  001675  // Notes : disable image in a image list
001468  001676  //       : returns true if index was ok and function was successful.
001469  001677  //       : you must turn off an image so when img_Refresh is called,
001470  001678  //       : the image will not be shown.
001471  001679  //       : if index is set to -1, all of the images are disabled
001472  001680        
001473  001681        
001474  001682  func img_Darken("handle", "index"), 1;
001475  001683  // Syntax: img_Darken(handle, index);
001476  001684  // Usage : r := img_Darken(hImageList, imagenum);
001477  001685  // Notes : darken image in a image list
001478  001686  //       : returns true if index was ok and function was successful.
001479  001687  //       : if index is set to -1, all of the images are darkened
001480  001688  //       : NB:- this feature will only work for the next refresh, then
001481  001689  //       : the image reverts back to normal when displayed again.
001482  001690        
001483  001691        
001484  001692  func img_Lighten("handle", "index"), 1;
001485  001693  // Syntax: img_Lighten(handle, index);
001486  001694  // Usage : r := img_Lighten(hImageList, imagenum);
001487  001695  // Notes : lighten image in a image list
001488  001696  //       : returns true if index was ok and function was successful.
001489  001697  //       : if index is set to -1, all of the images are lightened
001490  001698  //       : NB:- this feature will only work for the next refresh, then
001491  001699  //       : the image reverts back to normal when displayed again.
001492  001700        
001493  001701  func img_SetWord("handle", "index", "offset", "word"), 1;
001494  001702  // Syntax: img_SetWord(handle, index, offset, word);
001495  001703  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001496  001704  // Notes : set specified word (0-7) in a image entry
001497  001705  //       : returns TRUE if successful, return value usually ignored.
001498  001706        
001499  001707  func img_GetWord("handle", "index", "offset"), 1;
001500  001708  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001501  001709  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001502  001710  // Notes : returns specified word (0-14) from an image entry
001503  001711  //       : refer to image control entry offsets.
001504  001712        
001505  001713  func img_Show("handle", "index"), 1;
001506  001714  // Syntax: img_Show(handle, index);
001507  001715  // Usage : display image entry (regardless of enable/disable)
001508  001716  //       : returns TRUE if successful, return value usually ignored.
001509  001717        
001510  001718  func img_SetAttributes("handle", "index","value"), 1;
001511  001719  // Syntax: img_SetAttributes("handle", "index","offset");
001512  001720  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001513  001721  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001514  001722  //       : of an image control entry. "value" refers to various bits in
001515  001723  //       : the image control entry (see image attribute flags).
001516  001724  //       : A '1' bit in the "value" field SETS the respective bit
001517  001725  //       : in the IMAGE_FLAGS field of the image control entry.
001518  001726  //       : returns TRUE if successful, return value usually ignored.
001519  001727        
001520  001728  func img_ClearAttributes("handle", "index","value"), 1;
001521  001729  // Syntax: img_ClearAttributes("handle", "index","offset");
001522  001730  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001523  001731  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001524  001732  //       : of an image control entry. "value" refers to various bits in
001525  001733  //       : the image control entry (see image attribute flags)
001526  001734  //       : a '1' bit in the "value" field CLEARS the respective bit
001527  001735  //       : in the IMAGE_FLAGS field of the image control entry.
001528  001736  //       : returns TRUE if successful, return value usually ignored.
001529  001737        
001530  001738  func img_Touched("handle", "index"), 1;
001531  001739  // Syntax: r := img_Touched(handle, index);
001532  001740  // Usage : img_Touched(hndl, 17);
001533  001741  //       : returns -1 if image not touched, or returns index
001534  001742  // Notes : if index is passed as -1, function tests all images,
001535  001743  //       : and returns -1 if image not touched, or returns index.
001536  001744        
001537  001745        
001538  001746        
001539  001747        
001540  001748  //------------------------------------------------------------------//
001541  001749  //        Timer Function Prototypes
001542  001750  //------------------------------------------------------------------//
001543  001751  func sys_T(), 1;
001544  001752  // Syntax: sys_T();
001545  001753  // Usage : t := sys_T();
001546  001754  // Notes : return the current value of the rolling system timer (1msec) LO word
001547  001755        
001548  001756  func sys_T_HI(), 1;
001549  001757  // Syntax: sys_T_HI();
001550  001758  // Usage : t := sys_T_HI();
001551  001759  // Notes : return the current value of the rolling system timer (1msec) HI word
001552  001760        
001553  001761  func sys_SetTimer("timernum","value"), 0;
001554  001762  // Syntax: sys_SetTimer("timernum", "value");
001555  001763  // Usage : sys_SetTimer(TIMER5, 10000);
001556  001764  // Notes : set a countdown on the selected timer, or 'top up' if required.
001557  001765  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001558  001766  //       : Maximum timeout period is 65.535 seconds
001559  001767  //       : A timer can be read with the sys_GetTimer("timernum") function
001560  001768        
001561  001769  func sys_GetTimer("timernum"), 1;
001562  001770  // Syntax: t := sys_GetTimer("timernum");
001563  001771  // Usage : t := sys_GetTimer(TIMER3);
001564  001772  // Notes : returns 0 if timer has expired, or the current countdown value.
001565  001773  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001566  001774  //       : Maximum timeout period is 65.535 seconds
001567  001775  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001568  001776        
001569  001777  func sys_SetTimerEvent("timernum","function"), 1;
001570  001778  // Syntax: sys_SetTimerFunction("timernum", "function");
001571  001779  // Usage : sys_SetTimer(TIMER5, myfunc);
001572  001780  // Notes : set a function to be called for selected timer.
001573  001781  //       : When the timer reaches zero, the function is called.
001574  001782  //       : The called function must not have any parameters
001575  001783  //       : sys_SetTimerEvent returns any previous event function
001576  001784  //       : address, or zero if there was no previous function.
001577  001785        
001578  001786  func sys_EventQueue(), 1;
001579  001787  // Syntax: sys_EventQueue();
001580  001788  // Usage : tasks := sys_EventQueue();
001581  001789  // Notes : returns the max number of events that were pending
001582  001790  //       : in the timer queue since the last call to this function.
001583  001791  //       : This can be used to assess timer event overhead burden,
001584  001792  //       : especially after or during a sys_EventsPostpone action.
001585  001793        
001586  001794  func sys_EventsPostpone(), 0;
001587  001795  // Syntax: sys_EventPostpone();
001588  001796  // Usage : sys_EventPostpone();   // postpone the event queue
001589  001797  // Notes : postpone any events until the sys_EventResume function is executed
001590  001798  //       : The timer event queue will continue to queue events, but no action
001591  001799  //       : will take place untill a sys_EventResume function is encountered.
001592  001800  //       : The queue will continue to receive up to 32 events before discarding
001593  001801  //       : any further events. This function is required to allow a sequence of
001594  001802  //       : instructions or functions to occur that would otherwise be corrupted
001595  001803  //       : by an event occuring during the sequence of instructions or functions.
001596  001804  //       : A good example of this is when you set a position to print, if there
001597  001805  //       : was no way of locking the current sequence, an event may occur which
001598  001806  //       : does a similar thing, and a contention would occur - printing to
001599  001807  //       : the wrong position. This function should be used wisely, if any action
001600  001808  //       : that is required would take considerable time, it is better to disable
001601  001809  //       : any conflicting event functions with a bypass flag, then restart the
001602  001810  //       : conflicting event by re-issuing a timer value.
001603  001811        
001604  001812  func sys_EventsResume(), 0;
001605  001813  // Syntax: sys_EventsResume();
001606  001814  // Usage : sys_EventsResume();   // resume the event queue
001607  001815  // Notes : resume any postponed events. The queue will try to execute any timer
001608  001816  //       : events that were incurred during the postponed period.
001609  001817        
001610  001818        
001611  001819  func sys_Sleep("units"), 1;
001612  001820  // Syntax: t := sys_Sleep("units");
001613  001821  // Usage : t := sys_Sleep(10);
001614  001822  // Notes : sets the display into low power mode for a period of time.
001615  001823  //       : Touching the touch screen will also wake from sleep.
001616  001824  //       : Returns remaining sleep units.
001617  001825        
001618  001826  func iterator("offset"), 0;
001619  001827  // Syntax: t :=  iterator("offset");
001620  001828  // Usage : t :=  iterator(10);
001621  001829  // Notes : set the iterator size for ++/--
001622  001830  //       : The next postinc,postdec,preinc of predec will alter
001623  001831  //       : by the specified value.
001624  001832  //       : The offset will return to 1 after the next operation.
001625  001833        
001626  001834        
001627  001835        
001628  001836        
001629  001837  //------------------------------------------------------------------//
001630  001838  //         Touch Screen Function Prototypes
001631  001839  //------------------------------------------------------------------//
001632  001840        
001633  001841  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001634  001842  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001635  001843  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001636  001844  // Notes : Specifies a new touch detect region on the screen
001637  001845  //       : such that only touch activity in that region will
001638  001846  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001639  001847        
001640  001848  func touch_Set("mode"), 0;
001641  001849  // Syntax: touch_Set(mode);
001642  001850  // Usage : touch_Set(arg);
001643  001851  // Notes : Sets various Touch Screen related parameters
001644  001852  //       :
001645  001853  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001646  001854  //       : touch_Set(TOUCH_ENABLE);
001647  001855  //       : Enables and initialises Touch Screen hardware
001648  001856  //       :
001649  001857  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001650  001858  //       : touch_Set(TOUCH_DISABLE );
001651  001859  //       : Disables the Touch Screen
001652  001860  //       : Note: Touch Screen runs in the background and disabling
001653  001861  //       : it when not in use will free up extra resources
001654  001862  //       : such as 4DVM CPU cycles.
001655  001863  //       :
001656  001864  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001657  001865  //       : touch_Set(TOUCH_REGIONDEFAULT);
001658  001866  //       : This will reset the current active region to default
001659  001867  //       : to the full screen without the application having to
001660  001868  //       : set a new active region for the full screen.
001661  001869  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001662  001870  //       : that requre to be interfaced with an external pointing
001663  001871  //       : device, values that are poked into TOUCH_DRIVE will be
001664  001872  //       : read with the touch_Get() function)
001665  001873        
001666  001874        
001667  001875  func touch_Get("mode"), 1;
001668  001876  // Syntax: touch_Get(mode);
001669  001877  // Usage : arg1 := touch_Get(arg);
001670  001878  // Notes : Returns various Touch Screen parameters to caller
001671  001879  //       :
001672  001880  //       : mode = TOUCH_STATUS  (mode 0)
001673  001881  //       : var := touch_Get(TOUCH_STATUS);
001674  001882  //       : Returns the various states of the touch screen
001675  001883  //       : 0 = NOTOUCH
001676  001884  //       : 1 = TOUCH_PRESSED
001677  001885  //       : 2 = TOUCH_RELEASED
001678  001886  //       : 3 = TOUCH_MOVING
001679  001887  //       :
001680  001888  //       : mode = TOUCH_GETX   (mode 1)
001681  001889  //       : var := touch_Get(TOUCH_GETX);
001682  001890  //       : Returns the X coordinates of the touch
001683  001891  //       :
001684  001892  //       : mode = TOUCH_GETY   (mode 2)
001685  001893  //       : var := touch_Get(TOUCH_GETY);
001686  001894  //       : Returns the Y coordinates of the touch
001687  001895        
001688  001896  //------------------------------------------------------------------//
001689  001897  //        CTYPE Function Prototypes
001690  001898  //------------------------------------------------------------------//
001691  001899        
001692  001900  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001693  001901  // Syntax: isdigit("char");
001694  001902  // Usage : Var := isdigit(ch);
001695  001903  // Notes : char specifies the ascii character for the test
001696  001904  //     : 0 : char is not an ascii digit.
001697  001905  //     : 1 : char is an ascii digit..
001698  001906  //     : Valid range is "0123456789"
001699  001907        
001700  001908  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001701  001909  // Syntax: isxdigit("char");
001702  001910  // Usage : Var := isxdigit(ch);
001703  001911  // Notes : char specifies the ascii character for the test
001704  001912  //     : 0 : char is not an ascii hexadecimal digit.
001705  001913  //     : 1 : char is an ascii hexadecimal digit..
001706  001914  //     : Valid range is "0123456789ABCDEF"
001707  001915        
001708  001916  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001709  001917  // Syntax: isupper("char");
001710  001918  // Usage : Var := isupper(ch);
001711  001919  // Notes : char specifies the ascii character for the test
001712  001920  //     : 0 : char is not an ascii upper-case letter.
001713  001921  //     : 1 : char is an ascii upper-case letter.
001714  001922  //     : Valid range is "ABCD....WXYZ"
001715  001923        
001716  001924  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001717  001925  // Syntax: islower("char");
001718  001926  // Usage : Var := islower(ch);
001719  001927  // Notes : char specifies the ascii character for the test
001720  001928  //     : 0 : char is not an ascii lower-case letter.
001721  001929  //     : 1 : char is an ascii lower-case letter.
001722  001930  //     : Valid range is "abcd....wxyz"
001723  001931        
001724  001932  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001725  001933  // Syntax: isalpha("char");
001726  001934  // Usage : Var := isalpha(ch);
001727  001935  // Notes : char specifies the ascii character for the test
001728  001936  //     : 0 : char is not an ascii lower or upper case letter.
001729  001937  //     : 1 : char is an ascii lower or upper case letter.
001730  001938  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001731  001939        
001732  001940  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001733  001941  // Syntax: isalnum("char");
001734  001942  // Usage : Var := isalnum(ch);
001735  001943  // Notes : char specifies the ascii character for the test
001736  001944  //     : 0 : char is not an ascii alphanumeric character.
001737  001945  //     : 1 : char is an ascii alphanumeric character.
001738  001946  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001739  001947        
001740  001948  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001741  001949  // Syntax: isprint("char");
001742  001950  // Usage : Var := isprint(ch);
001743  001951  // Notes : char specifies the ascii character for the test
001744  001952  //     : 0 : char is not a printable ascii character.
001745  001953  //     : 1 : char is a printable ascii character.
001746  001954  //     : Valid range is "0x20...0x7F"
001747  001955        
001748  001956  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001749  001957  // Syntax: isspace("char");
001750  001958  // Usage : Var := isspace(ch);
001751  001959  // Notes : char specifies the ascii character for the test
001752  001960  //     : 0 : char is not a space type character.
001753  001961  //     : 1 : char is a space type character.
001754  001962  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001755  001963        
001756  001964  //unformatted
001757  001965  func iswhite("char"), 1;    //
001758  001966  // Syntax: iswhite("char");
001759  001967  // Usage : Var := iswhite(ch);
001760  001968  // Notes : char specifies the ascii character for the test
001761  001969  //     : 0 : char is not a space or tab character.
001762  001970  //     : 1 : char is not a space or tab character.
001763  001971  //     : Valid range is space or tab
001764  001972        
001765  001973  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001766  001974  // Syntax: toupper("char");
001767  001975  // Usage : Var := toupper(ch);
001768  001976  // Notes : char specifies the ascii character for the test
001769  001977  //     : "ABCD....XYZ" : if character is a lower case letter.
001770  001978  //     : char : if character is not a lower case letter.
001771  001979  //     : Valid range is "abcd....wxyz"
001772  001980        
001773  001981  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001774  001982  // Syntax: tolower("char");
001775  001983  // Usage : Var := tolower(ch);
001776  001984  // Notes : char specifies the ascii character for the test
001777  001985  //     : "abcd....xyz" : if character is an upper case letter.
001778  001986  //     : char : if character is not an upper case letter.
001779  001987  //     : Valid range is "ABCD....WXYZ"
001780  001988        
001781  001989  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001782  001990  // Syntax: LObyte(var);
001783  001991  // Usage : myVar := LObyte(myvar2);
001784  001992  // Notes : var specifies the user variable
001785  001993  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001786  001994        
001787  001995  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001788  001996  // Syntax: HIbyte(var);
001789  001997  // Usage : myVar := HIbyte(myvar2);
001790  001998  // Notes : var specifies the user variable
001791  001999  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001792  002000        
001793  002001        
001794  002002  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001795  002003  // Syntax: ByteSwap(var);
001796  002004  // Usage : myVar := ByteSwap(myvar2);
001797  002005  // Notes : var specifies the user variable
001798  002006  //     : Returns the endian swapped value of a 16 bit variable
001799  002007        
001800  002008        
001801  002009  //------------------------------------------------------------------//
001802  002010  //        Memory Allocation Function Prototypes
001803  002011  //------------------------------------------------------------------//
001804  002012        
001805  002013  func mem_Alloc("size"), 1;
001806  002014  // Syntax: mem_Alloc(bytesize);
001807  002015  // Usage : myvar := mem_Alloc(100);
001808  002016  // Notes : Allocate a block of memory to pointer myvar
001809  002017  //       : The allocated memory contains garbage but is a fast allocation.
001810  002018  //       : The block must later be released with mem_Free();
001811  002019  //       : returns 0 if function fails
001812  002020        
001813  002021  func mem_AllocV("size"), 1;
001814  002022  // Syntax: mem_AllocV(bytesize);
001815  002023  // Usage : myvar := mem_AllocV(100);
001816  002024  // Notes : Allocate a block of memory to pointer myvar
001817  002025  //       : The block of memory is filled with signature values
001818  002026  //       : the block starts with A5,5A then fills with incrementing
001819  002027  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001820  002028  //       : This can be helpful when debugging
001821  002029  //       : The block must later be released with mem_Free();
001822  002030  //       : returns 0 if function fails
001823  002031        
001824  002032  func mem_AllocZ("size"), 1;
001825  002033  // Syntax: mem_AllocZ(bytesize);
001826  002034  // Usage : myvar := mem_AllocC(100);
001827  002035  // Notes : Allocate a zeroed block of memory to pointer myvar
001828  002036  //       : The block of memory is filled with zeroes
001829  002037  //       : The block must later be released with mem_Free();
001830  002038  //       : returns 0 if function fails
001831  002039        
001832  002040  func mem_Realloc("ptr", "size"), 1;
001833  002041  // Syntax: myvar := mem_Realloc("ptr", "size");
001834  002042  // Usage : myvar := mem_Realloc(ptr, size);
001835  002043  // Notes : The function may move the memory block to a new location,
001836  002044  //       : in which case the new location is returned.
001837  002045  //       : The content of the memory block is preserved up to the lesser
001838  002046  //       : of the new and old sizes, even if the block is moved.
001839  002047  //       : If the new size is larger, the value of the newly allocated
001840  002048  //       : portion is indeterminate. In case that ptr is NULL,
001841  002049  //       : the function behaves exactly as mem_Alloc, assigning a new block
001842  002050  //       : of size bytes and returning a pointer to the beginning of it.
001843  002051  //       : In case that the size is 0, the memory previously allocated in
001844  002052  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001845  002053  //       : pointer is returned.
001846  002054        
001847  002055  func mem_Free("allocation"), 1;
001848  002056  // Syntax: myvar := mem_Free(allocation);
001849  002057  // Usage : myvar := mem_Free(myvar);
001850  002058  // Notes : De-allocate a block of memory previously created with
001851  002059  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001852  002060  //       : returns 0 if function fails
001853  002061        
001854  002062  func mem_Heap(), 1;
001855  002063  // Syntax: myvar := mem_Heap();
001856  002064  // Usage : myvar := mem_Heap();
001857  002065  // Notes : returns bytecount available in heap
001858  002066  //       :
001859  002067        
001860  002068  func mem_Set("ptr","char","size"), 1;
001861  002069  // Syntax: mem_Set(ptr,char,bytesize);
001862  002070  // Usage : mem_Set(p, 'A', 100);
001863  002071  // Notes : fill a block of memory with a byte value
001864  002072  //       : returns ptr
001865  002073        
001866  002074  func mem_Copy("src", "dest", "bytecount"), 1;
001867  002075  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001868  002076  // Usage : myvar := mem_Copy(p1, p2, 100);
001869  002077  // Notes : copy a word aligned block of memory from src to dest
001870  002078  //       : Note that count is a byte count, this facilitates
001871  002079  //       : copying word aligned byte arrays when using word
001872  002080  //       : aliggned packed strings.
001873  002081  //       : returns src
001874  002082        
001875  002083  func mem_Compare("ptr1","ptr2","count"), 1;
001876  002084  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001877  002085  // Usage : myvar := mem_Compare(p1, p2, 100);
001878  002086  // Notes : compare blocks of memory at src, dest
001879  002087  //       : returns 0 if we have a match
001880  002088        
001881  002089  //------------------------------------------------------------------//
001882  002090  //        FAT16 Function Prototypes
001883  002091  //------------------------------------------------------------------//
001884  002092        
001885  002093  func file_Error(), 1;
001886  002094  // Syntax: myvar := file_Error();
001887  002095  // Usage : e := file_Error();
001888  002096  // Notes : return the most recent file error.
001889  002097  //       :
001890  002098        
001891  002099  func file_Count("filename"), 1;
001892  002100  // Syntax: count := file_Count("filename");
001893  002101  // Usage : count := file_Count("*.4dg");
001894  002102  // Notes : returns number of files found that match the criteria
001895  002103        
001896  002104  func file_Dir("filename"), 1;
001897  002105  // Syntax: count := file_Dir("filename");
001898  002106  // Usage : count := file_Dir("*.4dg");
001899  002107  // Notes : streams a string of filenames that agree with the search key
001900  002108  //       : returns number of files found that match the criteria
001901  002109        
001902  002110  func file_FindFirst("fname"), 1;
001903  002111  // Syntax: res := file_FindFirst("fname");
001904  002112  // Usage : if (file_FindFirst("*.4xe") ....
001905  002113  // Notes : returns true if at least 1 file exists
001906  002114  //       : that satisfies the file argument.
001907  002115  //       : Wildcards are usually used so if
001908  002116  //       : file_FindFirst returns true, further
001909  002117  //       : tests can be made using file_FindNext();
001910  002118  //       : to find all the files that match the
001911  002119  //       : wildcard class. Note that the stream behaviour
001912  002120  //       : is the same as file_Dir.
001913  002121  //       :
001914  002122        
001915  002123  func file_FindNext(), 1;
001916  002124  // Syntax: res := file_FindNext();
001917  002125  // Usage : while ((file_FindNext()) ....
001918  002126  // Notes : returns true if more file exists
001919  002127  //       : that satisfies the file argument
001920  002128  //       : that was given for  file_FindFirst.
001921  002129  //       : Wildcards must be used for
001922  002130  //       : file_FindFirst, else this function will
001923  002131  //       : always return zero as the only occurence
001924  002132  //       : will have already been found.
001925  002133  //       : Note that the stream behaviour
001926  002134  //       : is the same as file_Dir.
001927  002135  //       :
001928  002136        
001929  002137  func file_Exists("fname"), 1;
001930  002138  // Syntax: res := file_Exists("fname"),
001931  002139  // Usage : if(file_Exists("myfile") ....
001932  002140  // Notes : returns true if file exists
001933  002141  //       :
001934  002142        
001935  002143  func file_Open("fname", "mode"), 1;
001936  002144  // Syntax: handle := file_Open("fname","mode"),
001937  002145  // Usage : handle := file_Open("myfile.txt", 'r');
001938  002146  // Notes : returns handle if file exists
001939  002147  //       :
001940  002148        
001941  002149  func file_Close("handle"), 1;
001942  002150  // Syntax: res := file_Close("handle");
001943  002151  // Usage : res := file_Close(hnd1);
001944  002152  // Notes : returns true if file closed ok
001945  002153  //       :
001946  002154        
001947  002155  func file_Read("*dest", "size", "handle"), 1;
001948  002156  // Syntax: res := file_Read("*dest", "size", "handle"),
001949  002157  // Usage : res := file_Read(memblock,20,hnd1);
001950  002158  // Notes : returns number of characters read
001951  002159  //       : if "dest" is zero, data is read direct to GRAM window
001952  002160  //       :
001953  002161        
001954  002162        
001955  002163  func file_Seek("handle", "HiWord", "LoWord"), 1;
001956  002164  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
001957  002165  // Usage : res := file_Seek(hSource, 0, 0x1234);
001958  002166  // Notes : set file position to 0x00001234 (byte position 4660)
001959  002167  //       : for the file handle so subsequent data may be read
001960  002168  //       : from that position onwards with file_GetC(...),
001961  002169  //       : file_GetW(...) or file_GetS(...), or an image
001962  002170  //       : can be displayed with file_Image(...)
001963  002171  // Notes : returns true if ok, usually ignored
001964  002172        
001965  002173  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001966  002174  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001967  002175  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
001968  002176  // Notes : set file seek position to 123000
001969  002177  //       : for the file handle so subsequent data may be read
001970  002178  //       : from that record position onwards with file_GetC(...),
001971  002179  //       : file_GetW(...) or file_GetS(...), or an image
001972  002180  //       : can be displayed with file_Image(...)
001973  002181  // Notes : returns true if ok, usually ignored
001974  002182        
001975  002183  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
001976  002184  // Syntax: file_Tell("handle", &HiWord, &LoWord);
001977  002185  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
001978  002186  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
001979  002187  //       : returns true if function succeeded
001980  002188        
001981  002189  func file_Write("*source", "size", "handle"), 1;
001982  002190  // Syntax: res := fwrite("*source", "size", "handle"),
001983  002191  // Usage : res := fwrite(memblock, 20, hnd1);
001984  002192  // Notes : returns number of bytes written
001985  002193  //       :
001986  002194        
001987  002195  func file_Size("handle", "&HiWord", "&LoWord"), 1;
001988  002196  // Syntax: file_Size("handle", &HiWord, &LoWord);
001989  002197  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
001990  002198  // Notes : Reads the 32 bit file size and stores it into 2 variables.
001991  002199  //       : returns true if function succeeded
001992  002200        
001993  002201  func file_Image("x", "y", "handle"), 1;
001994  002202  // Syntax: file_Image(x, y, handle);
001995  002203  // Usage : file_Image(10, 10, hnd1);
001996  002204  // Notes : Display an image from a file at the current file position.
001997  002205  //       : The image is displayed at x,y (with respect to top left corner).
001998  002206  //       : If there is more than 1 image in the file, it can be
001999  002207  //       : accessed with file_Seek(...)
002000  002208        
002001  002209  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002002  002210  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002003  002211  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002004  002212  // Notes : Save a image from screen to file at the current file position.
002005  002213  //       : The image can later be displayed with file_Image(...);
002006  002214  //       : The file may be opened in append mode to accumulate multiple
002007  002215  //       : images. Later, the images can be accessed with file_Seek(...);
002008  002216  //       : Note that the image will be sector aligned.
002009  002217  //       : All image headers must start on a sector boundary.
002010  002218  //       : The image is saved from x, y (with respect to top left corner)
002011  002219  //       : and the capture area is determined by "width" and "height".
002012  002220  //       : returns 0 if function succeeded
002013  002221        
002014  002222  func file_PutC("char","handle"), 1;
002015  002223  // Syntax: file_PutC("char", "handle");
002016  002224  // Usage : file_PutC('x', hndl);
002017  002225  // Notes : returns true if function succeeded
002018  002226        
002019  002227  func file_GetC("handle"), 1;
002020  002228  // Syntax: file_GetC("handle");
002021  002229  // Usage : mychar := fgetC("handle");
002022  002230  // Notes : returns next char from file
002023  002231        
002024  002232  func file_PutW("word","handle"), 1;
002025  002233  // Syntax: file_PutW("word","handle");
002026  002234  // Usage : file_PutW(0x1234, hndl);
002027  002235  // Notes : returns true if function succeeded
002028  002236        
002029  002237  func file_GetW("handle"), 1;
002030  002238  // Syntax: file_GetW("handle");
002031  002239  // Usage : myword := fgetW("handle");
002032  002240  // Notes : returns next word in file
002033  002241        
002034  002242  func file_PutS("*source", "handle"), 1;
002035  002243  // Syntax: res := file_Puts("*source", "handle"),
002036  002244  // Usage : res := file_Puts(mystring, hnd1);
002037  002245  // Notes : returns number of characters written
002038  002246  //       :
002039  002247        
002040  002248  func file_GetS("*string", "size", "handle"), 1;
002041  002249  // Syntax: res := file_Gets("*string", "size", "handle");
002042  002250  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002043  002251  // Notes : get a string from a file
002044  002252  //       : returns pointer to string or null if failed.
002045  002253  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002046  002254  //       : NB:- only reads up to "size-1" characters into "string"
002047  002255  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002048  002256  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002049  002257  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002050  002258  //       : C] It reaches the end of file
002051  002259  //       : D] A read error occurs.
002052  002260        
002053  002261        
002054  002262  func file_Erase("fname"), 1;
002055  002263  // Syntax: res := file_Erase("fname");
002056  002264  // Usage : res := file_Erase("myfile.txt");
002057  002265  // Notes : returns true if successful
002058  002266  //       :
002059  002267        
002060  002268  func file_Rewind("handle"), 1;
002061  002269  // Syntax: res := file_Rewind("handle");
002062  002270  // Usage : res := file_Rewind(hnd1);
002063  002271  // Notes : returns true if file rewound ok (usually ignored)
002064  002272  //       : resets the file pointer the the beginning of the open file.
002065  002273        
002066  002274  func file_LoadFunction("fname.4xe"), 1;
002067  002275  // Syntax: res := file_LoadFunction("fname.4fn");
002068  002276  // Usage : myfunc := file_LoadFunction(myfuncname);
002069  002277  // Notes : Load a function or program from disk and
002070  002278  //       : return a function pointer to the allocation.
002071  002279  //       : The function can then be invoked just like any other
002072  002280  //       : function would be called via a function pointer.
002073  002281  //       : Parameters may be passed to it in a conventional way.
002074  002282  //       : The function may be discarded at any time when no
002075  002283  //       : longer required, thus freeing its memory resources.
002076  002284  //       : The loaded function can be discarded with mem_Free(..)
002077  002285  //       : eg:
002078  002286  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002079  002287  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002080  002288  //       : then elsewhere in your program:-
002081  002289  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002082  002290  //       : if(res == QUIT_APPLICATION) goto exitApp;
002083  002291  //       : Later in your program, when popupWindow is no longer
002084  002292  //       : required for the application:-
002085  002293  //       : res := mem_Free(popupWindow);
002086  002294  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002087  002295  //       : The callers stack is shared by the loaded function,
002088  002296  //       : however any global variables in the loaded function
002089  002297  //       : are private to that function.
002090  002298  //
002091  002299        
002092  002300  func file_Run("fname.4xe", "arglistptr"), 1;
002093  002301  // Syntax: res := file_Run("fname.4xe","arglistptr");
002094  002302  // Usage : res := file_Run(fname, argptr);
002095  002303  // Notes : current program releases any allocated memory but
002096  002304  //       : retains the stack and global memory.
002097  002305  //       : If arglistptr is 0, no arguments are passed, else
002098  002306  //       : arglist points to an array, the first element being
002099  002307  //       : the number of elements in the array.
002100  002308  //       : func 'main' in the called program accepts
002101  002309  //       : the arguments, if any. THe arguments can only
002102  002310  //       : be passed by value, no pointers or references can be
002103  002311  //       : used as all memory is cleared before the file
002104  002312  //       : is loaded. Refer to file_Exec and file_LoadFunction
002105  002313  //       : for functions that can pass by reference.
002106  002314        
002107  002315  func file_Exec("fname.4xe", "arglistptr"), 1;
002108  002316  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002109  002317  // Usage : res := file_Exec("fname.4xe","arglistptr");
002110  002318  // Notes : returns like a function, current program
002111  002319  //       : calling program is kept active and control returns to it.
002112  002320  //       : If arglistptr is 0, no arguments are passed, else
002113  002321  //       : arglist points to an array, the first element being
002114  002322  //       : the number of elements in the array.
002115  002323  //       : func 'main' in the called program accepts the arguments.
002116  002324  //       : This function is similar to file_LoadFunction(...), however,
002117  002325  //       : the function argument list is passed by pointer, and
002118  002326  //       : the memory consumed by the function is released as
002119  002327  //       : soon as the function completes.
002120  002328        
002121  002329  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002122  002330  // Syntax	: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002123  002331  // Usage	: hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002124  002332  // Notes	: Reads a control file to create an image list.
002125  002333  // 	: Returns NULL if function fails.
002126  002334  // 	: Returns a handle (pointer to the memory allocation) to the
002127  002335  // 	: image control list that has been created.
002128  002336  // 	: "fname1" is the control list filename "*.dat"
002129  002337  // 	: "fname2" is the image filename "*.gci"
002130  002338  // 	: "mode" is 0 for FAT based GCI and DAT with quick load and slower for each display
002131  002339  // 	: "mode" is 1 for FAT based GCI and DAT with slower load and faster for each display
002132  002340  // 	: "mode" is 2 for FAT based DAT with RAW GCI
002133  002341  // 	: "mode" is 3 for Flash based 'file system' GCI (GCIF) with itegerated DAT and other file types
002134  002342  // 	: "fname1" and "fname2" are then the Flash high and low words of the GFIC start location.
002135  002343        
002136  002344  // Notes : This function Calculates the size of a chunk of memory required for
002137  002345  //       : a image list and populates it from the image control file ("*.dat")
002138  002346  //       : therefore, when imagelist is no longer required, you must de-allocate
002139  002347  //       : the image list memory by using eg:- mem_Free(hImagelist);
002140  002348  //       : to restore the heap.
002141  002349  //       :
002142  002350  //       : mode 0:- it is assumed that there is a graphics file with the
002143  002351  //       : file extension "fname2.gci". In this case, the images have been stored
002144  002352  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002145  002353  //       : "fname1.dat" file are saved in the image control so that the image control
002146  002354  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002147  002355  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002148  002356  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002149  002357  //       : for the file offsets and save them in the relevant entries in the image control.
002150  002358  //       : The penalty is that images take longer to find when displayed due to file_Seek
002151  002359  //       : overheads.
002152  002360  //
002153  002361  //       : mode 1:- it is assumed that there is a graphics file with the
002154  002362  //       : file extension "fname2.gci". In this case, the images have been stored
002155  002363  //       : in a FAT16 file concurrently, and the offset of the images are saved
002156  002364  //       : in the image control so that image file (*.gci) can be mapped to directly.
002157  002365  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002158  002366  //       : internally. This means that there is no seek time penalty, however, the
002159  002367  //       : image list takes a lot longer to build, as all the seeking is done at control
002160  002368  //       : build time.
002161  002369        
002162  002370  //       : mode 2:- the graphics file with the is placed in a partitioned area
002163  002371  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002164  002372  //       : disk, and the absolute address of the images are saved in the DAT file
002165  002373  //       : This is the fastest operation of the image control as there is no seeking
002166  002374  //       : or other disk activity taking place.
002167  002375        
002168  002376  func file_Mount(), 1;
002169  002377  // Syntax: r := file_Mount();
002170  002378  // Usage : r := file_Mount();
002171  002379  // Notes : Create a control block for FAT16 and mount the File System
002172  002380        
002173  002381  func file_Unmount(), 0;
002174  002382  // Syntax: file_Unmount();
002175  002383  // Usage : file_Unmount();
002176  002384  // Notes : release any control block and buffers for FAT16
002177  002385  //       : and unmount the File System
002178  002386        
002179  002387  func file_PlayWAV("fname1"), 1;
002180  002388  // Syntax: file_PlayWAV("fname1");
002181  002389  // Usage : file_PlayWAV("ding.wav");
002182  002390  // Notes : Play a wave file with filename "fname1"
002183  002391  //       : This function automatically grabs a chunk
002184  002392  //       : of memory for a file buffer, and a wave
002185  002393  //       : buffer. The minimum memory requirement is
002186  002394  //       : about 580 bytes for the disk io service and
002187  002395  //       : a minimum wave buffer size of 1024. The siz
002188  002396  //       : of the wave buffer allocation
002189  002397  //       : can be increased by the snd_BufSize function.
002190  002398  //       : The default size 1024 bytes.
002191  002399  //       : NB the memory is only required during the
002192  002400  //       : duration of play, and is automatically
002193  002401  //       : released while not in use.
002194  002402  //       : See the Sound Class services for other associated controls.
002195  002403  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002196  002404  //       : If errors occured, the folling is returned
002197  002405  //       : -7  : Insufficient memory available for WAV buffer and file
002198  002406  //       : -6  : cant play this rate
002199  002407  //       : -5  : no data chunk found in first rsector
002200  002408  //       : -4  : no format data
002201  002409  //       : -3  : no wave chunk signature
002202  002410  //       : -2  : bad wave file format
002203  002411  //       : -1  : file not found
002204  002412        
002205  002413        
002206  002414        
002207  002415  //------------------------------------------------------------------//
002208  002416  //        Sound Class Services
002209  002417  //------------------------------------------------------------------//
002210  002418        
002211  002419  func snd_Volume("var"), 0;
002212  002420  // Syntax: snd_Volume("var");
002213  002421  // Usage : snd_Volume(30);
002214  002422  // Notes : set sound playback volume.  Var must
002215  002423  //       : be in the range from 8 (min volume)
002216  002424  //       : to 127 (max volume). If var is less
002217  002425  //       : than 8 volume is set to 8, and if
002218  002426  //       : var > 127 it is set to 127.
002219  002427        
002220  002428  func snd_Pitch("pitch"), 1;
002221  002429  // func snd_Pitch("freq"), 1;
002222  002430  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002223  002431  // Notes : sets the samples playback rate to a different frequency
002224  002432  //       : The minimum value is 4khz
002225  002433  //       : Setting the pitch to zero restores the original sample rate
002226  002434  //       : Return value is the samples original sample rate.
002227  002435        
002228  002436  func snd_BufSize("var"), 0;
002229  002437  // Syntax: snd_BufSize("var");
002230  002438  // Usage : snd_BufSize(2);
002231  002439  // Notes : specify the a memory chunk size for the wavefile buffer.
002232  002440  //       : default size 1024 bytes.
002233  002441  //       : 0 = 1024 bytes (default)
002234  002442  //       : 1 = 2048 bytes
002235  002443  //       : 2 = 4096 bytes
002236  002444  //       : 3 = 8192 bytes
002237  002445        
002238  002446  func snd_Stop(), 0;
002239  002447  // Syntax: snd_Stop();
002240  002448  // Usage : snd_Stop();
002241  002449  // Notes : stop any sound that is playing, releasing
002242  002450  //       : buffers and closes any open wav file.
002243  002451        
002244  002452  func snd_Pause(), 0;
002245  002453  // Syntax: snd_Pause();
002246  002454  // Usage : snd_Pause();
002247  002455  // Notes : pauses any sound that is playing, does nothing
002248  002456  //       : until sound is resumed with snd_Continue().
002249  002457  //       : The sample cam be terminated with snd_Stop.
002250  002458  //       : buffers and closes any open wav file.
002251  002459        
002252  002460  func snd_Continue(), 0;
002253  002461  // Syntax: snd_Continue();
002254  002462  // Usage : snd_Continue();
002255  002463  // Notes : resume any sound that is paused by snd_Pause.
002256  002464        
002257  002465  func snd_Playing(), 1;
002258  002466  // Syntax: snd_Playing();
002259  002467  // Usage : r := snd_Playing();
002260  002468  // Notes : returns 0 if sound has finished playing,
002261  002469  //       : else return number of 512 byte blocks to go.
002262  002470        
002263  002471        
002264  002472        
002265  002473  //------------------------------------------------------------------//
002266  002474  //        String Class Services
002267  002475  //------------------------------------------------------------------//
002268  002476        
002269  002477  func str_Ptr("&var"), 1;
002270  002478  // Syntax: str_Ptr(&var);
002271  002479  // Usage : p := str_Ptr(&var);
002272  002480  // Notes : return a byte pointer to a word region
002273  002481        
002274  002482  func str_GetD("&ptr", "&var"), 1;
002275  002483  // Syntax: str_GetD(&ptr, &var);
002276  002484  // Usage : ok := str_GetD(&ptr, &var);
002277  002485  // Notes : convert number in a string to DWORD ( myvar[2] )
002278  002486  //       : returns true if function succeeds, advancing ptr
002279  002487        
002280  002488  func str_GetW("&ptr", "&var"), 1;
002281  002489  // Syntax: str_GetW(&ptr, &var);
002282  002490  // Usage : ok := str_GetW(&ptr, &var);
002283  002491  // Notes : convert number in a string to WORD ( myvar )
002284  002492  //       : returns true if function succeeds, advancing ptr
002285  002493        
002286  002494  func str_GetHexW("&ptr", "&var"), 1;
002287  002495  // Syntax: str_GetHexW(&ptr, &var);
002288  002496  // Usage : ok := str_GetHexW(&ptr, &var);
002289  002497  // Notes : convert HEX number in a string to WORD ( myvar )
002290  002498  //       : returns true if function succeeds, advancing ptr
002291  002499        
002292  002500  func str_GetC("&ptr", "&var"), 1;
002293  002501  // Syntax: str_GetC(&ptr, &var);
002294  002502  // Usage : ok := str_GetC(&ptr, &var);
002295  002503  // Notes : get a valid ascii char in a string to WORD ( myvar )
002296  002504  //       : returns true if function succeeds, advancing ptr
002297  002505        
002298  002506  func str_GetByte("ptr"), 1;
002299  002507  // Syntax: str_GetByte(ptr);
002300  002508  // Usage : myvar := str_GetByte(ptr);
002301  002509  // Notes : get a byte to myvar
002302  002510  //       : returns value
002303  002511        
002304  002512  func str_GetWord("ptr"), 1;
002305  002513  // Syntax: GetWord(ptr);
002306  002514  // Usage : GetWord(ptr);
002307  002515  // Notes : get a word to myvar
002308  002516  //       : returns value
002309  002517        
002310  002518  func str_PutByte("ptr","val"), 0;
002311  002519  // Syntax: str_PutByte(ptr);
002312  002520  // Usage : myvar := str_PutByte(ptr);
002313  002521  // Notes : put a byte at ptr
002314  002522  //       : returns value
002315  002523        
002316  002524  func str_PutWord("ptr","val"), 0;
002317  002525  // Syntax: str_PutWord("ptr","val");
002318  002526  // Usage : str_PutWord(p,100);
002319  002527  // Notes : put word 100 at current pointer location
002320  002528  //       : returns value
002321  002529        
002322  002530  func str_Match("&ptr", "*str"), 1;
002323  002531  // Syntax: str_Match(&ptr, *str);
002324  002532  // Usage : r := str_Match(&p, "hello");
002325  002533  // Notes : Case sensitive match
002326  002534  //       : returns true if function succeded, andvancing pointer to position past
002327  002535  //       : the matched item. Note that any whitespace characters are skipped
002328  002536  //       : in the source string prior to the test.
002329  002537        
002330  002538  func str_MatchI("&ptr", "*str"), 1;
002331  002539  // Syntax: str_MatchI(&ptr, *str);
002332  002540  // Usage : r := str_MatchI(&p, "hello");
002333  002541  // Notes : Case insensitive match
002334  002542  //       : returns true if function succeded, andvancing pointer to position past
002335  002543  //       : the matched item. Note that any whitespace characters are skipped
002336  002544  //       : in the source string prior to the test.
002337  002545        
002338  002546  func str_Find("&ptr", "*str"), 1;
002339  002547  // Syntax: str_Find(&ptr, *str);
002340  002548  // Usage : n := str_Find(&p, "hello");
002341  002549  // Notes : given the address of a pointer to a source string as the
002342  002550  //       : first argument, and a pointer to a test string as the second
002343  002551  //       : argument, attempt to find the position of the matching string
002344  002552  //       : in the source string. The test is performed with case sensitivity.
002345  002553  //       : return 0 if not found, else returns the address of the first
002346  002554  //       : character of the match. NB:- The source pointer is not altered.
002347  002555        
002348  002556  func str_FindI("&ptr", "*str"), 1;
002349  002557  // Syntax: str_Find(&ptr, *str);
002350  002558  // Usage : n := str_Find(&p, "hello");
002351  002559  // Notes : given the address of a pointer to a source string as the
002352  002560  //       : first argument, and a pointer to a test string as the second
002353  002561  //       : argument, attempt to find the position of the matching string
002354  002562  //       : in the source string. The test is performed with no case
002355  002563  //       : sensitivity, eg upper and lower case chars are accepted.
002356  002564  //       : return 0 if not found, else returns the address of the first
002357  002565  //       : character of the match. NB:- The source pointer is not altered.
002358  002566        
002359  002567  func str_Length("ptr"), 1;
002360  002568  // Syntax: str_Length(ptr);
002361  002569  // Usage : len := str_Ptr(mystring);
002362  002570  // Notes : return the length of a byte aligned string excluding terminator
002363  002571        
002364  002572  func str_Printf("&ptr", "*format"), 1;
002365  002573  // Syntax: str_Printf("&ptr", "*format");
002366  002574  // Usage : r := str_Printf(&p, "%8s");
002367  002575  // Notes : refer to documentation
002368  002576  //       :
002369  002577        
002370  002578  func str_Cat("dest","src"), 1;
002371  002579  // Syntax: str_Append("&dest","&src");
002372  002580  // Usage : str_Append(&buf,"Hello");
002373  002581  // Notes : Appends a copy of the source string to the destination string.
002374  002582  //       : The terminating null character in destination is overwritten by
002375  002583  //       : the first character of source, and a new null-character is appended
002376  002584  //       : at the end of the new string formed by the concatenation of both in destination.
002377  002585  //       : returns destination.
002378  002586        
002379  002587  func str_CatN("dest","src","count"), 1;
002380  002588  // Syntax: str_Append("&dest","&src","count");
002381  002589  // Usage : str_Append(&buf,"Monday",3);
002382  002590  // Notes : Appends a copy of the source string to the destination string.
002383  002591  //       : The number of characters copied is limited by "count".
002384  002592  //       : The terminating null character in destination is overwritten by
002385  002593  //       : the first character of source, and a new null-character is appended
002386  002594  //       : at the end of the new string formed by the concatenation of both in destination.
002387  002595  //       : returns destination.
002388  002596        
002389  002597        
002390  002598  func sys_StoreTouchCalibration(), 1;
002391  002599  // Syntax: sys_StoreTouchCalibration();
002392  002600  // Usage : r := sys_StoreTouchCalibration();
002393  002601  // Notes : Store the touch calibration values in non-volatile memory.
002394  002602  //       : Returns true if the values have been accepted and stored,
002395  002603  //       : else returns false if write could not be performed, or
002396  002604  //       : touch calibration values are improbable.
002397  002605  //       : The values that are stored are obtained from:-
002398  002606  //     : TOUCH_XMINCAL             78  // touch calibration value
002399  002607  //     : TOUCH_YMINCAL             79  // touch calibration value
002400  002608  //       : TOUCH_XMAXCAL             80  // touch calibration value
002401  002609  //       : TOUCH_YMAXCAL             81  // touch calibration value
002402  002610  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002403  002611  //       : This function is not supported on uVGA, Capicitive touch
002404  002612  //       : and 4.3" resistive touch modules.
002405  002613        
002406  002614        
002407  002615  func unicode_page("charbeg","charend","charoffset"), 1;
002408  002616  // Syntax: unicode_page("charbeg","charend","charoffset");
002409  002617  // Usage : eg:  F_Traditional_0x20_0xFF
002410  002618  // Notes : After selecting a unicode image control with txt_FontID,
002411  002619  //       : this function is called to set the required font within the
002412  002620  //       : unicode set. The file "Unicode.inc" contains wrappers for
002413  002621  //       : this function, and it is not normally called directly.
002414  002622  //       : Returns count of characters in the set.
002415  002623  //       : Refer to "Unicode.inc" for further information.
002416  002624        
002417  002625        
002418  002626  func EVE_SP(), 1;
002419  002627  // Syntax: EVE_SP();
002420  002628  // Usage : eg:  print(EVE_SP());
002421  002629  // Notes : Used for debugging to assess the current stack level,
002422  002630  //       : mainly for checking stack leaks
002423  002631        
002424  002632  func EVE_SSIZE(), 1;
002425  002633  // Syntax: EVE_SSIZE();
002426  002634  // Usage : eg:  print(EVE_SSIZE());
002427  002635  // Notes : Used to get the stack size,
002428  002636  //       : mainly for debugging purposes
002429  002637        
002430  002638        
002431  002639  // uVGAII extended functions
002432  002640  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002433  002641  // Syntax: disp_Sync(line);
002434  002642  // Usage : disp_Sync(480);
002435  002643  // Notes : Waits till the hardware gets to a certain line.
002436  002644  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002437  002645  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002438  002646  //       : depending on the graphics operation. The higher the value, the slower
002439  002647  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002440  002648  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002441  002649  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002442  002650  //       : be slowest (as its actually right at the end of the blanking period) and 508
002443  002651  //       : will cause a hangup situation as it is above the highes scanline value.
002444  002652  //       : Currently, this function is only supported on displays with SSD1963 driver.
002445  002653        
002446  002654        
002447  002655  // New functions added to PmmC v2.8
002448  002656  //================================================================
002449  002657  func CY(), 1;
002450  002658  // Syntax: CY();
002451  002659  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002452  002660  //       : print(myvar," "CY(),"\n");           // carry = 1
002453  002661  // Notes : This function returns the carry status of an
002454  002662  // unsigned overflow from any 16 or 32bit additions or sutractions.
002455  002663  //================================================================
002456  002664        
002457  002665        
002458  002666  //================================================================
002459  002667  func str_ByteMove("src", "dest", "count"), 1;
002460  002668  // func str_ByteMove("src", "dest", "count"), 1;
002461  002669  // Syntax   : str_ByteMove(src, dest, bytecount);
002462  002670  // Input    : STR *source points to byte aligned source.
002463  002671  //          : STR *dest   points to byte aligned destination.
002464  002672  //          : VAR count   number of bytes to transfer.
002465  002673  // Usage    : nextpos := str_ByteMove(s, d, 100);
002466  002674  // Notes    : copy bytes from "src" to "dest", stopping only
002467  002675  //          : when "count" is exhausted.
002468  002676  //          : No terminator is appended, it is purely a
002469  002677  //          : byte copy, and any zeroes encountered will
002470  002678  //          : also be copied.
002471  002679  // Returns  : returns a pointer to the end of the destination
002472  002680  //          : (which is "dest" + "count")
002473  002681  //================================================================
002474  002682        
002475  002683        
002476  002684  //================================================================
002477  002685  func str_Copy("dest", "src"), 1;
002478  002686  // Syntax   : str_Copy(dest, src);
002479  002687  // Input    : STR *dest   points to byte aligned destination.
002480  002688  //          : STR *source points to byte aligned source.
002481  002689  // Usage    : nextplace := str_Copy(d, s);
002482  002690  // Notes    : copy a string from "src" to "dest", stopping only
002483  002691  //          : when the end of source string "src" is encountered
002484  002692  //          : (0x00 terminator).
002485  002693  //          : The terminator is always appended, even if "src" is
002486  002694  //          : an empty string.
002487  002695  // Returns  : returns a pointer to the 0x00 string terminator at
002488  002696  //          : end of "dest" (which is "dest" + str_Length(src); )
002489  002697  //================================================================
002490  002698        
002491  002699  //================================================================
002492  002700  func str_CopyN("dest", "src", "count"), 1;
002493  002701  // Syntax   : str_CopyN(dest, src, bytecount);
002494  002702  // Input    : STR *dest   points to byte aligned destination.
002495  002703  //          : STR *source points to byte aligned source.
002496  002704  //          : VAR count   max number of chars to copy.
002497  002705  // Usage    : nextplace := str_CopyN(d, s, 100);
002498  002706  // Notes    : copy a string from "src" to "dest", stopping only
002499  002707  //          : when "count" is exhausted, or end of source
002500  002708  //          : string "str" is encountered (0x00 string terminator).
002501  002709  //          : The terminator is always appended, even if
002502  002710  //          : "count" is zero, or "src" is a null string.
002503  002711  // Returns  : returns a pointer to the 0x00 string terminator
002504  002712  //          : (which is "dest" + whatever was copied)
002505  002713  //================================================================
002506  002714        
002507  002715  //================================================================
002508  002716  func umul_1616("&res32", "val1", "val2"), 1;
002509  002717  // Syntax   : umul_1616(&res32, varA, varB);
002510  002718  // Input    : DWORD *result   points to 32bit result register.
002511  002719  //          : VAR   val1  16bit register or constant
002512  002720  //          : VAR   val2  16bit register or constant
002513  002721  // Usage    : var res32[2];
002514  002722  //          : umul_1616(&res32, myvar, 50000);
002515  002723  // Notes    : performs an unsigned multiply of 2 x 16bit values
002516  002724  //          : placing the 32bit result in a 2 word array.
002517  002725  // Returns  : the pointer to the 32bit result.
002518  002726  //          : carry and overflow are not affected.
002519  002727  //================================================================
002520  002728        
002521  002729  //================================================================
002522  002730  func uadd_3232("&res32", "&val1", "&val2"), 1;
002523  002731  // Syntax   : cmp_3232(&res32, &varA, &varB);
002524  002732  // Input    : DWORD *res32 points to optional result (or zero for compare)
002525  002733  //          : DWORD *val1 points to 32bit augend
002526  002734  //          : DWORD *val2 points to 32bit addend
002527  002735  // Usage    : var res32[2];
002528  002736  //          : res := cmp_3232(res32, val1, val2);
002529  002737  // Notes    : performs an unsigned addition of 2 x 32bit values
002530  002738  //          : placing the 32bit result in a 2 word array.
002531  002739  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002532  002740  //          ; carry flag is also set on 32bit unsigned overflow
002533  002741  //          ; and can be read with the CY() function.
002534  002742  //================================================================
002535  002743        
002536  002744  //================================================================
002537  002745  func usub_3232("&res32", "&val1", "&val2"), 1;
002538  002746  // Syntax   : cmp_3232(&res32, &varA, &varB);
002539  002747  // Input    : DWORD *res32 points to optional result (or zero for compare)
002540  002748  //          : DWORD *val1 points to first 32bit minuend
002541  002749  //          : DWORD *val2 points to 32bit subtrahend
002542  002750  // Usage    : var res32[2];
002543  002751  //          : res := cmp_3232(res32, val1, val2);
002544  002752  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002545  002753  //          : placing the 32bit result in a 2 word array.
002546  002754  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002547  002755  //          ; carry flag is also set on 32bit unsigned underflow
002548  002756  //          ; and can be read with the CY() function.
002549  002757  //================================================================
002550  002758        
002551  002759  //================================================================
002552  002760  func ucmp_3232("&val1", "&val2"), 1;
002553  002761  // Syntax   : cmp_3232(&varA, &varB);
002554  002762  // Input    : DWORD *val1 points to 32bit minuend
002555  002763  //          : DWORD *val2 points to 32bit sutrahend
002556  002764  // Usage    : res := cmp_3232(val1, val2);
002557  002765  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002558  002766  //          : The result of the subtraction is returned.
002559  002767  // Returns  : 0  if equal
002560  002768  //          : 1  if val1 > val2
002561  002769  //          : -1 if val1 < val2
002562  002770  //          : This function does not affect the carry flag.
002563  002771  //================================================================
002564  002772        
002565  002773  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002566  002774  // Syntax: disp_Disconnect();                  New in v3.8
002567  002775  // Usage : disp_Disconnect();
002568  002776  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002569  002777  //       : its lowest possible power consumption. Use after disabling peripheral power
002570  002778  //       : to ensure the minimal power usage by the display.
002571  002779  //       : disp_Init() should be used to reinitialise the display.
002572  002780        
002573  002781  func reserved(), 0;                            
002574  002782        
002575  002783  func sys_DeepSleep("units"), 1;
002576  002784  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002577  002785  // Usage : t := sys_DeepSleep(10);
002578  002786  // Notes : sets the display and processor into lowest power mode for a period of time.
002579  002787  //       : When returning from DeepSleep the display should be reinitialised
002580  002788  //       : with disp_Init().
002581  002789  //       : Touching the touch screen will also wake from sleep.
002582  002790  //       : Returns remaining sleep units.
002583  002791        
002584  002792  func sys_PmmC(), 1;
002585  002793  // Syntax: sys_PmmC();
002586  002794  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer, new in v4.6
002587  002795  // Notes : print the system PmmC name and revision eg "Picaso\n4.6"
002588  002796  //       : Can be captured to a buffer using the to( function
002589  002797  //       : Returns PmmC version as a hex number, eg 0x46
002590  002798        
002591  002799  func sys_Driver(), 0;
002592  002800  // Syntax: sys_Driver();
002593  002801  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer, new in v4.6
002594  002802  // Notes : print the system PmmC name and revision eg "uLCD-32PTU"
002595  002803  //       : Can be captured to a buffer using the to( function
002596  002804  //       : Returns nothing.
002597  002805        
002598  002806  func OW_Reset("pin"), 1;                             // issue 1wire reset command
002599  002807  // Syntax   : OW_Reset(PA0);
002600  002808  // Usage    : OW_Reset(PA0);
002601  002809  // Notes    : Only available on PA0 to PA13
002602  002810  //          : Resets  ONEWIRE device
002603  002811  //          : Returns the status, 0 = ACK.
002604  002812  //          :
002605  002813        
002606  002814  func OW_Read("pin"), 1;                              // read data from 1wire bus
002607  002815  // Syntax   : OW_Read(PA0);
002608  002816  // Usage    : arg1 := OW_Read(PA0);
002609  002817  // Notes    : Only available on PA0 to PA13
002610  002818  //          : Reads value of the ONEWIRE pin
002611  002819  //          : that was previously selected for ONEWIRE comms.
002612  002820  //          :
002613  002821  //          : pin = 0 : the next byte from the ONEWIRE bus
002614  002822        
002615  002823  func OW_Read9("pin"), 1;                             // read data from 1wire bus, 9bit mode
002616  002824  // Syntax   : OW_Read9(PA0);
002617  002825  // Usage    : OW_Read9(PA0);
002618  002826  // Notes    : Only available on PA0 to PA13
002619  002827  //          : Reads 9 bit value of the appropriate ONEWIRE pin
002620  002828  //          : that was previously selected for ONEWIRE comms.
002621  002829  //          :
002622  002830  //          : read the 9 bits from the ONEWIRE bus
002623  002831        
002624  002832  func OW_Write("pin", "value"), 0;                      // write value to 1wire device
002625  002833  // Syntax   : OW_Write(PA0, arg);
002626  002834  // Usage    : OW_Write(PA0, arg);
002627  002835  // Notes    : Only available on PA0 to PA13
002628  002836  //          : Sends ONEWIRE data on the appropriate
002629  002837  //          : pin that was previously  selected as ONEWIRE comms.
002630  002838  //          :
002631  002839  //          : write arg to the ONEWIRE bus
002632  002840        
002633  002841  func snd_Freq("Freq", "Duration"), 1;
002634  002842  // Syntax	: snd_Freq("Freq", "Duration");
002635  002843  // Usage	: r := snd_Freq(1000, 2000);
002636  002844  // Notes	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002637  002845  // 	: else return True.
002638  002846  // 	: Minimum Freq is 20
002639  002847  // 	: This will produce a pure Square wave and is designed for driving
002640  002848  // 	: Piezo transducers which require this sort of drive. It can be used
002641  002849  // 	: directly with high impedience speakers.
002642  002850        
002643  002851  func gfx_SpriteSet("bitmaps", "colours", "palette"), 0;
002644  002852  // Syntax   : gfx_SpriteSet("bitmaps", "colours", "palette");
002645  002853  // Usage    : gfx_SpriteSet(mysprites, mycolours, mypalette);
002646  002854  // Notes    : 3 sets of data are required by the sprite generator,
002647  002855  //          : this function sets the internal pointers for the 3 parts.
002648  002856  //          : 1] the bitmaps for the sprites,
002649  002857  //          : 2] the colour lookup table (CLUT),
002650  002858  //          : 3] the 4 colour palettes.
002651  002859        
002652  002860        
002653  002861  func gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage"), 0;
002654  002862  // Syntax 	: gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage");
002655  002863  // Usage 	: gfx_BlitSprite(1,2,10,10,SOUTH,0);  // example show a cherry upside down using the third palette of mypalette
002656  002864  // Notes 	: Places the required sprite bitmap at the origin xpos, ypos using the required 4 colour palette.
002657  002865  //  	: orientation determines in which direction the sprite will be displayed.
002658  002866  //    	: if preimage exists it should be large enough to hold the entire image 'underneath' the sprite.
002659  002867        
002660  002868  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
002661  002869  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
002662  002870  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
002663  002871  // Notes   : reads an arbitrary rectangular area from the display to an array.
002664  002872  //         : If "ptr" is 0, the correctly sized array is created, in which case
002665  002873  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
002666  002874  //         : is expected to point to a correctly sized array.
002667  002875  //         : NB if an array is supplied, its size must be large enough, and may
002668  002876  //         : be calculated:-
002669  002877  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
002670  002878  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
002671  002879  // Returns : A pointer to the created aray, or the users array.
002672  002880  //         : In the case of ptr=0, if there is insufficient
002673  002881  //         : memory to create the array, zero is returned
002674  002882        
002675  002883        
002676  002884  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
002677  002885  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
002678  002886  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
002679  002887  // Notes   : "ptr" points to the array to be written.
002680  002888  // Returns : nothing
002681  002889        
002682  002890  func rect_Intersect("&rect1", "&rect2"), 1;
002683  002891  // Syntax   : rect_Intersect(&rect1, &rect2);
002684  002892  // Usage    : rect_Intersect(box1, box2);
002685  002893  // Notes    : return true if any part of rect1 is within rect2
002686  002894  //          : each rectangle is an array of 4 words in the format:-
002687  002895  //	    : element 0 = RECT_LEFT			
002688  002896  //	    : element 1 = RECT_TOP			
002689  002897  //	    : element 2 = RECT_WIDTH 		
002690  002898  //	    : element 3 = RECT_HEIGHT 
002691  002899  //          : This function is ideal for use as a collision detector.		
002692  002900        
002693  002901  func rect_Within("&rect1", "&rect2"), 1;
002694  002902  // Syntax   : rect_Within(&rect1, &rect2);
002695  002903  // Usage    : rect_Within(box1, box2);
002696  002904  // Notes    : return true if rect1 is fully within rect2
002697  002905  //          : each rectangle is an array of 4 words in the format:-
002698  002906  //	    : element 0 = RECT_LEFT			
002699  002907  //	    : element 1 = RECT_TOP			
002700  002908  //	    : element 2 = RECT_WIDTH
002701  002909  //	    : element 3 = RECT_HEIGHT 
002702  002910        
002703  002911  func snd_RTTTL("TunePtr",), 1;                           // play a RTTTL tune string
002704  002912  // Syntax	: snd_RTTTL(TunePtr);
002705  002913  // Usage	: snd_RTTTL("...notes...");
002706  002914  // Notes	: Play an RTTTL tune string from a data statement or a direct string
002707  002915  // 	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002708  002916        
002709  002917  func joystick("Pin"), 1;                                     // read the joystick value
002710  002918  // Syntax   : Joystick("Pin");
002711  002919  // Usage    : var := Joystick(IO1_PIN);
002712  002920  // *Notes   : Returned values are:-
002713  002921  //          :    JOY_RELEASED 0
002714  002922  //          :    JOY_UP       1
002715  002923  //          :    JOY_LEFT     2
002716  002924  //          :    JOY_DOWN     3
002717  002925  //          :    JOY_RIGHT    4
002718  002926  //          :    JOY_BTNB     5
002719  002927  //          :    JOY_BTNA     6
002720  002928        
002721  002929  func gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour"), 0;         // display an Annular ring segment
002722  002930  // Syntax 	: gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour") ;
002723  002931  // Usage 	: gfx_RingSegment(x, y, starta, enda, rx, w, colour) ;
002724  002932  // Notes 	: Draw a Segment of a ring at x, y from rad1 to rad2 starting at starta to enda
002725  002933  // 	: in colour.
002726  002934  //
002727  002935        
002728  002936  func gfx_AngularMeter("value", "&MeterRam", "&MeterDef"), 0;                           // draw an angular meter scale and value
002729  002937  // Syntax 	: gfx_AngularMeter("value", "&MeterRam", "&MeterDef") ;
002730  002938  // Usage 	: gfx_AngularMeter(value, MeterRam, MeterDef) ;
002731  002939  // Notes 	: Draw an Angular Meter as defined by MeterDef (if required), using MeterRam positioning at
002732  002940  // 	: position value. See the reference for the MeterDef values
002733  002941  //
002734  002942        
002735  002943  // AngularMeter constants
002736  002944  #CONST
002737  002995  #END
002738  002996        
002739  002997  #constant PANEL2_FILLED 0x8000
002740  002997  #constant PANEL2_FILLED 0x8000
002741  002998        
002742  002999  func gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf"), 0;                           // draw a windows style 3D panel
002743  003000  // Syntax 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002744  003001  // Usage 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002745  003002  // Notes	: Draws a panel2 (groupbox) at screen location defined by
002746  003003  // 	: x, y, width and height with left colour "cl", right colour "cr" and option fill colour "cf".
002747  003004  // 	:  w1 and w2 define the width of the outer and inner borders.
002748  003005  // 	:         state = 0 : recessed
002749  003006  // 	:         state = 1 : raised
002750  003007  // 	: 	  or state with PANEL2_FILLED to draw the fill
002751  003008        
002752  003009  func gfx_Needle("value", "&NeedleRam", "&NeedleDef"), 0;                           // draw a needle on a meter base
002753  003010  // Syntax 	: gfx_Needle("value", "&NeedleRam", "&NeedleDef") ;
002754  003011  // Usage 	: gfx_Needle(value, NeedleRam, NeedleDef) ;
002755  003012  // Notes 	: Draw a Needle as defined by NeedleDef (if required), using NeedleRam positioning at
002756  003013  // 	: position value. See the reference for the NeedleDef values
002757  003014  //
002758  003015        
002759  003016  #CONST
002760  003038  #END
002761  003039        
002762  003040  #CONST
002763  003047  #END
002764  003048        
002765  003049  func gfx_Dial("value", "&DialRam", "&DialDef"), 0;                           // draw a Dial / knob
002766  003050  // Syntax 	: gfx_Dial("value", "&DialRam", "&DialDef") ;
002767  003051  // Usage 	: gfx_Dial(value, DialRam, DialDef) ;
002768  003052  // Notes 	: Draw a Dial as defined by DialDef (if required), using DialRam positioning at
002769  003053  // 	: position value. See the reference for the DialDef values
002770  003054  //
002771  003055        
002772  003056  #CONST
002773  003114  #END
002774  003115        
002775  003116  func gfx_Gauge("value", "&GaugeRam", "&GaugeDef"), 0;                           // draw a gauge
002776  003117  // Syntax 	: gfx_Gauge("value", "&GaugeRam", "&GaugeDef") ;
002777  003118  // Usage 	: gfx_Gauge(value, GaugeRam, GaugeDef) ;
002778  003119  // Notes 	: Draw a Gauge as defined by GaugeDef (if required), using GaugeRam positioning at
002779  003120  // 	: position value. See the reference for the GaugeDef values
002780  003121  //
002781  003122        
002782  003123  #CONST
002783  003148  #END
002784  003149        
002785  003150  // widget_* functions
002786  003151  //
002787  003152  #CONST
002788  003185  #END
002789  003186        
002790  003187  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
002791  003188  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
002792  003189  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
002793  003190  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
002794  003191  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
002795  003192  //         : to be used for rounded panels, rounded buttons, circular buttons.
002796  003193  //         : "style" specifies the drawing mode
002797  003194  //         :     GRAD_DOWN         // gradient changes in the vertical direction
002798  003195  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
002799  003196  //         :     GRAD_UP           // gradient changes in the vertical direction
002800  003197  //         :     GRAD_LEFT         // gradient change in the horizontal direction
002801  003198  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
002802  003199  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
002803  003200  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
002804  003201  // Returns : nothing.
002805  003202        
002806  003203        
002807  003204  //------------------------------------------------------------------//
002808  003205  //     gradient control constants                                   //
002809  003206  //------------------------------------------------------------------//
002810  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002811  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002812  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002813  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002814  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002815  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002816  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002817  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002818  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002819  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002820  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002821  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002822  003213        
002823  003214  #CONST
002824  003217  #END
002825  003218        
002826  003219  #CONST
002827  003251  #END
002828  003252        
002829  003253  func gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef"), 0;                           // draw a value to a series of 7 segment led Digits
002830  003254  // Syntax 	: gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef");
002831  003255  // Usage 	: gfx_LedDigits(value, LedDigitRam, LedDigitDef);
002832  003256  // Notes 	: Draw a series of 7 segment Led Digits as defined by LedDigitDef, using LedDigitRam positioning at
002833  003257  // 	: position value. See the reference for LedDigitDef values.
002834  003258  //
002835  003259        
002836  003260  func gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value"), 0;                           // draw a single 7 segment led digit
002837  003261  // Syntax 	: gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value");
002838  003262  // Usage 	: gfx_LedDigit(x, y, digitsize, oncolour, offcolour, value);
002839  003263  // Notes 	: Draws a single 7 segment led Digit at x, y of size digitsize using oncolour and offcolour.
002840  003264  // 	: The value can be 0-9 (0-9), A-F (0x0a-0x0f), blank(0x10) and - (0x11).
002841  003265  //      : Or value with LEDDIGIT_F_SHOW_DP to show a decimal point, LEDDIGIT_F_DP_COMMA to make the Decimal
002842  003266  // 	: point a comma and LEDDIGIT_F_DP_ON to turn the decimal point on
002843  003267  // 	:
002844  003268  // 	: LEDDIGIT_F_SET_SEGMENTS can be used to turn value into a series of bits to turn on individual segments
002845  003269  //      : eg LEDDIGIT_F_SET_SEGMENTS + 9 will turn on the top and bottom segments. Again LEDDIGIT_F_SHOW_DP and
002846  003270  // 	: LEDDIGIT_F_DP_COMMA can be used, but in this case the DP is the 8th segment. 
002847  003271  // Returns : nothing.
002848  003272        
002849  003273  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
002850  003274  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
002851  003275  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
002852  003276  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
002853  003277  //         : determined by "radius". 
002854  003278  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
002855  003279  // Returns : nothing.
002856  003280        
002857  003281  func putstrCentred("xc", "yc", "string"), 0;
002858  003282  // Syntax  : putstrCentred(x, y, "string"),
002859  003283  // Usage   : putstrCentred(100, 100, "HELLO");
002860  003284  // Notes   : Print a string centred at position x, y
002861  003285  //         : "String" may be a string constant, or pointer to a word aligned string.
002862  003286  // Returns : nothing.
002863  003287        
002864  003288  func widget_Create("count"), 1;
002865  003289  // Syntax 	: widget_Create("count"),
002866  003290  // Usage  	: widget_Create(count);
002867  003291  // Notes  	: Creates a widget Control capable of hoolding count elements and returns
002868  003292  //        	: a handle for the control.
002869  003293  // Returns	: Widget control handle.
002870  003294        
002871  003295  func widget_Add("hndl", "index", "widget"), 1;
002872  003296  // Syntax 	: widget_Add("hndl", "index", "widget"),
002873  003297  // Usage  	: widget_Add(hndl, index, widget);
002874  003298  // Notes  	: Add a widget ram entry "widget" into index "index" of the widget control referenced
002875  003299  //        	: by "hndl".
002876  003300  // Returns	: ssnothing.
002877  003301        
002878  003302  func widget_Delete("hndl", "index"), 1;
002879  003303  // Syntax 	: widget_Delete("hndl", "index"),
002880  003304  // Usage  	: widget_Delete(hndl, index);
002881  003305  // Notes  	: Delete widget ram entry "index" from the widget control referenced by "hndl".
002882  003306  // Returns	: sssnothing.
002883  003307        
002884  003308  func widget_Show("hndl", "index"), 1;
002885  003309  // Syntax	: widget_Show(handle, index);
002886  003310  // Usage	: display a flash resident image entry.
002887  003311  // Returns	: TRUE if successful, return value usually ignored.
002888  003312        
002889  003313  func widget_LoadFlash("Extra"), 1;
002890  003314  // Syntax	: hImagelist := widget_LoadFlash("Extra") ;
002891  003315  // Usage 	: hImagelist := widget_LoadFlash(0);
002892  003316  // Notes	: Reads the flash control file to create an widget list.
002893  003317  //      	: Returns NULL if function fails.
002894  003318  //      	: Returns a handle (pointer to the memory allocation) to the
002895  003319  //      	: widget control list that has been created.
002896  003320  //      	: "Extra" is the number of extra widget controls to be created
002897  003321  //      	: beyond the count in flash memory
002898  003322  // Returns 	: pointer to Widget control, or null if failed.
002899  003323        
002900  003324  func widget_Realloc("handle", "n"), 1;
002901  003325  // Syntax	: widget_Realloc(handle, n);
002902  003326  // Usage 	: Resizes a widget control to contain n entries, allowing it to be expanded or
002903  003327  //      	: condensed. Doing this unnecessarily can lead to RAM fragmentation. It is
002904  003328  //             	: much better to allocate widget controls once with the desired number of entries.
002905  003329  // Returns	: new handle to widget control.
002906  003330        
002907  003331  func widget_GetWord("hndl", "index", "offset"), 1;
002908  003332  // Syntax	: myvar := widget_GetWord("handle", "index", "offset");
002909  003333  // Usage 	: myvar := widget_GetWord(hndl, 5, WIDGET_YPOS);
002910  003334  // Notes 	: returns specified word (0-14) from a widget entry
002911  003335  //       	: refer to widget control entry offsets.
002912  003336        
002913  003337  func widget_Setposition("hndl", "index", "xpos", "ypos"), 1;
002914  003338  // Syntax	: widget_SetPosition(handle, index, xpos, ypos);
002915  003339  // Usage 	: r := widget_SetPosition(hImageList, imagenum, x, y);
002916  003340  // Notes 	: set the position of the widget control
002917  003341  //       	: returns true if index was ok and function was successful.
002918  003342        
002919  003343  func widget_Enable("hndl", "index"), 1;
002920  003344  // Syntax	: widget_Enable(handle, index);
002921  003345  // Usage 	: r := widget_Enable(hImageList, imagenum);
002922  003346  // Notes 	: enable an item in a widget control.
002923  003347  // Returns     	: true if index was ok and function was successful.
002924  003348        
002925  003349  func widget_Disable("hndl", "index"), 1;
002926  003350  // Syntax	: widget_Disable(handle, index);
002927  003351  // Usage 	: r := widget_Disable(hImageList, imagenum);
002928  003352  // Notes 	: disable an inetm in a widget control.
002929  003353  // Returns      : true if index was ok and function was successful.
002930  003354        
002931  003355  func widget_SetWord("hndl", "index", "offset", "value"), 1;
002932  003356  // Syntax: widget_SetWord(handle, index, offset, word);
002933  003357  // Usage : widget_SetWord(hndl, 5, IMAGE_XPOS, 10);
002934  003358  // Notes : set specified word (0-7) in a image entry
002935  003359  //       : returns TRUE if successful, return value usually ignored.
002936  003360        
002937  003361  func widget_SetAttributes("hndl", "index", "value"), 1;
002938  003362  // Syntax: widget_SetAttributes("handle", "index","offset");
002939  003363  // Usage : widget_SetAttributes(hndl, 5, I_TOPMOST);
002940  003364  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
002941  003365  //       : of an image control entry. "value" refers to various bits in
002942  003366  //       : the image control entry (see image attribute flags).
002943  003367  //       : A '1' bit in the "value" field SETS the respective bit
002944  003368  //       : in the IMAGE_FLAGS field of the image control entry.
002945  003369  //       : returns TRUE if successful, return value usually ignored.
002946  003370        
002947  003371  func widget_ClearAttributes("hndl", "index", "value"), 1;
002948  003372  // Syntax: widget_ClearAttributes("handle", "index","offset");
002949  003373  // Usage : widget_ClearAttributes(hndl, 5, I_TOPMOST);
002950  003374  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
002951  003375  //       : of an image control entry. "value" refers to various bits in
002952  003376  //       : the image control entry (see image attribute flags)
002953  003377  //       : a '1' bit in the "value" field CLEARS the respective bit
002954  003378  //       : in the IMAGE_FLAGS field of the image control entry.
002955  003379  //       : returns TRUE if successful, return value usually ignored.
002956  003380        
002957  003381  func widget_Touched("hndl", "index"), 1;
002958  003382  // Syntax: r := widget_Touched(handle, index);
002959  003383  // Usage : widget_Touched(hndl, 17);
002960  003384  //       : returns -1 if image not touched, or returns index
002961  003385  // Notes : if index is passed as -1, function tests all images,
002962  003386  //       : and returns -1 if image not touched, or returns index.
002963  003387        
002964  003388  func widget_FontID("id"), 1;                   // text font ID for flash based font
002965  003389  // Syntax: widget_FontID(id);
002966  003390  // Usage : widget_FontID(0);
002967  003391  //       : returns id of previous font
002968  003392        
002969  003393  #CONST
002970  003431  #END
002971  003432        
002972  003433  func gfx_Slider5("value", "&SliderRam", "&SliderDef"), 0;                           // draw a slider
002973  003434  // Syntax 	: gfx_Slider5("value", "&SliderRam", "&SliderDef") ;
002974  003435  // Usage 	: gfx_Slider5(value, SliderRam, SliderDef) ;
002975  003436  // Notes 	: Draw a Slider as defined by SliderDef (if required), using SliderRam positioning at
002976  003437  // 	: position value. See the reference for the SliderDef values
002977  003438  //
002978  003439        
002979  003440  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
002980  003441  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
002981  003442  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
002982  003443  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
002983  003444  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
002984  003445  //         : If "radius1" is zero, the inner rectangle will have square corners.
002985  003446  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
002986  003447  // Returns : nothing.
002987  003448        
002988  003449  /////////////////////
002989  003450  #CONST
002990  003469  #END
002991  003470        
002992  003471  func gfx_Switch("state", "&SwitchRam", "&SwitchDef"), 0;                           // draw a switch
002993  003472  // Syntax 	: gfx_Switch("state", "&SwitchRam", "&SwitchDef") ;
002994  003473  // Usage 	: gfx_Switch(state, SwitchRam, SwitchDef) ;
002995  003474  // Notes 	: Draw a Switch as defined by SwitchDef (if required), using SwitchRam positioning at
002996  003475  // 	: position value. See the reference for the SwitchDef values
002997  003476  //
002998  003477        
002999  003478  #CONST
003000  003507  #END
003001  003508        
003002  003509  func gfx_Button4("state", "&gfx_ButtonRam", "&gfx_ButtonDef"), 0;                           // draw a button
003003  003510  // Syntax 	: gfx_Button4("state", "&ButtonRam", "&ButtonDef") ;
003004  003511  // Usage 	: gfx_Button4(state, ButtonRam, ButtonDef) ;
003005  003512  // Notes 	: Draw a Button as defined by ButtonDef (if required), using ButtonRam positioning at
003006  003513  // 	: position value. See the reference for the ButtonDef values
003007  003514  //
003008  003515        
003009  003516  #CONST
003010  003531  #END
003011  003532        
003012  003533  func gfx_Led("state", "&LedRam", "&LedDef"), 0;                           // draw an LED
003013  003534  // Syntax 	: gfx_Led("state", "&LedRam", "&LedDef") ;
003014  003535  // Usage 	: gfx_Led(state, LedRam, LedDef) ;
003015  003536  // Notes 	: Draw a Led as defined by LedDef (if required), using LedRam positioning in
003016  003537  // 	: state state. See the reference for the LedDef values
003017  003538  //
003018  003539        
003019  003540  #CONST
003020  003558  #END
003021  003559  #CONST
003022  003577  #END
003023  003578        
003024  003579  func gfx_Scale("&ScaleRam", "&ScaleDef"), 0;                           // draw a Scale
003025  003580  // Syntax 	: gfx_Scale("&ScaleRam", "&ScaleDef") ;
003026  003581  // Usage 	: gfx_Scale(ScaleRam, ScaleDef) ;
003027  003582  // Notes 	: Draw a Scale as defined by ScaleDef, setting LedRam for use in touch processing.
003028  003583  // 	: See the reference for the ScaleDef values. If touch processing is not required 0 may be used as the SclaleRam parameter.
003029  003584  //
003030  003585        
003031  003586  #CONST
003032  003590  #END
003033  003591        
003034  003592  #CONST
003035  003612  #END
003036  003613        
003037  003614  func gfx_RulerGauge("state", "&RulerGaugeRam", "&RulerGaugeDef"), 0;                           // draw a Ruler Gauge
003038  003615  // Syntax 	: gfx_Led("position", "&RulerGaugeRam", "&RulerGaugeDef") ;
003039  003616  // Usage 	: gfx_Led(position, RulerGaugeRam, RulerGaugeDef) ;
003040  003617  // Notes 	: Draw a RulerGauge as defined by RulerGaugeDef (if required), using RulerGaugeRam positioning at
003041  003618  // 	: position value. See the reference for the RulerGaugeDef values
003042  003619  //
003043  003620        
003044  003621  #CONST
003045  003631  #END
003046  003632        
003047  003633  func file_CheckUpdate("Filename", "Options"), 1;                           // check and/or update the program running in Flash
003048  003634  // Syntax 	: file_CheckUpdate("Filename", "Options") ;
003049  003635  // Usage 	: file_CheckUpdate("thisfile.4xe", CheckUpdate_Check) ;
003050  003636  // Notes 	: Check and/or update the program running in flash using the specified file on uSD.
003051  003637  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003052  003638  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003053  003639  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003054  003640  //
003055  003641  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003056  003642  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003057  003643  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003058  003644  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003059  003645  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003060  003646  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003061  003647        
003062  003648  func udiv_3232("res32", "val1", "val2"), 1;
003063  003649  // Syntax   : udiv_1616(res32, varA, varB);
003064  003650  // Input    : DWORD *result   points to 32bit result register.
003065  003651  //          : DWORD   val1  pointer to 32bit value (dividend)
003066  003652  //          : DWORD   val2  pointer to 32bit value (divisor)
003067  003653  // Usage    : var res32[2];
003068  003654  //          : umul_1616(res32, myvar, 50000);
003069  003655  // Notes    : performs an unsigned division of 2 x 32bit values
003070  003656  //          : placing the 32bit result in a 2 word array.
003071  003657  // Returns  : the pointer to the 32bit result.
003072  003658  //          : carry and overflow are not affected.
003073  003659        
003074  003660  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
003075  003661  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
003076  003662  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
003077  003663  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
003078  003664  //         : "style" specifies the drawing mode
003079  003665  //         :     GRAD_DOWN         // gradient changes in the vertical direction
003080  003666  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
003081  003667  //         :     GRAD_UP           // gradient changes in the vertical direction
003082  003668  //         :     GRAD_LEFT         // gradient change in the horizontal direction
003083  003669  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
003084  003670  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
003085  003671  // Returns : nothing.
003086  003672        
003087  003673  func I2C2_Open("speed"), 1;
003088  003674  // Syntax : I2C2_Openx(speed),
003089  003675  // Usage  : I2C2_Open(I2C_MED);
003090  003676  // Notes : configures the I2C1 module
003091  003677  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003092  003678  // Returns: True if successful
003093  003679        
003094  003680        
003095  003681  func I2C3_Open("speed"), 1;
003096  003682  // Syntax : I2C3_Openx(speed),
003097  003683  // Usage  : I2C3_Open(I2C_MED);
003098  003684  // Notes : configures the I2C1 module
003099  003685  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003100  003686  // Returns: True if successful
003101  003687        
003102  003688  func I2C2_Close(), 0;
003103  003689  // Usage : I2C2_Close();
003104  003690  // Notes : disables the I2C2 module.
003105  003691        
003106  003692  func I2C3_Close(), 0;
003107  003693  // Usage : I2C3_Close();
003108  003694  // Notes : disables the I2C3 module.
003109  003695        
003110  003696  func I2C2_Start(), 1;
003111  003697  // Syntax: I2C2_Start();
003112  003698  // Usage : I2C2_Start();
003113  003699  // Notes : generates a Start condition.
003114  003700  //       : returns true if successful (usually ignored)
003115  003701        
003116  003702  func I2C3_Start(), 1;
003117  003703  // Syntax: I2C3_Start();
003118  003704  // Usage : I2C3_Start();
003119  003705  // Notes : generates a Start condition.
003120  003706  //       : returns true if successful (usually ignored)
003121  003707        
003122  003708  func I2C2_Stop(), 1;
003123  003709  // Syntax: I2C2_Stop();
003124  003710  // Usage : I2C2_Stop();
003125  003711  // Notes : generates a Stop condition.
003126  003712  //       : returns true if successful (usually ignored)
003127  003713        
003128  003714  func I2C3_Stop(), 1;
003129  003715  // Syntax: I2C3_Stop();
003130  003716  // Usage : I2C3_Stop();
003131  003717  // Notes : generates a Stop condition.
003132  003718  //       : returns true if successful (usually ignored)
003133  003719        
003134  003720  func I2C2_Restart(), 1;
003135  003721  // Syntax: I2C2_Restart();
003136  003722  // Usage : I2C2_Restart();
003137  003723  // Notes : generates a Restart condition.
003138  003724  //       : returns true if successful (usually ignored)
003139  003725        
003140  003726  func I2C3_Restart(), 1;
003141  003727  // Syntax: I2C3_Restart();
003142  003728  // Usage : I2C3_Restart();
003143  003729  // Notes : generates a Restart condition.
003144  003730  //       : returns true if successful (usually ignored)
003145  003731        
003146  003732  func I2C2_Read(), 1;
003147  003733  // Syntax: I2C2_Read();
003148  003734  // Usage : ch := I2C2_Read();
003149  003735  // Notes : reads a single byte from the I2C Bus.
003150  003736        
003151  003737  func I2C3_Read(), 1;
003152  003738  // Syntax: I2C3_Read();
003153  003739  // Usage : ch := I2C3_Read();
003154  003740  // Notes : reads a single byte from the I2C Bus.
003155  003741        
003156  003742  func I2C2_Write("byte"), 1;
003157  003743  // Syntax: I2C2_Write(byte);
003158  003744  // Usage : r := I2C2_Write(ch);
003159  003745  // Notes : is used to write a byte to the I2C bus.
003160  003746  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003161  003747        
003162  003748  func I2C3_Write("byte"), 1;
003163  003749  // Syntax: I2C3_Write(byte);
003164  003750  // Usage : r := I2C3_Write(ch);
003165  003751  // Notes : is used to write a byte to the I2C bus.
003166  003752  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003167  003753        
003168  003754  func I2C2_Ack(), 0;
003169  003755  // Syntax: I2C2_Ack();
003170  003756  // Usage : I2C2_Ack();
003171  003757  // Notes : generates the acknowledge condition.
003172  003758        
003173  003759  func I2C3_Ack(), 0;
003174  003760  // Syntax: I2C3_Ack();
003175  003761  // Usage : I2C3_Ack();
003176  003762  // Notes : generates the acknowledge condition.
003177  003763        
003178  003764  func I2C2_Nack(), 0;
003179  003765  // Syntax: I2C2_Nack();
003180  003766  // Usage : I2C2_Nack();
003181  003767  // Notes : generates the negative acknowledge condition.
003182  003768        
003183  003769  func I2C3_Nack(), 0;
003184  003770  // Syntax: I2C3_Nack();
003185  003771  // Usage : I2C3_Nack();
003186  003772  // Notes : generates the negative acknowledge condition.
003187  003773        
003188  003774  func I2C2_AckStatus(), 1;
003189  003775  // Syntax: I2C2_AckStatus();
003190  003776  // Usage : r := I2C2_AckStatus();
003191  003777  // Notes : returns the ACK status from the device.
003192  003778        
003193  003779  func I2C3_AckStatus(), 1;
003194  003780  // Syntax: I2C3_AckStatus();
003195  003781  // Usage : r := I2C3_AckStatus();
003196  003782  // Notes : returns the ACK status from the device.
003197  003783        
003198  003784  func I2C2_AckPoll("control"), 1;
003199  003785  // Syntax: I2C2_AckPoll();
003200  003786  // Usage : r := I2C2_AckPoll(0xA0);
003201  003787  // Notes : waits for a device to return from ACK polling.
003202  003788        
003203  003789  func I2C3_AckPoll("control"), 1;
003204  003790  // Syntax: I2C3_AckPoll();
003205  003791  // Usage : r := I2C3_AckPoll(0xA0);
003206  003792  // Notes : waits for a device to return from ACK polling.
003207  003793        
003208  003794  func I2C2_Idle(), 1;
003209  003795  // Syntax : I2C2_Idle();
003210  003796  // Usage  : r := I2C2_Idle();
003211  003797  // Notes  : waits until the I2C Bus is Inactive.
003212  003798  //        : Times out if bus not idle within 1 second
003213  003799  // Returns: TRUE if successful, else failed (timed out)
003214  003800        
003215  003801  func I2C3_Idle(), 1;
003216  003802  // Syntax : I2C3_Idle();
003217  003803  // Usage  : r := I2C3_Idle();
003218  003804  // Notes  : waits until the I2C Bus is Inactive.
003219  003805  //        : Times out if bus not idle within 1 second
003220  003806  // Returns: TRUE if successful, else failed (timed out)
003221  003807        
003222  003808  func I2C2_Gets("buffer", "size"), 1;
003223  003809  // Syntax: I2C2_Gets("buffer", "size");
003224  003810  // Usage : r := I2C2_Gets(mybuf, 16);
003225  003811  // Notes : only reads up to "size" characters into "buffer"
003226  003812  //       : Reads up to asciiz terminator including terminator
003227  003813        
003228  003814  func I2C3_Gets("buffer", "size"), 1;
003229  003815  // Syntax: I2C3_Gets("buffer", "size");
003230  003816  // Usage : r := I2C3_Gets(mybuf, 16);
003231  003817  // Notes : only reads up to "size" characters into "buffer"
003232  003818  //       : Reads up to asciiz terminator including terminator
003233  003819        
003234  003820  func I2C2_Getn("buffer", "size"), 1;
003235  003821  // Syntax: I2C2_Gets("buffer", "size");
003236  003822  // Usage : r := I2C2_Gets(mybuf, 16);
003237  003823  // Notes : reads "size" bytes into "buffer"
003238  003824  //       :
003239  003825        
003240  003826  func I2C3_Getn("buffer", "size"), 1;
003241  003827  // Syntax: I2C3_Gets("buffer", "size");
003242  003828  // Usage : r := I2C3_Gets(mybuf, 16);
003243  003829  // Notes : reads "size" bytes into "buffer"
003244  003830  //       :
003245  003831        
003246  003832  func I2C2_Puts("buffer"), 1;
003247  003833  // Syntax: I2C2_Puts("buffer");
003248  003834  // Usage : r := I2C2_Puts(mybuf);
003249  003835  // Notes : writes an asciiz string to the I2C device
003250  003836  //       : returns count of characters written
003251  003837        
003252  003838  func I2C3_Puts("buffer"), 1;
003253  003839  // Syntax: I2C3_Puts("buffer");
003254  003840  // Usage : r := I2C3_Puts(mybuf);
003255  003841  // Notes : writes an asciiz string to the I2C device
003256  003842  //       : returns count of characters written
003257  003843        
003258  003844  func I2C2_Putn("buffer", "count"), 1;
003259  003845  // Syntax: I2C2_Putn("buffer","count");
003260  003846  // Usage : r := I2C2_Puts(mybuf,10);
003261  003847  // Notes : writes up to "size" bytes to the I2C device
003262  003848  //       : returns number of bytes written
003263  003849        
003264  003850  func I2C3_Putn("buffer", "count"), 1;
003265  003851  // Syntax: I2C3_Putn("buffer","count");
003266  003852  // Usage : r := I2C3_Puts(mybuf,10);
003267  003853  // Notes : writes up to "size" bytes to the I2C device
003268  003854  //       : returns number of bytes written
003269  003855        
003270  003856  func gfx_XYrotToVal("x","y","base","mina","maxa","minv","maxv"), 1;         // convert a rotational x/y postion to a value
003271  003857  // Usage	: gfx_XYrotToVal(x,y,XYROT_EAST,starta,enda,minv,maxv)
003272  003858  // Notes	: Convert a rotational angle into a value
003273  003859  // 	: Calculates a position for a rotary input starting at mina and continuing to maxa. both angles must be greater than 0.
003274  003860  // 	: Base can be XYROT_EAST, used for internal widgets, or XYROT_SOUTH, used for GCI widgets.
003275  003861  // 	: Returns a value from minv to maxv
003276  003862        
003277  003863  func gfx_XYlinToVal("x","y","base","minpos","maxpos","minv","maxv"), 1;         // convert a linear x/y postion to a value
003278  003864  // Usage	: gfx_XYrotToVal(x,y,XYLIN_X,startp,endp,minv,maxv)
003279  003865  // Notes	: Convert a linear position into a value
003280  003866  // 	: Calculates a position for a linear input starting at minpos and continuing to maxpos. 
003281  003867  // 	: Base can be XYLIN_X, to use the x value for calculations, or XYLIN_Y, to use the y value.
003282  003868  // 	: Returns a value from minv to maxv
003283  003869        
003284  003870  func media_InitSpeed("Speed"), 1;                     // initialize uSD card at a given speed
003285  003871  // Usage	: media_Init(SPI_SPEED15);
003286  003872  // Notes	: Initialise uSD CARD at a specified speed
003287  003873  // 	: Response: 0 = No Card
003288  003874  // 	:           1 = Card Initialised
003289  003875  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003290  003876        
003291  003877  func file_MountSpeed("Speed"), 1;                     // mount a uSD card at a given speed
003292  003878  // Syntax	: r := file_Mount(SPI_SPEED15);
003293  003879  // Usage	: r := file_Mount(SPI_SPEED15);
003294  003880  // Notes	: Create a control block for FAT16 and mount the File System at the specified speed
003295  003881  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003296  003882        
003297  003883  func img_FileRead("*dest", "size", "handle", "index"), 1;
003298  003884  // Syntax: res := img_FileRead("*dest", "size", "handle", "index"),
003299  003885  // Usage : res := img_FileRead(memblock,20,hnd1);
003300  003886  // Notes : returns number of characters read
003301  003887  //       : if "dest" is zero, data is read direct to GRAM window
003302  003888  //       :
003303  003889        
003304  003890  func img_FileSeek("handle", "index", "HiWord", "LoWord"), 1;
003305  003891  // Syntax: res := img_FileSeek("handle", "index", "HiWord", "LoWord")
003306  003892  // Usage : res := img_FileSeek(hSource, 0, 0x1234);
003307  003893  // Notes : set file position to 0x00001234 (byte position 4660)
003308  003894  //       : for the file handle so subsequent data may be read
003309  003895  //       : from that position onwards with img_FileGetC(...),
003310  003896  //       : img_FileGetW(...) or img_FileGetS(...)
003311  003897  // Notes : returns true if ok, usually ignored
003312  003898        
003313  003899  func img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003314  003900  // Syntax: img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003315  003901  // Usage : res := img_FileIndex(hsource, 0, 1000, 123), 1;
003316  003902  // Notes : set file seek position to 123000
003317  003903  //       : for the file handle so subsequent data may be read
003318  003904  //       : from that record position onwards with img_FileGetC(...),
003319  003905  //       : img_FileGetW(...) or img_FileGetS(...)
003320  003906  // Notes : returns true if ok, usually ignored
003321  003907        
003322  003908  func img_FileTell("handle", "index", "&HiWord", "&LoWord"), 1;
003323  003909  // Syntax: img_FileTell("handle", "index", &HiWord, &LoWord);
003324  003910  // Usage : img_FileTell(fhndl, &SizeHi, &SizeLo);
003325  003911  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003326  003912  //       : returns true if function succeeded
003327  003913        
003328  003914  func img_FileSize("handle", "index", "&HiWord", "&LoWord"), 1;
003329  003915  // Syntax: img_FileSize("handle", "index", &HiWord, &LoWord);
003330  003916  // Usage : img_FileSize(fhndl, &SizeHi, &SizeLo);
003331  003917  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003332  003918  //       : returns true if function succeeded
003333  003919        
003334  003920  func img_FileGetC("handle", "index"), 1;
003335  003921  // Syntax: img_FileGetC("handle", "index");
003336  003922  // Usage : mychar := fgetC("handle", "index");
003337  003923  // Notes : returns next char from file
003338  003924        
003339  003925  func img_FileGetW("handle", "index"), 1;
003340  003926  // Syntax: img_FileGetW("handle", "index");
003341  003927  // Usage : myword := fgetW("handle", "index");
003342  003928  // Notes : returns next word in file
003343  003929        
003344  003930  func img_FileGetS("*string", "size", "handle", "index"), 1;
003345  003931  // Syntax: res := img_FileGets("*string", "size", "handle", "index");
003346  003932  // Usage : res := img_FileGets(mystr , 81, hnd1); // read up to 80 chars
003347  003933  // Notes : get a string from a file
003348  003934  //       : returns pointer to string or null if failed.
003349  003935  //       : img_FileGetS(...) automatically appends a null-terminator to the data read.
003350  003936  //       : NB:- only reads up to "size-1" characters into "string"
003351  003937  //       : img_FileGetS(...) will stop reading when any of the following conditions are true:
003352  003938  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003353  003939  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003354  003940  //       : C] It reaches the end of file
003355  003941  //       : D] A read error occurs.
003356  003942        
003357  003943  func img_FileRewind("handle", "index"), 1;
003358  003944  // Syntax: res := img_FileRewind("handle", "index");
003359  003945  // Usage : res := img_FileRewind(hnd1);
003360  003946  // Notes : returns true if file rewound ok (usually ignored)
003361  003947  //       : resets the file pointer the the beginning of the open file.
003362  003948        
003363  003949  func img_FileLoadFunction("handle", "index"), 1;
003364  003950  // Syntax: res := img_FileLoadFunction("handle", "index");
003365  003951  // Usage : myfunc := img_FileLoadFunction("handle", "index");
003366  003952  // Notes : Load a function or program from disk and
003367  003953  //       : return a function pointer to the allocation.
003368  003954  //       : The function can then be invoked just like any other
003369  003955  //       : function would be called via a function pointer.
003370  003956  //       : Parameters may be passed to it in a conventional way.
003371  003957  //       : The function may be discarded at any time when no
003372  003958  //       : longer required, thus freeing its memory resources.
003373  003959  //       : The loaded function can be discarded with mem_Free(..)
003374  003960  //       : eg:
003375  003961  //       : popupWindow := img_FileLoadFunction("handle", "index");
003376  003962  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003377  003963  //       : then elsewhere in your program:-
003378  003964  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003379  003965  //       : if(res == QUIT_APPLICATION) goto exitApp;
003380  003966  //       : Later in your program, when popupWindow is no longer
003381  003967  //       : required for the application:-
003382  003968  //       : res := mem_Free(popupWindow);
003383  003969  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003384  003970  //       : The callers stack is shared by the loaded function,
003385  003971  //       : however any global variables in the loaded function
003386  003972  //       : are private to that function.
003387  003973  //
003388  003974        
003389  003975  func img_FileRun("handle", "index", "arglistptr"), 1;
003390  003976  // Syntax: res := img_FileRun("handle", "index","arglistptr");
003391  003977  // Usage : res := img_FileRun("handle", "index", argptr);
003392  003978  // Notes : current program releases any allocated memory but
003393  003979  //       : retains the stack and global memory.
003394  003980  //       : If arglistptr is 0, no arguments are passed, else
003395  003981  //       : arglist points to an array, the first element being
003396  003982  //       : the number of elements in the array.
003397  003983  //       : func 'main' in the called program accepts
003398  003984  //       : the arguments, if any. THe arguments can only
003399  003985  //       : be passed by value, no pointers or references can be
003400  003986  //       : used as all memory is cleared before the file
003401  003987  //       : is loaded. Refer to img_FileExec and img_FileLoadFunction
003402  003988  //       : for functions that can pass by reference.
003403  003989        
003404  003990  func img_FileExec("handle", "index", "arglistptr"), 1;
003405  003991  // Syntax: res := img_FileExec("handle", "index","arglistptr");
003406  003992  // Usage : res := img_FileExec("handle", "index","arglistptr");
003407  003993  // Notes : returns like a function, current program
003408  003994  //       : calling program is kept active and control returns to it.
003409  003995  //       : If arglistptr is 0, no arguments are passed, else
003410  003996  //       : arglist points to an array, the first element being
003411  003997  //       : the number of elements in the array.
003412  003998  //       : func 'main' in the called program accepts the arguments.
003413  003999  //       : This function is similar to img_FileLoadFunction(...), however,
003414  004000  //       : the function argument list is passed by pointer, and
003415  004001  //       : the memory consumed by the function is released as
003416  004002  //       : soon as the function completes.
003417  004003        
003418  004004  func img_FilePlayWAV("handle", "index"), 1;
003419  004005  // Syntax: img_FilePlayWAV("handle", "index");
003420  004006  // Usage : img_FilePlayWAV("handle", "index");
003421  004007  // Notes : Play a wave file at index "index" in the filesystem "handle"
003422  004008  //       : This function automatically grabs a chunk
003423  004009  //       : of memory for a file buffer, and a wave
003424  004010  //       : buffer. The minimum memory requirement is
003425  004011  //       : about 580 bytes for the disk io service and
003426  004012  //       : a minimum wave buffer size of 1024. The siz
003427  004013  //       : of the wave buffer allocation
003428  004014  //       : can be increased by the snd_BufSize function.
003429  004015  //       : The default size 1024 bytes.
003430  004016  //       : NB the memory is only required during the
003431  004017  //       : duration of play, and is automatically
003432  004018  //       : released while not in use.
003433  004019  //       : See the Sound Class services for other associated controls.
003434  004020  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003435  004021  //       : If errors occured, the folling is returned
003436  004022  //       : -7  : Insufficient memory available for WAV buffer and file
003437  004023  //       : -6  : cant play this rate
003438  004024  //       : -5  : no data chunk found in first rsector
003439  004025  //       : -4  : no format data
003440  004026  //       : -3  : no wave chunk signature
003441  004027  //       : -2  : bad wave file format
003442  004028  //       : -1  : file not found
003443  004029        
003444  004030  func img_TxtFontID("handle", "index"), 1;                   // 2  text font ID (0 = system font)
003445  004031  // Syntax: img_TxtFontID("handle", "index");
003446  004032  // Usage : img_TxtFontID("handle", "index");
003447  004033  // Notes : Set the font to a font held in the image file system
003448  004034        
003449  004035  func img_FileCheckUpdate("handle", "index", "Options"), 1;                           // check and/or update the program running in Flash
003450  004036  // Syntax 	: img_FileCheckUpdate("handle", "index", "Options") ;
003451  004037  // Usage 	: img_FileCheckUpdate("handle", "index", CheckUpdate_Check) ;
003452  004038  // Notes 	: Check and/or update the program running in flash using the specified file in Flash memory.
003453  004039  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003454  004040  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003455  004041  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003456  004042  //
003457  004043  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003458  004044  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003459  004045  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003460  004046  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003461  004047  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003462  004048  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003463  004049        
003464  004050  func flash_Block32Erase(), 1;            // erase the required 32k flash block
003465  004051  // Syntax	: flash_Block32Erase();
003466  004052  // Usage	: flash_Block32Erase();
003467  004053  // Notes	: Erase the 32KB flash block including the currently set address
003468  004054  // 	: This uses the 0x52 command.
003469  004055        
003470  004056  func flash_Sector4Erase(), 1;            // erase the required 4k flash sector
003471  004057  // Syntax: flash_Sector4Erase();
003472  004058  // Usage : flash_Sector4Erase();
003473  004059  // Notes	: Erase the 4KB flash sector including the currently set address
003474  004060  // 	: This uses the 0x20 command.
003475  004061        
003476  004062  func com_Mode("8" ,"N", "1", "comport"), 1 ;
003477  004063  // Syntax	: comx_Mode("databits", "parity", "Stopbits", "comport");
003478  004064  // Usage	: comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
003479  004065  // *Notes	: Data Bits must be 8
003480  004066  // 	: Parity may be 'N', 'O' or 'E'.
003481  004067  // 	: Stop Bits may be 1 or 2.
003482  004068  // 	: returns true if mode was acceptable
003483  004069        
003484  004070  func img_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in a Flash GCI
003485  004071  // Syntax: img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003486  004072  // Usage : img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003487  004073  // Notes	: Load and call the Function found at index "idx" in the Flash GCI identified by "Hndl". 
003488  004074  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003489  004075  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003490  004076  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003491  004077  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003492  004078  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003493  004079  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003494  004080  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003495  004081  // 	: Returns 0 if successful.
003496  004082        
003497  004083  func img_FunctionFreeCache("handle"), 0 ;                                 // Free all cached Flash GCI Functions 
003498  004084  // Syntax: img_FunctionFreeCache(hndl);
003499  004085  // Usage : img_FunctionFreeCache(hndl);
003500  004086  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003501  004087  // 	: Flash GCI.
003502  004088        
003503  004089  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
003504  004090  // *Notes   : (if you calculate all of the incoming data
003505  004091  //          : INCLUDING the CRC, the result should be 0x00
003506  004092  //          : This is equivalent to simple addition of all bytes
003507  004093  //          : and returning the negated sum an 8 bit value.
003508  004094  //          : For the standard test string "123456789",
003509  004095  //          : crc_CSUM_8 will return 0x0023.
003510  004096        
003511  004097  func gfx_GradientShape("GradientRAM", "HorzVert", "OuterWidth", "X", "Y", "W", "H", "TLrad", "TRrad", "BLrad", "BRrad", "Darken", "OuterColor", "OuterType", "OuterLevel", "InnerColor", "InnerType", "InnerLevel", "Split"), 0 ;
003512  004098  // Syntax 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003513  004099  // Usage 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003514  004100  // Notes 	: Produce a shaped color gradient using the supplied parameters.0
003515  004101  // 	: GradientRAM	This Function requires a quantity or RAM to work. It also needs to be initialised and it's size varies accoring to the largest corner radius. Multiple gradient shape calls can
003516  004102  // 	: 	share the same GradientRAM. eg gradientRAM[29+91*2] := [-1,-1,-9999,0,0,91] ;  Would support a maximum radius of 90 degrees, note the 91 in two places.
003517  004103  // 	: HorzVert	Horizontal or Vertical -- 0 or 1
003518  004104  // 	: OuterWidth	Outer gradient width 0 to ...
003519  004105  // 	: X	x co-ordinate
003520  004106  // 	: Y	y co-ordinate
003521  004107  // 	: W	width
003522  004108  // 	: H	height
003523  004109  // 	: LTrad	Top left corner radius
003524  004110  // 	: TRrad	Top right corner radius
003525  004111  // 	: BLrad	Bottom left radius
003526  004112  // 	: BRrad	Bottom right radius
003527  004113  // 	: Darken	Darken both colours by a value. Can be a -ve value to lighten
003528  004114  // 	: OuterCol	Outer Gradient colour
003529  004115  // 	: OuterType	Outer Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003530  004116  // 	: OuterLevel	Outer Gradient level 0 - 63
003531  004117  // 	: InnerCol	Inner Gradient colour
003532  004118  // 	: InnerType	Inner Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003533  004119  // 	: InnerLevel	Inner Gradient level 0 - 63
003534  004120  // 	: Split	Split gradient, 0 - no split, 1 - top, 2 - bottom 
003535  004121  // 
003536  004122  // Returns	: nothing
003537  004123        
003538  004124        
003539  004125  func gfx_GradientColor("Type", "Darken", "Level", "H", "Pos", "Color"), 1 ;
003540  004126  // Syntax 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003541  004127  // Usage 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003542  004128  // Notes 	: Given the parameters, adjust the input color to produce the output color.
003543  004129  // 	: Type	Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003544  004130  // 	: Darken	Darken colour by a value. Can be a -ve value to lighten
003545  004131  // 	: Level	Gradient level 0 - 63
003546  004132  // 	: H	Height of the object that gradient is applied
003547  004133  // 	: Pos	Position in the height that gradient is calculated
003548  004134  // 	: Color	Source colour that gradient is applied to
003549  004135  // 
003550  004136  // Returns	: Color after Adjustment.
003551  004137        
003552  004138  func gfx_GradTriangleFilled("X0", "Y0", "X1", "Y1", "X2", "Y2", "SolidCol", "GradientCol", "GradientHeight", "GradientY", "GradientLevel", "Type"), 0;
003553  004139  // Syntax 	: gfx_GradTriangleFilled(X0, Y0, X1, Y1, X2, Y2, SolidCol, GradientCol, GradientHeight, GradientY, GradientLevel, Type);
003554  004140  // Usage 	: gfx_GradTriangleFilled(10, 10, 10, 100, 100, 100 ,YELLOW, DARKKHAKI, 100, 10, 30, 1);
003555  004141  // Notes 	: Produce a triangle with or without a gradient.
003556  004142  // 	: X0	First triangle point x coordinate
003557  004143  // 	: Y0	First triangle point y coordinate
003558  004144  // 	: X1	Second triangle point x coordinate
003559  004145  // 	: Y1	Second triangle point y coordinate
003560  004146  // 	: X2	Third triangle point x coordinate
003561  004147  // 	: Y2	Third triangle point y coordinate
003562  004148  // 	: SolidCol	Colour that will be used if the Solid or Gradient parameter is set to 0
003563  004149  // 	: GradientCol	Colour that will be used if the Solid or Gradient parameter is set to 1
003564  004150  // 	: GradientHeight	Height of the area that the gradient will be calculated. Can be larger than the triangle
003565  004151  // 	: GradientY	Position on the Y axis that the gradient will be calculated from with respect to triangle position
003566  004152  // 	: GradientLevel	Level of gradient applied
003567  004153  // 	: Type	Select wether solid triangle or gardient triangle is drawn. 
003568  004154        
003569  004155  func media_InitFlash("Command"), 1;                    // initialize Flash Memory
003570  004156  // Usage	: media_InitFlash();
003571  004157  // Notes	: Initialise Flash Memory 
003572  004158  // 	: Response: 0 = Normally ignored, but should be 0
003573  004159  // 	:           1 = a uSD Card has been Initialised, you should not use this command for uSD cards
003574  004160  // 	: Note that for systems with SPI Flash the response will be 0, however, this function needs to be called to 
003575  004161  // 	: init the Flash memory chip.
003576  004162  // 	: Command	The command used to set the flash memory into 4 byte addressing mode
003577  004163  // 	: FLASH_ADDR_DEF_COMMAND	The default command will be used (0xB7)
003578  004164  // 	: FLASH_ADDR_ALWAYS_4BYTE	No command will be sent (for chips permantly in 4 byte mode)
003579  004165  // 	: else this command will be sent to enter 4 Byte Addressing mode, if the capacity of the chip appears to
003580  004166  // 	: be greater than 16MB. Requires the JEDEC approved response to the 'FLASH READ ID' (0x9F) command.
003581  004167        
003582  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003583  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003584  004169        
003585  004170  func file_RunSpeed("Speed", "fname.4xe", "arglistptr"), 1;
003586  004171  // Syntax	: res := file_Run(SPI_SPEED15, "fname.4xe","arglistptr");
003587  004172  // Usage	: res := file_Run(SPI_SPEED15, fname, argptr);
003588  004173  // Notes	: current program releases any allocated memory but
003589  004174  // 	: retains the stack and global memory.
003590  004175  // 	: If arglistptr is 0, no arguments are passed, else
003591  004176  // 	: arglist points to an array, the first element being
003592  004177  // 	: the number of elements in the array.
003593  004178  // 	: func 'main' in the called program accepts
003594  004179  // 	: the arguments, if any. The arguments can only
003595  004180  // 	: be passed by value, no pointers or references can be
003596  004181  // 	: used as all memory is cleared before the file
003597  004182  // 	: is loaded. Refer to file_Exec and file_LoadFunction
003598  004183  // 	: for functions that can pass by reference.
003599  004184  // 	: Speed specifies the File System is mounted at the specified speed
003600  004185  // 	: can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003601  004186        
003602  004187  func I2CS_Open("Addr", "RdBuf", "RdBufSize", "WrBuf", "WrBufSize", "WaitOption"), 0;  // Open I2C Slave
003603  004188  // Usage	: I2CS_Open(Addr, RdBuf, RdBufS, WrBuf, WrBufs, 0xaa);
003604  004189  // Notes	: Initialize and open the I2C Slave 
003605  004190  // 	: The slave ACKs any transmissions from the master until the read buffer fills
003606  004191  // 	: The slave NAKs any receives by the master until the write buffer is released, or is empty
003607  004192  // 	: Addr	The I2C Address for this Slave
003608  004193  // 	: RdBuf	The buffer for receiving 'commands' from the master
003609  004194  // 	: RdBufSize	The size of the receive buffer 
003610  004195  // 	: WrBuf	The buffer for sending 'responses' to the master
003611  004196  // 	: WrBufSize	The size of the write buffer
003612  004197  // 	: WaitOption	The character to send when no data is available, or all sent, or with I2C_CLOCK_STRETCHING to use clock stretching 
003613  004198  // 	: Response: None
003614  004199        
003615  004200  func I2CS_Close(), 0;          // Close I2C Slave
003616  004201  // Usage	: I2CS_Close();
003617  004202  // Notes	: Closes the I2C Slave 
003618  004203  // 	: Response: None
003619  004204        
003620  004205  func I2CS_Write("Byte"), 0;      // Write byte to output buffer
003621  004206  // Usage	: I2CS_Write("Byte");
003622  004207  // Notes	: Writes a byte to the I2C Slave Write Buffer
003623  004208  // 	: When everything to be written to the Master is in the write buffer, the buffer should be released
003624  004209  // 	: with I2CS_Release()
003625  004210  // 	: Response: None
003626  004211        
003627  004212  func I2CS_Count(), 1;          // Count of bytes in input buffer
003628  004213  // Usage	: I2CS_Count();
003629  004214  // Notes	: Retrieve the number of bytes available in the I2C Slave's read buffer
003630  004215  // 	: Response: Number of bytes in the buffer
003631  004216        
003632  004217  func I2CS_Read(), 1;           // Read byte from Read Buffer
003633  004218  // Usage	: I2CS_Read();
003634  004219  // Notes	: Read a byte from the I2C Slave's read buffer
003635  004220  // 	: Response: byte read from buffer
003636  004221        
003637  004222  func I2CS_Release(), 0;        // Release output buffer to enable Master to read
003638  004223  // Usage	: I2CS_Release();
003639  004224  // Notes	: Release an accumulated I2C Slave write buffer for sending to the master
003640  004225  // 	: Response: None
003641  004226        
003642  004227  func I2CS_Overflow(), 1;        // Check for any overflow in the read or write processes
003643  004228  // Usage	: I2CS_Overflow();
003644  004229  // Notes	: Check for any overflow in the read or write processes, the error is automatically
003645  004230  // 	: Reset at the start of the next I2CS_Write() or the last I2CS_Read() for the current buffer.
003646  004231  // 	: Response: Overflow flags
003647  004232  // 	: 0x01 : The host has sent more data than the I2CS_Read() buffer can hold
003648  004233  // 	: 0x02 : The host has read all the data the I2CS_Write() buffer contained
003649  004234  // 	: 0x04 : The host has read more data than the I2CS_Write() buffer contained
003650  004235        
003651  004236  func com_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003652  004237  // Usage	: com_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003653  004238  // Usage	: com_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003654  004239  // Notes	: initialize a serial buffer for the COM0 output.
003655  004240  // 	: The program must declare a var array as a circular buffer.
003656  004241  // 	: When a TX buffer is declared for comms, the transmission
003657  004242  // 	: of characters becomes non blocking. If the buffer has
003658  004243  // 	: insufficient space to accept the next character from a
003659  004244  // 	: serout_x() function, the excess characters will be ignored,
003660  004245  // 	: and the com_Full_x() error will be asserted.   If the
003661  004246  // 	: TX buffer is no longer required, just set the buffer pointer
003662  004247  // 	: to zero, the size in this case doesnt matter and is ignored.
003663  004248  // 	: The function can resize or reallocated to another buffer at
003664  004249  // 	: any time. The buffer is flushed before any changes are made.
003665  004250  // 	: "pin" designates an IO pin to control a bi-directional
003666  004251  // 	: control device for half duplex mode. "pin" will go HI at the
003667  004252  // 	: start of a transmission, and will return low after the final
003668  004253  // 	: byte is transmitted. If not required, just set "pin" to zero.
003669  004254        
003670  004255  func com_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003671  004256  // Syntax	: com_InitBrk(buffer, bufsize, qualifier);
003672  004257  // Usage1	: com_InitBrk(mybuf, 20, 0);
003673  004258  // Usage2	: com_InitBrk(mybuf, 20, ':');
003674  004259  // Notes	: initialize a serial capture buffer for the comms input
003675  004260  // 	: The program must declare a var array as a circular buffer.
003676  004261  // 	: Usage1 declares a circular buffer which will continually
003677  004262  // 	: buffer characters.
003678  004263  // 	: Usage2 must receive ':' before any characters will
003679  004264  // 	: accumulate in the buffer.
003680  004265        
003681  004266  //------------------------------------------------------------------//
003682  004267  //     break control constant                                       //
003683  004268  //------------------------------------------------------------------//
003684  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003685  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003686  004270        
003687  004271  func disp_Refresh(), 0;  // Refresh an ePaper display
003688  004272  // Syntax	: disp_Refresh();
003689  004273  // Usage	: disp_Refresh();
003690  004274  // Notes	: This command is only applicable to ePaper displays.
003691  004275  // 	: Refresh an ePaper display
003692  004276  // 	: After updating the RAM in an ePaper display thuis commmand is used
003693  004277  // 	: to place the contents of the RAM onto the ePaper.
003694  004278        
003695  004279  func disp_Busy(), 1;  // Check the busy status of an ePaper display
003696  004280  // Syntax	: disp_Busy();
003697  004281  // Usage	: disp_Busy();
003698  004282  // Notes	: This command is only applicable to ePaper displays.
003699  004283  // 	: Return the busy status of an ePaper display
003700  004284  // 
003701  004285  // Returns	: 1 if the display is busy, 0 otherwise
003702  004286        
003703  004287  //=========================================================================================================
003704  004288  // Internal FLASH memory functions
003705  004289  //=========================================================================================================
003706  004290  func intflash_GetByte("ptr"), 1;
003707  004291  // Syntax   : intflash_GetByte(ptr);
003708  004292  // Usage    : myvar := intflash_GetByte(1); // read the first byte from internal flash
003709  004293  // Notes    : Reads a single byte from internal flash.
003710  004294  // Returns  : the byte value from the location
003711  004295        
003712  004296        
003713  004297  func intflash_GetWord("ptr"), 1;
003714  004298  // Syntax   : intflash_GetWord(ptr);
003715  004299  // Usage    : myvar := intflash_GetWord(0x0000); // read first word from internal flash
003716  004300  // Notes    : Reads a single word from any internal flash location.
003717  004301  //          : The pointer is byte aligned.
003718  004302  // Returns  : the byte value from the location
003719  004303        
003720  004304        
003721  004305  func intflash_Copy("ptr", "dest", "count"), 1;
003722  004306  // Syntax   : intflash_Copy(ptr, dest, count);
003723  004307  // Usage    : myvar := intflash_Copy(0x123, mybuf, 20); // read 20 bytes from internal flash starting from 0x123
003724  004308  // Notes    : Copies bytes from any internal flash locations to a user buffer.
003725  004309  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
003726  004310  // Returns  : the count of bytes transferred.
003727  004311        
003728  004312  func intflash_WriteBlock("sourceptr", "Size"), 1;
003729  004313  // Syntax   : intflash_WriteBlock(pbuf);
003730  004314  // Usage    : result := intflash_WriteBlock(buffer); // store the 2k buffer 
003731  004315  // Notes    : Copies a buffer to NVM. Size bytes are written. A maximum of 2048 bytes can be written.
003732  004316  // Returns  : returns true if the function succeeded.
003733  004317        
003734  004318  func intflash_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in internal flash
003735  004319  // Syntax: intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003736  004320  // Usage : intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003737  004321  // Notes	: Load and call the Function found at index "idx" in the internal flash widget identified by "Hndl". 
003738  004322  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003739  004323  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003740  004324  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003741  004325  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003742  004326  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003743  004327  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003744  004328  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003745  004329  // 	: Returns 0 if successful.
003746  004330        
003747  004331  func intflash_FunctionFreeCache("handle"), 0 ;                                 // Free all cached internal Flash Functions 
003748  004332  // Syntax: img_FunctionFreeCache(hndl);
003749  004333  // Usage : img_FunctionFreeCache(hndl);
003750  004334  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003751  004335  // 	: widget handle.
003752  004336        
003753  004337  func com1_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003754  004338  // Usage	: com1_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003755  004339  // Usage	: com1_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003756  004340  // Notes	: initialize a serial buffer for the COM1 output.
003757  004341  // 	: The program must declare a var array as a circular buffer.
003758  004342  // 	: When a TX buffer is declared for comms, the transmission
003759  004343  // 	: of characters becomes non blocking. If the buffer has
003760  004344  // 	: insufficient space to accept the next character from a
003761  004345  // 	: serout_x() function, the excess characters will be ignored,
003762  004346  // 	: and the com_Full_x() error will be asserted.   If the
003763  004347  // 	: TX buffer is no longer required, just set the buffer pointer
003764  004348  // 	: to zero, the size in this case doesnt matter and is ignored.
003765  004349  // 	: The function can resize or reallocated to another buffer at
003766  004350  // 	: any time. The buffer is flushed before any changes are made.
003767  004351  // 	: "pin" designates an IO pin to control a bi-directional
003768  004352  // 	: control device for half duplex mode. "pin" will go HI at the
003769  004353  // 	: start of a transmission, and will return low after the final
003770  004354  // 	: byte is transmitted. If not required, just set "pin" to zero.
003771  004355        
003772  004356  func com1_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003773  004357  // Syntax	: com1_InitBrk(buffer, bufsize, qualifier);
003774  004358  // Usage1	: com1_InitBrk(mybuf, 20, 0);
003775  004359  // Usage2	: com1_InitBrk(mybuf, 20, ':');
003776  004360  // Notes	: initialize a serial capture buffer for the comms input
003777  004361  // 	: The program must declare a var array as a circular buffer.
003778  004362  // 	: Usage1 declares a circular buffer which will continually
003779  004363  // 	: buffer characters.
003780  004364  // 	: Usage2 must receive ':' before any characters will
003781  004365  // 	: accumulate in the buffer.
003782  004366        
003783  004367  //------------------------------------------------------------------//
003784  004368  // CONSTANTS
003785  004369  //------------------------------------------------------------------//
003786  004370        
003787  004371  #CONST
003788  004500  #END
003789  004501        
003790  004502  // generic constants
003791  004503  #CONST
003792  004514  #END
003793  004515        
003794  004516  // other constants
003795  004517  #CONST
003796  004520  #END
003797  004521        
003798  004522  //------------------------------------------------------------------------------
003799  004523  // Pin related constants
003800  004524  //------------------------------------------------------------------------------
003801  004525  #CONST
003802  004547  #END
003803  004548        
003804  004549  //------------------------------------------------------------------------------
003805  004550  //gfx_Set() related constants
003806  004551  //------------------------------------------------------------------------------
003807  004552  #CONST
003808  004569  #END
003809  004570        
003810  004571        
003811  004572  //gfx_Get() related constants
003812  004573  #CONST
003813  004582  #END
003814  004583        
003815  004584        
003816  004585        
003817  004586        
003818  004587  #CONST
003819  004600  #END
003820  004601        
003821  004602        
003822  004603  #CONST
003823  004625  #END
003824  004626        
003825  004627  //------------------------------------------------------------------------------
003826  004628  //txt_Set() related constants
003827  004629  //------------------------------------------------------------------------------
003828  004630  #CONST
003829  004649  #END
003830  004650        
003831  004651        
003832  004652        
003833  004653  //------------------------------------------------------------------------------
003834  004654  //txt_Set() related arguments
003835  004655  // NB:- FONT4 must be inherited if required,
003836  004656  // eg #inherit "FONT4.fnt"
003837  004657  //------------------------------------------------------------------------------
003838  004658  #CONST
003839  004670  #END
003840  004671        
003841  004672        
003842  004673        
003843  004674  //touch_Set() related constants
003844  004675  #CONST
003845  004679  #END
003846  004680        
003847  004681  //touch_Get() related constants
003848  004682  #CONST
003849  004690  #END
003850  004691        
003851  004692  // image control offset related constants
003852  004693  #CONST
003853  004700  #END
003854  004701        
003855  004702  // image attribute flags
003856  004703  // for img_SetAttributes(...) and img_ClearAttributes(...)
003857  004704  #CONST
003858  004718  #END
003859  004719        
003860  004720        
003861  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003862  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003863  004722        
003864  004723  // image control entry offsets
003865  004724  #CONST
003866  004739  #END
003867  004740        
003868  004741  #CONST
003869  004759  #END
003870  004760        
003871  004761        
003872  004762        
003873  004763        
003874  004764  #CONST
003875  004784  #END
003876  004785        
003877  004786        
003878  004787        
003879  004788  // timer control  related constants
003880  004789  #CONST
003881  004798  #END
003882  004799        
003883  004800  // I2C timing related constants
003884  004801  #CONST
003885  004805  #END
003886  004806        
003887  004807        
003888  004808  // spi_Init(...)  mode arguments
003889  004809  #CONST
003890  004832  #END
003891  004833        
003892  004834  //------------------------------------------------------------------------------
003893  004835  // system WORD variables accesible with peekW and pokeW or pointer access
003894  004836  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
003895  004837  // can also be accessed with peekW and pokeW
003896  004838  //------------------------------------------------------------------------------
003897  004839        
003898  004840  #CONST
003899  004934  #END
003900  004935        
003901  004936  //------------------------------------------------------------------------------
003902  004937  // FILEIO Error Code Constants
003903  004938  //------------------------------------------------------------------------------
003904  004939  #CONST
003905  004965  #END
003906  004966        
003907  004967  //==================================================================================================
003908  004968        
003909  004969        
003910  004970        
003911  000013      #ENDIF
003912  000014        
003913  000015        
003914  000016  //===========================================================================================
003915  000017        
003916  000018        
003917  000002        
003918  000003  //#constant OLDCOMPILE
003919  000004        
003920  000005        
003921  000006        
003922  000007        
003923  000008        
003924  000009  // generated 2/19/2023 3:05:54 PM
003925  000010  // uSDRequired:- 1   InternalRequired:- 1   InherentsInProgFlash:- 0   GciFlashFS:- 1   InherentWidgets:- 0   InternalObjects:- 14   GciFlashFiles:- 1
003926  000011        
003927  000012        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

003928  000013  #inherit "4DGL_16bitColours.fnc"
003929  000013  #inherit "4DGL_16bitColours.fnc"
003930  000004  */
003931  000005        
003932  000006        
003933  000007        
003934  000008  #CONST
003935  000149  #END
003936  000150        
003937  000014        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

003938  000015  #inherit "VisualConst.inc"
003939  000015  #inherit "VisualConst.inc"
003940  000001  // Line Patterns
003941  000002  #constant  LPCOARSE    0xF0F0
003942  000002  #constant  LPCOARSE    0xF0F0
003943  000003  #constant  LPMEDIUM    0x3333
003944  000003  #constant  LPMEDIUM    0x3333
003945  000004  #constant  LPFINE      0xAAAA
003946  000004  #constant  LPFINE      0xAAAA
003947  000005  #constant  LPDASHDOT   0x03CF
003948  000005  #constant  LPDASHDOT   0x03CF
003949  000006  #constant  LPDASHDOTDOT 0x0333
003950  000006  #constant  LPDASHDOTDOT 0x0333
003951  000007  #constant  LPSOLID     0x0000
003952  000007  #constant  LPSOLID     0x0000
003953  000016        
003954  000017        
file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGaugeConst.inc

003955  000018  #inherit "SprinterGaugeConst.inc"
003956  000018  #inherit "SprinterGaugeConst.inc"
003957  000001  // File generated 2/19/2023 3:05:49 PM
003958  000002  // Warning! This is a generated file, any manual changes will be
003959  000003  // lost during the next generation.
003960  000004        
003961  000005  #constant  Strings2Count    1
003962  000005  #constant  Strings2Count    1
003963  000006  #constant  Strings2Size     17
003964  000006  #constant  Strings2Size     17
003965  000007  #constant  Strings0Count    1
003966  000007  #constant  Strings0Count    1
003967  000008  #constant  Strings0Size     13
003968  000008  #constant  Strings0Size     13
003969  000009  #constant  Strings4Count    1
003970  000009  #constant  Strings4Count    1
003971  000010  #constant  Strings4Size     4
003972  000010  #constant  Strings4Size     4
003973  000011  #constant  Strings5Count    1
003974  000011  #constant  Strings5Count    1
003975  000012  #constant  Strings5Size     6
003976  000012  #constant  Strings5Size     6
003977  000013  #constant  Strings7Count    1
003978  000013  #constant  Strings7Count    1
003979  000014  #constant  Strings7Size     13
003980  000014  #constant  Strings7Size     13
003981  000015  #constant  Strings9Count    1
003982  000015  #constant  Strings9Count    1
003983  000016  #constant  Strings9Size     5
003984  000016  #constant  Strings9Size     5
003985  000017  #constant  Strings10Count    1
003986  000017  #constant  Strings10Count    1
003987  000018  #constant  Strings10Size     7
003988  000018  #constant  Strings10Size     7
003989  000019  #constant  Strings11Count    1
003990  000019  #constant  Strings11Count    1
003991  000020  #constant  Strings11Size     15
003992  000020  #constant  Strings11Size     15
003993  000021  #constant  Strings12Count    1
003994  000021  #constant  Strings12Count    1
003995  000022  #constant  Strings12Size     13
003996  000022  #constant  Strings12Size     13
003997  000023  #constant  Strings15Count    1
003998  000023  #constant  Strings15Count    1
003999  000024  #constant  Strings15Size     13
004000  000024  #constant  Strings15Size     13
004001  000025  #constant  Strings16Count    1
004002  000025  #constant  Strings16Count    1
004003  000026  #constant  Strings16Size     13
004004  000026  #constant  Strings16Size     13
004005  000027  #constant  Strings18Count    1
004006  000027  #constant  Strings18Count    1
004007  000028  #constant  Strings18Size     6
004008  000028  #constant  Strings18Size     6
004009  000029  #constant  Strings19Count    1
004010  000029  #constant  Strings19Count    1
004011  000030  #constant  Strings19Size     6
004012  000030  #constant  Strings19Size     6
004013  000031  #constant  Strings20Count    1
004014  000031  #constant  Strings20Count    1
004015  000032  #constant  Strings20Size     5
004016  000032  #constant  Strings20Size     5
004017  000033  #constant  Strings21Count    1
004018  000033  #constant  Strings21Count    1
004019  000034  #constant  Strings21Size     3
004020  000034  #constant  Strings21Size     3
004021  000035  #constant  Strings22Count    1
004022  000035  #constant  Strings22Count    1
004023  000036  #constant  Strings22Size     13
004024  000036  #constant  Strings22Size     13
004025  000037  #constant  Strings23Count    1
004026  000037  #constant  Strings23Count    1
004027  000038  #constant  Strings23Size     5
004028  000038  #constant  Strings23Size     5
004029  000039  #constant  Strings24Count    1
004030  000039  #constant  Strings24Count    1
004031  000040  #constant  Strings24Size     12
004032  000040  #constant  Strings24Size     12
004033  000041  #constant  Strings13Count    1
004034  000041  #constant  Strings13Count    1
004035  000042  #constant  Strings13Size     4
004036  000042  #constant  Strings13Size     4
004037  000043  #constant  Strings14Count    1
004038  000043  #constant  Strings14Count    1
004039  000044  #constant  Strings14Size     16
004040  000044  #constant  Strings14Size     16
004041  000045  #constant  Strings25Count    1
004042  000045  #constant  Strings25Count    1
004043  000046  #constant  Strings25Size     5
004044  000046  #constant  Strings25Size     5
004045  000047  #constant  Strings26Count    1
004046  000047  #constant  Strings26Count    1
004047  000048  #constant  Strings26Size     17
004048  000048  #constant  Strings26Size     17
004049  000049  #constant  Strings17Count    1
004050  000049  #constant  Strings17Count    1
004051  000050  #constant  Strings17Size     6
004052  000050  #constant  Strings17Size     6
004053  000051  #constant  Strings3Count    1
004054  000051  #constant  Strings3Count    1
004055  000052  #constant  Strings3Size     6
004056  000052  #constant  Strings3Size     6
004057  000053  #constant  Strings6Count    1
004058  000053  #constant  Strings6Count    1
004059  000054  #constant  Strings6Size     12
004060  000054  #constant  Strings6Size     12
004061  000055  #constant  Strings27Count    1
004062  000055  #constant  Strings27Count    1
004063  000056  #constant  Strings27Size     3
004064  000056  #constant  Strings27Size     3
004065  000057  #constant  Strings28Count    1
004066  000057  #constant  Strings28Count    1
004067  000058  #constant  Strings28Size     10
004068  000058  #constant  Strings28Size     10
004069  000059  #constant  Strings8Count    1
004070  000059  #constant  Strings8Count    1
004071  000060  #constant  Strings8Size     13
004072  000060  #constant  Strings8Size     13
004073  000061  #constant  Strings29Count    1
004074  000061  #constant  Strings29Count    1
004075  000062  #constant  Strings29Size     4
004076  000062  #constant  Strings29Size     4
004077  000063  #constant  Strings30Count    1
004078  000063  #constant  Strings30Count    1
004079  000064  #constant  Strings30Size     6
004080  000064  #constant  Strings30Size     6
004081  000065  #constant  Strings31Count    1
004082  000065  #constant  Strings31Count    1
004083  000066  #constant  Strings31Size     13
004084  000066  #constant  Strings31Size     13
004085  000067  #constant  Strings1Count    1
004086  000067  #constant  Strings1Count    1
004087  000068  #constant  Strings1Size     12
004088  000068  #constant  Strings1Size     12
004089  000069  #constant  Strings32Count    1
004090  000069  #constant  Strings32Count    1
004091  000070  #constant  Strings32Size     2
004092  000070  #constant  Strings32Size     2
004093  000071  #constant  IFONT_OFFSET     33
004094  000071  #constant  IFONT_OFFSET     33
004095  000072  // object indexes into WIDGET pointer
004096  000073  #CONST
004097  000088  #END
004098  000089        
004099  000090  // object indexes into ImageControl
004100  000091  #CONST
004101  000122  #END
004102  000123        
004103  000124        
004104  000125  #constant  Strings2StartH   0x0
004105  000125  #constant  Strings2StartH   0x0
004106  000126  #constant  Strings2StartL   0x0
004107  000126  #constant  Strings2StartL   0x0
004108  000127  #constant  Strings0StartH   0x0
004109  000127  #constant  Strings0StartH   0x0
004110  000128  #constant  Strings0StartL   0x200
004111  000128  #constant  Strings0StartL   0x200
004112  000129  #constant  Strings4StartH   0x0
004113  000129  #constant  Strings4StartH   0x0
004114  000130  #constant  Strings4StartL   0x400
004115  000130  #constant  Strings4StartL   0x400
004116  000131  #constant  Strings5StartH   0x0
004117  000131  #constant  Strings5StartH   0x0
004118  000132  #constant  Strings5StartL   0x600
004119  000132  #constant  Strings5StartL   0x600
004120  000133  #constant  Strings7StartH   0x0
004121  000133  #constant  Strings7StartH   0x0
004122  000134  #constant  Strings7StartL   0x800
004123  000134  #constant  Strings7StartL   0x800
004124  000135  #constant  Strings9StartH   0x0
004125  000135  #constant  Strings9StartH   0x0
004126  000136  #constant  Strings9StartL   0xA00
004127  000136  #constant  Strings9StartL   0xA00
004128  000137  #constant  Strings10StartH   0x0
004129  000137  #constant  Strings10StartH   0x0
004130  000138  #constant  Strings10StartL   0xC00
004131  000138  #constant  Strings10StartL   0xC00
004132  000139  #constant  Strings11StartH   0x0
004133  000139  #constant  Strings11StartH   0x0
004134  000140  #constant  Strings11StartL   0xE00
004135  000140  #constant  Strings11StartL   0xE00
004136  000141  #constant  Strings12StartH   0x0
004137  000141  #constant  Strings12StartH   0x0
004138  000142  #constant  Strings12StartL   0x1000
004139  000142  #constant  Strings12StartL   0x1000
004140  000143  #constant  Strings15StartH   0x0
004141  000143  #constant  Strings15StartH   0x0
004142  000144  #constant  Strings15StartL   0x1200
004143  000144  #constant  Strings15StartL   0x1200
004144  000145  #constant  Strings16StartH   0x0
004145  000145  #constant  Strings16StartH   0x0
004146  000146  #constant  Strings16StartL   0x1400
004147  000146  #constant  Strings16StartL   0x1400
004148  000147  #constant  Strings18StartH   0x0
004149  000147  #constant  Strings18StartH   0x0
004150  000148  #constant  Strings18StartL   0x1600
004151  000148  #constant  Strings18StartL   0x1600
004152  000149  #constant  Strings19StartH   0x0
004153  000149  #constant  Strings19StartH   0x0
004154  000150  #constant  Strings19StartL   0x1800
004155  000150  #constant  Strings19StartL   0x1800
004156  000151  #constant  Strings20StartH   0x0
004157  000151  #constant  Strings20StartH   0x0
004158  000152  #constant  Strings20StartL   0x1A00
004159  000152  #constant  Strings20StartL   0x1A00
004160  000153  #constant  Strings21StartH   0x0
004161  000153  #constant  Strings21StartH   0x0
004162  000154  #constant  Strings21StartL   0x1C00
004163  000154  #constant  Strings21StartL   0x1C00
004164  000155  #constant  Strings22StartH   0x0
004165  000155  #constant  Strings22StartH   0x0
004166  000156  #constant  Strings22StartL   0x1E00
004167  000156  #constant  Strings22StartL   0x1E00
004168  000157  #constant  Strings23StartH   0x0
004169  000157  #constant  Strings23StartH   0x0
004170  000158  #constant  Strings23StartL   0x2000
004171  000158  #constant  Strings23StartL   0x2000
004172  000159  #constant  Strings24StartH   0x0
004173  000159  #constant  Strings24StartH   0x0
004174  000160  #constant  Strings24StartL   0x2200
004175  000160  #constant  Strings24StartL   0x2200
004176  000161  #constant  Strings13StartH   0x0
004177  000161  #constant  Strings13StartH   0x0
004178  000162  #constant  Strings13StartL   0x2400
004179  000162  #constant  Strings13StartL   0x2400
004180  000163  #constant  Strings14StartH   0x0
004181  000163  #constant  Strings14StartH   0x0
004182  000164  #constant  Strings14StartL   0x2600
004183  000164  #constant  Strings14StartL   0x2600
004184  000165  #constant  Strings25StartH   0x0
004185  000165  #constant  Strings25StartH   0x0
004186  000166  #constant  Strings25StartL   0x2800
004187  000166  #constant  Strings25StartL   0x2800
004188  000167  #constant  Strings26StartH   0x0
004189  000167  #constant  Strings26StartH   0x0
004190  000168  #constant  Strings26StartL   0x2A00
004191  000168  #constant  Strings26StartL   0x2A00
004192  000169  #constant  Strings17StartH   0x0
004193  000169  #constant  Strings17StartH   0x0
004194  000170  #constant  Strings17StartL   0x2C00
004195  000170  #constant  Strings17StartL   0x2C00
004196  000171  #constant  Strings3StartH   0x0
004197  000171  #constant  Strings3StartH   0x0
004198  000172  #constant  Strings3StartL   0x2E00
004199  000172  #constant  Strings3StartL   0x2E00
004200  000173  #constant  Strings6StartH   0x0
004201  000173  #constant  Strings6StartH   0x0
004202  000174  #constant  Strings6StartL   0x3000
004203  000174  #constant  Strings6StartL   0x3000
004204  000175  #constant  Strings27StartH   0x0
004205  000175  #constant  Strings27StartH   0x0
004206  000176  #constant  Strings27StartL   0x3200
004207  000176  #constant  Strings27StartL   0x3200
004208  000177  #constant  Strings28StartH   0x0
004209  000177  #constant  Strings28StartH   0x0
004210  000178  #constant  Strings28StartL   0x3400
004211  000178  #constant  Strings28StartL   0x3400
004212  000179  #constant  Strings8StartH   0x0
004213  000179  #constant  Strings8StartH   0x0
004214  000180  #constant  Strings8StartL   0x3600
004215  000180  #constant  Strings8StartL   0x3600
004216  000181  #constant  Strings29StartH   0x0
004217  000181  #constant  Strings29StartH   0x0
004218  000182  #constant  Strings29StartL   0x3800
004219  000182  #constant  Strings29StartL   0x3800
004220  000183  #constant  Strings30StartH   0x0
004221  000183  #constant  Strings30StartH   0x0
004222  000184  #constant  Strings30StartL   0x3A00
004223  000184  #constant  Strings30StartL   0x3A00
004224  000185  #constant  Strings31StartH   0x0
004225  000185  #constant  Strings31StartH   0x0
004226  000186  #constant  Strings31StartL   0x3C00
004227  000186  #constant  Strings31StartL   0x3C00
004228  000187  #constant  Strings1StartH   0x0
004229  000187  #constant  Strings1StartH   0x0
004230  000188  #constant  Strings1StartL   0x3E00
004231  000188  #constant  Strings1StartL   0x3E00
004232  000189  #constant  Strings32StartH   0x0
004233  000189  #constant  Strings32StartH   0x0
004234  000190  #constant  Strings32StartL   0x4000
004235  000190  #constant  Strings32StartL   0x4000
004236  000191        
004237  000192  #constant  ffsEndUnits4k    0x0041  // First unused 4k Sector on Flash
004238  000192  #constant  ffsEndUnits4k    0x0041  // First unused 4k Sector on Flash
004239  000193  #constant  ffsEnd4kH        0x0004  // Address of first unused 4k Sector on Flash, High
004240  000193  #constant  ffsEnd4kH        0x0004  // Address of first unused 4k Sector on Flash, High
004241  000194  #constant  ffsEnd4kL        0x1000  // Address of first unused 4k Sector on Flash, Low
004242  000194  #constant  ffsEnd4kL        0x1000  // Address of first unused 4k Sector on Flash, Low
004243  000195  #constant  ffsEndUnits32k   0x0009  // First unused 32k Block on Flash
004244  000195  #constant  ffsEndUnits32k   0x0009  // First unused 32k Block on Flash
004245  000196  #constant  ffsEnd32kH       0x0004  // Address of first unused 32k Block on Flash, High
004246  000196  #constant  ffsEnd32kH       0x0004  // Address of first unused 32k Block on Flash, High
004247  000197  #constant  ffsEnd32kL       0x8000  // Address of first unused 32k Block on Flash, Low
004248  000197  #constant  ffsEnd32kL       0x8000  // Address of first unused 32k Block on Flash, Low
004249  000198  #constant  ffsEndUnits64k   0x0005  // First unused 64k Block on Flash
004250  000198  #constant  ffsEndUnits64k   0x0005  // First unused 64k Block on Flash
004251  000199  #constant  ffsEnd64kH       0x0005  // Address of first unused 64k Block on Flash, High
004252  000199  #constant  ffsEnd64kH       0x0005  // Address of first unused 64k Block on Flash, High
004253  000200  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
004254  000200  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
004255  000201        
004256  000202  #IFNOT EXISTS NOGLOBALS
004257  000203  var hndl ;
004258  000204  #ENDIF
004259  000019        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\CLPrintStringsGciFS.inc

004260  000020  #inherit "CLPrintStringsGciFS.inc"
004261  000020  #inherit "CLPrintStringsGciFS.inc"
004262  000001  func PrintStrings(var ID, var *msgid, var String)
004263  000002      var StringID, i, ch, offs32[2], res32[2] ;
004264  000003      StringID := oStringss[1+ID] ;
004265  000004      if (String)
004266  000005          stringsCV[ID] := -1 ;
004267  000006      else
004268  000007          stringsCV[ID] := msgid ;
004269  000008      endif
004270  000009      if ((StringID == -1) || (*(StringID + Ofs_String_Form) != CurrentForm)) return ;
004271  000010      i := *(StringID + Ofs_String_GciFSFontIdx) ;
004272  000011      if (i < 0)
004273  000012  //to(COM0) ; print("CLP Font Flash ", -1-i, "\n") ;
004274  000013          img_TxtFontID(0xffff, -1-i) ;
004275  000014      else
004276  000015  //to(COM0) ; print("CLP Font Internal ", i, "\n") ;
004277  000016          txt_FontID(i) ;
004278  000017      endif
004279  000018      txt_Attributes(*(StringID + Ofs_String_FontAttribs)) ; // >> 4 fix for r25,6,7,8 PmmC
004280  000019  //    txt_Opacity(*(StringID + STTransparent)) ;
004281  000020        
004282  000021      if (*(StringID + Ofs_String_Transparent))
004283  000022          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), *(StringID + Ofs_String_BGColor));
004284  000023      else if (FormBGcolors[CurrentForm] != ColorBGimage)
004285  000024          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), FormBGcolors[CurrentForm]);
004286  000025      else
004287  000026          gfx_ClipWindow(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2)) ;
004288  000027          gfx_Clipping(ON) ;
004289  000028          img_Show(hndl,FormStartIndex[CurrentForm]) ;
004290  000029          gfx_Clipping(OFF) ;
004291  000030        
004292  000031      endif
004293  000032        
004294  000033      txt_FGcolour(*(StringID + Ofs_String_FGColor)) ;
004295  000034      txt_BGcolour(*(StringID + Ofs_String_BGColor)) ;
004296  000035      txt_Opacity(TRANSPARENT);                // 8  text OPAQUE or TRANSPARENT
004297  000036        
004298  000037      gfx_MoveTo(*(StringID + Ofs_String_x1) , *(StringID + Ofs_String_y1)) ;
004299  000038        
004300  000039      if (String)
004301  000040          i := 0 ;
004302  000041          ch := msgid[i++] ;
004303  000042          while (ch != 0)
004304  000043              putch(ch) ;
004305  000044              ch := msgid[i++] ;
004306  000045          wend
004307  000046      else
004308  000047          umul_1616(offs32, *(StringID + Ofs_String_Size), msgid);
004309  000048          res32[1] := *(StringID + Ofs_String_StartH) ;
004310  000049          res32[0] := *(StringID + Ofs_String_StartL) ;
004311  000050          uadd_3232(res32,res32,offs32) ;
004312  000051          img_FileSeek(hndl, iTextStrings, res32[1], res32[0]);
004313  000052          repeat
004314  000053              if (*(StringID + Ofs_String_Ansi))
004315  000054                  ch := img_FileGetC(hndl, iTextStrings) ;
004316  000055              else
004317  000056                  ch := img_FileGetW(hndl, iTextStrings) ;
004318  000057              endif
004319  000058              putch(ch) ;
004320  000059          until (ch == 0) ;
004321  000060      endif
004322  000061        
004323  000062  endfunc
004324  000063        
004325  000021        
004326  000022  #constant IPDatasize 22
004327  000022  #constant IPDatasize 22
004328  000023        
004329  000024  #CONST
004330  000028  #END
004331  000029        
004332  000030        
004333  000031        
004334  000032  #CONST
004335  000175  #END
004336  000176        
004337  000294  #END
4338  0A80
4339  0A81
4340  0A82
4341  0A83
4342  0A84
4343  0A85
4344  0A86
4345  0A87
4346  0A88
4347  0A89
4348  0A8A
4349  0A8B
4350  0A8C
4351  0A8D
4352  0A8E
4353  0A8F
4354  0A90
4355  0A91
4356  0A92
4357  0A93
4358  0A94
4359  0A95
4360  0A96
4361  0A97
4362  0A98
4363  0A99
4364  0A9A
4365  0A9B
4366  0A9C
4367  0A9D
4368  0A9E
4369  0A9F
4370  0AA0
4371  0AA1
4372  0AA2
4373  0AA3
4374  0AA4
4375  0AA5
4376  0AA6
4377  0AA7
4378  0AA8
4379  0AA9
4380  0AAA
4381  0AAB
4382  0AAC
4383  0AAD
4384  0AAE
4385  0AAF
4386  0AB0
4387  0AB1
4388  0AB2
4389  0AB3
4390  0AB4
4391  0AB5
4392  0AB6
4393  0AB7
4394  0AB8
4395  0AB9
4396  0ABA
4397  0ABB
4398  0ABC
4399  0ABD
4400  0ABE
4401  0ABF
4402  0AC0
4403  0AC1
4404  0AC2
4405  0AC3
4406  0AC4
4407  0AC5
4408  0AC6
4409  0AC7
4410  0AC8
4411  0AC9
4412  0ACA
4413  0ACB
4414  0ACC
4415  0ACD
4416  0ACE
4417  0ACF
4418  0AD0
4419  0AD1
4420  0AD2
4421  0AD3
4422  0AD4
4423  0AD5
4424  0AD6
4425  0AD7
4426  0AD8
4427  0AD9
4428  0ADA
4429  0ADB
4430  0ADC
4431  0ADD
4432  0ADE
4433  0ADF
4434  0AE0
4435  0AE1
4436  0AE2
4437  0AE3
4438  0AE4
4439  0AE5
4440  0AE6
4441  0AE7
4442  0AE8
4443  0AE9
4444  0AEA
4445  0AEB
4446  0AEC
4447  0AED
4448  0AEE
4449  0AEF
4450  0AF0
4451  0AF1
4452  0AF2
4453  0AF3
4454  0AF4
4455  0AF5
4456  0AF6
4457  0AF7
4458  0AF8
4459  0AF9
4460  0AFA
4461  0AFB
4462  0AFC
4463  0AFD
4464  0AFE
4465  0AFF
4466  0B00
4467  0B01
4468  0B02
4469  0B03
4470  0B04
4471  0B05
4472  0B06
4473  0B07
4474  0B08
4475  0B09
4476  0B0A
4477  0B0B
4478  0B0C
4479  0B0D
4480  0B0E
4481  0B0F
4482  0B10
4483  0B11
4484  0B12
4485  0B13
4486  0B14
4487  0B15
4488  0B16
4489  0B17
4490  0B18
4491  0B19
4492  0B1A
4493  0B1B
4494  0B1C
4495  0B1D
4496  0B1E
4497  0B1F
4498  0B20
4499  0B21
4500  0B22
4501  0B23
4502  0B24
4503  0B25
4504  0B26
4505  0B27
4506  0B28
4507  0B29
4508  0B2A
4509  0B2B
4510  0B2C
4511  0B2D
4512  0B2E
4513  0B2F
4514  0B30
4515  0B31
4516  0B32
4517  0B33
4518  0B34
4519  0B35
4520  0B36
4521  0B37
4522  0B38
4523  0B39
4524  0B3A
4525  0B3B
4526  0B3C
4527  0B3D
4528  0B3E
4529  0B3F
4530  0B40
4531  0B41
4532  0B42
4533  0B43
4534  0B44
4535  0B45
4536  0B46
4537  0B47
4538  0B48
4539  0B49
4540  0B4A
4541  0B4B
4542  0B4C
4543  0B4D
4544  0B4E
4545  0B4F
4546  0B50
4547  0B51
4548  0B52
4549  0B53
4550  0B54
4551  0B55
4552  0B56
4553  0B57
4554  0B58
4555  0B59
4556  0B5A
4557  0B5B
4558  0B5C
4559  0B5D
4560  0B5E
4561  0B5F
4562  0B60
4563  0B61
4564  0B62
4565  0B63
4566  0B64
4567  0B65
4568  0B66
4569  0B67
4570  0B68
4571  0B69
4572  0B6A
4573  0B6B
4574  0B6C
4575  0B6D
4576  0B6E
4577  0B6F
4578  0B70
4579  0B71
4580  0B72
4581  0B73
4582  0B74
4583  0B75
4584  0B76
4585  0B77
4586  0B78
4587  0B79
4588  0B7A
4589  0B7B
4590  0B7C
4591  0B7D
4592  0B7E
4593  0B7F
4594  0B80
4595  0B81
4596  0B82
4597  0B83
4598  0B84
4599  0B85
4600  0B86
4601  0B87
4602  0B88
4603  0B89
4604  0B8A
4605  0B8B
4606  0B8C
4607  0B8D
4608  0B8E
4609  0B8F
4610  0B90
4611  0B91
4612  0B92
4613  0B93
4614  0B94
4615  0B95
4616  0B96
4617  0B97
4618  0B98
4619  0B99
4620  0B9A
4621  0B9B
4622  0B9C
4623  0B9D
4624  0B9E
4625  0B9F
4626  0BA0
4627  0BA1
4628  0BA2
4629  0BA3
4630  0BA4
4631  0BA5
4632  0BA6
4633  0BA7
4634  0BA8
4635  0BA9
4636  0BAA
4637  0BAB
4638  0BAC
4639  0BAD
4640  0BAE
4641  0BAF
4642  0BB0
4643  0BB1
4644  0BB2
4645  0BB3
4646  0BB4
4647  0BB5
4648  0BB6
4649  0BB7
4650  0BB8
4651  0BB9
4652  0BBA
4653  0BBB
4654  0BBC
4655  0BBD
4656  0BBE
4657  0BBF
4658  0BC0
4659  0BC1
4660  0BC2
4661  0BC3
4662  0BC4
4663  0BC5
4664  0BC6
4665  0BC7
4666  0BC8
4667  0BC9
4668  0BCA
4669  0BCB
4670  0BCC
4671  0BCD
4672  0BCE
4673  0BCF
4674  0BD0
4675  0BD1
4676  0BD2
4677  0BD3
4678  0BD4
4679  0BD5
4680  0BD6
4681  0BD7
4682  0BD8
4683  0BD9
4684  0BDA
4685  0BDB
4686  0BDC
4687  0BDD
4688  0BDE
4689  0BDF
4690  0BE0
4691  0BE1
4692  0BE2
4693  0BE3
4694  0BE4
4695  0BE5
4696  0BE6
4697  0BE7
4698  0BE8
4699  0BE9
4700  0BEA
4701  0BEB
4702  0BEC
4703  0BED
4704  0BEE
4705  0BEF
4706  0BF0
4707  0BF1
4708  0BF2
4709  0BF3
4710  0BF4
4711  0BF5
4712  0BF6
4713  0BF7
4714  0BF8
4715  0BF9
4716  0BFA
4717  0BFB
4718  0BFC
4719  0BFD
4720  0BFE
4721  0BFF
4722  0C00
4723  0C01
4724  0C02
4725  0C03
4726  0C04
4727  0C05
4728  0C06
4729  0C07
4730  0C08
4731  0C09
4732  0C0A
4733  0C0B
4734  0C0C
4735  0C0D
4736  0C0E
4737  0C0F
4738  0C10
4739  0C11
4740  0C12
4741  0C13
4742  0C14
4743  0C15
4744  0C16
4745  0C17
4746  0C18
4747  0C19
4748  0C1A
4749  0C1B
4750  0C1C
4751  0C1D
4752  0C1E
4753  0C1F
4754  0C20
4755  0C21
4756  0C22
4757  0C23
4758  0C24
4759  0C25
4760  0C26
4761  0C27
4762  0C28
4763  0C29
4764  0C2A
4765  0C2B
4766  0C2C
4767  0C2D
4768  0C2E
4769  0C2F
4770  0C30
4771  0C31
4772  0C32
4773  0C33
4774  0C34
4775  0C35
4776  0C36
4777  0C37
4778  0C38
4779  0C39
4780  0C3A
4781  0C3B
4782  0C3C
4783  0C3D
4784  0C3E
4785  0C3F
4786  0C40
4787  0C41
4788  0C42
4789  0C43
4790  0C44
4791  0C45
4792  0C46
4793  0C47
4794  0C48
4795  0C49
4796  0C4A
4797  0C4B
4798  0C4C
4799  0C4D
4800  0C4E
4801  0C4F
4802  0C50
4803  0C51
4804  0C52
4805  0C53
4806  0C54
4807  0C55
4808  0C56
4809  0C57
4810  0C58
4811  0C59
4812  0C5A
4813  0C5B
4814  0C5C
4815  0C5D
4816  0C5E
4817  0C5F
4818  0C60
4819  0C61
4820  0C62
4821  0C63
4822  0C64
4823  0C65
4824  0C66
4825  0C67
4826  0C68
4827  0C69
4828  0C6A
4829  0C6B
4830  0C6C
4831  0C6D
4832  0C6E
4833  0C6F
4834  0C70
4835  0C71
4836  0C72
4837  0C73
4838  0C74
4839  0C75
4840  0C76
4841  0C77
4842  0C78
4843  0C79
4844  0C7A
4845  0C7B
4846  0C7C
4847  0C7D
4848  0C7E
4849  0C7F
4850  0C80
4851  0C81
4852  0C82
4853  0C83
4854  0C84
4855  0C85
4856  0C86
4857  0C87
4858  0C88
4859  0C89
4860  0C8A
4861  0C8B
4862  0C8C
4863  0C8D
4864  0C8E
4865  0C8F
4866  0C90
4867  0C91
4868  0C92
4869  0C93
4870  0C94
4871  0C95
4872  0C96
4873  0C97
4874  0C98
4875  0C99
4876  0C9A
4877  0C9B
4878  0C9C
4879  0C9D
4880  0C9E
4881  0C9F
4882  0CA0
4883  0CA1
4884  0CA2
4885  0CA3
4886  0CA4
4887  0CA5
4888  0CA6
4889  0CA7
4890  0CA8
4891  0CA9
4892  0CAA
4893  0CAB
4894  0CAC
4895  0CAD
4896  0CAE
4897  0CAF
4898  0CB0
4899  0CB1
4900  0CB2
4901  0CB3
4902  0CB4
4903  0CB5
4904  0CB6
4905  0CB7
4906  0CB8
4907  0CB9
4908  0CBA
4909  0CBB
4910  0CBC
4911  0CBD
4912  0CBE
4913  0CBF
4914  0CC0
4915  0CC1
4916  0CC2
4917  0CC3
4918  0CC4
4919  0CC5
4920  0CC6
4921  0CC7
4922  0CC8
4923  0CC9
4924  0CCA
4925  0CCB
4926  0CCC
4927  0CCD
4928  0CCE
4929  0CCF
4930  0CD0
4931  0CD1
4932  0CD2
4933  0CD3
4934  0CD4
4935  0CD5
4936  0CD6
4937  0CD7
4938  0CD8
4939  0CD9
4940  0CDA
4941  0CDB
4942  0CDC
4943  0CDD
4944  0CDE
4945  0CDF
4946  0CE0
4947  0CE1
4948  0CE2
4949  0CE3
4950  0CE4
4951  0CE5
4952  0CE6
4953  0CE7
4954  0CE8
4955  0CE9
4956  0CEA
4957  0CEB
4958  0CEC
4959  0CED
4960  0CEE
4961  0CEF
4962  0CF0
4963  0CF1
4964  0CF2
4965  0CF3
4966  0CF4
4967  0CF5
4968  0CF6
4969  0CF7
4970  0CF8
4971  0CF9
4972  0CFA
4973  0CFB
4974  0CFC
4975  0CFD
4976  0CFE
4977  0CFF
4978  0D00
4979  0D01
4980  0D02
4981  0D03
4982  0D04
4983  0D05
4984  0D06
4985  0D07
4986  0D08
4987  0D09
4988  0D0A
4989  0D0B
4990  0D0C
4991  0D0D
4992  0D0E
4993  0D0F
4994  0D10
4995  0D11
4996  0D12
4997  0D13
4998  0D14
4999  0D15
5000  0D16
5001  0D17
5002  0D18
5003  0D19
5004  0D1A
5005  0D1B
5006  0D1C
5007  0D1D
5008  0D1E
5009  0D1F
5010  0D20
5011  0D21
5012  0D22
5013  0D23
5014  0D24
5015  0D25
5016  0D26
5017  0D27
5018  0D28
5019  0D29
5020  0D2A
5021  0D2B
5022  0D2C
5023  0D2D
5024  0D2E
5025  0D2F
5026  0D30
5027  0D31
5028  0D32
5029  0D33
5030  0D34
5031  0D35
5032  0D36
5033  0D37
5034  0D38
5035  0D39
5036  0D3A
5037  0D3B
5038  0D3C
5039  0D3D
5040  0D3E
5041  0D3F
5042  0D40
5043  0D41
5044  0D42
5045  0D43
5046  0D44
5047  0D45
5048  0D46
5049  0D47
5050  0D48
5051  0D49
5052  0D4A
5053  0D4B
5054  0D4C
5055  0D4D
5056  0D4E
5057  0D4F
5058  0D50
5059  0D51
5060  0D52
5061  0D53
5062  0D54
5063  0D55
5064  0D56
5065  0D57
5066  0D58
5067  0D59
5068  0D5A
5069  0D5B
5070  0D5C
5071  0D5D
5072  0D5E
5073  0D5F
5074  0D60
5075  0D61
5076  0D62
5077  0D63
5078  0D64
5079  0D65
5080  0D66
5081  0D67
5082  0D68
5083  0D69
5084  0D6A
5085  0D6B
5086  0D6C
5087  0D6D
5088  0D6E
5089  0D6F
5090  0D70
5091  0D71
5092  0D72
5093  0D73
5094  0D74
5095  0D75
5096  0D76
5097  0D77
5098  0D78
5099  0D79
5100  0D7A
5101  0D7B
5102  0D7C
5103  0D7D
5104  0D7E
5105  0D7F
5106  0D80
5107  0D81
5108  0D82
5109  0D83
5110  0D84
5111  0D85
5112  0D86
5113  0D87
5114  0D88
5115  0D89
5116  0D8A
5117  0D8B
5118  0D8C
5119  0D8D
5120  0D8E
5121  0D8F
5122  0D90
5123  0D91
5124  0D92
5125  0D93
5126  0D94
5127  0D95
5128  0D96
5129  0D97
5130  0D98
5131  0D99
5132  0D9A
5133  0D9B
5134  0D9C
5135  0D9D
5136  0D9E
5137  0D9F
5138  0DA0
5139  0DA1
5140  0DA2
5141  0DA3
5142  0DA4
5143  0DA5
5144  0DA6
5145  0DA7
5146  0DA8
5147  0DA9
5148  0DAA
5149  0DAB
5150  0DAC
5151  0DAD
5152  0DAE
5153  0DAF
5154  0DB0
5155  0DB1
5156  0DB2
5157  0DB3
5158  0DB4
5159  0DB5
5160  0DB6
5161  0DB7
5162  0DB8
5163  0DB9
5164  0DBA
5165  0DBB
5166  0DBC
5167  0DBD
5168  0DBE
5169  0DBF
5170  0DC0
5171  0DC1
5172  0DC2
5173  0DC3
5174  0DC4
5175  0DC5
5176  0DC6
5177  0DC7
5178  0DC8
5179  0DC9
5180  0DCA
5181  0DCB
5182  0DCC
5183  0DCD
5184  0DCE
5185  0DCF
5186  0DD0
5187  0DD1
5188  0DD2
5189  0DD3
5190  0DD4
5191  0DD5
5192  0DD6
5193  0DD7
5194  0DD8
5195  0DD9
5196  0DDA
5197  0DDB
5198  0DDC
5199  0DDD
5200  0DDE
5201  0DDF
5202  0DE0
5203  0DE1
5204  0DE2
5205  0DE3
5206  0DE4
5207  0DE5
5208  0DE6
5209  0DE7
5210  0DE8
5211  0DE9
5212  0DEA
5213  0DEB
5214  0DEC
5215  0DED
5216  0DEE
5217  0DEF
5218  0DF0
5219  0DF1
5220  0DF2
5221  0DF3
5222  0DF4
5223  0DF5
5224  0DF6
5225  0DF7
5226  0DF8
5227  0DF9
5228  0DFA
5229  0DFB
5230  0DFC
5231  0DFD
5232  0DFE
5233  0DFF
5234  0E00
5235  0E01
5236  0E02
5237  0E03
5238  0E04
5239  0E05
5240  0E06
5241  0E07
5242  0E08
5243  0E09
5244  0E0A
5245  0E0B
5246  0E0C
5247  0E0D
5248  0E0E
5249  0E0F
5250  0E10
5251  0E11
5252  0E12
5253  0E13
5254  0E14
5255  0E15
5256  0E16
5257  0E17
5258  0E18
5259  0E19
5260  0E1A
5261  0E1B
5262  0E1C
5263  0E1D
5264  0E1E
5265  0E1F
5266  0E20
5267  0E21
5268  0E22
5269  0E23
5270  0E24
5271  0E25
5272  0E26
5273  0E27
5274  0E28
5275  0E29
5276  0E2A
5277  0E2B
5278  0E2C
5279  0E2D
5280  0E2E
5281  0E2F
5282  0E30
5283  0E31
5284  0E32
5285  0E33
5286  0E34
5287  0E35
5288  0E36
5289  0E37
5290  0E38
5291  0E39
5292  0E3A
5293  0E3B
5294  0E3C
5295  0E3D
5296  0E3E
5297  0E3F
5298  0E40
5299  0E41
5300  0E42
5301  0E43
5302  0E44
5303  0E45
5304  0E46
5305  0E47
5306  0E48
5307  0E49
5308  0E4A
5309  0E4B
5310  0E4C
5311  0E4D
5312  0E4E
5313  0E4F
5314  0E50
5315  0E51
5316  0E52
5317  0E53
5318  0E54
5319  0E55
5320  0E56
5321  0E57
5322  0E58
5323  0E59
5324  0E5A
5325  0E5B
5326  0E5C
5327  0E5D
5328  0E5E
5329  0E5F
5330  0E60
5331  0E61
5332  0E62
5333  0E63
5334  0E64
5335  0E65
5336  0E66
5337  0E67
5338  0E68
5339  0E69
5340  0E6A
5341  0E6B
5342  0E6C
5343  0E6D
5344  0E6E
5345  0E6F
5346  0E70
5347  0E71
5348  0E72
5349  0E73
5350  0E74
5351  0E75
5352  0E76
5353  0E77
5354  0E78
5355  0E79
5356  0E7A
5357  0E7B
5358  0E7C
5359  0E7D
5360  0E7E
5361  0E7F
5362  0E80
5363  0E81
5364  0E82
5365  0E83
5366  0E84
5367  0E85
5368  0E86
5369  0E87
5370  0E88
5371  0E89
5372  0E8A
5373  0E8B
5374  0E8C
5375  0E8D
5376  0E8E
5377  0E8F
5378  0E90
5379  0E91
5380  0E92
5381  0E93
5382  0E94
5383  0E95
5384  0E96
5385  0E97
5386  0E98
5387  0E99
5388  0E9A
5389  0E9B
5390  0E9C
5391  0E9D
5392  0E9E
5393  0E9F
5394  0EA0
5395  0EA1
5396  0EA2
5397  0EA3
5398  0EA4
5399  0EA5
5400  0EA6
5401  0EA7
5402  0EA8
5403  0EA9
5404  0EAA
5405  0EAB
5406  0EAC
5407  0EAD
5408  0EAE
5409  0EAF
5410  0EB0
5411  0EB1
5412  0EB2
5413  0EB3
5414  0EB4
5415  0EB5
5416  0EB6
5417  0EB7
5418  0EB8
5419  0EB9
5420  0EBA
5421  0EBB
5422  0EBC
5423  0EBD
5424  0EBE
5425  0EBF
5426  0EC0
5427  0EC1
5428  0EC2
5429  0EC3
5430  0EC4
5431  0EC5
5432  0EC6
5433  0EC7
5434  0EC8
5435  0EC9
5436  0ECA
5437  0ECB
5438  0ECC
5439  0ECD
5440  0ECE
5441  0ECF
5442  0ED0
5443  0ED1
5444  0ED2
5445  0ED3
5446  0ED4
5447  0ED5
5448  0ED6
5449  0ED7
5450  0ED8
5451  0ED9
5452  0EDA
5453  0EDB
5454  0EDC
5455  0EDD
5456  0EDE
5457  0EDF
5458  0EE0
5459  0EE1
5460  0EE2
5461  0EE3
5462  0EE4
5463  0EE5
5464  0EE6
5465  0EE7
5466  0EE8
5467  0EE9
5468  0EEA
5469  0EEB
5470  0EEC
5471  0EED
5472  0EEE
5473  0EEF
5474  0EF0
5475  0EF1
5476  0EF2
5477  0EF3
5478  0EF4
5479  0EF5
5480  0EF6
5481  0EF7
5482  0EF8
5483  0EF9
5484  0EFA
5485  0EFB
5486  0EFC
5487  0EFD
5488  0EFE
5489  0EFF
5490  0F00
5491  0F01
5492  0F02
5493  0F03
5494  0F04
5495  0F05
5496  0F06
5497  0F07
5498  0F08
5499  0F09
5500  0F0A
5501  0F0B
5502  0F0C
5503  0F0D
5504  0F0E
5505  0F0F
5506  0F10
5507  0F11
5508  0F12
5509  0F13
5510  0F14
5511  0F15
5512  0F16
5513  0F17
5514  0F18
5515  0F19
5516  0F1A
5517  0F1B
5518  0F1C
5519  0F1D
5520  0F1E
5521  0F1F
5522  0F20
5523  0F21
5524  0F22
5525  0F23
5526  0F24
5527  0F25
5528  0F26
5529  0F27
5530  0F28
5531  0F29
5532  0F2A
5533  0F2B
5534  0F2C
5535  0F2D
5536  0F2E
5537  0F2F
5538  0F30
5539  0F31
5540  0F32
5541  0F33
5542  0F34
5543  0F35
5544  0F36
5545  0F37
5546  0F38
5547  0F39
5548  0F3A
5549  0F3B
5550  0F3C
5551  0F3D
5552  0F3E
5553  0F3F
5554  0F40
5555  0F41
5556  0F42
5557  0F43
5558  0F44
5559  0F45
5560  0F46
5561  0F47
5562  0F48
5563  0F49
5564  0F4A
5565  0F4B
5566  0F4C
5567  0F4D
5568  0F4E
5569  0F4F
5570  0F50
5571  0F51
5572  0F52
5573  0F53
5574  0F54
5575  0F55
5576  0F56
5577  0F57
5578  0F58
5579  0F59
5580  0F5A
5581  0F5B
5582  0F5C
5583  0F5D
5584  0F5E
5585  0F5F
5586  0F60
5587  0F61
5588  0F62
5589  0F63
5590  0F64
5591  0F65
5592  0F66
5593  0F67
5594  0F68
5595  0F69
5596  0F6A
5597  0F6B
5598  0F6C
5599  0F6D
5600  0F6E
5601  0F6F
5602  0F70
5603  0F71
5604  0F72
5605  0F73
5606  0F74
5607  0F75
5608  0F76
5609  0F77
5610  0F78
5611  0F79
5612  0F7A
5613  0F7B
5614  0F7C
5615  0F7D
5616  0F7E
5617  0F7F
5618  0F80
5619  0F81
5620  0F82
5621  0F83
5622  0F84
5623  0F85
5624  0F86
5625  0F87
5626  0F88
5627  0F89
5628  0F8A
5629  0F8B
5630  0F8C
5631  0F8D
5632  0F8E
5633  0F8F
5634  0F90
5635  0F91
5636  0F92
5637  0F93
5638  0F94
5639  0F95
5640  0F96
5641  0F97
5642  0F98
5643  0F99
5644  0F9A
5645  0F9B
5646  0F9C
5647  0F9D
5648  0F9E
5649  0F9F
5650  0FA0
5651  0FA1
5652  0FA2
5653  0FA3
5654  0FA4
5655  0FA5
5656  0FA6
5657  0FA7
5658  0FA8
5659  0FA9
5660  0FAA
5661  0FAB
5662  0FAC
5663  0FAD
5664  0FAE
5665  0FAF
5666  0FB0
5667  0FB1
5668  0FB2
5669  0FB3
5670  0FB4
5671  0FB5
5672  0FB6
5673  0FB7
5674  0FB8
5675  0FB9
5676  0FBA
5677  0FBB
5678  0FBC
5679  0FBD
5680  0FBE
5681  0FBF
5682  0FC0
5683  0FC1
5684  0FC2
5685  0FC3
5686  0FC4
5687  0FC5
5688  0FC6
5689  0FC7
5690  0FC8
5691  0FC9
5692  0FCA
5693  0FCB
5694  0FCC
5695  0FCD
5696  0FCE
5697  0FCF
5698  0FD0
5699  0FD1
5700  0FD2
5701  0FD3
5702  0FD4
5703  0FD5
5704  0FD6
5705  0FD7
5706  0FD8
5707  0FD9
5708  0FDA
5709  0FDB
5710  0FDC
5711  0FDD
5712  0FDE
5713  0FDF
5714  0FE0
5715  0FE1
5716  0FE2
5717  0FE3
5718  0FE4
5719  0FE5
5720  0FE6
5721  0FE7
5722  0FE8
5723  0FE9
5724  0FEA
5725  0FEB
5726  0FEC
5727  0FED
5728  0FEE
5729  0FEF
5730  0FF0
5731  0FF1
5732  0FF2
5733  0FF3
5734  0FF4
5735  0FF5
5736  0FF6
5737  0FF7
5738  0FF8
5739  0FF9
5740  0FFA
5741  0FFB
5742  0FFC
5743  0FFD
5744  0FFE
5745  0FFF
5746  1000
5747  1001
5748  1002
5749  1003
5750  1004
5751  1005
5752  1006
5753  1007
5754  1008
5755  1009
5756  100A
5757  100B
5758  100C
5759  100D
5760  100E
5761  100F
5762  1010
5763  1011
5764  1012
5765  1013
5766  1014
5767  1015
5768  1016
5769  1017
5770  1018
5771  1019
5772  101A
5773  101B
5774  101C
5775  101D
5776  101E
5777  101F
5778  1020
5779  1021
5780  1022
5781  1023
5782  1024
5783  1025
5784  1026
5785  1027
5786  1028
5787  1029
5788  102A
5789  102B
5790  102C
5791  102D
5792  102E
5793  102F
5794  1030
5795  1031
5796  1032
5797  1033
5798  1034
5799  1035
5800  1036
5801  1037
5802  1038
5803  1039
5804  103A
5805  103B
5806  103C
5807  103D
5808  103E
5809  103F
5810  1040
5811  1041
5812  1042
5813  1043
5814  1044
5815  1045
5816  1046
5817  1047
5818  1048
5819  1049
5820  104A
5821  104B
5822  104C
5823  104D
5824  104E
5825  104F
5826  1050
5827  1051
5828  1052
5829  1053
5830  1054
5831  1055
5832  1056
5833  1057
5834  1058
5835  1059
5836  105A
5837  105B
5838  105C
5839  105D
5840  105E
5841  105F
5842  1060
5843  1061
5844  1062
5845  1063
5846  1064
5847  1065
5848  1066
5849  1067
5850  1068
5851  1069
5852  106A
5853  106B
5854  106C
5855  106D
5856  106E
5857  106F
5858  1070
5859  1071
5860  1072
5861  1073
5862  1074
5863  1075
5864  1076
5865  1077
5866  1078
5867  1079
5868  107A
5869  107B
5870  107C
5871  107D
5872  107E
5873  107F
5874  1080
5875  1081
5876  1082
5877  1083
5878  1084
5879  1085
5880  1086
5881  1087
5882  1088
5883  1089
5884  108A
5885  108B
5886  108C
5887  108D
5888  108E
5889  108F
5890  1090
5891  1091
5892  1092
5893  1093
5894  1094
5895  1095
5896  1096
5897  1097
5898  1098
5899  1099
5900  109A
5901  109B
5902  109C
5903  109D
5904  109E
5905  109F
5906  10A0
5907  10A1
5908  10A2
5909  10A3
5910  10A4
5911  10A5
5912  10A6
5913  10A7
5914  10A8
5915  10A9
5916  10AA
5917  10AB
5918  10AC
5919  10AD
5920  10AE
5921  10AF
5922  10B0
5923  10B1
5924  10B2
5925  10B3
5926  10B4
5927  10B5
5928  10B6
5929  10B7
5930  10B8
5931  10B9
5932  10BA
5933  10BB
5934  10BC
5935  10BD
5936  10BE
5937  10BF
5938  10C0
5939  10C1
5940  10C2
5941  10C3
5942  10C4
5943  10C5
5944  10C6
5945  10C7
5946  10C8
5947  10C9
5948  10CA
5949  10CB
5950  10CC
5951  10CD
5952  10CE
5953  10CF
5954  10D0
5955  10D1
5956  10D2
5957  10D3
5958  10D4
5959  10D5
5960  10D6
5961  10D7
5962  10D8
5963  10D9
5964  10DA
5965  10DB
5966  10DC
5967  10DD
5968  10DE
5969  10DF
5970  10E0
5971  10E1
5972  10E2
5973  10E3
5974  10E4
5975  10E5
5976  10E6
5977  10E7
5978  10E8
5979  10E9
5980  10EA
5981  10EB
5982  10EC
5983  10ED
5984  10EE
5985  10EF
5986  10F0
5987  10F1
5988  10F2
5989  10F3
5990  10F4
5991  10F5
5992  10F6
5993  10F7
5994  10F8
5995  10F9
5996  10FA
5997  10FB
5998  10FC
5999  10FD
6000  10FE
6001  10FF
6002  1100
6003  1101
6004  1102
6005  1103
6006  1104
6007  1105
6008  1106
6009  1107
6010  1108
6011  1109
6012  110A
6013  110B
6014  110C
6015  110D
6016  110E
6017  110F
6018  1110
6019  1111
6020  1112
6021  1113
6022  1114
6023  1115
6024  1116
6025  1117
6026  1118
6027  1119
6028  111A
6029  111B
6030  111C
6031  111D
6032  111E
6033  111F
6034  1120
6035  1121
6036  1122
6037  1123
6038  1124
6039  1125
6040  1126
6041  1127
6042  1128
6043  1129
6044  112A
6045  112B
6046  112C
6047  112D
6048  112E
6049  112F
6050  1130
6051  1131
6052  1132
6053  1133
6054  1134
6055  1135
6056  1136
6057  1137
6058  1138
6059  1139
6060  113A
6061  113B
6062  113C
6063  113D
6064  113E
6065  113F
6066  1140
6067  1141
6068  1142
6069  1143
6070  1144
6071  1145
6072  1146
6073  1147
6074  1148
6075  1149
6076  114A
6077  114B
6078  114C
6079  114D
6080  114E
6081  114F
6082  1150
6083  1151
6084  1152
6085  1153
6086  1154
6087  1155
6088  1156
6089  1157
6090  1158
6091  1159
6092  115A
6093  115B
6094  115C
6095  115D
6096  115E
6097  115F
6098  1160
6099  1161
6100  1162
6101  1163
6102  1164
6103  1165
6104  1166
6105  1167
6106  1168
6107  1169
6108  116A
6109  116B
6110  116C
6111  116D
6112  116E
6113  116F
6114  1170
6115  1171
6116  1172
6117  1173
6118  1174
6119  1175
6120  1176
6121  1177
6122  1178
6123  1179
6124  117A
6125  117B
6126  117C
6127  117D
6128  117E
6129  117F
6130  1180
6131  1181
6132  1182
6133  1183
6134  1184
6135  1185
6136  1186
6137  1187
6138  1188
6139  1189
6140  118A
6141  118B
6142  118C
6143  118D
6144  118E
6145  118F
6146  1190
6147  1191
6148  1192
6149  1193
6150  1194
6151  1195
6152  1196
6153  1197
6154  1198
6155  1199
6156  119A
6157  119B
6158  119C
6159  119D
6160  119E
6161  119F
6162  11A0
6163  11A1
6164  11A2
6165  11A3
6166  11A4
6167  11A5
6168  11A6
6169  11A7
6170  11A8
6171  11A9
6172  11AA
6173  11AB
6174  11AC
6175  11AD
6176  11AE
6177  11AF
6178  11B0
6179  11B1
6180  11B2
6181  11B3
6182  11B4
6183  11B5
6184  11B6
6185  11B7
6186  11B8
6187  11B9
6188  11BA
6189  11BB
6190  11BC
6191  11BD
6192  11BE
6193  11BF
6194  11C0
6195  11C1
6196  11C2
6197  11C3
6198  11C4
6199  11C5
6200  11C6
6201  11C7
6202  11C8
6203  11C9
6204  11CA
6205  11CB
6206  11CC
6207  11CD
6208  11CE
6209  11CF
6210  11D0
6211  11D1
6212  11D2
6213  11D3
6214  11D4
6215  11D5
6216  11D6
6217  11D7
6218  11D8
6219  11D9
6220  11DA
6221  11DB
6222  11DC
6223  11DD
6224  11DE
6225  11DF
6226  11E0
6227  11E1
6228  11E2
6229  11E3
6230  11E4
6231  11E5
6232  11E6
6233  11E7
6234  11E8
6235  11E9
6236  11EA
6237  11EB
6238  11EC
6239  11ED
6240  11EE
6241  11EF
6242  11F0
6243  11F1
6244  11F2
6245  11F3
6246  11F4
6247  11F5
6248  11F6
6249  11F7
6250  11F8
6251  11F9
6252  11FA
6253  11FB
6254  11FC
6255  11FD
6256  11FE
6257  11FF
6258  1200
6259  1201
6260  1202
6261  1203
6262  1204
6263  1205
6264  1206
6265  1207
6266  1208
6267  1209
6268  120A
6269  120B
6270  120C
6271  120D
6272  120E
6273  120F
6274  1210
6275  1211
6276  1212
6277  1213
6278  1214
6279  1215
6280  1216
6281  1217
6282  1218
6283  1219
6284  121A
6285  121B
6286  121C
6287  121D
6288  121E
6289  121F
6290  1220
6291  1221
6292  1222
6293  1223
6294  1224
6295  1225
6296  1226
6297  1227
6298  1228
6299  1229
6300  122A
6301  122B
6302  122C
6303  122D
6304  122E
6305  122F
6306  1230
6307  1231
6308  1232
6309  1233
6310  1234
6311  1235
6312  1236
6313  1237
6314  1238
6315  1239
6316  123A
6317  123B
6318  123C
6319  123D
6320  123E
6321  123F
6322  1240
6323  1241
6324  1242
6325  1243
6326  1244
6327  1245
6328  1246
6329  1247
6330  1248
6331  1249
6332  124A
6333  124B
6334  124C
6335  124D
6336  124E
6337  124F
6338  1250
6339  1251
6340  1252
6341  1253
6342  1254
6343  1255
6344  1256
6345  1257
6346  1258
6347  1259
6348  125A
6349  125B
6350  125C
6351  125D
6352  125E
6353  125F
6354  1260
6355  1261
6356  1262
6357  1263
6358  1264
6359  1265
6360  1266
6361  1267
6362  1268
6363  1269
6364  126A
6365  126B
6366  126C
6367  126D
6368  126E
6369  126F
6370  1270
6371  1271
6372  1272
6373  1273
6374  1274
6375  1275
6376  1276
6377  1277
6378  1278
6379  1279
6380  127A
6381  127B
6382  127C
6383  127D
6384  127E
6385  127F
6386  1280
6387  1281
6388  1282
6389  1283
6390  1284
6391  1285
6392  1286
6393  1287
6394  1288
6395  1289
6396  128A
6397  128B
6398  128C
6399  128D
6400  128E
6401  128F
6402  1290
6403  1291
6404  1292
6405  1293
6406  1294
6407  1295
6408  1296
6409  1297
6410  1298
6411  1299
6412  129A
6413  129B
6414  129C
6415  129D
6416  129E
6417  129F
6418  12A0
6419  12A1
6420  12A2
6421  12A3
6422  12A4
6423  12A5
6424  12A6
6425  12A7
6426  12A8
6427  12A9
6428  12AA
6429  12AB
6430  12AC
6431  12AD
6432  12AE
6433  12AF
6434  12B0
6435  12B1
6436  12B2
6437  12B3
6438  12B4
6439  12B5
6440  12B6
6441  12B7
6442  12B8
6443  12B9
6444  12BA
6445  12BB
6446  12BC
6447  12BD
6448  12BE
6449  12BF
6450  12C0
6451  12C1
6452  12C2
6453  12C3
6454  12C4
6455  12C5
6456  12C6
6457  12C7
6458  12C8
6459  12C9
6460  12CA
6461  12CB
6462  12CC
6463  12CD
6464  12CE
6465  12CF
6466  12D0
6467  12D1
6468  12D2
6469  12D3
6470  12D4
6471  12D5
6472  12D6
6473  12D7
6474  12D8
6475  12D9
6476  12DA
6477  12DB
6478  12DC
6479  12DD
6480  12DE
6481  12DF
6482  12E0
6483  12E1
6484  12E2
6485  12E3
6486  12E4
6487  12E5
6488  12E6
6489  12E7
6490  12E8
6491  12E9
6492  12EA
6493  12EB
6494  12EC
6495  12ED
6496  12EE
6497  12EF
6498  12F0
6499  12F1
6500  12F2
6501  12F3
6502  12F4
6503  12F5
6504  12F6
6505  12F7
6506  12F8
6507  12F9
6508  12FA
6509  12FB
6510  12FC
6511  12FD
6512  12FE
6513  12FF
6514  1300
6515  1301
6516  1302
6517  1303
6518  1304
6519  1305
6520  1306
6521  1307
6522  1308
6523  1309
6524  130A
6525  130B
6526  130C
6527  130D
6528  130E
6529  130F
6530  1310
6531  1311
6532  1312
6533  1313
6534  1314
6535  1315
6536  1316
6537  1317
6538  1318
6539  1319
6540  131A
6541  131B
6542  131C
6543  131D
6544  131E
6545  131F
6546  1320
6547  1321
6548  1322
6549  1323
6550  1324
6551  1325
6552  1326
6553  1327
6554  1328
6555  1329
6556  132A
6557  132B
6558  132C
6559  132D
6560  132E
6561  132F
6562  1330
6563  1331
6564  1332
6565  1333
6566  1334
6567  1335
6568  1336
6569  1337
6570  1338
6571  1339
6572  133A
6573  133B
6574  133C
6575  133D
6576  133E
6577  133F
6578  1340
6579  1341
6580  1342
6581  1343
6582  1344
6583  1345
6584  1346
6585  1347
6586  1348
6587  1349
6588  134A
6589  134B
6590  134C
6591  134D
6592  134E
6593  134F
6594  1350
6595  1351
6596  1352
6597  1353
6598  1354
6599  1355
6600  1356
6601  1357
6602  1358
6603  1359
6604  135A
6605  135B
6606  135C
6607  135D
6608  135E
6609  135F
6610  1360
6611  1361
6612  1362
6613  1363
6614  1364
6615  1365
6616  1366
6617  1367
6618  1368
6619  1369
6620  136A
6621  136B
6622  136C
6623  136D
6624  136E
6625  136F
6626  1370
6627  1371
6628  1372
6629  1373
6630  1374
6631  1375
6632  1376
6633  1377
6634  1378
6635  1379
6636  137A
6637  137B
6638  137C
6639  137D
6640  137E
6641  137F
6642  1380
6643  1381
6644  1382
6645  1383
6646  1384
6647  1385
6648  1386
6649  1387
6650  1388
6651  1389
6652  138A
6653  138B
6654  138C
6655  138D
6656  138E
6657  138F
6658  1390
6659  1391
6660  1392
6661  1393
6662  1394
6663  1395
6664  1396
6665  1397
6666  1398
6667  1399
6668  139A
6669  139B
6670  139C
6671  139D
6672  139E
6673  139F
6674  13A0
6675  13A1
6676  13A2
6677  13A3
6678  13A4
6679  13A5
6680  13A6
6681  13A7
6682  13A8
6683  13A9
6684  13AA
6685  13AB
6686  13AC
6687  13AD
6688  13AE
6689  13AF
6690  13B0
6691  13B1
6692  13B2
6693  13B3
6694  13B4
6695  13B5
6696  13B6
6697  13B7
6698  13B8
6699  13B9
6700  13BA
6701  13BB
6702  13BC
6703  13BD
6704  13BE
6705  13BF
6706  13C0
6707  13C1
6708  13C2
6709  13C3
6710  13C4
6711  13C5
6712  13C6
6713  13C7
6714  13C8
6715  13C9
6716  13CA
6717  13CB
6718  13CC
6719  13CD
6720  13CE
6721  13CF
6722  13D0
6723  13D1
6724  13D2
6725  13D3
6726  13D4
6727  13D5
6728  13D6
6729  13D7
6730  13D8
6731  13D9
6732  13DA
6733  13DB
6734  13DC
6735  13DD
6736  13DE
6737  13DF
6738  13E0
6739  13E1
6740  13E2
6741  13E3
6742  13E4
6743  13E5
6744  13E6
6745  13E7
6746  13E8
6747  13E9
6748  13EA
6749  13EB
6750  13EC
6751  13ED
6752  13EE
6753  13EF
6754  13F0
6755  13F1
6756  13F2
6757  13F3
6758  13F4
6759  13F5
6760  13F6
6761  13F7
6762  13F8
6763  13F9
6764  13FA
6765  13FB
6766  13FC
6767  13FD
6768  13FE
6769  13FF
6770  1400
6771  1401
6772  1402
6773  1403
6774  1404
6775  1405
6776  1406
6777  1407
6778  1408
6779  1409
6780  140A
6781  140B
6782  140C
6783  140D
6784  140E
6785  140F
6786  1410
6787  1411
6788  1412
6789  1413
6790  1414
6791  1415
6792  1416
6793  1417
6794  1418
6795  1419
6796  141A
6797  141B
6798  141C
6799  141D
6800  141E
6801  141F
6802  1420
6803  1421
6804  1422
6805  1423
6806  1424
6807  1425
6808  1426
6809  1427
6810  1428
6811  1429
6812  142A
6813  142B
6814  142C
6815  142D
6816  142E
6817  142F
6818  1430
6819  1431
6820  1432
6821  1433
6822  1434
6823  1435
6824  1436
6825  1437
6826  1438
6827  1439
6828  143A
6829  143B
6830  143C
6831  143D
6832  143E
6833  143F
6834  1440
6835  1441
6836  1442
6837  1443
6838  1444
6839  1445
6840  1446
6841  1447
6842  1448
6843  1449
6844  144A
6845  144B
6846  144C
6847  144D
6848  144E
6849  144F
6850  1450
6851  1451
6852  1452
6853  1453
6854  1454
6855  1455
6856  1456
6857  1457
6858  1458
6859  1459
6860  145A
6861  145B
6862  145C
6863  145D
6864  145E
6865  145F
6866  1460
6867  1461
6868  1462
6869  1463
6870  1464
6871  1465
6872  1466
6873  1467
6874  1468
6875  1469
6876  146A
6877  146B
6878  146C
6879  146D
6880  146E
6881  146F
6882  1470
6883  1471
6884  1472
6885  1473
6886  1474
6887  1475
6888  1476
6889  1477
6890  1478
6891  1479
6892  147A
6893  147B
6894  147C
6895  147D
6896  147E
6897  147F
6898  1480
6899  1481
6900  1482
6901  1483
6902  1484
6903  1485
6904  1486
6905  1487
6906  1488
6907  1489
6908  148A
6909  148B
6910  148C
6911  148D
6912  148E
6913  148F
6914  1490
6915  1491
6916  1492
6917  1493
6918  1494
6919  1495
6920  1496
6921  1497
6922  1498
6923  1499
6924  149A
6925  149B
6926  149C
6927  149D
6928  149E
6929  149F
6930  14A0
6931  14A1
6932  14A2
6933  14A3
6934  14A4
6935  14A5
6936  14A6
6937  14A7
6938  14A8
6939  14A9
6940  14AA
6941  14AB
6942  14AC
6943  14AD
6944  14AE
6945  14AF
6946  14B0
6947  14B1
6948  14B2
6949  14B3
6950  14B4
6951  14B5
6952  14B6
6953  14B7
6954  14B8
6955  14B9
6956  14BA
6957  14BB
6958  14BC
6959  14BD
6960  14BE
6961  14BF
6962  14C0
6963  14C1
6964  14C2
6965  14C3
6966  14C4
6967  14C5
6968  14C6
6969  14C7
6970  14C8
6971  14C9
6972  14CA
6973  14CB
6974  14CC
6975  14CD
6976  14CE
6977  14CF
6978  14D0
6979  14D1
6980  14D2
6981  14D3
6982  14D4
6983  14D5
6984  14D6
6985  14D7
6986  14D8
6987  14D9
6988  14DA
6989  14DB
6990  14DC
6991  14DD
6992  14DE
6993  14DF
6994  14E0
6995  14E1
6996  14E2
6997  14E3
6998  14E4
6999  14E5
7000  14E6
7001  14E7
7002  14E8
7003  14E9
7004  14EA
7005  14EB
7006  14EC
7007  14ED
7008  14EE
7009  14EF
7010  14F0
7011  14F1
7012  14F2
7013  14F3
7014  14F4
7015  14F5
7016  14F6
7017  14F7
7018  14F8
7019  14F9
007020  000295        
007021  000296      var vIAngularMeter0[WIDGET_RAM_SPACE] ;
007022  000297      var vIAngularMeter1[WIDGET_RAM_SPACE] ;
007023  000298      var vILedDigits0[WIDGET_RAM_SPACE+2] ;
007024  000299      var vIAngularMeter3[WIDGET_RAM_SPACE] ;
007025  000300      var vILedDigits1[WIDGET_RAM_SPACE+2] ;
007026  000301      var vILedDigits2[WIDGET_RAM_SPACE+2] ;
007027  000302      var vILedDigits3[WIDGET_RAM_SPACE+2] ;
007028  000303      var vIAngularMeter2[WIDGET_RAM_SPACE] ;
007029  000304      var vILedDigits4[WIDGET_RAM_SPACE+2] ;
007030  000305      var vILedDigits6[WIDGET_RAM_SPACE+2] ;
007031  000306      var vILedDigits7[WIDGET_RAM_SPACE+2] ;
007032  000307      var vILedDigits8[WIDGET_RAM_SPACE+2] ;
007033  000308      var vILedDigits5[WIDGET_RAM_SPACE+2] ;
007034  000309      var vILedDigits9[WIDGET_RAM_SPACE+2] ;
007035  000310  var stringsCV[33] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], hstrings ;
7036  0AC2
7037  0AC3
7038  0AC4
7039  0AC5
7040  0AC6
7041  0AC7
7042  0AC8
7043  0AC9
7044  0ACA
7045  0ACB
7046  0ACC
7047  0ACD
7048  0ACE
7049  0ACF
7050  0AD0
7051  0AD1
7052  0AD2
7053  0AD3
7054  0AD4
7055  0AD5
7056  0AD6
7057  0AD7
7058  0AD8
7059  0AD9
7060  0ADA
7061  0ADB
7062  0ADC
7063  0ADD
7064  0ADE
7065  0ADF
7066  0AE0
7067  0AE1
7068  0AE2
7069  0AE3
7070  0AE4
7071  0AE5
7072  0AE6
7073  0AE7
7074  0AE8
7075  0AE9
7076  0AEA
7077  0AEB
7078  0AEC
7079  0AED
7080  0AEE
7081  0AEF
7082  0AF0
7083  0AF1
7084  0AF2
7085  0AF3
7086  0AF4
7087  0AF5
7088  0AF6
7089  0AF7
7090  0AF8
7091  0AF9
7092  0AFA
7093  0AFB
7094  0AFC
7095  0AFD
7096  0AFE
7097  0AFF
7098  0B00
7099  0B01
7100  0B02
7101  0B03
007102  000311  // Start P2.inc
007103  000312  var vObjects[MaxIntObjects+1] ;              // address of RAM objects
007104  000313  var GObjectIdx, GObjectFunc, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings ;
007105  000314  var oObjects[MaxTotObjects+1] ;                 // address of objects
007106  000315  var CurrentForm, oldn, ImageTouched ;
007107  000316  var TouchXpos, TouchYpos ;
007108  000317  var GObjectType, TouchState, CurInputData, pInputIndex ;
007109  000318  var comRX[40], cmd[CMDLenMAX] ;
007110  000319        
007111  000320  var InputCS, OutputCS ;
007112  000321        
007113  000322  // > ? Constant/Global/Data ? <
007114  000323        
007115  000324  func addressInternalWidget(var idx var iponly)
007116  000325      var i, j ;
007117  000326  //to(COM0) ; print("Address Int ", idx, " ") ; pause(2) ;
007118  000327      GObjectIdx := xobj2iobj[idx] ;
007119  000328      GObjectType := (GObjectIdx>>8) ;                          // extract object type
007120  000329      i := oObjects[GObjectType] ;                              // i is address of list of all objects of this type
007121  000330      GObjectIdx &= 0xff ;
007122  000331      //GObjectIdx *= 2 ;
007123  000332      j := GObjectIdx * 2 ;
007124  000333      GObjectDATA := i[j + 2] ;                                 // address of this object
007125  000334      i := vObjects[GObjectType-tiAngularMeter] ;               // i is address of list of all ram objects of his type
007126  000335      GObjectRAM := i[j] ;                                      // address of this objects' ram
007127  000336      i := GObjectType-tiAngularMeter ;
007128  000337      GObjectFunc := gfxInternals[i] ; // address function
007129  000338      GObjectParms := gfxIntParms[i] ;
007130  000339      GObjectStrings := gfxIntStrings[i] ;
007131  000340  //to(COM0) ; print([HEX4] GObjectFunc, " ", [HEX4] GObjectRAM, " ", [HEX4] GObjectDATA, " ", GObjectType, " ", GObjectIdx, "\r\n") ;
007132  000341  //    GObjectFunc(0, GObjectRAM, GObjectDATA) ;
007133  000342  endfunc
007134  000343        
007135  000344  func seroutCS(var op)
007136  000345      serout(op) ;
007137  000346      OutputCS ^= op ;
007138  000347  endfunc
007139  000348        
007140  000349  func nak0()
007141  000350      serout(NAK) ;
007142  000351      InputCS := 0 ;
007143  000352  endfunc
007144  000353        
007145  000354  func seroutOcs()
007146  000355      serout(OutputCS) ;
007147  000356      OutputCS := 0 ;
007148  000357  endfunc
007149  000358        
007150  000359  func SendReport(var id, var objt, var objn, var val)
007151  000360      seroutCS(id) ;
007152  000361      seroutCS(objt) ;
007153  000362      seroutCS(objn) ;
007154  000363      seroutCS(val >> 8) ; // first 8 bits
007155  000364      seroutCS(val) ;
007156  000365      seroutOcs() ;
007157  000366  endfunc
007158  000367        
007159  000368        
007160  000369  func ReadObject(var ObjectType, var ObjectIdx)
007161  000370      var j, k, Objects ;
007162  000371      if ((ObjectType >= tiLedDigitsH) && (ObjectType <= tiLinearInput))
007163  000372          j := ObjectIdx *2 ;
007164  000373          k := vObjects[ObjectType-tiAngularMeter] ;               // k is address of list of all ram objects of his type
007165  000374          k := k[j] ;                                              // k is address of this objects' ram
007166  000375          if (ObjectType == tiLedDigit)
007167  000376              k := k[0] ;
007168  000377          else 
007169  000378              k := k[WIDGET_VAL1] ;
007170  000379          endif
007171  000380  //gfx_MoveTo(0,0); txt_Opacity(OPAQUE) ; print(ObjectType, " ", ObjectIdx, " ", k," ") ;
007172  000381      else
007173  000382      Objects := *(oObjects+ObjectType) ;
007174  000383        
007175  000384      j := 2 + ObjectIdx * 2 + Objects ;
007176  000385       if (ObjectType == tForm)
007177  000386          k := CurrentForm ;
007178  000387      else if (ObjectType == tStrings)
007179  000388          k := stringsCV[ObjectIdx];
007180  000389          else
007181  000390          k := img_GetWord(hndl, *j, IMAGE_INDEX);
007182  000391          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
007183  000392                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
007184  000393      endif
007185  000394      endif
007186  000395      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
007187  000396  endfunc
007188  000397        
007189  000398  var wp ;
007190  000399        
007191  000400        
007192  000401  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
007193  000402      var i, j, k, Objects ;
007194  000403  //    ObjectType &= 0x3f ; Why was his there? Anibuttons? Complex cascades?
007195  000404      if (ObjectType == tForm)
007196  000405          ActivateForm(ObjectIdx) ;
007197  000406          return ;
007198  000407      endif
007199  000408      Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
007200  000409      i := *(Objects) ;
007201  000410      if ((ObjectType >= tiAngularMeter) && (ObjectType <= tiLinearInput))
007202  000411          i := oObjects[ObjectType] ;                              // f is address of list of all objects of this type
007203  000412          j := ObjectIdx *2 ;
007204  000413          i := i[j + 2] ;                         // f is address of this object
007205  000414          k := vObjects[ObjectType-tiAngularMeter] ;               // a is address of list of all ram objects of his type
007206  000415          k := k[j] ;                             // a is address of this objects' ram
007207  000416              j := ObjectType-tiAngularMeter ;
007208  000417              Objects := gfxInternals[j] ;           // locate function address   
007209  000418              Objects(NewVal, k, i) ; 
007210  000419          return ;
007211  000420      endif
007212  000421      switch (ObjectType)
007213  000422          case tWinButton :
007214  000423              j := InputControls[oWinButtons[ObjectIdx+1]] ;
007215  000424              break ;
007216  000425          case tUserButton :
007217  000426              j := InputControls[oUserButtons[ObjectIdx+1]] ;
007218  000427              break ;
007219  000428          default : j := -1 ;
007220  000429      endswitch
007221  000430        
007222  000431      if (j != -1)
007223  000432          k := img_GetWord(hndl, i , IMAGE_INDEX) ;
007224  000433              NewVal := NewVal << 1 ;
007225  000434              if (OVF())      // button group index change
007226  000435                  if (*(j+InputData+Ofs_IPD_P1))
007227  000436                      k &= 1 ;    // mask off old group index for momentary
007228  000437                  else
007229  000438                      k &= 3 ;    // mask off old group index for toggle
007230  000439                  endif
007231  000440              else            // normal set
007232  000441                  if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
007233  000442                  k &= 0xfffc ;    // retain only group index for state set
007234  000443              endif
007235  000444              NewVal |= k ;
007236  000445  //        endif
007237  000446          endif
007238  000447        
007239  000448          if (ObjectType == tStrings)
007240  000449              PrintStrings(ObjectIdx, NewVal, 0);
007241  000450              return ;
007242  000451          endif
007243  000452      img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
007244  000453      img_Show(hndl, i) ; // will only display if form is current
007245  000454      return ; // compiler bug circumvention!
007246  000455  endfunc
007247  000456        
007248  000457  func TurnOffButtons(var group)
007249  000458      var j, k, l, m, n, o, p;
007250  000459      m := GObjectIdx ;     // save as will be clobbered
007251  000460      n := GObjectType ;     // save as will be clobbered
007252  000461      for (j := 0; j < nInputs; j++)
007253  000462          k := j*IPDatasize ;
007254  000463          if (*(InputData+k+Ofs_IPD_P2) == group)
007255  000464              l := -1 ;
007256  000465               if (*(InputData+k) == tWinButton)
007257  000466                  l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007258  000467                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
007259  000468                  img_Show(hndl, l);      // only shows on current form
007260  000469        
007261  000470              else if (*(InputData+k) == tUserButton)
007262  000471                  l := oUserButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007263  000472                  img_SetWord(hndl, l, IMAGE_INDEX, img_GetWord(hndl, l, IMAGE_INDEX) & 0xfffc );
007264  000473                  img_Show(hndl, l);      // only shows on current form
007265  000474              endif
007266  000475          endif
007267  000476      next
007268  000477      GObjectIdx := m ;     // Restore
007269  000478      GObjectType := n ;    // Restore
007270  000479  endfunc
007271  000480        
007272  000481        
007273  000482        
007274  000483        
007275  000484  func ActivateForm(var newform)
007276  000485      var i, j, *p ;
007277  000486        
007278  000487          widget_Disable(wp, ALL) ;
007279  000488      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
007280  000489          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
007281  000490              if (img_GetWord(hndl, i, IMAGE_TAG))
007282  000491                  img_Disable(hndl,i) ;
007283  000492              endif
007284  000493          next
007285  000494      endif
007286  000495      CurrentForm := newform ;
007287  000496      // display newform image or clear to image color
007288  000497      if (FormBGcolors[CurrentForm] != ColorBGimage)
007289  000498          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
007290  000499          gfx_Cls() ;
007291  000500          DoGFXObjects() ;                                    // display GFX 'widgets'
007292  000501      endif
007293  000502        
007294  000503      // enable inputs
007295  000504      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
007296  000505          j := img_GetWord(hndl, i, IMAGE_TAG) ;
007297  000506          if (j)
007298  000507              j-- ;
007299  000508              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
007300  000509              //if (j != tKeyboard)
007301  000510              if (((j <= tWinButton) || (j >= t4Dbutton)) && (j != tSmartGauge) )               // enable inputs
007302  000511                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
007303  000512              endif
007304  000513              img_Show(hndl,i) ; // show initialy, if required
007305  000514              if (j == tForm)
007306  000515                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
007307  000516              endif
007308  000517          endif
007309  000518      next
007310  000519        
007311  000520      // enable inputs
007312  000521         var a, f ; 
007313  000532  */
007314  000533      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007315  000534          addressInternalWidget(i, 0) ;
007316  000535          widget_Enable(wp,i) ;
007317  000536          if (GObjectType != tiLabelB) widget_ClearAttributes(wp,i,WIDGET_F_INITIALISED) ; // don't clear initialised for tiLabelB
007318  000537                  j := GObjectRAM[WIDGET_VAL1] ;
007319  000538                  GObjectFunc(j, GObjectRAM, GObjectDATA) ; 
007320  000539      next
007321  000540      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007322  000541          if (InternalInputControls[i] != -1)
007323  000542              widget_SetAttributes(wp,i,WIDGET_F_TOUCH_ENABLE) ;
007324  000543          endif
007325  000544      next
007326  000545        
007327  000546      for (i := 0; i < nStrings; i++)
007328  000547          if (stringsCV[i] != -1)
007329  000548              WriteObject(tStrings, i, stringsCV[i]) ;
007330  000549          endif
007331  000550      next
007332  000551        
007333  000552  endfunc
007334  000553        
007335  000554  func UpdateObjects(var newval)
007336  000555      var IPidx, otherOBJ, oldvalue ;
007337  000556      if (GObjectType < tiLedDigitsH)
007338  000557          oldvalue := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ;
007339  000558      else
007340  000559          oldvalue := GObjectRAM[WIDGET_VAL1] ;
007341  000560      endif
007342  000561      if ( ( oldvalue != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
007343  000562        
007344  000563      if (GObjectType < tiLedDigitsH)
007345  000564          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
007346  000565              img_Show(hndl, *(pInputIndex));      // only shows on current form
007347  000566      else
007348  000567          WriteObject(GObjectType, GObjectIdx, newval) ;
007349  000568      endif
007350  000569          if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
007351  000570              if (*(CurInputData+Ofs_IPD_P1))
007352  000571                  newval &= 1;
007353  000572              else
007354  000573                  newval &= 3;
007355  000574              endif
007356  000575              if (newval > 1) newval := 1;
007357  000576          endif
007358  000577          IPidx := *(CurInputData+TouchState) ;
007359  000578          while(IPidx != 0)
007360  000579              otherOBJ := IPidx + InputData;
007361  000580              if (*(otherOBJ) == OT_REPORT)
007362  000581                  SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
007363  000582              else if (*(otherOBJ) == OT_MAGIC)
007364  000583                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
007365  000584                  IPidx(newval) ;
007366  000585  //            else if (TouchState == *(otherOBJ+Ofs_IPD_P4))  // test prior to Workshop 6.5.0.0
007367  000586              else if ((TouchState == *(otherOBJ+Ofs_IPD_P4)) || (*(CurInputData+Ofs_IPD_P1) && ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))))
007368  000587                  if (*(otherOBJ) == OT_ACTIVATE)
007369  000588                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
007370  000589                      GObjectType := tForm ;
007371  000590                  else if (*(otherOBJ) == OT_SETCONST)
007372  000591                      newval := *(otherOBJ+Ofs_IPD_P3) ;
007373  000592                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007374  000593                  else if (*(otherOBJ) == OT_SETANOTHER)
007375  000594                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007376  000595                  else if (*(otherOBJ) == OT_PREVFRAME)
007377  000596                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
007378  000597                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
007379  000598                      endif
007380  000599                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007381  000600                  else if (*(otherOBJ) == OT_NEXTFRAME)
007382  000601                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
007383  000602                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
007384  000603                      endif
007385  000604                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007386  000605                  else if (*(otherOBJ) == OT_PREVSTRING)
007387  000606                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)])
007388  000607                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]-1) ;
007389  000608                      endif
007390  000609                  else if (*(otherOBJ) == OT_NEXTSTRING)
007391  000610                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)] < *(otherOBJ+Ofs_IPD_P3)) // fix IPD_P2 not filled in yet
007392  000611                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]+1) ;
007393  000612                      endif
007394  000613                  endif
007395  000614              endif
007396  000615              IPidx := *(otherOBJ+TouchState) ;
007397  000616          wend
007398  000617      endif
007399  000618  endfunc
007400  000619        
007401  000620  // End P2.inc
007402  000621  func DoGFXObjects()
007403  000622  endfunc
007404  000623        
007405  000624  // Start P3.inc
007406  000625  func main()
007407  000626      var comTX[50], cmdi, i, j, TouchStatus ;
007408  000627        
007409  000628        
007410  000629      gfx_ScreenMode(LANDSCAPE) ;
007411  000630        
007412  000631      media_InitFlash(FLASH_ADDR_DEF_COMMAND) ;
007413  000632        
007414  000633        
007415  000634  //    gfx_MoveTo(0, 0);
007416  000635  //    print(mem_Heap()," ") ;
007417  000636  //    gfx_TransparentColour(0x0020);
007418  000637  //    gfx_Transparency(ON);
007419  000638        
007420  000639        
007421  000640      // open image control
007422  000641      hndl := file_LoadImageControl(0, 0, 3);
007423  000642        
007424  000643      // init 'constants'
007425  000644  // End P3.inc
007426  000645        
007427  000646      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
007428  000647      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
007429  000648      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
007430  000649      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
007431  000650      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
007432  000651      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
007433  000652      oObjects[tWinButton] := oWinButtons ;
007434  000653      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
007435  000654      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
007436  000655      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
007437  000656      oObjects[tForm] := oForms ;
007438  000657      oObjects[tGauge] := oGauges ;
007439  000658      oObjects[tImage] := oImages ;
007440  000659      oObjects[tKeyboard] := oDipSwitchs ; // dummy as no object there
007441  000660      oObjects[tLed] := oLeds ;
007442  000661      oObjects[tLeddigits] := oDipSwitchs ; // dummy as no object there
007443  000662      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
007444  000663      oObjects[tStrings] := oStringss ;
007445  000664      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
007446  000665      oObjects[tUserled] := oDipSwitchs ; // dummy as no object there
007447  000666      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
007448  000667      oObjects[tStaticText] := oDipSwitchs ; // dummy as no object there
007449  000668      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
007450  000669      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
007451  000670      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
007452  000671      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
007453  000672      oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
007454  000673      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
007455  000674      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
007456  000675      oObjects[t4Dbutton] := oDipSwitchs ; // dummy as no object there
007457  000676      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
007458  000677      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
007459  000678      oObjects[tUserButton] := oUserButtons ;
007460  000679      oObjects[tMagicObject] := oDipSwitchs ; // dummy as no object there
007461  000680      oObjects[tSmartGauge] := oDipSwitchs ; // dummy as no object there
007462  000681      oObjects[tSmartSlider] := oDipSwitchs ; // dummy as no object there
007463  000682      oObjects[tSmartKnob] := oDipSwitchs ; // dummy as no object there
007464  000683      oObjects[tiLedDigitsH] := oDipSwitchs ; // dummy as no object there
007465  000684      oObjects[tiAngularMeter] := oiAngularMeters ;
007466  000685      oObjects[tiGauge] := oDipSwitchs ; // dummy as no object there
007467  000686      oObjects[tiLabelB] := oDipSwitchs ; // dummy as no object there
007468  000687      oObjects[tiUserGauge] := oDipSwitchs ; // dummy as no object there
007469  000688      oObjects[tiMediaGauge] := oDipSwitchs ; // dummy as no object there
007470  000689      oObjects[tiMediaThermometer] := oDipSwitchs ; // dummy as no object there
007471  000690      oObjects[tiLed] := oDipSwitchs ; // dummy as no object there
007472  000691      oObjects[tiMediaLed] := oDipSwitchs ; // dummy as no object there
007473  000692      oObjects[tiLedDigits] := oiLedDigitss ;
007474  000693      oObjects[tiNeedle] := oDipSwitchs ; // dummy as no object there
007475  000694      oObjects[tiRuler] := oDipSwitchs ; // dummy as no object there
007476  000695      oObjects[tiLedDigit] := oDipSwitchs ; // dummy as no object there
007477  000696      oObjects[tiButtonD] := oDipSwitchs ; // dummy as no object there
007478  000697      oObjects[tiButtonE] := oDipSwitchs ; // dummy as no object there
007479  000698      oObjects[tiMediaButton] := oDipSwitchs ; // dummy as no object there
007480  000699      oObjects[tiToggleInput] := oDipSwitchs ; // dummy as no object there
007481  000700      oObjects[tiDial] := oDipSwitchs ; // dummy as no object there
007482  000701      oObjects[tiMediaRotary] := oDipSwitchs ; // dummy as no object there
007483  000702      oObjects[tiRotaryInput] := oDipSwitchs ; // dummy as no object there
007484  000703      oObjects[tiSwitch] := oDipSwitchs ; // dummy as no object there
007485  000704      oObjects[tiSwitchB] := oDipSwitchs ; // dummy as no object there
007486  000705      oObjects[tiSliderE] := oDipSwitchs ; // dummy as no object there
007487  000706      oObjects[tiMediaSlider] := oDipSwitchs ; // dummy as no object there
007488  000707      oObjects[tiSliderH] := oDipSwitchs ; // dummy as no object there
007489  000708      oObjects[tiSliderG] := oDipSwitchs ; // dummy as no object there
007490  000709      oObjects[tiSliderF] := oDipSwitchs ; // dummy as no object there
007491  000710      oObjects[tiSliderD] := oDipSwitchs ; // dummy as no object there
007492  000711      oObjects[tiSliderC] := oDipSwitchs ; // dummy as no object there
007493  000712      oObjects[tiLinearInput] := oDipSwitchs ; // dummy as no object there
007494  000713      vObjects[0] := oiviAngularMeter ;
007495  000714      vObjects[8] := oiviLedDigits ;
007496  000715  // Start P4.inc
007497  000716      wp := widget_Create(14) ;
007498  000717      for (i := 0; i < 14; i++)
007499  000718  	addressInternalWidget(i, 0) ;
007500  000719          if (GObjectType != tiLedDigit) widget_Add(wp, i, GObjectRAM) ;    // don't add tiLedDigit objects as they are only 1 word long
007501  000720      next
007502  000721        
007503  000722      // init comms
007504  000723      com_Init(comRX,CMDLenMAX,0);
007505  000724      com_SetBaud(COM0,19886);
007506  000725      com_TXbuffer(comTX, 100, 0);
007507  000726      // tag 'real' objects
007508  000727      for (i := 0; i <= MaxTotObjects; i++)
007509  000728          if (   (i != tSounds)
007510  000729              && (i != tTimer)
007511  000730              && (i != tPinOutput)
007512  000731              && (i != tMagicObject)
007513  000732              && (i != tPinInput) )
007514  000733              TouchXpos := oObjects[i] ;
007515  000734              TouchYpos := *(TouchXpos) ;
007516  000735              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
007517  000736                  oldn := *(TouchXpos+ImageTouched*2) ;
007518  000737                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
007519  000738                  if (oldn != -1)
007520  000739                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
007521  000740                      img_Disable(hndl, oldn) ;
007522  000741                  endif
007523  000742              next
007524  000743          endif
007525  000744      next
007526  000745        
007527  000746      // display initial form
007528  000747      CurrentForm := -1 ;
007529  000748  // End P4.inc
007530  000749  // Start P5.inc
007531  000750      ActivateForm(0) ; // need to change this according to first actual form
007532  000751        
007533  000752  // End P5.inc
007534  000753  // Start P6.inc px44
007535  000754      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
007536  000755      oldn := -1 ;
007537  000756      repeat
007538  000757        
007539  000758          // check comms for command, how to NAK invalid command
007540  000759          if (com_Count() != 0)
007541  000760              i := serin() ;
007542  000761              InputCS ^= i ;               // update checksum
007543  000762              if (   (cmdi > 2)
007544  000763                  && (cmd[0] == WRITE_STRU) )
007545  000764                  j := (cmdi-1) >> 1 + 2 ;
007546  000765                  if (j == CMDLenMAX)    // max length exceeded
007547  000766                      nak0() ;
007548  000767                      cmdi := -1 ;
007549  000768                  else if (cmdi & 1)
007550  000769                      cmd[j] := i ;
007551  000770                      if (cmd[2] == 0)    // if string complete
007552  000771                          if (InputCS)
007553  000772                              nak0() ;
007554  000773                          else
007555  000774                              if (cmd[0] == WRITE_STRU)
007556  000775                              cmd[j] := 0 ;                     // terminate it
007557  000776                              PrintStrings(cmd[1], &cmd[3], 1) ;
007558  000777                              serout(ACK) ;
007559  000778                              else
007560  000779                              endif
007561  000780                          endif
007562  000781                          cmdi := -1 ;
007563  000782                      endif
007564  000783                  else
007565  000784                      cmd[j] := cmd[j] << 8 + i ;
007566  000785                      cmd[2]-- ;          // dec length
007567  000786                  endif
007568  000787                  cmdi++ ;
007569  000788              else // not unicode string
007570  000789                  cmd[cmdi++] := i ;
007571  000790                   if ((cmd[0] == WRITE_STR) || (cmd[0] == WRITE_LABEL) )                  // Ansi String or Label
007572  000791                      if (cmdi == CMDLenMAX)      // max length exceeded
007573  000792                          nak0() ;
007574  000793                          cmdi := 0 ;
007575  000794                      else if (cmdi > 2)
007576  000795                          if (cmd[2] == -1)
007577  000796                              if (InputCS)
007578  000797                                  nak0() ;
007579  000798                              else
007580  000799                                  if ((cmd[0] == WRITE_STR) || (cmd[0] == WRITE_LABEL))
007581  000800                                  cmd[cmdi-1] := 0 ;                     // terminate it
007582  000801                                  PrintStrings(cmd[1], &cmd[3], 1) ;
007583  000802                                  serout(ACK) ;
007584  000803                                  else
007585  000804                                  endif
007586  000805                              endif
007587  000806                              cmdi := 0 ;
007588  000807                          else
007589  000808                              cmd[2]-- ;          // dec length
007590  000809                          endif
007591  000810                      endif
007592  000811                  else if (   (cmd[0] == READ_OBJ)
007593  000812                           && (cmdi == 4)         )
007594  000813                      if (InputCS)
007595  000814                          nak0() ;
007596  000815                      else
007597  000816                          ReadObject(cmd[1], cmd[2]) ;
007598  000817                      endif
007599  000818                      cmdi := 0 ;
007600  000819                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
007601  000820                           && (cmdi == 6)          )
007602  000821                      if (InputCS)
007603  000822                          nak0() ;
007604  000823                      else
007605  000824                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
007606  000825                          serout(ACK) ;
007607  000826                      endif
007608  000827                      cmdi := 0 ;
007609  000828                  else if (   (cmd[0] == WRITE_CONTRAST)
007610  000829                           && (cmdi == 3)         )
007611  000830                      if (InputCS)
007612  000831                          nak0() ;
007613  000832                      else
007614  000833                          gfx_Contrast(cmd[1]) ;
007615  000834                          serout(ACK) ;
007616  000835                      endif
007617  000836                      cmdi := 0 ;
007618  000837                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
007619  000838                      nak0() ;
007620  000839                      cmdi := 0 ;
007621  000840                  endif
007622  000841              endif   // not unicode string
007623  000842          endif   // a character is available
007624  000843        
007625  000844        
007626  000845      // touch code processing
007627  000846        
007628  000847          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
007629  000848          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
007630  000849              ImageTouched := img_Touched(hndl,-1) ;
007631  000850              if (ImageTouched == -1)
007632  000851                  ImageTouched := widget_Touched(wp, ALL) ;
007633  000852                  if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
007634  000853              endif
007635  000854              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
007636  000855                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
007637  000856              endif
007638  000857              if (TouchStatus != TOUCH_RELEASED)        // if not released
007639  000858                  if (oldn != -1)
007640  000859                      ImageTouched := oldn ;
007641  000860                  else
007642  000861                      if (oldn != ImageTouched)
007643  000862                  oldn := ImageTouched ;
007644  000863                          TouchStatus := TOUCH_PRESSED ;
007645  000864                      endif
007646  000865                  endif
007647  000866                  TouchXpos  := touch_Get(TOUCH_GETX);
007648  000867                  TouchYpos  := touch_Get(TOUCH_GETY);
007649  000868                  TouchState := Ofs_IPD_DOWN ;
007650  000869              else
007651  000870                  ImageTouched := oldn ;                     // simulate release of what we touched
007652  000871                  oldn := -1 ;                    // prevent double release
007653  000872                  TouchState := Ofs_IPD_RELEASE ;
007654  000873              endif
007655  000874              if (TouchStatus == TOUCH_PRESSED)
file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.ImgData\MagicTouch.inc

007656  000875  #inherit "MagicTouch.inc"
007657  000875  #inherit "MagicTouch.inc"
007658  000001  //
007659  000002  // Added 2/14/2023 4:58:40 PM
007660  000003  //
007661  000004  // Use 'ImageTouched' to detect 'current' object compare to values such as iWinbutton0
007662  000005  // to determine the object for which a touch has just been detected.
007663  000006  //
007664  000007        
007665  000008  //ActivateForm(1); // Change to Form 1
007666  000876              endif
007667  000877              if (ImageTouched >= 0)
007668  000878                          CurInputData := InputControls[ImageTouched] + InputData;
007669  000879                          GObjectType := *(CurInputData) ;
007670  000880                          if (GObjectType == tSmartSlider)
007671  000881                              i := tTrackbar ; // GSlider ;
007672  000882                          else if (GObjectType == tSmartKnob)
007673  000883                              i := tKnob ;
007674  000884                          else if (GObjectType >= t4Dbutton) 
007675  000885                              i := GObjectType - 23 ; // adjust to ensure next in gosub
007676  000886                          else 
007677  000887                              i := GObjectType ;
007678  000888                          endif
007679  000889                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007680  000890                          ImageTouched := -1 ; // show processed here
007681  000891              endif
007682  000892              if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
007683  000893              if (ImageTouched >= 0)
007684  000894  //print(ImageTouched," ") ;
007685  000895  //                        CurInputData := InternalInputControls[ImageTouched] + InternalInputData;
007686  000896                          CurInputData := InternalInputControls[ImageTouched] + InputData;
007687  000897  //                        GObjectType := *(CurInputData) ;
007688  000898  //                        i := GObjectType ;
007689  000899  //                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
007690  000900  //                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
007691  000901                          addressInternalWidget(ImageTouched, 0) ;
007692  000902  //                        i := xobj2iiobj[ImageTouched] ;                            // address object type and hash from ram index
007693  000903  //                        GObjectIdx := i & 0xff ;
007694  000904  //                        GObjectType := (i>>8) ;                                   // extract object type
007695  000905                          if (GObjectType <= tiToggleInput) 
007696  000906                              i := 0 ;
007697  000907                          else if (GObjectType <= tiRotaryInput) 
007698  000908                              i := 1 ;
007699  000909                          else if (GObjectType <= tiSwitchB) 
007700  000910                              i := 2 ;
007701  000911                          else 
007702  000912                              i := 3 ;
007703  000913                          endif
007704  000914  //to(COM0) ; print(i, "\r\n") ;  
007705  000915        
007706  000916                          gosub (i), (ciButton, ciDial, ciSwitch, ciSlider) ;
007707  000917        
007708  000918        
007709  000919  //            ImageTouched := widget_Touched(wp, ALL) ;
007710  000920              endif
007711  000921          endif
007712  000922   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
007713  000923        
007714  000924          sys_EventsResume() ;
007715  000925      forever
007716  000926        
007717  000927  ciSwitch:
007718  000928  cDipswitch:
007719  000929        
007720  000930  cKnob:
007721  000931  ciDial:
007722  000932        
007723  000933  cRockerswitch:
007724  000934        
007725  000935  cRotaryswitch:
007726  000936        
007727  000937  cSlider:
007728  000938  cTrackbar:
007729  000939  ciSlider:
007730  000940        
007731  000941  ciButton:
007732  000942        
007733  000943  c4DButton:
007734  000944  cUserButton:
007735  000945  cWinbutton:
007736  000946      pInputIndex := oObjects[GObjectType]  + *(CurInputData+Ofs_IPD_OBJVIDX) ;
007737  000947      i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
007738  000948  CommonButtons:
007739  000949      if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
007740  000950          if (TouchStatus == TOUCH_RELEASED)
007741  000951              i &= 0xfffe ;
007742  000952              TouchState == Ofs_IPD_DOWN ;
007743  000953          else
007744  000954              i |= 1 ;
007745  000955              TouchState == Ofs_IPD_RELEASE ;
007746  000956          endif
007747  000957      else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
007748  000958          if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
007749  000959              if ((i & 3) == 3)
007750  000960                  i &= 0xfffc ;
007751  000961              else
007752  000962                  i++ ;
007753  000963              endif
007754  000964          else
007755  000965              i |= 1 ;                                      // make down regardless of current state
007756  000966          endif
007757  000967      else                        // group action, up all other buttons on touch press, reports 0 for button down
007758  000968          if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
007759  000969              TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
007760  000970          endif
007761  000971          if (GObjectType < tiLedDigits)
007762  000972              i := (i & 0xfffc) | 2 ;         // uSD button, four, grouping and blocking states
007763  000973          else
007764  000974              i := 1 ;                        // Internal button two states
007765  000975          endif
007766  000976      endif
007767  000977        
007768  000978      UpdateObjects(i) ;
007769  000979  endsub ;
007770  000980        
007771  000981  cAniButton:
007772  000982        
007773  000983  cColorPicker:
007774  000984        
007775  000985  endfunc
007776  000986  // End P6.inc
Notice: variable 'GObjectRAM' is being indexed (line 559 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'IPidx' requires 1 argument (line 584 file:SprinterGauge.4DGenieS)
Notice: variable 'GObjectRAM' is being indexed (line 537 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'GObjectFunc' requires 3 arguments (line 538 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 485 file:SprinterGauge.4DGenieS)
Notice: local var 'a' in func 'ActivateForm' is never used (line 521 file:SprinterGauge.4DGenieS)
Notice: local var 'f' in func 'ActivateForm' is never used (line 521 file:SprinterGauge.4DGenieS)
Notice: local var 'o' in func 'TurnOffButtons' is never used (line 458 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'TurnOffButtons' is never used (line 458 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 413 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 415 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'Objects' requires 3 arguments (line 418 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 374 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 376 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 378 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 333 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 335 file:SprinterGauge.4DGenieS)
Notice: function argument 'iponly' in func 'addressInternalWidget' is never used (line 324 file:SprinterGauge.4DGenieS)


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXFLASH                           128  0x00000080 (const dword)  (not used)
__MAXMEM                           30290  0x00007652 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             4  0x00000004 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 12)
ActivateForm                        5813  0x000016b5 (User func) args[1] r=0  (usage 9)
addressInternalWidget               7319  0x00001c97 (User func) args[2] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (usage 6)
ANALOGUE                               2  0x00000002 (const dword)  (not used)
ANGULAR_bgcol                         66  0x00000042 (const dword)  (not used)
ANGULAR_c1                            24  0x00000018 (const dword)  (not used)
ANGULAR_c2                            26  0x0000001a (const dword)  (not used)
ANGULAR_c3                            28  0x0000001c (const dword)  (not used)
ANGULAR_capcol                        46  0x0000002e (const dword)  (not used)
ANGULAR_capfnt                        44  0x0000002c (const dword)  (not used)
ANGULAR_capofsx                       48  0x00000030 (const dword)  (not used)
ANGULAR_capofsy                       50  0x00000032 (const dword)  (not used)
ANGULAR_Caption                       52  0x00000034 (const dword)  (not used)
ANGULAR_cxx                           62  0x0000003e (const dword)  (not used)
ANGULAR_cyx                           64  0x00000040 (const dword)  (not used)
ANGULAR_F_BG_TRANSPARENT             N/A         N/A (macro)   0x0002   (not used)
ANGULAR_F_LABEL_STRINGS              N/A         N/A (macro)   0x0001   (not used)
ANGULAR_F_TEXT_PCT_COLOUR            N/A         N/A (macro)   0x0008   (not used)
ANGULAR_F_TICK_PCT_COLOUR            N/A         N/A (macro)   0x0004   (not used)
ANGULAR_flags                         42  0x0000002a (const dword)  (not used)
ANGULAR_h                             60  0x0000003c (const dword)  (not used)
ANGULAR_incro                         30  0x0000001e (const dword)  (not used)
ANGULAR_labcol                        36  0x00000024 (const dword)  (not used)
ANGULAR_labfnt                        34  0x00000022 (const dword)  (not used)
ANGULAR_labofs                        38  0x00000026 (const dword)  (not used)
ANGULAR_labs                          32  0x00000020 (const dword)  (not used)
ANGULAR_labstr                        40  0x00000028 (const dword)  (not used)
ANGULAR_maxa                          70  0x00000046 (const dword)  (not used)
ANGULAR_maxv                          74  0x0000004a (const dword)  (not used)
ANGULAR_mina                          68  0x00000044 (const dword)  (not used)
ANGULAR_minv                          72  0x00000048 (const dword)  (not used)
ANGULAR_p1                            20  0x00000014 (const dword)  (not used)
ANGULAR_p2                            22  0x00000016 (const dword)  (not used)
ANGULAR_ri                             2  0x00000002 (const dword)  (not used)
ANGULAR_ro                             0  0x00000000 (const dword)  (not used)
ANGULAR_tc                            18  0x00000012 (const dword)  (not used)
ANGULAR_tcks                           4  0x00000004 (const dword)  (not used)
ANGULAR_tiszl                         12  0x0000000c (const dword)  (not used)
ANGULAR_tiszs                         14  0x0000000e (const dword)  (not used)
ANGULAR_tkl                            6  0x00000006 (const dword)  (not used)
ANGULAR_toszl                          8  0x00000008 (const dword)  (not used)
ANGULAR_toszs                         10  0x0000000a (const dword)  (not used)
ANGULAR_tw                            16  0x00000010 (const dword)  (not used)
ANGULAR_w                             58  0x0000003a (const dword)  (not used)
ANGULAR_x                             54  0x00000036 (const dword)  (not used)
ANGULAR_y                             56  0x00000038 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                          24  0x00000018 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 111)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BREAK                              65533  0x0000fffd (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON4_BC0                           12  0x0000000c (const dword)  (not used)
BUTTON4_BC1                           14  0x0000000e (const dword)  (not used)
BUTTON4_BR1                           28  0x0000001c (const dword)  (not used)
BUTTON4_BR2                           30  0x0000001e (const dword)  (not used)
BUTTON4_BRG                           32  0x00000020 (const dword)  (not used)
BUTTON4_CAP                           26  0x0000001a (const dword)  (not used)
BUTTON4_FC0                           28  0x0000001c (const dword)  (not used)
BUTTON4_FC1                           30  0x0000001e (const dword)  (not used)
BUTTON4_FST                           32  0x00000020 (const dword)  (not used)
BUTTON4_FSZ                           34  0x00000022 (const dword)  (not used)
BUTTON4_IB1                           16  0x00000010 (const dword)  (not used)
BUTTON4_IB2                           18  0x00000012 (const dword)  (not used)
BUTTON4_IG0                           20  0x00000014 (const dword)  (not used)
BUTTON4_IG1                           22  0x00000016 (const dword)  (not used)
BUTTON4_OB1                            6  0x00000006 (const dword)  (not used)
BUTTON4_OB2                            8  0x00000008 (const dword)  (not used)
BUTTON4_OBG                           10  0x0000000a (const dword)  (not used)
BUTTON4_rad                            4  0x00000004 (const dword)  (not used)
BUTTON4_TPC                           24  0x00000018 (const dword)  (not used)
BUTTON4_XP                             0  0x00000000 (const dword)  (not used)
BUTTON4_YP                             2  0x00000002 (const dword)  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHECKUPDATE_INVALIDFILE                5  0x00000005 (const dword)  (not used)
CHECKUPDATE_NEWFILE                    1  0x00000001 (const dword)  (not used)
CHECKUPDATE_NOFILE                     4  0x00000004 (const dword)  (not used)
CHECKUPDATE_OLDFILE                    2  0x00000002 (const dword)  (not used)
CHECKUPDATE_QUERY                      1  0x00000001 (const dword)  (not used)
CHECKUPDATE_UPDATEALWAYS               3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATEDONE                 3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATENEWER                2  0x00000002 (const dword)  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
ciButton                          UNRESOLVED  (not used)
ciDial                            UNRESOLVED  (not used)
ciSlider                          UNRESOLVED  (not used)
ciSwitch                          UNRESOLVED  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  692  0x000002b4 (mem) word[80] (global)  (usage 90)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 12)
ColorBGimage                          32  0x00000020 (const dword)  (usage 6)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_InitBrk                        -427  0xfffffe55 (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferBrk                    -426  0xfffffe56 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_InitBrk                         -417  0xfffffe5f (PmmC func) args[3] r=0  (not used)
com_Mode                            -400  0xfffffe70 (PmmC func) args[4] r=1  (not used)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferBrk                     -416  0xfffffe60 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                                612  0x00000264 (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
crc_CSUM_8                          -403  0xfffffe6d (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         608  0x00000260 (mem) word (global)  (usage 30)
CurrentForm                          594  0x00000252 (mem) word (global)  (usage 54)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIAL_bevColour                        28  0x0000001c (const dword)  (not used)
DIAL_bevColour2                       30  0x0000001e (const dword)  (not used)
DIAL_bevSize                          26  0x0000001a (const dword)  (not used)
DIAL_bgcolour                         22  0x00000016 (const dword)  (not used)
DIAL_capcol                           72  0x00000048 (const dword)  (not used)
DIAL_capfnt                           70  0x00000046 (const dword)  (not used)
DIAL_capofsx                          74  0x0000004a (const dword)  (not used)
DIAL_capofsy                          76  0x0000004c (const dword)  (not used)
DIAL_caption                          78  0x0000004e (const dword)  (not used)
DIAL_colour                           24  0x00000018 (const dword)  (not used)
DIAL_cx                                8  0x00000008 (const dword)  (not used)
DIAL_cy                               10  0x0000000a (const dword)  (not used)
DIAL_F_BG_TRANSPARENT                N/A         N/A (macro)   0x0002   (not used)
DIAL_F_HANDLE_CIRCLE                 N/A         N/A (macro)   0x0000   (not used)
DIAL_F_HANDLE_LINE                   N/A         N/A (macro)   0x0030   (not used)
DIAL_F_HANDLE_RECTANGLE              N/A         N/A (macro)   0x0020   (not used)
DIAL_F_HANDLE_STYLE                  N/A         N/A (macro)   0x00f0   (not used)
DIAL_F_HANDLE_TRIANGLE               N/A         N/A (macro)   0x0010   (not used)
DIAL_F_INDICATOR_CIRCLE              N/A         N/A (macro)   0x0000   (not used)
DIAL_F_INDICATOR_LINE                N/A         N/A (macro)   0x0300   (not used)
DIAL_F_INDICATOR_RECTANGLE           N/A         N/A (macro)   0x0200   (not used)
DIAL_F_INDICATOR_STYLE               N/A         N/A (macro)   0x0f00   (not used)
DIAL_F_INDICATOR_TRIANGLE            N/A         N/A (macro)   0x0100   (not used)
DIAL_F_LABEL_STRINGS                 N/A         N/A (macro)   0x0001   (not used)
DIAL_flags                            80  0x00000050 (const dword)  (not used)
DIAL_h                                 6  0x00000006 (const dword)  (not used)
DIAL_handlecolour                     54  0x00000036 (const dword)  (not used)
DIAL_handlelength                     58  0x0000003a (const dword)  (not used)
DIAL_handlesize                       56  0x00000038 (const dword)  (not used)
DIAL_indc1h                           42  0x0000002a (const dword)  (not used)
DIAL_indc1l                           36  0x00000024 (const dword)  (not used)
DIAL_indc2h                           44  0x0000002c (const dword)  (not used)
DIAL_indc2l                           38  0x00000026 (const dword)  (not used)
DIAL_indc3h                           46  0x0000002e (const dword)  (not used)
DIAL_indc3l                           40  0x00000028 (const dword)  (not used)
DIAL_indlength                        52  0x00000034 (const dword)  (not used)
DIAL_indOffset                        48  0x00000030 (const dword)  (not used)
DIAL_indp1                            32  0x00000020 (const dword)  (not used)
DIAL_indp2                            34  0x00000022 (const dword)  (not used)
DIAL_indsize                          50  0x00000032 (const dword)  (not used)
DIAL_labcolour                        60  0x0000003c (const dword)  (not used)
DIAL_labcount                         66  0x00000042 (const dword)  (not used)
DIAL_labfont                          62  0x0000003e (const dword)  (not used)
DIAL_labofs                           64  0x00000040 (const dword)  (not used)
DIAL_labstr                           68  0x00000044 (const dword)  (not used)
DIAL_maxa                             16  0x00000010 (const dword)  (not used)
DIAL_maxv                             20  0x00000014 (const dword)  (not used)
DIAL_mina                             14  0x0000000e (const dword)  (not used)
DIAL_minv                             18  0x00000012 (const dword)  (not used)
DIAL_rad                              12  0x0000000c (const dword)  (not used)
DIAL_w                                 4  0x00000004 (const dword)  (not used)
DIAL_x                                 0  0x00000000 (const dword)  (not used)
DIAL_y                                 2  0x00000002 (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Busy                           -419  0xfffffe5d (PmmC func) args[0] r=1  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[2] r=1  (not used)
disp_Refresh                        -418  0xfffffe5e (PmmC func) args[0] r=0  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        5066  0x000013ca (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
EAST                                   3  0x00000003 (const dword)  (not used)
EAST_MIRRORED                          7  0x00000007 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
ffsEnd32kH                             4  0x00000004 (const dword)  (not used)
ffsEnd32kL                         32768  0x00008000 (const dword)  (not used)
ffsEnd4kH                              4  0x00000004 (const dword)  (not used)
ffsEnd4kL                           4096  0x00001000 (const dword)  (not used)
ffsEnd64kH                             5  0x00000005 (const dword)  (not used)
ffsEnd64kL                             0  0x00000000 (const dword)  (not used)
ffsEndUnits32k                         9  0x00000009 (const dword)  (not used)
ffsEndUnits4k                         65  0x00000041 (const dword)  (not used)
ffsEndUnits64k                         5  0x00000005 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_CheckUpdate                    -344  0xfffffea8 (PmmC func) args[2] r=1  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (not used)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
file_MountSpeed                     -382  0xfffffe82 (PmmC func) args[1] r=1  (not used)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_RunSpeed                       -408  0xfffffe68 (PmmC func) args[3] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
FLASH_ADDR_ALWAYS_4BYTE            65534  0x0000fffe (const dword)  (not used)
FLASH_ADDR_DEF_COMMAND             65535  0x0000ffff (const dword)  (usage 3)
flash_Block32Erase                  -398  0xfffffe72 (PmmC func) args[0] r=1  (not used)
flash_Block64Erase                  -157  0xffffff63 (PmmC func) args[0] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_Sector4Erase                  -399  0xfffffe71 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                        2675  0x00000a73FormBGcolors                        2675  0x00000a73 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 8)
FormBGcolors                      UNRESOLVED  (usage 4)
FormEndIndex                         867  0x00000363FormEndIndex                         867  0x00000363 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
FormStartIndex                       857  0x00000359FormStartIndex                       857  0x00000359 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 7)
FormStartIndex                    UNRESOLVED  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAUGE_COLOR                           18  0x00000012 (const dword)  (not used)
GAUGE_F_HORZ                         N/A         N/A (macro)    0x0002   (not used)
GAUGE_F_TOPRIGHT                     N/A         N/A (macro)    0x0001   (not used)
GAUGE_FLAGS                           36  0x00000024 (const dword)  (not used)
GAUGE_H                                6  0x00000006 (const dword)  (not used)
GAUGE_MAXV                            12  0x0000000c (const dword)  (not used)
GAUGE_MINV                            10  0x0000000a (const dword)  (not used)
GAUGE_P1                              34  0x00000022 (const dword)  (not used)
GAUGE_P1H                             22  0x00000016 (const dword)  (not used)
GAUGE_P1L                             20  0x00000014 (const dword)  (not used)
GAUGE_P2                              32  0x00000020 (const dword)  (not used)
GAUGE_P2H                             26  0x0000001a (const dword)  (not used)
GAUGE_P2L                             24  0x00000018 (const dword)  (not used)
GAUGE_P3H                             30  0x0000001e (const dword)  (not used)
GAUGE_P3L                             28  0x0000001c (const dword)  (not used)
GAUGE_SPACING                         16  0x00000010 (const dword)  (not used)
GAUGE_T                                8  0x00000008 (const dword)  (not used)
GAUGE_TICKH                           14  0x0000000e (const dword)  (not used)
GAUGE_W                                4  0x00000004 (const dword)  (not used)
GAUGE_X                                0  0x00000000 (const dword)  (not used)
GAUGE_Y                                2  0x00000002 (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_AngularMeter                    -312  0xfffffec8 (PmmC func) args[3] r=0  (usage 3)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
gfx_BlitSprite                      -304  0xfffffed0 (PmmC func) args[6] r=0  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
gfx_Button4                         -340  0xfffffeac (PmmC func) args[3] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 6)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 3)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 3)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dial                            -315  0xfffffec5 (PmmC func) args[3] r=0  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Gauge                           -316  0xfffffec4 (PmmC func) args[3] r=0  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -346  0xfffffea6 (PmmC func) args[7] r=0  (not used)
gfx_GradientColor                   -405  0xfffffe6b (PmmC func) args[6] r=1  (not used)
gfx_GradientShape                   -404  0xfffffe6c (PmmC func) args[19] r=0  (not used)
gfx_GradTriangleFilled              -406  0xfffffe6a (PmmC func) args[12] r=0  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
gfx_Led                             -341  0xfffffeab (PmmC func) args[3] r=0  (not used)
gfx_LedDigit                        -319  0xfffffec1 (PmmC func) args[6] r=0  (not used)
gfx_LedDigits                       -318  0xfffffec2 (PmmC func) args[3] r=0  (usage 3)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_Needle                          -314  0xfffffec6 (PmmC func) args[3] r=0  (not used)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_Panel2                          -313  0xfffffec7 (PmmC func) args[10] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
gfx_ReadGRAMarea                    -305  0xfffffecf (PmmC func) args[5] r=1  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 6)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_RingSegment                     -311  0xfffffec9 (PmmC func) args[7] r=0  (not used)
gfx_RoundGradient                   -317  0xfffffec3 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -320  0xfffffec0 (PmmC func) args[6] r=0  (not used)
gfx_RulerGauge                      -343  0xfffffea9 (PmmC func) args[3] r=0  (not used)
gfx_Scale                           -342  0xfffffeaa (PmmC func) args[2] r=0  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
gfx_Slider5                         -337  0xfffffeaf (PmmC func) args[3] r=0  (not used)
gfx_SpriteSet                       -303  0xfffffed1 (PmmC func) args[3] r=0  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
gfx_Surround                        -338  0xfffffeae (PmmC func) args[7] r=0  (not used)
gfx_Switch                          -339  0xfffffead (PmmC func) args[3] r=0  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
gfx_WriteGRAMarea                   -306  0xfffffece (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
gfx_XYlinToVal                      -380  0xfffffe84 (PmmC func) args[7] r=1  (not used)
gfx_XYrotToVal                      -379  0xfffffe85 (PmmC func) args[7] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
gfxInternals                           7  0x00000007gfxInternals                           7  0x00000007 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
gfxIntParms                           65  0x00000041gfxIntParms                           65  0x00000041 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
gfxIntStrings                        123  0x0000007bgfxIntStrings                        123  0x0000007b (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectDATA                          452  0x000001c4 (mem) word (global)  (usage 6)
GObjectFunc                          448  0x000001c0 (mem) word (global)  (usage 6)
GObjectIdx                           446  0x000001be (mem) word (global)  (usage 21)
GObjectParms                         454  0x000001c6 (mem) word (global)  (usage 3)
GObjectRAM                           450  0x000001c2 (mem) word (global)  (usage 15)
GObjectStrings                       456  0x000001c8 (mem) word (global)  (usage 3)
GObjectType                          604  0x0000025c (mem) word (global)  (usage 90)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (usage 12)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 102)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
hstrings                             388  0x00000184 (mem) word (global)Notice: global var 'hstrings' is never used
  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C1_Close                          -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C1_Nack                           -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C1_Putn                           -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -361  0xfffffe97 (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -367  0xfffffe91 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -365  0xfffffe93 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -349  0xfffffea3 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -373  0xfffffe8b (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -371  0xfffffe8d (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -369  0xfffffe8f (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -363  0xfffffe95 (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
I2C2_Putn                           -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -375  0xfffffe89 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -357  0xfffffe9b (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -355  0xfffffe9d (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -351  0xfffffea1 (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -359  0xfffffe99 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -362  0xfffffe96 (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -368  0xfffffe90 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -366  0xfffffe92 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -350  0xfffffea2 (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -374  0xfffffe8a (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -372  0xfffffe8c (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -370  0xfffffe8e (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -364  0xfffffe94 (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
I2C3_Putn                           -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -376  0xfffffe88 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -358  0xfffffe9a (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -356  0xfffffe9c (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -360  0xfffffe98 (PmmC func) args[1] r=1  (not used)
I2C_CLOCK_STRETCHING               32768  0x00008000 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2CS_Close                          -410  0xfffffe66 (PmmC func) args[0] r=0  (not used)
I2CS_Count                          -412  0xfffffe64 (PmmC func) args[0] r=1  (not used)
I2CS_Open                           -409  0xfffffe67 (PmmC func) args[6] r=0  (not used)
I2CS_Overflow                       -415  0xfffffe61 (PmmC func) args[0] r=1  (not used)
I2CS_Read                           -413  0xfffffe63 (PmmC func) args[0] r=1  (not used)
I2CS_Release                        -414  0xfffffe62 (PmmC func) args[0] r=0  (not used)
I2CS_Write                          -411  0xfffffe65 (PmmC func) args[1] r=0  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 3)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 6)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                          33  0x00000021 (const dword)  (not used)
iFontIFont0                           26  0x0000001a (const ??? 0)  (not used)
iFontStrings10                        28  0x0000001c (const ??? 0)  (usage 40)
iFontStrings2                         27  0x0000001b (const ??? 0)  (usage 26)
iFormEndIndex                        887  0x00000377iFormEndIndex                        887  0x00000377 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iFormStartIndex                      877  0x0000036diFormStartIndex                      877  0x0000036d (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iGauge0                                1  0x00000001 (const ??? 0)  (usage 3)
iGauge1                               10  0x0000000a (const ??? 0)  (usage 3)
iGauge2                               11  0x0000000b (const ??? 0)  (usage 3)
iGauge3                               12  0x0000000c (const ??? 0)  (usage 3)
iIAngularMeter0                        0  0x00000000 (const ??? 0)  (not used)
IIAngularMeter0                      237  0x000000edIIAngularMeter0                      237  0x000000ed (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter1                        1  0x00000001 (const ??? 0)  (not used)
IIAngularMeter1                      338  0x00000152IIAngularMeter1                      338  0x00000152 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter2                        7  0x00000007 (const ??? 0)  (not used)
IIAngularMeter2                      625  0x00000271IIAngularMeter2                      625  0x00000271 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter3                        3  0x00000003 (const ??? 0)  (not used)
IIAngularMeter3                      460  0x000001ccIIAngularMeter3                      460  0x000001cc (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits0                           2  0x00000002 (const ??? 0)  (not used)
IILedDigits0                         438  0x000001b6IILedDigits0                         438  0x000001b6 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits1                           4  0x00000004 (const ??? 0)  (not used)
IILedDigits1                         559  0x0000022fIILedDigits1                         559  0x0000022f (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits2                           5  0x00000005 (const ??? 0)  (not used)
IILedDigits2                         581  0x00000245IILedDigits2                         581  0x00000245 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits3                           6  0x00000006 (const ??? 0)  (not used)
IILedDigits3                         603  0x0000025bIILedDigits3                         603  0x0000025b (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits4                           8  0x00000008 (const ??? 0)  (not used)
IILedDigits4                         725  0x000002d5IILedDigits4                         725  0x000002d5 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits5                          12  0x0000000c (const ??? 0)  (not used)
IILedDigits5                         813  0x0000032dIILedDigits5                         813  0x0000032d (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits6                           9  0x00000009 (const ??? 0)  (not used)
IILedDigits6                         747  0x000002ebIILedDigits6                         747  0x000002eb (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits7                          10  0x0000000a (const ??? 0)  (not used)
IILedDigits7                         769  0x00000301IILedDigits7                         769  0x00000301 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits8                          11  0x0000000b (const ??? 0)  (not used)
IILedDigits8                         791  0x00000317IILedDigits8                         791  0x00000317 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits9                          13  0x0000000d (const ??? 0)  (not used)
IILedDigits9                         835  0x00000343IILedDigits9                         835  0x00000343 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iImage0                                0  0x00000000 (const ??? 0)  (usage 3)
iImage1                                2  0x00000002 (const ??? 0)  (usage 3)
iImage10                              13  0x0000000d (const ??? 0)  (usage 3)
iImage3                                3  0x00000003 (const ??? 0)  (usage 3)
iImage4                                4  0x00000004 (const ??? 0)  (usage 3)
iImage5                                6  0x00000006 (const ??? 0)  (usage 3)
iImage6                                5  0x00000005 (const ??? 0)  (usage 3)
iImage7                                7  0x00000007 (const ??? 0)  (usage 3)
iImage8                                8  0x00000008 (const ??? 0)  (usage 3)
iImage9                                9  0x00000009 (const ??? 0)  (usage 3)
iLed0                                 15  0x0000000f (const ??? 0)  (usage 3)
ILINEARIP_COLOR1                      12  0x0000000c (const dword)  (not used)
ILINEARIP_COLOR2                      14  0x0000000e (const dword)  (not used)
ILINEARIP_COLOR3                      16  0x00000010 (const dword)  (not used)
ILINEARIP_COLOR4                      18  0x00000012 (const dword)  (not used)
ILINEARIP_COLOR5                      20  0x00000014 (const dword)  (not used)
ILINEARIP_COLOR6                      22  0x00000016 (const dword)  (not used)
ILINEARIP_H                            6  0x00000006 (const dword)  (not used)
ILINEARIP_INDEX                        8  0x00000008 (const dword)  (not used)
ILINEARIP_MAXVAL                      42  0x0000002a (const dword)  (not used)
ILINEARIP_MINVAL                      44  0x0000002c (const dword)  (not used)
ILINEARIP_OFFSET_BR                   46  0x0000002e (const dword)  (not used)
ILINEARIP_OFFSET_TL                   48  0x00000030 (const dword)  (not used)
ILINEARIP_ORIENTATION                 10  0x0000000a (const dword)  (not used)
ILINEARIP_TEXT1                       36  0x00000024 (const dword)  (not used)
ILINEARIP_TEXT2                       38  0x00000026 (const dword)  (not used)
ILINEARIP_TEXT3                       40  0x00000028 (const dword)  (not used)
ILINEARIP_VALUE1                      24  0x00000018 (const dword)  (not used)
ILINEARIP_VALUE2                      26  0x0000001a (const dword)  (not used)
ILINEARIP_VALUE3                      28  0x0000001c (const dword)  (not used)
ILINEARIP_VALUE4                      30  0x0000001e (const dword)  (not used)
ILINEARIP_VALUE5                      32  0x00000020 (const dword)  (not used)
ILINEARIP_VALUE6                      34  0x00000022 (const dword)  (not used)
ILINEARIP_W                            4  0x00000004 (const dword)  (not used)
ILINEARIP_X                            0  0x00000000 (const dword)  (not used)
ILINEARIP_Y                            2  0x00000002 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 45)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
ImageTouched                         598  0x00000256 (mem) word (global)  (usage 72)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
img_FileCheckUpdate                 -397  0xfffffe73 (PmmC func) args[3] r=1  (not used)
img_FileExec                        -394  0xfffffe76 (PmmC func) args[3] r=1  (not used)
img_FileGetC                        -388  0xfffffe7c (PmmC func) args[2] r=1  (usage 3)
img_FileGetS                        -390  0xfffffe7a (PmmC func) args[4] r=1  (not used)
img_FileGetW                        -389  0xfffffe7b (PmmC func) args[2] r=1  (usage 3)
img_FileIndex                       -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_FileLoadFunction                -392  0xfffffe78 (PmmC func) args[2] r=1  (not used)
img_FilePlayWAV                     -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
img_FileRead                        -383  0xfffffe81 (PmmC func) args[4] r=1  (not used)
img_FileRewind                      -391  0xfffffe79 (PmmC func) args[2] r=1  (not used)
img_FileRun                         -393  0xfffffe77 (PmmC func) args[3] r=1  (not used)
img_FileSeek                        -384  0xfffffe80 (PmmC func) args[4] r=1  (usage 3)
img_FileSize                        -387  0xfffffe7d (PmmC func) args[4] r=1  (not used)
img_FileTell                        -386  0xfffffe7e (PmmC func) args[4] r=1  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
img_FunctionCall                    -401  0xfffffe6f (PmmC func) args[7] r=1  (not used)
img_FunctionFreeCache               -402  0xfffffe6e (PmmC func) args[1] r=0  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 39)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 6)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 15)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 18)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
img_TxtFontID                       -396  0xfffffe74 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
InputControls                        897  0x00000381InputControls                        897  0x00000381 (mem) word[26] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
InputCS                              852  0x00000354 (mem) word (global)  (usage 21)
InputData                            977  0x000003d1InputData                            977  0x000003d1 (mem) word[297] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 33)
InternalInputControls                949  0x000003b5InternalInputControls                949  0x000003b5 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
intflash_Copy                       -422  0xfffffe5a (PmmC func) args[3] r=1  (not used)
intflash_FunctionCall               -424  0xfffffe58 (PmmC func) args[7] r=1  (not used)
intflash_FunctionFreeCache          -425  0xfffffe57 (PmmC func) args[1] r=0  (not used)
intflash_GetByte                    -420  0xfffffe5c (PmmC func) args[1] r=1  (not used)
intflash_GetWord                    -421  0xfffffe5b (PmmC func) args[1] r=1  (not used)
intflash_WriteBlock                 -423  0xfffffe59 (PmmC func) args[2] r=1  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO10_PIN                              10  0x0000000a (const dword)  (not used)
IO11_PIN                              11  0x0000000b (const dword)  (not used)
IO12_PIN                              12  0x0000000c (const dword)  (not used)
IO13_PIN                              13  0x0000000d (const dword)  (not used)
IO14_PIN                              14  0x0000000e (const dword)  (not used)
IO15_PIN                              15  0x0000000f (const dword)  (not used)
IO16_PIN                              16  0x00000010 (const dword)  (not used)
IO17_PIN                              17  0x00000011 (const dword)  (not used)
IO18_PIN                              18  0x00000012 (const dword)  (not used)
IO19_PIN                              19  0x00000013 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IO6_PIN                                6  0x00000006 (const dword)  (not used)
IO7_PIN                                7  0x00000007 (const dword)  (not used)
IO8_PIN                                8  0x00000008 (const dword)  (not used)
IO9_PIN                                9  0x00000009 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
IROTARYIP_COLOR1                      10  0x0000000a (const dword)  (not used)
IROTARYIP_COLOR2                      12  0x0000000c (const dword)  (not used)
IROTARYIP_COLOR3                      14  0x0000000e (const dword)  (not used)
IROTARYIP_COLOR4                      16  0x00000010 (const dword)  (not used)
IROTARYIP_COLOR5                      18  0x00000012 (const dword)  (not used)
IROTARYIP_COLOR6                      20  0x00000014 (const dword)  (not used)
IROTARYIP_H                            6  0x00000006 (const dword)  (not used)
IROTARYIP_INDEX                        8  0x00000008 (const dword)  (not used)
IROTARYIP_MAXANGLE                    40  0x00000028 (const dword)  (not used)
IROTARYIP_MAXVALUE                    42  0x0000002a (const dword)  (not used)
IROTARYIP_MINANGLE                    44  0x0000002c (const dword)  (not used)
IROTARYIP_MINVALUE                    46  0x0000002e (const dword)  (not used)
IROTARYIP_TEXT1                       34  0x00000022 (const dword)  (not used)
IROTARYIP_TEXT2                       36  0x00000024 (const dword)  (not used)
IROTARYIP_TEXT3                       38  0x00000026 (const dword)  (not used)
IROTARYIP_VALUE1                      22  0x00000016 (const dword)  (not used)
IROTARYIP_VALUE2                      24  0x00000018 (const dword)  (not used)
IROTARYIP_VALUE3                      26  0x0000001a (const dword)  (not used)
IROTARYIP_VALUE4                      28  0x0000001c (const dword)  (not used)
IROTARYIP_VALUE5                      30  0x0000001e (const dword)  (not used)
IROTARYIP_VALUE6                      32  0x00000020 (const dword)  (not used)
IROTARYIP_W                            4  0x00000004 (const dword)  (not used)
IROTARYIP_X                            0  0x00000000 (const dword)  (not used)
IROTARYIP_Y                            2  0x00000002 (const dword)  (not used)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStrings0                           1571  0x00000623iStrings0                           1571  0x00000623 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings1                           1599  0x0000063fiStrings1                           1599  0x0000063f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings10                          1851  0x0000073biStrings10                          1851  0x0000073b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings11                          1879  0x00000757iStrings11                          1879  0x00000757 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings12                          1907  0x00000773iStrings12                          1907  0x00000773 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings13                          1935  0x0000078fiStrings13                          1935  0x0000078f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings14                          1963  0x000007abiStrings14                          1963  0x000007ab (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings15                          1991  0x000007c7iStrings15                          1991  0x000007c7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings16                          2019  0x000007e3iStrings16                          2019  0x000007e3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings17                          2047  0x000007ffiStrings17                          2047  0x000007ff (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings18                          2075  0x0000081biStrings18                          2075  0x0000081b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings19                          2103  0x00000837iStrings19                          2103  0x00000837 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings2                           1627  0x0000065biStrings2                           1627  0x0000065b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings20                          2131  0x00000853iStrings20                          2131  0x00000853 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings21                          2159  0x0000086fiStrings21                          2159  0x0000086f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings22                          2187  0x0000088biStrings22                          2187  0x0000088b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings23                          2215  0x000008a7iStrings23                          2215  0x000008a7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings24                          2243  0x000008c3iStrings24                          2243  0x000008c3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings25                          2271  0x000008dfiStrings25                          2271  0x000008df (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings26                          2299  0x000008fbiStrings26                          2299  0x000008fb (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings27                          2327  0x00000917iStrings27                          2327  0x00000917 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings28                          2355  0x00000933iStrings28                          2355  0x00000933 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings29                          2383  0x0000094fiStrings29                          2383  0x0000094f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings3                           1655  0x00000677iStrings3                           1655  0x00000677 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings30                          2411  0x0000096biStrings30                          2411  0x0000096b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings31                          2439  0x00000987iStrings31                          2439  0x00000987 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings32                          2467  0x000009a3iStrings32                          2467  0x000009a3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings4                           1683  0x00000693iStrings4                           1683  0x00000693 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings5                           1711  0x000006afiStrings5                           1711  0x000006af (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings6                           1739  0x000006cbiStrings6                           1739  0x000006cb (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings7                           1767  0x000006e7iStrings7                           1767  0x000006e7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings8                           1795  0x00000703iStrings8                           1795  0x00000703 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings9                           1823  0x0000071fiStrings9                           1823  0x0000071f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iTextStrings                          29  0x0000001d (const ??? 0)  (usage 9)
ITOGGLEIP_COLOR1                      10  0x0000000a (const dword)  (not used)
ITOGGLEIP_COLOR2                      12  0x0000000c (const dword)  (not used)
ITOGGLEIP_COLOR3                      14  0x0000000e (const dword)  (not used)
ITOGGLEIP_COLOR4                      16  0x00000010 (const dword)  (not used)
ITOGGLEIP_COLOR5                      18  0x00000012 (const dword)  (not used)
ITOGGLEIP_COLOR6                      20  0x00000014 (const dword)  (not used)
ITOGGLEIP_H                            6  0x00000006 (const dword)  (not used)
ITOGGLEIP_INDEX                        8  0x00000008 (const dword)  (not used)
ITOGGLEIP_MATRIX                      40  0x00000028 (const dword)  (not used)
ITOGGLEIP_MOMENTARY                   42  0x0000002a (const dword)  (not used)
ITOGGLEIP_TEXT1                       34  0x00000022 (const dword)  (not used)
ITOGGLEIP_TEXT2                       36  0x00000024 (const dword)  (not used)
ITOGGLEIP_TEXT3                       38  0x00000026 (const dword)  (not used)
ITOGGLEIP_VALUE1                      22  0x00000016 (const dword)  (not used)
ITOGGLEIP_VALUE2                      24  0x00000018 (const dword)  (not used)
ITOGGLEIP_VALUE3                      26  0x0000001a (const dword)  (not used)
ITOGGLEIP_VALUE4                      28  0x0000001c (const dword)  (not used)
ITOGGLEIP_VALUE5                      30  0x0000001e (const dword)  (not used)
ITOGGLEIP_VALUE6                      32  0x00000020 (const dword)  (not used)
ITOGGLEIP_W                            4  0x00000004 (const dword)  (not used)
ITOGGLEIP_X                            0  0x00000000 (const dword)  (not used)
ITOGGLEIP_Y                            2  0x00000002 (const dword)  (not used)
iUserbutton0                          16  0x00000010 (const ??? 0)  (usage 3)
iUserbutton1                          14  0x0000000e (const ??? 0)  (usage 3)
iUserbutton2                          17  0x00000011 (const ??? 0)  (usage 3)
iUserbutton3                          18  0x00000012 (const ??? 0)  (usage 3)
iUserbutton4                          20  0x00000014 (const ??? 0)  (usage 3)
iUserbutton5                          21  0x00000015 (const ??? 0)  (usage 3)
iUserbutton6                          25  0x00000019 (const ??? 0)  (usage 3)
iUserbutton8                          19  0x00000013 (const ??? 0)  (usage 3)
IUSERGAUGE_COLOR1                     10  0x0000000a (const dword)  (not used)
IUSERGAUGE_COLOR2                     12  0x0000000c (const dword)  (not used)
IUSERGAUGE_COLOR3                     14  0x0000000e (const dword)  (not used)
IUSERGAUGE_COLOR4                     16  0x00000010 (const dword)  (not used)
IUSERGAUGE_COLOR5                     18  0x00000012 (const dword)  (not used)
IUSERGAUGE_COLOR6                     20  0x00000014 (const dword)  (not used)
IUSERGAUGE_H                           6  0x00000006 (const dword)  (not used)
IUSERGAUGE_INDEX                       8  0x00000008 (const dword)  (not used)
IUSERGAUGE_TEXT1                      34  0x00000022 (const dword)  (not used)
IUSERGAUGE_TEXT2                      36  0x00000024 (const dword)  (not used)
IUSERGAUGE_TEXT3                      38  0x00000026 (const dword)  (not used)
IUSERGAUGE_VALUE1                     22  0x00000016 (const dword)  (not used)
IUSERGAUGE_VALUE2                     24  0x00000018 (const dword)  (not used)
IUSERGAUGE_VALUE3                     26  0x0000001a (const dword)  (not used)
IUSERGAUGE_VALUE4                     28  0x0000001c (const dword)  (not used)
IUSERGAUGE_VALUE5                     30  0x0000001e (const dword)  (not used)
IUSERGAUGE_VALUE6                     32  0x00000020 (const dword)  (not used)
IUSERGAUGE_W                           4  0x00000004 (const dword)  (not used)
IUSERGAUGE_X                           0  0x00000000 (const dword)  (not used)
IUSERGAUGE_Y                           2  0x00000002 (const dword)  (not used)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton0                           22  0x00000016 (const ??? 0)  (usage 3)
iWinbutton1                           23  0x00000017 (const ??? 0)  (usage 3)
iWinbutton2                           24  0x00000018 (const ??? 0)  (usage 3)
JOY_BTNA                               6  0x00000006 (const dword)  (not used)
JOY_BTNB                               5  0x00000005 (const dword)  (not used)
JOY_DOWN                               3  0x00000003 (const dword)  (not used)
JOY_FIRE                               5  0x00000005 (const dword)  (not used)
JOY_LEFT                               2  0x00000002 (const dword)  (not used)
JOY_RELEASED                           0  0x00000000 (const dword)  (not used)
JOY_RIGHT                              4  0x00000004 (const dword)  (not used)
JOY_UP                                 1  0x00000001 (const dword)  (not used)
joystick                            -310  0xfffffeca (PmmC func) args[1] r=1  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                 2685  0x00000a7dkKeyboardKeystrokes                 2685  0x00000a7d (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LED1_cbe                              10  0x0000000a (const dword)  (not used)
LED1_cbs                               8  0x00000008 (const dword)  (not used)
LED1_cOff                             16  0x00000010 (const dword)  (not used)
LED1_cOn                              14  0x0000000e (const dword)  (not used)
LED1_cs                               12  0x0000000c (const dword)  (not used)
LED1_h                                 6  0x00000006 (const dword)  (not used)
LED1_iBr                              18  0x00000012 (const dword)  (not used)
LED1_iLr                              22  0x00000016 (const dword)  (not used)
LED1_oBr                              20  0x00000014 (const dword)  (not used)
LED1_oLr                              24  0x00000018 (const dword)  (not used)
LED1_sh                               26  0x0000001a (const dword)  (not used)
LED1_w                                 4  0x00000004 (const dword)  (not used)
LED1_x                                 0  0x00000000 (const dword)  (not used)
LED1_y                                 2  0x00000002 (const dword)  (not used)
LEDDIGIT_F_DP_COMMA                  N/A         N/A (macro)   0x0400   (not used)
LEDDIGIT_F_DP_ON                     N/A         N/A (macro)   0x0200   (not used)
LEDDIGIT_F_SET_SEGMENTS              N/A         N/A (macro)   0x1000   (not used)
LEDDIGIT_F_SHOW_DP                   N/A         N/A (macro)   0x0800   (not used)
LEDDIGITS_decimals                    10  0x0000000a (const dword)  (not used)
LEDDIGITS_digits                       8  0x00000008 (const dword)  (not used)
LEDDIGITS_digsize                     14  0x0000000e (const dword)  (not used)
LEDDIGITS_F_DP_COMMA                 N/A         N/A (macro)   0x0040   (not used)
LEDDIGITS_F_DP_DOT                   N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_FIXED                    N/A         N/A (macro)   0x0002   (not used)
LEDDIGITS_F_FLOAT                    N/A         N/A (macro)   0x0008   (not used)
LEDDIGITS_F_FLOATFORMATS             N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_GENERAL                  N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_INT16                    N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_INT32                    N/A         N/A (macro)   0x0004   (not used)
LEDDIGITS_F_LEADING0                 N/A         N/A (macro)   0x0020   (not used)
LEDDIGITS_F_LEADINGb                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_SCIENTIFIC               N/A         N/A (macro)   0x0001   (not used)
LEDDIGITS_F_SIGNED                   N/A         N/A (macro)   0x0010   (not used)
LEDDIGITS_F_TYPES                    N/A         N/A (macro)   0x000c   (not used)
LEDDIGITS_F_UNSIGNED                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_flags                       20  0x00000014 (const dword)  (not used)
LEDDIGITS_gap                         12  0x0000000c (const dword)  (not used)
LEDDIGITS_h                            6  0x00000006 (const dword)  (not used)
LEDDIGITS_offcolour                   18  0x00000012 (const dword)  (not used)
LEDDIGITS_oncolour                    16  0x00000010 (const dword)  (not used)
LEDDIGITS_w                            4  0x00000004 (const dword)  (not used)
LEDDIGITS_x                            0  0x00000000 (const dword)  (not used)
LEDDIGITS_y                            2  0x00000002 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIAngularMeter0                      333  0x0000014dLIAngularMeter0                      333  0x0000014d (mem) byte[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter0                   UNRESOLVED  (usage 2)
LIAngularMeter1                      434  0x000001b2LIAngularMeter1                      434  0x000001b2 (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter1                   UNRESOLVED  (usage 2)
LIAngularMeter2                      721  0x000002d1LIAngularMeter2                      721  0x000002d1 (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter2                   UNRESOLVED  (usage 2)
LIAngularMeter3                      556  0x0000022cLIAngularMeter3                      556  0x0000022c (mem) byte[3] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter3                   UNRESOLVED  (usage 2)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                2802  0x00000af2 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxIntObjects                         27  0x0000001b (const dword)  (usage 3)
MaxTotObjects                         67  0x00000043 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_Init4                         -407  0xfffffe69 (const dword)  (not used)
media_InitFlash                     -407  0xfffffe69 (PmmC func) args[1] r=1  (usage 6)
media_InitSpeed                     -381  0xfffffe83 (PmmC func) args[1] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                7284  0x00001c74 (User func) args[0] r=0  (usage 24)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NEEDLE_bgcol                          12  0x0000000c (const dword)  (not used)
NEEDLE_ccol                           36  0x00000024 (const dword)  (not used)
NEEDLE_colour                         32  0x00000020 (const dword)  (not used)
NEEDLE_crad                           34  0x00000022 (const dword)  (not used)
NEEDLE_cxx                             8  0x00000008 (const dword)  (not used)
NEEDLE_cyx                            10  0x0000000a (const dword)  (not used)
NEEDLE_extra                          30  0x0000001e (const dword)  (not used)
NEEDLE_F_DOUBLETRIANGLE                4  0x00000004 (const dword)  (not used)
NEEDLE_F_LINE                          0  0x00000000 (const dword)  (not used)
NEEDLE_F_POINTRECTANGLE                2  0x00000002 (const dword)  (not used)
NEEDLE_F_RECTANGLE                     1  0x00000001 (const dword)  (not used)
NEEDLE_F_ROUNDEDRECTANGLE              5  0x00000005 (const dword)  (not used)
NEEDLE_F_TRIANGLE                      3  0x00000003 (const dword)  (not used)
NEEDLE_h                               6  0x00000006 (const dword)  (not used)
NEEDLE_icol                           40  0x00000028 (const dword)  (not used)
NEEDLE_irad                           38  0x00000026 (const dword)  (not used)
NEEDLE_len                            22  0x00000016 (const dword)  (not used)
NEEDLE_maxa                           16  0x00000010 (const dword)  (not used)
NEEDLE_maxv                           20  0x00000014 (const dword)  (not used)
NEEDLE_mina                           14  0x0000000e (const dword)  (not used)
NEEDLE_minv                           18  0x00000012 (const dword)  (not used)
NEEDLE_offs                           26  0x0000001a (const dword)  (not used)
NEEDLE_rad                            28  0x0000001c (const dword)  (not used)
NEEDLE_style                          24  0x00000018 (const dword)  (not used)
NEEDLE_w                               4  0x00000004 (const dword)  (not used)
NEEDLE_x                               0  0x00000000 (const dword)  (not used)
NEEDLE_y                               2  0x00000002 (const dword)  (not used)
nInputs                               27  0x0000001b (const dword)  (usage 3)
nObjects                              26  0x0000001a (const dword)  (not used)
NORTH                                  0  0x00000000 (const dword)  (not used)
NORTH_MIRRORED                         4  0x00000004 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
nStrings                              33  0x00000021 (const dword)  (usage 3)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                         2495  0x000009bfoDipSwitchs                         2495  0x000009bf (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 174)
OFF                                    0  0x00000000 (const dword)  (usage 3)
oForms                              2505  0x000009c9oForms                              2505  0x000009c9 (mem) word[6] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (not used)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (not used)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (not used)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (not used)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (not used)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 6)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 12)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 18)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 48)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 9)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 3)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 9)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 18)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 9)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (usage 3)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (usage 6)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (usage 3)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (usage 3)
Ofs_String_Form                       24  0x00000018 (const dword)  (usage 3)
Ofs_String_GciFSFontIdx               26  0x0000001a (const dword)  (usage 3)
Ofs_String_Size                        4  0x00000004 (const dword)  (usage 3)
Ofs_String_StartH                      0  0x00000000 (const dword)  (usage 3)
Ofs_String_StartL                      2  0x00000002 (const dword)  (usage 3)
Ofs_String_Transparent                20  0x00000014 (const dword)  (usage 3)
Ofs_String_x1                          6  0x00000006 (const dword)  (usage 12)
Ofs_String_x2                         10  0x0000000a (const dword)  (usage 9)
Ofs_String_y1                          8  0x00000008 (const dword)  (usage 12)
Ofs_String_y2                         12  0x0000000c (const dword)  (usage 9)
oGauges                             2517  0x000009d5oGauges                             2517  0x000009d5 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiAngularMeters                     2643  0x00000a53oiAngularMeters                     2643  0x00000a53 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiLedDigitss                        2653  0x00000a5doiLedDigitss                        2653  0x00000a5d (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oImages                             2527  0x000009dfoImages                             2527  0x000009df (mem) word[12] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviAngularMeter                     181  0x000000b5oiviAngularMeter                     181  0x000000b5 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviLedDigits                        189  0x000000bdoiviLedDigits                        189  0x000000bd (mem) word[10] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 596  0x00000254 (mem) word (global)  (usage 42)
oLeds                               2551  0x000009f7oLeds                               2551  0x000009f7 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 3)
oObjects                             458  0x000001ca (mem) word[68] (global)  (usage 219)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oStringss                           2555  0x000009fboStringss                           2555  0x000009fb (mem) word[34] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 4)
oStringss                         UNRESOLVED  (usage 2)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 24)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 3)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (usage 3)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (usage 3)
OT_REPORT                            100  0x00000064 (const dword)  (usage 30)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 3)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
oUserButtons                        2623  0x00000a3foUserButtons                        2623  0x00000a3f (mem) word[10] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OutputCS                             854  0x00000356 (mem) word (global)  (usage 9)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (usage 3)
OW_Read                             -299  0xfffffed5 (PmmC func) args[1] r=1  (not used)
OW_Read9                            -300  0xfffffed4 (PmmC func) args[1] r=1  (not used)
OW_Reset                            -298  0xfffffed6 (PmmC func) args[1] r=1  (not used)
OW_Write                            -301  0xfffffed3 (PmmC func) args[2] r=0  (not used)
oWinButtons                         2497  0x000009c1oWinButtons                         2497  0x000009c1 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL2_FILLED                      32768  0x00008000 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (not used)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
pInputIndex                          610  0x00000262 (mem) word (global)  (usage 15)
PIXXI                                  4  0x00000004 (const dword)  (usage 3)
PIXXI44_FUNCTIONS                      0  0x00000000 (const ??? 0)  (not used)
PIXXI_44_CHIP                          5  0x00000005 (const ??? 0)  (not used)
pixxiLCD_39P4CT                        0  0x00000000 (const ??? 0)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PrintStrings                        7454  0x00001d1e (User func) args[3] r=0  (usage 9)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 6)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (not used)
putstrCentred                       -321  0xfffffebf (PmmC func) args[3] r=0  (not used)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          6984  0x00001b48 (User func) args[2] r=0  (usage 3)
RECT_HEIGHT                            3  0x00000003 (const dword)  (not used)
rect_Intersect                      -307  0xfffffecd (PmmC func) args[2] r=1  (not used)
RECT_LEFT                              0  0x00000000 (const dword)  (not used)
RECT_TOP                               1  0x00000001 (const dword)  (not used)
RECT_WIDTH                             2  0x00000002 (const dword)  (not used)
rect_Within                         -308  0xfffffecc (PmmC func) args[2] r=1  (not used)
RED                                63488  0x0000f800 (const dword)  (usage 21)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 3)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                   2687  0x00000a7frKeyboardRoutines                   2687  0x00000a7f (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RULERGAUGE_F_ORIENT_VERT               2  0x00000002 (const dword)  (not used)
RULERGAUGE_F_TICKS_BOTTOM              0  0x00000000 (const dword)  (not used)
RULERGAUGE_F_TICKS_TOP                 1  0x00000001 (const dword)  (not used)
RULERGAUGE_HC                         24  0x00000018 (const dword)  (not used)
RULERGAUGE_height                      6  0x00000006 (const dword)  (not used)
RULERGAUGE_IC                         30  0x0000001e (const dword)  (not used)
RULERGAUGE_LC                         22  0x00000016 (const dword)  (not used)
RULERGAUGE_majorTickSize              16  0x00000010 (const dword)  (not used)
RULERGAUGE_MC                         26  0x0000001a (const dword)  (not used)
RULERGAUGE_medium                     18  0x00000012 (const dword)  (not used)
RULERGAUGE_minorTicks                 12  0x0000000c (const dword)  (not used)
RULERGAUGE_minorTickSize              14  0x0000000e (const dword)  (not used)
RULERGAUGE_options                    32  0x00000020 (const dword)  (not used)
RULERGAUGE_range                       8  0x00000008 (const dword)  (not used)
RULERGAUGE_TC                         28  0x0000001c (const dword)  (not used)
RULERGAUGE_threshold                  20  0x00000014 (const dword)  (not used)
RULERGAUGE_ticks                      10  0x0000000a (const dword)  (not used)
RULERGAUGE_width                       4  0x00000004 (const dword)  (not used)
RULERGAUGE_XP                          0  0x00000000 (const dword)  (not used)
RULERGAUGE_YP                          2  0x00000002 (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCALE_BC                              20  0x00000014 (const dword)  (not used)
SCALE_BR                             N/A         N/A (macro)    0x0002   (not used)
SCALE_CenterGap                       26  0x0000001a (const dword)  (not used)
SCALE_CENTRE                         N/A         N/A (macro)    0x0003   (not used)
SCALE_END_ALIGN                      N/A         N/A (macro)    0x0020   (not used)
SCALE_FONT                            24  0x00000018 (const dword)  (not used)
SCALE_HIDE_ZERO                      N/A         N/A (macro)    0x0000   (not used)
SCALE_HORZ                           N/A         N/A (macro)    0x0000   (not used)
SCALE_length                           4  0x00000004 (const dword)  (not used)
SCALE_max                              8  0x00000008 (const dword)  (not used)
SCALE_min                              6  0x00000006 (const dword)  (not used)
SCALE_NO_END_ALIGN                   N/A         N/A (macro)    0x0000   (not used)
SCALE_NONE                           N/A         N/A (macro)    0x0000   (not used)
SCALE_SHOW_ZERO                      N/A         N/A (macro)    0x0040   (not used)
SCALE_TC                              18  0x00000012 (const dword)  (not used)
SCALE_ticklength                      12  0x0000000c (const dword)  (not used)
SCALE_ticklengthMinor                 16  0x00000010 (const dword)  (not used)
SCALE_ticks                           10  0x0000000a (const dword)  (not used)
SCALE_TICKS_BOTH                     N/A         N/A (macro)    0x000c   (not used)
SCALE_TICKS_BR                       N/A         N/A (macro)    0x0008   (not used)
SCALE_TICKS_NONE                     N/A         N/A (macro)    0x0000   (not used)
SCALE_TICKS_TL                       N/A         N/A (macro)    0x0004   (not used)
SCALE_ticksMinor                      14  0x0000000e (const dword)  (not used)
SCALE_TL                             N/A         N/A (macro)    0x0001   (not used)
SCALE_type                            28  0x0000001c (const dword)  (not used)
SCALE_VERT                           N/A         N/A (macro)    0x0010   (not used)
SCALE_XC                              22  0x00000016 (const dword)  (not used)
SCALE_XP                               0  0x00000000 (const dword)  (not used)
SCALE_YP                               2  0x00000002 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
SendReport                          7217  0x00001c31 (User func) args[4] r=0  (usage 6)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 21)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                            7300  0x00001c84 (User func) args[1] r=0  (usage 15)
seroutOcs                           7267  0x00001c63 (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (usage 12)
SLIDER5_base_color                    14  0x0000000e (const dword)  (not used)
SLIDER5_F_ORIENT_VERT                N/A         N/A (macro)     0x0001    /* Switch orientation (0 - horizontal, 1 - vertical) */   (not used)
SLIDER5_F_PROGRESSBAR                N/A         N/A (macro)     0x0008    /* Progress Bar mode */   (not used)
SLIDER5_F_TICKS                      N/A         N/A (macro)     0x0002    /* Enable Marker Ticks*/   (not used)
SLIDER5_F_VALUE_IND                  N/A         N/A (macro)     0x0004    /* Enable slider value indicator */   (not used)
SLIDER5_font_c                        38  0x00000026 (const dword)  (not used)
SLIDER5_font_s                        36  0x00000024 (const dword)  (not used)
SLIDER5_knob_f_c_1                    46  0x0000002e (const dword)  (not used)
SLIDER5_knob_f_c_2                    48  0x00000030 (const dword)  (not used)
SLIDER5_knob_f_g                      50  0x00000032 (const dword)  (not used)
SLIDER5_knob_o_c_1                    40  0x00000028 (const dword)  (not used)
SLIDER5_knob_o_c_2                    42  0x0000002a (const dword)  (not used)
SLIDER5_knob_o_g                      44  0x0000002c (const dword)  (not used)
SLIDER5_len                            4  0x00000004 (const dword)  (not used)
SLIDER5_max_val                       12  0x0000000c (const dword)  (not used)
SLIDER5_min_val                       10  0x0000000a (const dword)  (not used)
SLIDER5_num_ticks_L_1                 24  0x00000018 (const dword)  (not used)
SLIDER5_num_ticks_L_2                 26  0x0000001a (const dword)  (not used)
SLIDER5_options                        8  0x00000008 (const dword)  (not used)
SLIDER5_thk                            6  0x00000006 (const dword)  (not used)
SLIDER5_tick_maj_c                    30  0x0000001e (const dword)  (not used)
SLIDER5_tick_maj_l                    28  0x0000001c (const dword)  (not used)
SLIDER5_tick_min_c                    34  0x00000022 (const dword)  (not used)
SLIDER5_tick_min_l                    32  0x00000020 (const dword)  (not used)
SLIDER5_total_tick_B_R                22  0x00000016 (const dword)  (not used)
SLIDER5_total_tick_T_L                20  0x00000014 (const dword)  (not used)
SLIDER5_track_color                   18  0x00000012 (const dword)  (not used)
SLIDER5_track_empty                   16  0x00000010 (const dword)  (not used)
SLIDER5_x_pos                          0  0x00000000 (const dword)  (not used)
SLIDER5_y_pos                          2  0x00000002 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Freq                            -302  0xfffffed2 (PmmC func) args[2] r=1  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_RTTTL                           -309  0xfffffecb (PmmC func) args[1] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SOUND                                  3  0x00000003 (const dword)  (not used)
SOUTH                                  1  0x00000001 (const dword)  (not used)
SOUTH_MIRRORED                         5  0x00000005 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
Strings0Count                          1  0x00000001 (const dword)  (not used)
Strings0Size                          13  0x0000000d (const dword)  (usage 3)
Strings0StartH                         0  0x00000000 (const dword)  (usage 3)
Strings0StartL                       512  0x00000200 (const dword)  (usage 3)
Strings10Count                         1  0x00000001 (const dword)  (not used)
Strings10Size                          7  0x00000007 (const dword)  (usage 3)
Strings10StartH                        0  0x00000000 (const dword)  (usage 3)
Strings10StartL                     3072  0x00000c00 (const dword)  (usage 3)
Strings11Count                         1  0x00000001 (const dword)  (not used)
Strings11Size                         15  0x0000000f (const dword)  (usage 3)
Strings11StartH                        0  0x00000000 (const dword)  (usage 3)
Strings11StartL                     3584  0x00000e00 (const dword)  (usage 3)
Strings12Count                         1  0x00000001 (const dword)  (not used)
Strings12Size                         13  0x0000000d (const dword)  (usage 3)
Strings12StartH                        0  0x00000000 (const dword)  (usage 3)
Strings12StartL                     4096  0x00001000 (const dword)  (usage 3)
Strings13Count                         1  0x00000001 (const dword)  (not used)
Strings13Size                          4  0x00000004 (const dword)  (usage 3)
Strings13StartH                        0  0x00000000 (const dword)  (usage 3)
Strings13StartL                     9216  0x00002400 (const dword)  (usage 3)
Strings14Count                         1  0x00000001 (const dword)  (not used)
Strings14Size                         16  0x00000010 (const dword)  (usage 3)
Strings14StartH                        0  0x00000000 (const dword)  (usage 3)
Strings14StartL                     9728  0x00002600 (const dword)  (usage 3)
Strings15Count                         1  0x00000001 (const dword)  (not used)
Strings15Size                         13  0x0000000d (const dword)  (usage 3)
Strings15StartH                        0  0x00000000 (const dword)  (usage 3)
Strings15StartL                     4608  0x00001200 (const dword)  (usage 3)
Strings16Count                         1  0x00000001 (const dword)  (not used)
Strings16Size                         13  0x0000000d (const dword)  (usage 3)
Strings16StartH                        0  0x00000000 (const dword)  (usage 3)
Strings16StartL                     5120  0x00001400 (const dword)  (usage 3)
Strings17Count                         1  0x00000001 (const dword)  (not used)
Strings17Size                          6  0x00000006 (const dword)  (usage 3)
Strings17StartH                        0  0x00000000 (const dword)  (usage 3)
Strings17StartL                    11264  0x00002c00 (const dword)  (usage 3)
Strings18Count                         1  0x00000001 (const dword)  (not used)
Strings18Size                          6  0x00000006 (const dword)  (usage 3)
Strings18StartH                        0  0x00000000 (const dword)  (usage 3)
Strings18StartL                     5632  0x00001600 (const dword)  (usage 3)
Strings19Count                         1  0x00000001 (const dword)  (not used)
Strings19Size                          6  0x00000006 (const dword)  (usage 3)
Strings19StartH                        0  0x00000000 (const dword)  (usage 3)
Strings19StartL                     6144  0x00001800 (const dword)  (usage 3)
Strings1Count                          1  0x00000001 (const dword)  (not used)
Strings1Size                          12  0x0000000c (const dword)  (usage 3)
Strings1StartH                         0  0x00000000 (const dword)  (usage 3)
Strings1StartL                     15872  0x00003e00 (const dword)  (usage 3)
Strings20Count                         1  0x00000001 (const dword)  (not used)
Strings20Size                          5  0x00000005 (const dword)  (usage 3)
Strings20StartH                        0  0x00000000 (const dword)  (usage 3)
Strings20StartL                     6656  0x00001a00 (const dword)  (usage 3)
Strings21Count                         1  0x00000001 (const dword)  (not used)
Strings21Size                          3  0x00000003 (const dword)  (usage 3)
Strings21StartH                        0  0x00000000 (const dword)  (usage 3)
Strings21StartL                     7168  0x00001c00 (const dword)  (usage 3)
Strings22Count                         1  0x00000001 (const dword)  (not used)
Strings22Size                         13  0x0000000d (const dword)  (usage 3)
Strings22StartH                        0  0x00000000 (const dword)  (usage 3)
Strings22StartL                     7680  0x00001e00 (const dword)  (usage 3)
Strings23Count                         1  0x00000001 (const dword)  (not used)
Strings23Size                          5  0x00000005 (const dword)  (usage 3)
Strings23StartH                        0  0x00000000 (const dword)  (usage 3)
Strings23StartL                     8192  0x00002000 (const dword)  (usage 3)
Strings24Count                         1  0x00000001 (const dword)  (not used)
Strings24Size                         12  0x0000000c (const dword)  (usage 3)
Strings24StartH                        0  0x00000000 (const dword)  (usage 3)
Strings24StartL                     8704  0x00002200 (const dword)  (usage 3)
Strings25Count                         1  0x00000001 (const dword)  (not used)
Strings25Size                          5  0x00000005 (const dword)  (usage 3)
Strings25StartH                        0  0x00000000 (const dword)  (usage 3)
Strings25StartL                    10240  0x00002800 (const dword)  (usage 3)
Strings26Count                         1  0x00000001 (const dword)  (not used)
Strings26Size                         17  0x00000011 (const dword)  (usage 3)
Strings26StartH                        0  0x00000000 (const dword)  (usage 3)
Strings26StartL                    10752  0x00002a00 (const dword)  (usage 3)
Strings27Count                         1  0x00000001 (const dword)  (not used)
Strings27Size                          3  0x00000003 (const dword)  (usage 3)
Strings27StartH                        0  0x00000000 (const dword)  (usage 3)
Strings27StartL                    12800  0x00003200 (const dword)  (usage 3)
Strings28Count                         1  0x00000001 (const dword)  (not used)
Strings28Size                         10  0x0000000a (const dword)  (usage 3)
Strings28StartH                        0  0x00000000 (const dword)  (usage 3)
Strings28StartL                    13312  0x00003400 (const dword)  (usage 3)
Strings29Count                         1  0x00000001 (const dword)  (not used)
Strings29Size                          4  0x00000004 (const dword)  (usage 3)
Strings29StartH                        0  0x00000000 (const dword)  (usage 3)
Strings29StartL                    14336  0x00003800 (const dword)  (usage 3)
Strings2Count                          1  0x00000001 (const dword)  (not used)
Strings2Size                          17  0x00000011 (const dword)  (usage 3)
Strings2StartH                         0  0x00000000 (const dword)  (usage 3)
Strings2StartL                         0  0x00000000 (const dword)  (usage 3)
Strings30Count                         1  0x00000001 (const dword)  (not used)
Strings30Size                          6  0x00000006 (const dword)  (usage 3)
Strings30StartH                        0  0x00000000 (const dword)  (usage 3)
Strings30StartL                    14848  0x00003a00 (const dword)  (usage 3)
Strings31Count                         1  0x00000001 (const dword)  (not used)
Strings31Size                         13  0x0000000d (const dword)  (usage 3)
Strings31StartH                        0  0x00000000 (const dword)  (usage 3)
Strings31StartL                    15360  0x00003c00 (const dword)  (usage 3)
Strings32Count                         1  0x00000001 (const dword)  (not used)
Strings32Size                          2  0x00000002 (const dword)  (usage 3)
Strings32StartH                        0  0x00000000 (const dword)  (usage 3)
Strings32StartL                    16384  0x00004000 (const dword)  (usage 3)
Strings3Count                          1  0x00000001 (const dword)  (not used)
Strings3Size                           6  0x00000006 (const dword)  (usage 3)
Strings3StartH                         0  0x00000000 (const dword)  (usage 3)
Strings3StartL                     11776  0x00002e00 (const dword)  (usage 3)
Strings4Count                          1  0x00000001 (const dword)  (not used)
Strings4Size                           4  0x00000004 (const dword)  (usage 3)
Strings4StartH                         0  0x00000000 (const dword)  (usage 3)
Strings4StartL                      1024  0x00000400 (const dword)  (usage 3)
Strings5Count                          1  0x00000001 (const dword)  (not used)
Strings5Size                           6  0x00000006 (const dword)  (usage 3)
Strings5StartH                         0  0x00000000 (const dword)  (usage 3)
Strings5StartL                      1536  0x00000600 (const dword)  (usage 3)
Strings6Count                          1  0x00000001 (const dword)  (not used)
Strings6Size                          12  0x0000000c (const dword)  (usage 3)
Strings6StartH                         0  0x00000000 (const dword)  (usage 3)
Strings6StartL                     12288  0x00003000 (const dword)  (usage 3)
Strings7Count                          1  0x00000001 (const dword)  (not used)
Strings7Size                          13  0x0000000d (const dword)  (usage 3)
Strings7StartH                         0  0x00000000 (const dword)  (usage 3)
Strings7StartL                      2048  0x00000800 (const dword)  (usage 3)
Strings8Count                          1  0x00000001 (const dword)  (not used)
Strings8Size                          13  0x0000000d (const dword)  (usage 3)
Strings8StartH                         0  0x00000000 (const dword)  (usage 3)
Strings8StartL                     13824  0x00003600 (const dword)  (usage 3)
Strings9Count                          1  0x00000001 (const dword)  (not used)
Strings9Size                           5  0x00000005 (const dword)  (usage 3)
Strings9StartH                         0  0x00000000 (const dword)  (usage 3)
Strings9StartL                      2560  0x00000a00 (const dword)  (usage 3)
stringsCV                            322  0x00000142 (mem) word[33] (global)  (usage 27)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
SWITCH1_cOff                          20  0x00000014 (const dword)  (not used)
SWITCH1_cOn                           18  0x00000012 (const dword)  (not used)
SWITCH1_dshd                          12  0x0000000c (const dword)  (not used)
SWITCH1_F_ORIENT_VERT                N/A         N/A (macro)   0x0001  /* switch orientation (0: Horizontal, 1: Vertical) */   (not used)
SWITCH1_fcOff                         32  0x00000020 (const dword)  (not used)
SWITCH1_fcOn                          30  0x0000001e (const dword)  (not used)
SWITCH1_flg                            8  0x00000008 (const dword)  (not used)
SWITCH1_fnt                           26  0x0000001a (const dword)  (not used)
SWITCH1_fsz                           28  0x0000001c (const dword)  (not used)
SWITCH1_len                            4  0x00000004 (const dword)  (not used)
SWITCH1_lshd                          10  0x0000000a (const dword)  (not used)
SWITCH1_oBz                           14  0x0000000e (const dword)  (not used)
SWITCH1_tBz                           16  0x00000010 (const dword)  (not used)
SWITCH1_thk                            6  0x00000006 (const dword)  (not used)
SWITCH1_tOff                          24  0x00000018 (const dword)  (not used)
SWITCH1_tOn                           22  0x00000016 (const dword)  (not used)
SWITCH1_x                              0  0x00000000 (const dword)  (not used)
SWITCH1_y                              2  0x00000002 (const dword)  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_Driver                          -297  0xfffffed7 (PmmC func) args[0] r=0  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_PmmC                            -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 18)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 3)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tiAngularMeter                        39  0x00000027 (const dword)  (usage 21)
tiButtonD                             51  0x00000033 (const dword)  (usage 3)
tiButtonE                             52  0x00000034 (const dword)  (usage 3)
tiDial                                55  0x00000037 (const dword)  (usage 3)
tiGauge                               40  0x00000028 (const dword)  (usage 3)
tiLabelB                              41  0x00000029 (const dword)  (usage 6)
tiLed                                 45  0x0000002d (const dword)  (usage 3)
tiLedDigit                            50  0x00000032 (const dword)  (usage 9)
tiLedDigits                           47  0x0000002f (const dword)  (usage 6)
tiLedDigitsH                          38  0x00000026 (const dword)  (usage 12)
tiLinearInput                         67  0x00000043 (const dword)  (usage 9)
tImage                                12  0x0000000c (const dword)  (usage 3)
tiMediaButton                         53  0x00000035 (const dword)  (usage 3)
tiMediaGauge                          43  0x0000002b (const dword)  (usage 3)
tiMediaLed                            46  0x0000002e (const dword)  (usage 3)
tiMediaRotary                         56  0x00000038 (const dword)  (usage 3)
tiMediaSlider                         61  0x0000003d (const dword)  (usage 3)
tiMediaThermometer                    44  0x0000002c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tiNeedle                              48  0x00000030 (const dword)  (usage 3)
tiRotaryInput                         57  0x00000039 (const dword)  (usage 6)
tiRuler                               49  0x00000031 (const dword)  (usage 3)
tiSliderC                             66  0x00000042 (const dword)  (usage 3)
tiSliderD                             65  0x00000041 (const dword)  (usage 3)
tiSliderE                             60  0x0000003c (const dword)  (usage 3)
tiSliderF                             64  0x00000040 (const dword)  (usage 3)
tiSliderG                             63  0x0000003f (const dword)  (usage 3)
tiSliderH                             62  0x0000003e (const dword)  (usage 3)
tiSwitch                              58  0x0000003a (const dword)  (usage 3)
tiSwitchB                             59  0x0000003b (const dword)  (usage 6)
tiToggleInput                         54  0x00000036 (const dword)  (usage 6)
tiUserGauge                           42  0x0000002a (const dword)  (usage 3)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 6)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 3)
tMagicObject                          34  0x00000022 (const dword)  (usage 6)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 12)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 18)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           606  0x0000025e (mem) word (global)  (usage 24)
TouchXpos                            600  0x00000258 (mem) word (global)  (usage 12)
TouchYpos                            602  0x0000025a (mem) word (global)  (usage 9)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSmartGauge                           35  0x00000023 (const dword)  (usage 6)
tSmartKnob                            37  0x00000025 (const dword)  (usage 6)
tSmartSlider                          36  0x00000024 (const dword)  (usage 6)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 18)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 6)
TurnOffButtons                      6348  0x000018cc (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 42)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 30)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (usage 3)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 3)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 3)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 3)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (usage 3)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (usage 3)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                           -345  0xfffffea7 (PmmC func) args[3] r=1  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 3)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       5067  0x000013cb (User func) args[1] r=0  (usage 3)
USD_ENABLE                            25  0x00000019 (const dword)  (not used)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
vIAngularMeter0                        2  0x00000002 (mem) word[10] (global)  (usage 3)
vIAngularMeter1                       22  0x00000016 (mem) word[10] (global)  (usage 3)
vIAngularMeter2                      158  0x0000009e (mem) word[10] (global)  (usage 3)
vIAngularMeter3                       66  0x00000042 (mem) word[10] (global)  (usage 3)
vILedDigits0                          42  0x0000002a (mem) word[12] (global)  (usage 3)
vILedDigits1                          86  0x00000056 (mem) word[12] (global)  (usage 3)
vILedDigits2                         110  0x0000006e (mem) word[12] (global)  (usage 3)
vILedDigits3                         134  0x00000086 (mem) word[12] (global)  (usage 3)
vILedDigits4                         178  0x000000b2 (mem) word[12] (global)  (usage 3)
vILedDigits5                         274  0x00000112 (mem) word[12] (global)  (usage 3)
vILedDigits6                         202  0x000000ca (mem) word[12] (global)  (usage 3)
vILedDigits7                         226  0x000000e2 (mem) word[12] (global)  (usage 3)
vILedDigits8                         250  0x000000fa (mem) word[12] (global)  (usage 3)
vILedDigits9                         298  0x0000012a (mem) word[12] (global)  (usage 3)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
vObjects                             390  0x00000186 (mem) word[28] (global)  (usage 15)
WEST                                   2  0x00000002 (const dword)  (not used)
WEST_MIRRORED                          6  0x00000006 (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (usage 78)
WHITE                              65535  0x0000ffff (const dword)  (usage 63)
WHITESMOKE                         63422  0x0000f7be (const dword)  (usage 18)
widget_Add                          -323  0xfffffebd (PmmC func) args[3] r=1  (usage 3)
widget_ClearAttributes              -334  0xfffffeb2 (PmmC func) args[3] r=1  (usage 3)
widget_Create                       -322  0xfffffebe (PmmC func) args[1] r=1  (usage 3)
WIDGET_DECIMALS                       11  0x0000000b (const dword)  (not used)
WIDGET_DELAY                          10  0x0000000a (const dword)  (not used)
widget_Delete                       -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
widget_Disable                      -331  0xfffffeb5 (PmmC func) args[2] r=1  (usage 3)
widget_Enable                       -330  0xfffffeb6 (PmmC func) args[2] r=1  (usage 3)
WIDGET_F_DISABLED                   2048  0x00000800 (const dword)  (not used)
WIDGET_F_FLASH                      1024  0x00000400 (const dword)  (not used)
WIDGET_F_INITIALISED                8192  0x00002000 (const dword)  (usage 3)
WIDGET_F_INTERNAL                  16384  0x00004000 (const dword)  (not used)
WIDGET_F_RESERVED                    960  0x000003c0 (const dword)  (not used)
WIDGET_F_TOUCH_ENABLE              32768  0x00008000 (const dword)  (usage 3)
WIDGET_F_UNDRAW_ONLY                4096  0x00001000 (const dword)  (not used)
WIDGET_FLAGS                           6  0x00000006 (const dword)  (not used)
widget_FontID                       -336  0xfffffeb0 (PmmC func) args[1] r=1  (not used)
WIDGET_FRAMES                         11  0x0000000b (const dword)  (not used)
widget_GetWord                      -328  0xfffffeb8 (PmmC func) args[3] r=1  (not used)
WIDGET_HEIGHT                          3  0x00000003 (const dword)  (not used)
WIDGET_HI_WORD                         5  0x00000005 (const dword)  (not used)
WIDGET_LO_WORD                         4  0x00000004 (const dword)  (not used)
widget_LoadFlash                    -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
WIDGET_RAM_SPACE                      10  0x0000000a (const dword)  (usage 42)
widget_Realloc                      -327  0xfffffeb9 (PmmC func) args[2] r=1  (not used)
widget_SetAttributes                -333  0xfffffeb3 (PmmC func) args[3] r=1  (usage 3)
widget_Setposition                  -329  0xfffffeb7 (PmmC func) args[4] r=1  (not used)
widget_SetWord                      -332  0xfffffeb4 (PmmC func) args[4] r=1  (not used)
widget_Show                         -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
WIDGET_TAG                             7  0x00000007 (const dword)  (not used)
WIDGET_TAG2                            8  0x00000008 (const dword)  (not used)
widget_Touched                      -335  0xfffffeb1 (PmmC func) args[2] r=1  (usage 3)
WIDGET_VAL1                            9  0x00000009 (const dword)  (usage 9)
WIDGET_VAL2                           10  0x0000000a (const dword)  (not used)
WIDGET_WIDTH                           2  0x00000002 (const dword)  (not used)
WIDGET_XOTHER                          4  0x00000004 (const dword)  (not used)
WIDGET_XPOS                            0  0x00000000 (const dword)  (not used)
WIDGET_YOTHER                          5  0x00000005 (const dword)  (not used)
WIDGET_YPOS                            1  0x00000001 (const dword)  (not used)
wp                                   856  0x00000358 (mem) word (global)  (usage 21)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_LABEL                           12  0x0000000c (const dword)  (usage 6)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_STR                              2  0x00000002 (const dword)  (usage 6)
WRITE_STRU                             3  0x00000003 (const dword)  (usage 6)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         6575  0x000019af (User func) args[3] r=0  (usage 27)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
xobj2iobj                            209  0x000000d1xobj2iobj                            209  0x000000d1 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
XYLIN_X                                1  0x00000001 (const dword)  (not used)
XYLIN_Y                                0  0x00000000 (const dword)  (not used)
XYROT_EAST                             0  0x00000000 (const dword)  (not used)
XYROT_SOUTH                            1  0x00000001 (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
