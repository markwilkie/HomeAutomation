file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\pixxiLCD-39P4CT.fnc

000001  000001  #platform "pixxiLCD-39P4CT"
000002  000001  #platform "pixxiLCD-39P4CT"
000003  000008  */
000004  000009      #constant pixxiLCD_39P4CT
000005  000009      #constant pixxiLCD_39P4CT
000006  000010        
000007  000011      #IFNOT EXISTS PIXXI44_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PIXXI44functions.fnc

000008  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000009  000012          #inherit "PIXXI44functions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PIXXI44_FUNCTIONS
000014  000004  #constant PIXXI44_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000019  #END
000019  000020        
000020  000021  #CONST
000021  000027  #END
000022  000028        
000023  000029        
000024  000030  #CONST
000025  000044  #END
000026  000045        
000027  000046        
000028  000047  #CONST
000029  000212  #END
000030  000213        
000031  000214        
000032  000215  // baud divisor rates for setbaud(n);
000033  000216  #CONST
000034  000238  #END
000035  000239        
000036  000240        
000037  000241        
000038  000242        
000039  000247  */
000040  000248        
000041  000249        
000042  000250  //==============================================//
000043  000251  // EVE bios functions                           //
000044  000252  //==============================================//
000045  000253                                                  //
000046  000254  func serin(), 1;                // read a byte from COM0
000047  000255  // Syntax: serin();
000048  000256  // Usage : char := serin();
000049  000257  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000258  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000259  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000260  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000261  //     : Returns: -1 if no character is available
000054  000262  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000263  //     : Returns: positive value 0 to 255 for a valid character received
000056  000264        
000057  000265  func putch("char"), 0;                // write single char to current output device
000058  000266  // Syntax: putch("char");
000059  000267  // Usage : putch("A");
000060  000268  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000269  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000270  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000271  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000272  //     : The arguments can be a variable, array element, expression or constant
000065  000273        
000066  000274  func serout("char"), 0;                // write a byte to COM0
000067  000275  // Syntax: serout1("char");
000068  000276  // Usage : serout1(ch);
000069  000277  // Notes : send character to COM1
000070  000278        
000071  000279  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000280  // Syntax: setbaud(baud_number);
000073  000281  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000282  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000283  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000284  //       : this is used as a table pointer to get the baud rate divisor
000077  000285  //       : value for one of the 20 selected baud rates, control is then
000078  000286  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000287  //       : The pre-defined constants equate to a value of 0-19.
000080  000288  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000289  //       : will occur.
000082  000290        
000083  000291  func to("device"), 1;                // output device redirection
000084  000292  // Syntax: to(outstream);
000085  000293  // Usage : to(APPEND); putstr("TWO ");
000086  000294  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000295  //     :
000088  000296  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000297  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000298  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000299  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000300  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000301  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000302  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000303  //     : sequential data to a media stream.
000096  000304  //     :
000097  000305  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000306  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000307  //     :                            appended to user memory if previous redirection was to an array.
000100  000308  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000309  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000310  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000311  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000312  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000313        
000106  000314        
000107  000315  func pause("milliseconds"), 0;            // blocking delay
000108  000316  // Syntax: pause(milliseconds);
000109  000317  // Usage : pause(1000);                //pause for 1 second
000110  000318  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000319        
000112  000320  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000321  // Syntax: putnum(format, value);
000114  000322  // Usage : var := putnum(HEX, val);
000115  000323  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000324  //     : Format: A constant that specifies the number format
000117  000325  //     : Value : The number to be printed
000118  000326  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000327  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000328  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000329  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000330  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000331  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000332  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000333  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000334  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000335  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000336  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000337  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000338  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000339  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000340  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000341  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000342  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000343  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000344  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000345  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000346  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000347  //     : | | | | V V V
000140  000348  //     : | | | | | | |
000141  000349  //     : | | | | | |
000142  000350  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000351  //     : | | | | digit count |
000144  000352  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000353  //     : | | | |
000146  000354  //     : | | | |
000147  000355  //     : | | | |
000148  000356  //     : | | | |
000149  000357  //     : | | | |
000150  000358  //     : | | | |______ 1 = leading zeros included
000151  000359  //     : | | | 0 = leading zeros suppressed
000152  000360  //     : | | |
000153  000361  //     : | | |
000154  000362  //     : | | |_______ 1 = leading zero blanking
000155  000363  //     : | |
000156  000364  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000365  //     : |
000158  000366  //     : |______ 1 = space before unsigned number
000159  000367        
000160  000368        
000161  000369  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000370        
000163  000371  func putstr("string"), 1;                       // print string to current output device
000164  000372  // Syntax: putstr(pointer);
000165  000373  // Usage : putstr("HELLO\n");
000166  000374  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000375  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000376  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000377  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000378  //       : using the to(...); function.
000171  000379  //       : A string constant is automatically terminated with a zero.
000172  000380  //       : A string in a data statement is not automatically terminated with a zero.
000173  000381  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000382  //       : element packs 1 or 2 characters.
000175  000383        
000176  000384        
000177  000385  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000386  // Syntax: strlen("varAddress);
000179  000387  // Usage : strlen("HELLO\n");
000180  000388  // Notes : gives the length of a string that is packed into regular var array
000181  000389  //       : Use str_Length(ptr)  for string pointer mode
000182  000390        
000183  000391        
000184  000392  //==============================================//
000185  000393  // Memory Access Function Prototypes            //
000186  000394  //==============================================//
000187  000395                                                  //
000188  000396  func peekW("address"), 1;                       // read a word from system memory
000189  000397  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000398  // refer to address map of internal variables   //
000191  000399  //==============================================//
000192  000400  // Math Functions                               //
000193  000401  //==============================================//
000194  000402                                                  //
000195  000403  func ABS("value"), 1;                           // return a positive number
000196  000404  // Syntax: ABS(value);
000197  000405  // Usage : var := ABS(arg);
000198  000406  // Notes : Returns the absolute value of an argument
000199  000407        
000200  000408  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000409  // Syntax: MIN(value1, value2);
000202  000410  // Usage : var := MIN(arg1, arg2);
000203  000411  // Notes : Returns the minimum of 2 arguments
000204  000412        
000205  000413  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000414  // Syntax: MAX(value1, value2);
000207  000415  // Usage : var := MAX(arg1, arg2);
000208  000416  // Notes : Returns the maximum of 2 arguments
000209  000417        
000210  000418  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000419  // Syntax: SWAP(&var1, &var2);
000212  000420  // Usage : SWAP(&var1, &var2);
000213  000421  // Notes : Swaps the contents of 2 variables or memory locations
000214  000422        
000215  000423  func SIN("angle"), 1;                           // return SIN of angle
000216  000424  // Syntax: SIN(angle);
000217  000425  // Usage : var := SIN(arg);
000218  000426  // Notes : Returns the sine in radians of an argument in degrees
000219  000427  //       : the returned value range is from 127 to -127. The real
000220  000428  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000429  //       : scaling must be done in user code.
000222  000430        
000223  000431  func COS("angle"), 1;                           // return COS of angle
000224  000432  // Syntax: COS(angle);
000225  000433  // Usage : var := COS(arg);
000226  000434  // Notes : Returns the cosine in radians of an argument in degrees
000227  000435  //       : the returned value range is from 127 to -127. The real
000228  000436  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000437  //       : scaling must be done in user code.
000230  000438        
000231  000439  func RAND(), 1;                                 // return a pseudo random number
000232  000440  // Syntax: RAND();
000233  000441  // Usage : var := RAND();
000234  000442  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000443  //       : The random number generator must first be seeded
000236  000444  //       : by using the SEED(number) function.
000237  000445        
000238  000446  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000447  // Syntax: SEED(number);
000240  000448  // Usage : SEED(arg);
000241  000449  // Notes : Seeds the random number generator.
000242  000450        
000243  000451  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000452  // Syntax: OVF();
000245  000453  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000454  //       : hiWord := OVF();
000247  000455  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000456        
000249  000457  func SQRT("number"), 1;                         // return square root of a number
000250  000458  // Syntax: SQRT(number);
000251  000459  // Usage : SQRT(arg);
000252  000460  // Notes : Returns the integer square root of a number.
000253  000461  //------------------------------------------------------------------//
000254  000462  //          Text Related Function Prototypes
000255  000463  //------------------------------------------------------------------//
000256  000464        
000257  000465  func txt_MoveCursor("line", "column"), 0;
000258  000466  // Syntax: txt_SetCursor(line, column);
000259  000467  // Usage : txt_SetCursor(arg1, arg2);
000260  000468  // Notes : Moves the text Cursor to a new screen position set by
000261  000469  //       : line,column parameters.
000262  000470        
000263  000471  func txt_Set("mode", "value"), 0;
000264  000472  // Syntax: txt_Set(mode, value);
000265  000473  // Usage : txt_Set(arg1, arg2);
000266  000474  // Returns : Original value before the change
000267  000475  // Notes : Sets various text related parameters used by other functions
000268  000476  //       : This allows the features to be set programatically with a
000269  000477  //       : single function call.It is strongly recommended to use the
000270  000478  //       : pre-defined constants rather than the mode numbers.
000271  000479  //       : NB:- Although it is often required to be able to set text
000272  000480  //       : functions with a single function call for graphics engine
000273  000481  //       : related functions, there is a complete set of single parameter
000274  000482  //       : shortcut functions that have exactly the same function as
000275  000483  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000484  //       :
000277  000485  //       : mode = TEXT_COLOUR (mode 0)
000278  000486  //       : txt_Set(TEXT_COLOUR, value);
000279  000487  //       : value = 0 to 0xFFFF, Black to White
000280  000488  //       : Sets the Text colour for the display
000281  000489  //       : Default = LIME.
000282  000490  //       :
000283  000491  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000492  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000493  //       : value = 0 to 0xFFFF, Black to White
000286  000494  //       : Sets the Text background colour for the display. Effective
000287  000495  //       : when text mode is Opaque.
000288  000496  //       : Default = BLACK.
000289  000497  //       :
000290  000498  //       : mode = FONT_ID (mode 2)
000291  000499  //       : txt_Set(FONT_ID, value);
000292  000500  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000501  //       : else this value is the name of a font included
000294  000502  //       : in a users program in a data statement.
000295  000503  //       : Default = FONT SIZE 3.
000296  000504  //       :
000297  000505  //       : mode = TEXT_WIDTH  (mode 3)
000298  000506  //       : txt_Set(TEXT_WIDTH, value);
000299  000507  //       : value = 1 to 16
000300  000508  //       : Sets the Text Width multiplier
000301  000509  //       : text will be printed magnified horizontally
000302  000510  //       : by this factor, Default = 1.
000303  000511  //       :
000304  000512  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000513  //       : txt_Set(TEXT_HEIGHT, value);
000306  000514  //       : value = 1 to 16
000307  000515  //       : Sets the Text Height multiplier
000308  000516  //       : text will be printed magnified vertically
000309  000517  //       : by this factor, Default = 1.
000310  000518  //       :
000311  000519  //       : mode = TEXT_XGAP  (mode 5)
000312  000520  //       : txt_Set(TEXT_XGAP, value);
000313  000521  //       : value = 1 to 32
000314  000522  //       : Sets the horizontal gap between characters
000315  000523  //       : The gap is in pixel units, Default = 0
000316  000524  //       :
000317  000525  //       : mode = TEXT_YGAP  (mode 6)
000318  000526  //       : txt_Set(TEXT_YGAP, value);
000319  000527  //       : value = 1 to 32
000320  000528  //       : Sets the vertical gap below characters
000321  000529  //       : The gap is in pixel units, Default = 0
000322  000530  //       :
000323  000531  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000532  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000533  //       : value = 0 to 255
000326  000534  //       : Sets the delay time (in ms) during character
000327  000535  //       : printing to give a 'teletype' like effect.
000328  000536  //       : Often used to attract attention to a string
000329  000537  //       : being printed which can often be missed if
000330  000538  //       : just suddenly appearing or changing.
000331  000539  //       : Default = 0 ms.
000332  000540  //       :
000333  000541  //       : mode = TEXT_OPACITY (mode 8)
000334  000542  //       : txt_Set(TEXT_OPACITY, value);
000335  000543  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000544  //       : value = OPAQUE (1) = Text Opaque
000337  000545  //       : Sets the Opacity/Transparency of the text
000338  000546  //       : Default = 0 or TRANSPARENT
000339  000547  //       :
000340  000548  //       : mode = TEXT_BOLD (mode 9)
000341  000549  //       : txt_Set(TEXT_BOLD, value);
000342  000550  //       : value = dont care
000343  000551  //       : Sets Bold Text mode for the next string or char
000344  000552  //       : The feature automatically resets after printing
000345  000553  //       : using putstr or print has completed
000346  000554  //       :
000347  000555  //       : mode = TEXT_ITALIC (mode 10)
000348  000556  //       : txt_Set(TEXT_ITALIC, value);
000349  000557  //       : value = dont care
000350  000558  //       : Sets Italic Text mode for the next string or char
000351  000559  //       : The feature automatically resets after printing
000352  000560  //       : using putstr or print has completed
000353  000561        
000354  000562  //       : mode = TEXT_INVERSE (mode 11)
000355  000563  //       : txt_Set(TEXT_INVERSE, value);
000356  000564  //       : value = dont care
000357  000565  //       : Sets Inverse Text mode for the next string or char
000358  000566  //       : The feature automatically resets after printing
000359  000567  //       : using putstr or print has completed
000360  000568  //       :
000361  000569  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000570  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000571  //       : value = dont care
000364  000572  //       : Sets Underlined Text mode for the next string or char
000365  000573  //       : The feature automatically resets after printing
000366  000574  //       : using putstr or print has completed
000367  000575  //       :
000368  000576  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000577  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000578  //       : value = bits are defined as:
000371  000579  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000580  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000581  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000582  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000583  //       : Allows a combination of text attributes to be defined together
000376  000584  //       : by 'or'ing the bits together.
000377  000585  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000586  //       : The feature automatically resets after printing
000379  000587  //       : using putstr or print has completed.
000380  000588  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000589  //       :
000382  000590  //       : mode = TEXT_WRAP (mode 14)
000383  000591  //       : txt_Set(TEXT_WRAP , value);
000384  000592  //       : Sets the position where text wrap will occur
000385  000593  //       : The feature automatically resets when screen
000386  000594  //       : mode is changed. If the value is set to 0,
000387  000595  //       : text wrap is turned off.
000388  000596  //       : of the current screen. Default value is 0
000389  000597  // Notes : The value is in pixel units.
000390  000598  //       :
000391  000599        
000392  000600  //       : txt_Set mode 15 reserved for future use
000393  000601  //       :
000394  000602        
000395  000603        
000396  000604        
000397  000605  //=====================================================//
000398  000606  // Single parameter short-cuts                         //
000399  000607  // for the txt_Set functions                           //
000400  000608  // These functions return the existing value before    //
000401  000609  // the change is made.                                 //
000402  000610  //=====================================================//
000403  000611  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000612  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000613  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000614  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000615  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000616  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000617  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000618  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000619  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000620  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000621  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000622  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000623  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000624  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000625  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000626  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000627        
000420  000628        
000421  000629  //------------------------------------------------------------------//
000422  000630  //                 Hardware Function Prototypes
000423  000631  //------------------------------------------------------------------//
000424  000632        
000425  000633  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000426  000634  // Syntax: pin_Set(mode, pin);
000427  000635  // Usage : pin_Set(arg1, arg2);
000428  000636  // Notes : Sets the appropriate pins to Inputs or Outputs
000429  000637  //       : returns true if the pin number is legal (usually ignored)
000430  000638  //       :
000431  000639  //       : "mode" is either INPUT or OUTPUT
000432  000640  //       :
000433  000641  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000434  000642  //       : of your PiXXi-44 processor.
000435  000643        
000436  000644  func pin_HI("pin"), 1;                    // set pin to logic '1'
000437  000645  // Syntax: pin_HI(pin);
000438  000646  // Usage : pin_HI(arg);
000439  000647  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000440  000648  //       : pin that was previously selected as an Output.
000441  000649  //       : returns true if the pin number is legal (usually ignored)
000442  000650  //       :
000443  000651  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000444  000652  //       : of your PiXXi-44 processor.
000445  000653        
000446  000654  func pin_LO("pin"), 1;                    // set pin to logic '0'
000447  000655  // Syntax: pin_LO(pin);
000448  000656  // Usage : pin_LO(arg);
000449  000657  // Notes : Outputs a logic "Low" (0V) on the appropriate
000450  000658  //       : pin that was previously selected as an Output.
000451  000659  //       : returns true if the pin number is legal (usually ignored)
000452  000660  //       :
000453  000661  //       : "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000454  000662  //       : of your PiXXi-44 processor.
000455  000663        
000456  000664  func pin_Read("pin"), 1;                // read pin, logic or analogue
000457  000665  // Syntax	: pin_Read(pin);
000458  000666  // Usage	: arg1 := pin_Read(arg2);
000459  000667  // Notes	: Reads the logic state of the appropriate
000460  000668  // 	: pin that was previously selected as an Input.
000461  000669  // 	:
000462  000670  // 	: "pin" is IO1_PIN through IO19_PIN, depending on the I/O configuration
000463  000671  // 	: of your PiXXi-44 processor.
000464  000672  // 	: Returns 0 or 1 for a digital input
000465  000673  // 	: Returns 0..4095 for an analogue input
000466  000674        
000467  000675  //------------------------------------------------------------------//
000468  000676  //                 P1 module BUS I/O control
000469  000677  //------------------------------------------------------------------//
000470  000678        
000471  000679  func bus_In(), 1;
000472  000680  // Syntax: bus_In();
000473  000681  // Usage : arg1 := bus_In();
000474  000682  // Notes : Read the 7bit wide bus into the lower 7 bits of arg1.
000475  000683  //       : The upper 9 bits of arg1 are set to 0.
000476  000684  //       : Only available in Mode 2 (4-Wire SPI)
000477  000685  //       : 
000478  000686  //       : BUS_0 is IO12_PIN
000479  000687  //       : BUS_1 is IO13_PIN
000480  000688  //       : BUS_2 is IO14_PIN
000481  000689  //       : BUS_3 is IO15_PIN
000482  000690  //       : BUS_4 is IO16_PIN
000483  000691  //       : BUS_5 is IO17_PIN
000484  000692  //       : BUS_6 is IO18_PIN
000485  000693  //       : BUS_7 is N/A
000486  000694        
000487  000695  func bus_Out("var"), 0;
000488  000696  // Syntax: bus_Out(var);
000489  000697  // Usage : bus_Out(arg1);
000490  000698  // Notes : The lower 7 bits of arg1 are placed on the 7bit wide bus.
000491  000699  //       : The upper 9 bits of arg1 are ignored.
000492  000700  //       : NB:- any BUS pins that are set to inputs are not affected.
000493  000701  //       : Only available in Mode 2 (4-Wire SPI)
000494  000702  //       :
000495  000703  //       : BUS_0 is pin 27 of J1
000496  000704  //       : BUS_1 is pin 25 of J1
000497  000705  //       : BUS_2 is pin 23 of J1
000498  000706  //       : BUS_3 is pin 21 of J1
000499  000707  //       : BUS_4 is pin 19 of J1
000500  000708  //       : BUS_5 is pin 17 of J1
000501  000709  //       : BUS_6 is pin 13 of J2
000502  000710  //       : BUS_7 is pin 11 of J2
000503  000711        
000504  000712  func bus_Set("var"), 0;
000505  000713  // Syntax: bus_Set(var);
000506  000714  // Usage : bus_Set(arg1);
000507  000715  // Notes : Not available on the Pixxi Chips
000508  000716        
000509  000717  func bus_Write("var"), 0;
000510  000718  // Syntax: bus_Write(var);
000511  000719  // Usage : bus_Write(arg1);
000512  000720  // Notes : Not available on the Pixxi Chips
000513  000721        
000514  000722  func bus_Read(), 1;
000515  000723  // Syntax: bus_Read();
000516  000724  // Usage : arg1 := bus_Read();
000517  000725  // Notes : Not available on the Pixxi Chips
000518  000726        
000519  000727        
000520  000728  //------------------------------------------------------------------//
000521  000729  //   Graphics Functions
000522  000730  //------------------------------------------------------------------//
000523  000731  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000524  000732  // Syntax: gfx_Set(mode, value);
000525  000733  // Usage : gfx_Set(arg1, arg2);
000526  000734  // Notes : Sets various graphics parameters used by other functions
000527  000735  //       : This allows the features to be set programatically with a
000528  000736  //       : single function call.It is strongly recommended to use the
000529  000737  //       : pre-defined constants rather than the mode numbers.
000530  000738  //       : NB:- Although it is often required to be able to set graphics
000531  000739  //       : functions with a single function call for graphics engine
000532  000740  //       : related functions, there is a complete set of single parameter
000533  000741  //       : shortcut functions that have exactly the same function as
000534  000742  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000535  000743  //       :
000536  000744  //       : mode = PEN_SIZE (mode 16)
000537  000745  //       : gfx_Set(PEN_SIZE, value);
000538  000746  //       : value = SOLID (value 0) rectangle and circle objects are solid
000539  000747  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000540  000748  //       : Sets the mode of the Pen used by most graphics objects
000541  000749  //       :
000542  000750  //       : mode = BACKGROUND_COLOUR (mode 17)
000543  000751  //       : gfx_Set(BACKGROUND_COLOUR, value);
000544  000752  //       : value = 0 to 0xFFFF, Black to White
000545  000753  //       : Sets the Background colour of the screen
000546  000754  //       :
000547  000755  //       : mode = OBJECT_COLOUR (mode 18)
000548  000756  //       : gfx_Set(OBJECT_COLOUR, value);
000549  000757  //       : value = 0 to 0xFFFF, Black to White
000550  000758  //       : Sets the Object colour used in various functions
000551  000759  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000552  000760  //       :
000553  000761  //       : mode = CLIPPING (mode 19)
000554  000762  //       : gfx_Set(CLIPPING, value);
000555  000763  //       : value = OFF (value 0) Clipping disabled
000556  000764  //       : value = ON (value 1) Clipping enabled
000557  000765  //       : Enables/Disables the Clipping feature
000558  000766  //       :
000559  000767  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000560  000768  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000561  000769  //       : value = 0 to 0xFFFF Black to White
000562  000770  //       : Sets Bitmap, Image or Animation Transparency Colour.
000563  000771  //       : NB not implemented
000564  000772  //       :
000565  000773  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000566  000774  //       : gfx_Set(5, value);
000567  000775  //       : value = OFF (value 0) Transparency disabled
000568  000776  //       : value = ON (value 1) Transparency enabled
000569  000777  //       : Enables/Disables the Transparency feature
000570  000778  //       : NB not implemented
000571  000779  //       :
000572  000780  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000573  000781  //       : gfx_Set(FRAME_DELAY, value);
000574  000782  //       : value = 0 to 65535 ms
000575  000783  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000576  000784  //       : over-ride the embedded frame delay of the clip. After the event,
000577  000785  //       : the setting will auto disable and if further inter-frame delays need
000578  000786  //       : overriding the setting must be re-issued.
000579  000787  //       :
000580  000788  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000581  000789  //       : gfx_Set(SCREEN_MODE, value);
000582  000790  //       : value = LANDSCAPE   (value 0)
000583  000791  //       : value = LANDSCAPE_R (value 1)
000584  000792  //       : value = PORTRAIT    (value 2)
000585  000793  //       : value = PORTRAIT_R  (value 3)
000586  000794  //       :
000587  000795  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000588  000796  //       : gfx_Set(OUTLINE_COLOUR, value);
000589  000797  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000590  000798  //       : Sets the filled Rectangle or Circle objects outline colour
000591  000799  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000592  000800  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000593  000801  //       :
000594  000802  //       : Only supports variable contrast for uOLED Modules
000595  000803  //       : mode = CONTRAST (mode 25) : Contrast
000596  000804  //       : gfx_Set(CONTRAST, value);
000597  000805  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000598  000806  //       : when contrast=0, display is placed in low power mode.
000599  000807  //       : This function should be called with contrast=0 when
000600  000808  //       : powering down the module.
000601  000809  //       :
000602  000810  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000603  000811  //       : gfx_Set(LINE_PATTERN, value);
000604  000812  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000605  000813  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000606  000814  //       : a value of 0 turns the feature off
000607  000815  //       :
000608  000816  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000609  000817  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000610  000818  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000611  000819  //       : NB not implemented, default is COLOUR16
000612  000820  //       :
000613  000821  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000614  000822  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000615  000823  //       : sets the button and slider objects bevel width
000616  000824  //       :
000617  000825  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000618  000826  //       : gfx_Set(BEVEL_SHADOW , 5);
000619  000827  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000620  000828  //       :
000621  000829  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000622  000830  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000623  000831  //       : sets the origin of drawn objects to a position other than 0,0
000624  000832  //       :
000625  000833  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000626  000834  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000627  000835  //       : sets the origin of drawn objects to a position other than 0,0
000628  000836        
000629  000837        
000630  000838  func gfx_Cls(), 0;                    // clear the screen
000631  000839  // Syntax: gfx_Cls();
000632  000840  // Usage : gfx_Cls();
000633  000841  // Notes : Clears the screen with current background colour
000634  000842        
000635  000843  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000636  000844  // Syntax: gfx_MoveTo(x, y);
000637  000845  // Usage : gfx_MoveTo(arg1, arg2);
000638  000846  // Notes : Moves the origin to a new x,y position
000639  000847        
000640  000848  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000641  000849  // Syntax: gfx_MoveRel(x, y);
000642  000850  // Usage : gfx_MoveRel(arg1, arg2);
000643  000851  // Notes : Moves the origin to a new x,y position
000644  000852  //       : relative to the current origing
000645  000853        
000646  000854  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000647  000855  // Syntax: gfx_LineTo(x1, y1);
000648  000856  // Usage : gfx_LineTo(arg1, arg2);
000649  000857  // Notes : Draws a Line from the origin x,y to x1,y1.
000650  000858  //       : The new origin is then set to x1, y1. Line colour needs
000651  000859  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000652  000860        
000653  000861  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000654  000862  // Syntax: gfx_LineRel(x1, y1);
000655  000863  // Usage : gfx_LineRel(arg1, arg2);
000656  000864  // Notes : Draws a Line from the origin x,y to x1,y1.
000657  000865  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000658  000866  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000659  000867        
000660  000868  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000661  000869  // Syntax: gfx_Line(x1, x2, y2, colr);
000662  000870  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000663  000871  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000664  000872        
000665  000873  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000666  000874  // Syntax: gfx_Line(x1, x2, y, colr);
000667  000875  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000668  000876  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000669  000877        
000670  000878  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000671  000879  // Syntax: gfx_Line(y1, y2, x, colr);
000672  000880  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000673  000881  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000674  000882        
000675  000883  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000676  000884  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000677  000885  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000678  000886  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000679  000887  //       : bottom corner (x2,y2) on the screen.
000680  000888        
000681  000889  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000682  000890  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000683  000891  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000684  000892  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000685  000893  //       : bottom corner (x2,y2) on the screen.
000686  000894        
000687  000895  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000688  000896  // Syntax: gfx_Circle(x, y, rad, colr);
000689  000897  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000690  000898  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000691  000899        
000692  000900  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000693  000901  // Syntax: gfx_Circle(x, y, rad, colr);
000694  000902  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000695  000903  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000696  000904        
000697  000905  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000698  000906  // Syntax: gfx_PutPixel(x, y, colr);
000699  000907  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000700  000908  // Notes : Plots a coloured pixel on the screen at x,y location
000701  000909        
000702  000910  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000703  000911  // Syntax: gfx_GetPixel(x, y);
000704  000912  // Usage : var := gfx_GetPixel(arg1, arg2);
000705  000913  // Notes : Reads and returns the colour value of a pixel at location x,y
000706  000914        
000707  000915  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000708  000916  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000709  000917  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000710  000918  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000711  000919  //       : Vertices must be specified in an anti-clockwise fashion
000712  000920        
000713  000921  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000714  000922  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000715  000923  // Usage : gfx_OrbitInit(&arg1, &arg2);
000716  000924  // Notes : Sets up the Orbit function parameters.
000717  000925  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000718  000926  //       : variables that get updated after calling gfx_Orbit(,,) function.
000719  000927  //       : The coordiantaes are calculated relative to the origin
000720  000928  //       : obtained by using the gfx_MoveTo(x, y) function.
000721  000929        
000722  000930  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000723  000931  // Syntax: gfx_Orbit(angle, distance);
000724  000932  // Usage : gfx_Orbit(arg1, arg2);
000725  000933  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000726  000934  //       : only known parameters are the angle and the distance from the current origin.
000727  000935        
000728  000936  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000729  000937  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000730  000938  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000731  000939  // Notes : This function is very similar to the Ploygon function
000732  000940  //       : with the exception of the 1st and the last vertices not joined.
000733  000941        
000734  000942  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000735  000943  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000736  000944  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000737  000945  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000738  000946  //       : Vertices must be minimum of 3 and can be specified in any fashion
000739  000947        
000740  000948  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000741  000949  // Syntax: gfx_Dot();
000742  000950  // Usage : gfx_Dot();
000743  000951  // Notes : Places a coloured dot at the origin
000744  000952        
000745  000953        
000746  000954  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000747  000955  // Syntax: gfx_Bullet();
000748  000956  // Usage : gfx_Bullet();
000749  000957  // Notes : Places a coloured circle at the origin
000750  000958  //       : filled or unfilled state is controlled by PenSize
000751  000959        
000752  000960  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000753  000961  // Syntax: gfx_IncX();
000754  000962  // Usage : var := gfx_IncX();
000755  000963  // Notes : Increments the x coordinate of the origin
000756  000964        
000757  000965  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000758  000966  // Syntax: gfx_IncY();
000759  000967  // Usage : var := gfx_IncY();
000760  000968  // Notes : Increments the y coordinate of the origin
000761  000969        
000762  000970  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000763  000971  // Syntax: gfx_BoxTo(x1, y1);
000764  000972  // Usage : gfx_BoxTo(arg1, arg2);
000765  000973  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000766  000974  //       : The new origin is then set to x1,y1. Rectangle colour needs
000767  000975  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000768  000976  //       : and the PenSize setting determines if Box is solid or outline.
000769  000977        
000770  000978  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000771  000979  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000772  000980  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000773  000981  // Notes : Specifies a clipping window region on the screen such that any objects
000774  000982  //       : and text placed onto the screen will be clipped and displayed only
000775  000983  //       : within that region. For the clipping window to take effect, "Clipping"
000776  000984  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000777  000985        
000778  000986        
000779  000987  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000780  000988  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000781  000989  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000782  000990  // *Notes:
000783  000991        
000784  000992  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000785  000993  // Syntax: gfx_SetClipRegion();
000786  000994  // Usage : var := gfx_SetClipRegion();
000787  000995  // *Notes:
000788  000996        
000789  000997  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000790  000998  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000791  000999  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000792  001000  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000793  001001  //       : with xradius = xrad and yradius = yrad.
000794  001002  //       : if PenSize = 0 Ellipse is Solid
000795  001003  //       : if PenSize = 1 Ellipse is Outline
000796  001004        
000797  001005        
000798  001006  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000799  001007  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000800  001008  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000801  001009  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000802  001010  //       : with xradius = xrad and yradius = yrad.
000803  001011        
000804  001012  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000805  001013  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000806  001014  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000807  001015  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000808  001016  //       : x,y arguments (top left corner). The size of the button depends on
000809  001017  //       : the font, width, height and length of the text.
000810  001018  //       : The button appearance will depend on the state parameter setting:
000811  001019  //       :         state = 0 : Button Pressed
000812  001020  //       :         state = 1 : Button Raised
000813  001021        
000814  001022  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000815  001023  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000816  001024  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000817  001025  // Notes : Draws a panel (groupbox) at screen location defined by
000818  001026  //       : x, y, width and height with colour "colour".
000819  001027  //       :         state = 0 : recessed
000820  001028  //       :         state = 1 : raised
000821  001029        
000822  001030  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000823  001031  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000824  001032  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000825  001033  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000826  001034  //       : Slider parameters are as follows:
000827  001035  //       :         mode = 0 : Slider recessed
000828  001036  //       :         mode = 1 : Slider raised
000829  001037  //       :         x1, y1 = top left corner
000830  001038  //       :         x2, y2 = bottom right corner
000831  001039  //       :         scale = n : sets the full scale range from 0 to n
000832  001040  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000833  001041  //       : returns:-
000834  001042        
000835  001043        
000836  001044  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000837  001045  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000838  001046  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000839  001047  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000840  001048  //       : and pastes it to another location determined by xd, yd.
000841  001049        
000842  001050  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000843  001051  // Syntax: gfx_RGBto565(red, green, blue);
000844  001052  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000845  001053  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000846  001054        
000847  001055  func gfx_332to565("COLOUR8BIT"), 1;
000848  001056  // Syntax: gfx_332to565(colour);
000849  001057  // Usage : gfx_332to565(arg);
000850  001058  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000851  001059        
000852  001060  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000853  001061  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000854  001062  // Usage : gfx_Selection(1, RED, YELLOW);
000855  001063  // Notes : Called prior to drawing a button, this function
000856  001064  //       : hilites the required text line on a multiline button.
000857  001065        
000858  001066  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000859  001067  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000860  001068  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000861  001069  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000862  001070  //       : Vertices must be specified in an anti-clockwise fashion
000863  001071        
000864  001072        
000865  001073  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000866  001074  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000867  001075  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
000868  001076  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000869  001077  //       : Vertices must be minimum of 3 and can be specified in any fashion
000870  001078        
000871  001079        
000872  001080  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
000873  001081  // Syntax: gfx_Offset(x, y);
000874  001082  // Usage : gfx_Offset(arg1, arg2);
000875  001083  // Notes : Set the screen offset
000876  001084        
000877  001085        
000878  001086        
000879  001087  func gfx_Get("mode"), 1;
000880  001088  // Syntax: gfx_Get(mode);
000881  001089  // Usage : arg1 := gfx_Get(arg);
000882  001090  // Notes : Returns various parameters to caller
000883  001091  //       :
000884  001092  //       : mode = X_MAX (mode 0) : current orientations maximum X value
000885  001093  //       : var := gfx_Get(X_MAX);
000886  001094  //       : Returns the maximum horizontal value of the display
000887  001095  //       :
000888  001096  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
000889  001097  //       : var := gfx_Get(Y_MAX);
000890  001098  //       : Returns the maximum vertical value of the display
000891  001099  //       :
000892  001100  //       : mode = LEFT_POS (mode 2) : Left location of last Object
000893  001101  //       : var := gfx_Get(LEFT_POS);
000894  001102  //       : Returns the left location of the last drawn object
000895  001103  //       : such as a slider or button or an image/video
000896  001104  //       :
000897  001105  //       : mode = TOP_POS (mode 3) : Top location of Object
000898  001106  //       : var := gfx_Get(TOP_POS);
000899  001107  //       : Returns the top location of the last drawn object
000900  001108  //       : such as a slider or button or an image/video
000901  001109  //       :
000902  001110  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
000903  001111  //       : var := gfx_Get(RIGHT_POS);
000904  001112  //       : Returns the right location of the last drawn object
000905  001113  //       : such as a slider or button or an image/video
000906  001114  //       :
000907  001115  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
000908  001116  //       : var := gfx_Get(BOTTOM_POS );
000909  001117  //       : Returns the bottom location of the last drawn object
000910  001118  //       : such as a slider or button or an image/video
000911  001119  //       :
000912  001120        
000913  001121        
000914  001122  //==================================================//
000915  001123  // Single parameter short-cuts                      //
000916  001124  // for the gfx_Set functions                        //
000917  001125  // These functions return the existing value before //
000918  001126  // the change is made.                              //
000919  001127  //==================================================//
000920  001128  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
000921  001129  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
000922  001130  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
000923  001131  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
000924  001132  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
000925  001133  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
000926  001134  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
000927  001135  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
000928  001136  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
000929  001137  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
000930  001138  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
000931  001139  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
000932  001140  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
000933  001141  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
000934  001142  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
000935  001143  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
000936  001144        
000937  001145        
000938  001146  //==================================================//
000939  001147  // uSD/FLASH Function Prototypes                    //
000940  001148  //==================================================//
000941  001149  func media_Video("x", "y"), 0;                      // display movie at position x y
000942  001150  // Syntax: media_Video(x, y);
000943  001151  // Usage : media_Video(arg1, arg2);
000944  001152  // Notes : Play a Video/Animation clip from the uSD card at screen location
000945  001153  //       : specified by x,y (top left corner). The location of the clip in the
000946  001154  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
000947  001155        
000948  001156  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
000949  001157  // Syntax: media_VideoFrame(Frame_number);
000950  001158  // Usage : arg1 := media_VideoFrame();
000951  001159  // Notes : After a pointer to a valid video has been set with media_SetSector,
000952  001160  //       : calling this function shows each fram sequentially, returning
000953  001161  //       : the number of frames remaining. The position of the image is
000954  001162  //     : at the current origin as set with gfx_MoveTo(...);
000955  001163        
000956  001164  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
000957  001165  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
000958  001166  // Usage : media_SetAdd(arg1, arg2);
000959  001167  // Notes : Set uSD internal Address pointer for bytewise access
000960  001168        
000961  001169  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
000962  001170  // Syntax: media_SetSector(SectHiWord, SectLoWord);
000963  001171  // Usage : media_SetSector(arg1, arg2);
000964  001172  // Notes : Set uSD internal Sector pointer for sector block access
000965  001173        
000966  001174  func media_RdSector("*destination"), 1;
000967  001175  // Syntax: media_RdSector(*destination);
000968  001176  // Usage : media_RdSector(rdblock);
000969  001177  // Notes : Reads and Returns 512 bytes (256 words) into a destination
000970  001178  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
000971  001179  //       : After the read the Sector pointer is automatically incremented by 1.
000972  001180  //       : Returns TRUE if uSD response was TRUE
000973  001181        
000974  001182  func media_WrSector("*source"), 1;
000975  001183  // Syntax: media_WrSector(*source);
000976  001184  // Usage : media_WrSector(wrblock);
000977  001185  // Notes : Writes 512 bytes (256 words) from a source memory block
000978  001186  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
000979  001187  //       : pointer is automatically incremented by 1.
000980  001188  //       : Returns TRUE if uSD response was TRUE
000981  001189        
000982  001190  func media_ReadByte(), 1;                // read a byte at the current stream position
000983  001191  // Syntax: media_RdByte();
000984  001192  // Usage : var := media_RdByte();
000985  001193  // Notes : Reads and Returns a single byte of data from the
000986  001194  //       : uSD card pointed to by the internal Address pointer.
000987  001195  //       : After the read the Address pointer is automatically
000988  001196  //       : incremented by 1.
000989  001197        
000990  001198  func media_ReadWord(), 1;                // read a word at the current stream position
000991  001199  // Syntax: media_ReadWord();
000992  001200  // Usage : var := media_ReadWord();
000993  001201  // *Notes : Reads and Returns a single word of data from the
000994  001202  //       : uSD card pointed to by the internal Address pointer.
000995  001203  //       : After the read the Address pointer is automatically
000996  001204  //       : incremented by 2.
000997  001205        
000998  001206  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
000999  001207  // Syntax: media_WriteByte(arg1);
001000  001208  // Usage : var := media_WriteByte(arg1);
001001  001209  // *Notes : Writes and Returns xxxxx
001002  001210  //       : After the write the Address pointer is automatically
001003  001211  //       : incremented by 1.
001004  001212        
001005  001213  func media_WriteWord("word"), 1;            // write a word to the current stream position
001006  001214  // Syntax: media_WriteWord(arg1);
001007  001215  // Usage : var := media_WriteWord(arg1);
001008  001216  // *Notes : Writes and Returns xxxxx
001009  001217  //       : After the write the Address pointer is automatically
001010  001218  //       : incremented by 2.
001011  001219        
001012  001220  func media_Image("x", "y"), 0;            // display image at position x y
001013  001221  // Syntax: media_Image(x, y);
001014  001222  // Usage : media_Image(arg1, arg2);
001015  001223  // Notes : Display an image from the uSD card at screen location
001016  001224  //       : specified by x,y (top left corner). The location of the
001017  001225  //       : Image in the uSD card must be specified by
001018  001226  //       : media_setSector(Image_Sector_Add) function.
001019  001227        
001020  001228  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001021  001229  // Syntax: media_Flush();
001022  001230  // Usage : var := media_Flush();
001023  001231  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001024  001232  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001025  001233        
001026  001234  func media_Init(), 1;                    // initialize uSD card
001027  001235  // Usage	: media_Init();
001028  001236  // Notes	: Initialise uSD CARD
001029  001237  // 	: Response: 0 = No Card
001030  001238  // 	:           1 = Card Initialised
001031  001239  // 	: Do not use this for systems with SPI Flash, use media_InitFlash() instead
001032  001240  // 	: init the Media.
001033  001241        
001034  001242        
001035  001243  //==============================================//
001036  001244  // Communications Function Prototypes           //
001037  001245  //==============================================//
001038  001246  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001039  001247  // Syntax: com_Init(buffer, bufsize, qualifier);
001040  001248  // Usage1: com_Init(mybuf, 20, 0);
001041  001249  // Usage2: com_Init(mybuf, 20, ':');
001042  001250  // Notes : initialize a serial capture buffer for the comms input
001043  001251  //       : The program must declare a var array as a circular buffer.
001044  001252  //       : Usage1 declares a circular buffer which will continually
001045  001253  //       : buffer characters.
001046  001254  //       : Usage2 must receive ':' before any characters will
001047  001255  //       : accumulate in the buffer.
001048  001256        
001049  001257  func com_Reset(), 0;                 // reset the comms receiver
001050  001258  // Syntax: com_Reset();
001051  001259  // Usage : com_Reset();
001052  001260  // Notes : reset comms to default polled mode
001053  001261        
001054  001262  func com_Count(), 1;                // return count of characters in receive buffer
001055  001263  // Syntax: com_Count();
001056  001264  // Usage : arg := com_Count();
001057  001265  // Notes : return count of buffered characters in buffer attachment
001058  001266        
001059  001267  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001060  001268  // Syntax: com_Full();
001061  001269  // Usage : if (com_Full() ,,,, go read buffer;
001062  001270  // Notes : return true if buffer full (not necessarily an error if
001063  001271  //       : buffer is sized to a packet size)
001064  001272        
001065  001273  func com_Error(), 1;                // return comms errors comms error occurred
001066  001274  // Syntax: com_Error();
001067  001275  // Usage : if (com_Error() ) ...... take recovery action;
001068  001276  // Notes : return non zero if any errors low level comms errors occured
001069  001277  // returns :
001070  001278  // bit0 = Receiver Overflow Error
001071  001279  // bit1 = Receiver Framing Error
001072  001280  // bit2 = Transmit Buffer Overflow
001073  001281        
001074  001282  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001075  001283  // Syntax: com_Sync();
001076  001284  // Usage : com_Sync();
001077  001285  // return true if sync character has been received in com_Init("...") mode
001078  001286        
001079  001287        
001080  001288  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001081  001289  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001082  001290  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001083  001291  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001084  001292  // Notes : initialize a serial buffer for the COM0 output.
001085  001293  //       : The program must declare a var array as a circular buffer.
001086  001294  //       : When a TX buffer is declared for comms, the transmission
001087  001295  //       : of characters becomes non blocking. The only time
001088  001296  //       : blocking will occur is if the buffer has insufficient space
001089  001297  //       : to accept the next character, in which case the function
001090  001298  //       : will wait for buffer space to become available. If the
001091  001299  //       : TX buffer is no longer required, just set the buffer pointer
001092  001300  //       : to zero, the size in this case doesnt matter and is ignored.
001093  001301  //       : The function can resize or reallocated to another buffer at
001094  001302  //       : any time. The buffer is flushed before any changes are made.
001095  001303  //       : "pin" designates an IO pin to control a bi-directional 
001096  001304  //       : control device for half duplex mode. "pin" will go HI at the
001097  001305  //       : start of a transmission, and will return low after the final
001098  001306  //       : byte is transmitted. If not required, just set "pin" to zero.
001099  001307        
001100  001308        
001101  001309  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001102  001310  // Syntax: com_TXcount();
001103  001311  // Usage : arg := com_Count();
001104  001312  // Notes : return count of characters remaining in COM0 transmit buffer
001105  001313  //       : that was previously allocated with com_TXbuffer(...);
001106  001314        
001107  001315        
001108  001316  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001109  001317  // Syntax: com_TXemptyEvent(function);
001110  001318  // Usage : arg := com_TXemptyEvent();
001111  001319  // Notes : If a comms TX buffer that was previously allocated with
001112  001320  //       : com_TXbuffer(...);, this function can be used to set up
001113  001321  //       : a function to be called when the COM0 TX buffer is empty.
001114  001322  //       : This is useful for either reloading the TX buffer, setting
001115  001323  //       : or clearing a pin to change the direction of eg a RS485
001116  001324  //       : line driver, or any other form of traffic control.
001117  001325  //       : The event function must not have any parameters.
001118  001326  //       : To disable the event, simply call com_TXemptyEvent(0).
001119  001327  //       : com_TXbuffer(...); also resets any active event.
001120  001328  //       : com_TXemptyEvent returns any previous event function
001121  001329  //       : address, or zero if there was no previous function.
001122  001330        
001123  001331        
001124  001332  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001125  001333  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001126  001334  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001127  001335  // Notes : Expecting that a comms TX buffer that was previously allocated with
001128  001336  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001129  001337  //       : the buffer being sent wile it is being loaded. Mormally, when
001130  001338  //       : using buffered comms, the transmit process will begin
001131  001339  //       : immediately. This is often undesirable for 2 reasons,
001132  001340  //       : 1] you may wish to build a packet then send it later
001133  001341  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001134  001342  //       : as the FIFO buffer is constantly trying to empty while
001135  001343  //       : you are busy tring to fill it.
001136  001344  // return -1 if function is called illegally when TX comms is not buffered.
001137  001345  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001138  001346  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001139  001347        
001140  001348        
001141  001349  //=============================================================//
001142  001350  // Auxilliary Communications Function Prototypes
001143  001351  //=============================================================//
001144  001352  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001145  001353  // Syntax: com_Init(buffer, bufsize, qualifier);
001146  001354  // Usage1: com_Init(mybuf, 20, 0);
001147  001355  // Usage2: com_Init(mybuf, 20, ':');
001148  001356  // Notes : initialize a serial capture buffer for the comms input
001149  001357  //       : The program must declare a var array as a circular buffer.
001150  001358  //       : Usage1 declares a circular buffer which will continually
001151  001359  //       : buffer characters.
001152  001360  //       : Usage2 must receive ':' before any characters will
001153  001361  //       : accumulate in the buffer.
001154  001362        
001155  001363  func com1_Reset(), 0;
001156  001364  // Syntax: com_Reset();
001157  001365  // Usage : com_Reset();
001158  001366  // Notes : reset comms receiver to default polled mode
001159  001367        
001160  001368  func com1_Count(), 1;
001161  001369  // Syntax: com_Count();
001162  001370  // Usage : arg := com_Count();
001163  001371  // Notes : return count of characters in receive buffer
001164  001372        
001165  001373  func com1_Full(), 1;
001166  001374  // Syntax: com_Full();
001167  001375  // Usage : if (com_Full() ,,,, go read buffer;
001168  001376  // Notes : return true if receive buffer full
001169  001377        
001170  001378  func com1_Error(), 1;
001171  001379  // Syntax: com_Error();
001172  001380  // Usage : if (com_Error() ) ...... take recovery action;
001173  001381  // Notes : return non zero if any level comms errors occured
001174  001382  // returns :
001175  001383  // bit0 = Receiver Overflow Error
001176  001384  // bit1 = Receiver Framing Error
001177  001385  // bit2 = Transmit Buffer Overflow
001178  001386        
001179  001387  func com1_Sync(), 1;
001180  001388  // Syntax: com_Sync();
001181  001389  // Usage : com_Sync();
001182  001390  // Notes : return true if sync character has been received in com_Init("...") mode
001183  001391        
001184  001392        
001185  001393  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001186  001394  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001187  001395  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001188  001396  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001189  001397  // Notes : initialize a serial buffer for the COM1 output.
001190  001398  //       : The program must declare a var array as a circular buffer.
001191  001399  //       : When a TX buffer is declared for comms, the transmission
001192  001400  //       : of characters becomes non blocking. The only time
001193  001401  //       : blocking will occur is if the buffer has insufficient space
001194  001402  //       : to accept the next character, in which case the function
001195  001403  //       : will wait for buffer space to become available. If the
001196  001404  //       : TX buffer is no longer required, just set the buffer pointer
001197  001405  //       : to zero, the size in this case doesnt matter and is ignored.
001198  001406  //       : The function can resize or reallocated to another buffer at
001199  001407  //       : any time. The buffer is flushed before any changes are made.
001200  001408  //       : "pin" designates an IO pin to control a bi-directional 
001201  001409  //       : control device for half duplex mode. "pin" will go HI at the
001202  001410  //       : start of a transmission, and will return low after the final
001203  001411  //       : byte is transmitted. If not required, just set "pin" to zero.
001204  001412        
001205  001413        
001206  001414  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001207  001415  // Syntax: com1_TXcount();
001208  001416  // Usage : arg := com1_Count();
001209  001417  // Notes : return count of characters remaining in COM1 transmit buffer
001210  001418  //       : that was previously allocated with com1_TXbuffer(...);
001211  001419        
001212  001420        
001213  001421  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001214  001422  // Syntax: com1_TXemptyEvent(function);
001215  001423  // Usage : arg := com1_TXemptyEvent();
001216  001424  // Notes : If a comms TX buffer that was previously allocated with
001217  001425  //       : com1_TXbuffer(...);, this function can be used to set up
001218  001426  //       : a function to be called when the COM1 TX buffer is empty.
001219  001427  //       : This is useful for either reloading the TX buffer, setting
001220  001428  //       : or clearing a pin to change the direction of eg a RS485
001221  001429  //       : line driver, or any other form of traffic control.
001222  001430  //       : The event function must not have any parameters.
001223  001431  //       : To disable the event, simply call com1_TXemptyEvent(0).
001224  001432  //       : com1_TXbuffer(...); also resets any active event.
001225  001433  //       : com1_TXemptyEvent returns any previous event function
001226  001434  //       : address, or zero if there was no previous function.
001227  001435        
001228  001436        
001229  001437  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001230  001438  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001231  001439  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001232  001440  // Notes : Expecting that a comms TX buffer that was previously allocated with
001233  001441  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001234  001442  //       : the buffer being sent wile it is being loaded. Mormally, when
001235  001443  //       : using buffered comms, the transmit process will begin
001236  001444  //       : immediately. This is often undesirable for 2 reasons,
001237  001445  //       : 1] you may wish to build a packet then send it later
001238  001446  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001239  001447  //       : as the FIFO buffer is constantly trying to empty while
001240  001448  //       : you are busy tring to fill it.
001241  001449  // return -1 if function is called illegally when TX comms is not buffered.
001242  001450  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001243  001451  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001244  001452        
001245  001453  func serin1(), 1;
001246  001454  // Syntax: serin1();
001247  001455  // Usage : char := serin1();
001248  001456  // Notes : return the next available character from COM1
001249  001457        
001250  001458  func serout1("char"), 0;
001251  001459  // Syntax: serout1("char");
001252  001460  // Usage : serout1(ch);
001253  001461  // Notes : send character to COM1
001254  001462        
001255  001463  func com_SetBaud("comport","baudrate/10"), 1;
001256  001464  // Syntax: com_SetBaud("comport","baudrate/10");
001257  001465  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001258  001466  // Notes : sets to any viable baud rate from 160 to 655350
001259  001467  // return true if baud rate was acceptable
001260  001468        
001261  001469        
001262  001470        
001263  001471  //==============================================//
001264  001472  // Display Access                               //
001265  001473  //==============================================//
001266  001474  func disp_Init(), 0;                            // initialize display with required tables
001267  001475  // Syntax: disp_Init();
001268  001476  // Usage : disp_Init();
001269  001477  // Notes : Initialises or reinitialises the display.
001270  001478  //       : Normally used after restoration of peripheral power
001271  001479  //       : and after DeepSleep.
001272  001480        
001273  001481  func disp_SetReg("register", "data"), 0;
001274  001482  // Syntax: display_SetReg(register, data);
001275  001483  // Usage : display_SetReg(arg1, arg2);
001276  001484  // Notes : Sets uLCD specific display driver registers. Refer
001277  001485  //       : to appropriate display driver data sheet.
001278  001486        
001279  001487  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001280  001488  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001281  001489  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001282  001490  // Notes : Prepares the GRAM area for user access.
001283  001491  //       : Data can now be written with disp_GRAM.
001284  001492  //       : GRAM will be set accordingly for the correct screen mode.
001285  001493  //       : the LO word of the 32 bit pixel count is returned. This is
001286  001494  //       : usually all that is needed unlse GRAM area exceeds 256^2
001287  001495  //       : A copy of the 32bit value can be found in
001288  001496  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001289  001497        
001290  001498  func disp_WrGRAM("colour"), 0;
001291  001499  // Syntax: display_WrGRAM(colour);
001292  001500  // Usage : display_WrGRAM(arg);
001293  001501  // Notes : Data can be written to the GRAM consecutively using
001294  001502  //       : this function once the GRAM access window has been setup.
001295  001503        
001296  001504  func disp_WriteControl("value"), 0;             // write a control byte to the display
001297  001505  func disp_WriteWord("value"), 0;                // write a word to the display
001298  001506        
001299  001507        
001300  001508  func disp_ReadWord("Command", "dummy"), 1;                        // read a word from the display
001301  001509  // Syntax	: disp_ReadWord(command, 1);
001302  001510  // Usage	: x:=disp_ReadWord(command, 1);
001303  001511  // Notes	: Read a word from the controller
001304  001512  // Eg: 	: print(disp_ReadWord(0), 0);        // select Ilitek ID register, read using 0 dummy reads, print ID
001305  001513  // 	: (Many displays are write only)
001306  001514  // 	: Some SPI displays required the command be given as part of the read sequence.
001307  001515  // 	: For displays that do not require this the value will be ignored.
001308  001516        
001309  001517                                                  //
001310  001518  //==============================================//
001311  001519  // unadorned SPI functions                      //
001312  001520  //==============================================//
001313  001521  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001314  001522  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001315  001523  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001316  001524  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001317  001525                                                  //
001318  001526  //==============================================//
001319  001527  // flash device specific functions              //
001320  001528  //==============================================//
001321  001529  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001322  001530  // Syntax: flash_SIG();
001323  001531  // Usage : flash_SIG();
001324  001532  // Notes	: Returns the Flash Signature returned from the 'FLASH WAKEUP RETURN SIG'
001325  001533  // 	: (0xAB) command.
001326  001534        
001327  001535  func flash_ID(), 1;                             // read ID code from FLASH device
001328  001536  // Syntax: flash_ID();
001329  001537  // Usage : flash_ID();
001330  001538  // Notes	: Returns the second(memory type) and third(memory capacity) bytes returned from the 
001331  001539  // 	: 'FLASH READ ID REG' (0x9F) command.
001332  001540        
001333  001541  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001334  001542        
001335  001543  func flash_Block64Erase(), 1;            // erase the required 64k flash block
001336  001544  // Syntax: flash_Block64Erase();
001337  001545  // Usage : flash_Block64Erase();
001338  001546  // Notes	: Erase the 64KB flash block including the currently set address
001339  001547  // 	: This uses the 0xD8 command.
001340  001548                                                  //
001341  001549                                                  //
001342  001550  //==============================================//
001343  001551  // string and character size function           //
001344  001552  //==============================================//
001345  001553  func charwidth("char"), 1;                      // return width of a character in pixel units
001346  001554  func charheight("char"), 1;                     // return height of a character in pixel units
001347  001555  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001348  001556  func strheight(), 1;                            // return height of a string in pixel units
001349  001557        
001350  001558        
001351  001559  //------------------------------------------------------------------//
001352  001560  //        I2C Function Prototypes
001353  001561  //------------------------------------------------------------------//
001354  001562  func I2C1_Open("speed"), 0;
001355  001563  // Syntax: I2C1_Open(speed),
001356  001564  // Usage : I2C1_Open(I2C_MED);
001357  001565  // Notes : configures the I2C1 module
001358  001566  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001359  001567        
001360  001568  func I2C1_Close(), 0;
001361  001569  // Syntax: I2C1_Close();
001362  001570  // Usage : I2C1_Close();
001363  001571  // Notes : disables the I2C1 module.
001364  001572        
001365  001573  func I2C1_Start(), 1;
001366  001574  // Syntax: I2C1_Start();
001367  001575  // Usage : I2C1_Start();
001368  001576  // Notes : generates a Start condition.
001369  001577  //       : returns true if successful (usually ignored)
001370  001578        
001371  001579  func I2C1_Stop(), 1;
001372  001580  // Syntax: I2C1_Stop();
001373  001581  // Usage : I2C1_Stop();
001374  001582  // Notes : generates a Stop condition.
001375  001583  //       : returns true if successful (usually ignored)
001376  001584        
001377  001585  func I2C1_Restart(), 1;
001378  001586  // Syntax: I2C1_Restart();
001379  001587  // Usage : I2C1_Restart();
001380  001588  // Notes : generates a Restart condition.
001381  001589  //       : returns true if successful (usually ignored)
001382  001590        
001383  001591  func I2C1_Read(), 1;
001384  001592  // Syntax: I2C1_Read();
001385  001593  // Usage : ch := I2C1_Read();
001386  001594  // Notes : reads a single byte from the I2C Bus.
001387  001595        
001388  001596  func I2C1_Write("byte"), 1;
001389  001597  // Syntax: I2C1_Write(byte);
001390  001598  // Usage : r := I2C1_Write(ch);
001391  001599  // Notes : is used to write a byte to the I2C bus.
001392  001600  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001393  001601        
001394  001602  func I2C1_Ack(), 0;
001395  001603  // Syntax: I2C1_Ack();
001396  001604  // Usage : I2C1_Ack();
001397  001605  // Notes : generates the acknowledge condition.
001398  001606        
001399  001607  func I2C1_Nack(), 0;
001400  001608  // Syntax: I2C1_Nack();
001401  001609  // Usage : I2C1_Nack();
001402  001610  // Notes : generates the negative acknowledge condition.
001403  001611        
001404  001612  func I2C1_AckStatus(), 0;
001405  001613  // Syntax: I2C1_AckStatus();
001406  001614  // Usage : r := I2C1_AckStatus();
001407  001615  // Notes : returns the ACK status from the device.
001408  001616        
001409  001617  func I2C1_AckPoll("control"), 1;
001410  001618  // Syntax: I2C1_AckPoll();
001411  001619  // Usage : r := I2C1_AckPoll(0xA0);
001412  001620  // Notes : waits for a device to return from ACK polling.
001413  001621        
001414  001622  func I2C1_Idle(), 0;
001415  001623  // Syntax: I2C1_Idle();
001416  001624  // Usage : I2C1_Idle();
001417  001625  // Notes : waits until the I2C Bus is Inactive.
001418  001626        
001419  001627  func I2C1_Gets("buffer", "size"), 1;
001420  001628  // Syntax: I2C1_Gets("buffer", "size");
001421  001629  // Usage : r := I2C1_Gets(mybuf, 16);
001422  001630  // Notes : only reads up to "size" characters into "buffer"
001423  001631  //       : Reads up to asciiz terminator including terminator
001424  001632        
001425  001633  func I2C1_Getn("buffer", "size"), 1;
001426  001634  // Syntax: I2C1_Gets("buffer", "size");
001427  001635  // Usage : r := I2C1_Gets(mybuf, 16);
001428  001636  // Notes : reads "size" bytes into "buffer"
001429  001637  //       :
001430  001638        
001431  001639  func I2C1_Puts("buffer"), 1;
001432  001640  // Syntax: I2C1_Puts("buffer");
001433  001641  // Usage : r := I2C1_Puts(mybuf);
001434  001642  // Notes : writes an asciiz string to the I2C device
001435  001643  //       : returns count of characters written
001436  001644        
001437  001645  func I2C1_Putn("buffer", "count"), 1;
001438  001646  // Syntax: I2C1_Putn("buffer","count");
001439  001647  // Usage : r := I2C1_Puts(mybuf,10);
001440  001648  // Notes : writes up to "size" bytes to the I2C device
001441  001649  //       : returns number of bytes written
001442  001650        
001443  001651        
001444  001652  //------------------------------------------------------------------//
001445  001653  //        Image Control Function Prototypes
001446  001654  //------------------------------------------------------------------//
001447  001655  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001448  001656  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001449  001657  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001450  001658  // Notes : set the position where the image will be displayed
001451  001659  //       : returns true if index was ok and function was successful.
001452  001660  //       : you may turn off an image so when img_Refresh is called,
001453  001661  //       : the image will not be shown
001454  001662        
001455  001663  func img_Enable("handle", "index"), 1;
001456  001664  // Syntax: img_Enable(handle, index);
001457  001665  // Usage : r := img_Enable(hImageList, imagenum);
001458  001666  // Notes : enable image in a image list
001459  001667  //       : returns true if index was ok and function was successful.
001460  001668  //       : this is the default state so when img_Refresh is called,
001461  001669  //       : all the images in the list will be shown
001462  001670  //       : if index is set to -1, all of the images are enabled
001463  001671        
001464  001672  func img_Disable("handle", "index"), 1;
001465  001673  // Syntax: img_Disable(handle, index);
001466  001674  // Usage : r := img_Disable(hImageList, imagenum);
001467  001675  // Notes : disable image in a image list
001468  001676  //       : returns true if index was ok and function was successful.
001469  001677  //       : you must turn off an image so when img_Refresh is called,
001470  001678  //       : the image will not be shown.
001471  001679  //       : if index is set to -1, all of the images are disabled
001472  001680        
001473  001681        
001474  001682  func img_Darken("handle", "index"), 1;
001475  001683  // Syntax: img_Darken(handle, index);
001476  001684  // Usage : r := img_Darken(hImageList, imagenum);
001477  001685  // Notes : darken image in a image list
001478  001686  //       : returns true if index was ok and function was successful.
001479  001687  //       : if index is set to -1, all of the images are darkened
001480  001688  //       : NB:- this feature will only work for the next refresh, then
001481  001689  //       : the image reverts back to normal when displayed again.
001482  001690        
001483  001691        
001484  001692  func img_Lighten("handle", "index"), 1;
001485  001693  // Syntax: img_Lighten(handle, index);
001486  001694  // Usage : r := img_Lighten(hImageList, imagenum);
001487  001695  // Notes : lighten image in a image list
001488  001696  //       : returns true if index was ok and function was successful.
001489  001697  //       : if index is set to -1, all of the images are lightened
001490  001698  //       : NB:- this feature will only work for the next refresh, then
001491  001699  //       : the image reverts back to normal when displayed again.
001492  001700        
001493  001701  func img_SetWord("handle", "index", "offset", "word"), 1;
001494  001702  // Syntax: img_SetWord(handle, index, offset, word);
001495  001703  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001496  001704  // Notes : set specified word (0-7) in a image entry
001497  001705  //       : returns TRUE if successful, return value usually ignored.
001498  001706        
001499  001707  func img_GetWord("handle", "index", "offset"), 1;
001500  001708  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001501  001709  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001502  001710  // Notes : returns specified word (0-14) from an image entry
001503  001711  //       : refer to image control entry offsets.
001504  001712        
001505  001713  func img_Show("handle", "index"), 1;
001506  001714  // Syntax: img_Show(handle, index);
001507  001715  // Usage : display image entry (regardless of enable/disable)
001508  001716  //       : returns TRUE if successful, return value usually ignored.
001509  001717        
001510  001718  func img_SetAttributes("handle", "index","value"), 1;
001511  001719  // Syntax: img_SetAttributes("handle", "index","offset");
001512  001720  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001513  001721  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001514  001722  //       : of an image control entry. "value" refers to various bits in
001515  001723  //       : the image control entry (see image attribute flags).
001516  001724  //       : A '1' bit in the "value" field SETS the respective bit
001517  001725  //       : in the IMAGE_FLAGS field of the image control entry.
001518  001726  //       : returns TRUE if successful, return value usually ignored.
001519  001727        
001520  001728  func img_ClearAttributes("handle", "index","value"), 1;
001521  001729  // Syntax: img_ClearAttributes("handle", "index","offset");
001522  001730  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001523  001731  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001524  001732  //       : of an image control entry. "value" refers to various bits in
001525  001733  //       : the image control entry (see image attribute flags)
001526  001734  //       : a '1' bit in the "value" field CLEARS the respective bit
001527  001735  //       : in the IMAGE_FLAGS field of the image control entry.
001528  001736  //       : returns TRUE if successful, return value usually ignored.
001529  001737        
001530  001738  func img_Touched("handle", "index"), 1;
001531  001739  // Syntax: r := img_Touched(handle, index);
001532  001740  // Usage : img_Touched(hndl, 17);
001533  001741  //       : returns -1 if image not touched, or returns index
001534  001742  // Notes : if index is passed as -1, function tests all images,
001535  001743  //       : and returns -1 if image not touched, or returns index.
001536  001744        
001537  001745        
001538  001746        
001539  001747        
001540  001748  //------------------------------------------------------------------//
001541  001749  //        Timer Function Prototypes
001542  001750  //------------------------------------------------------------------//
001543  001751  func sys_T(), 1;
001544  001752  // Syntax: sys_T();
001545  001753  // Usage : t := sys_T();
001546  001754  // Notes : return the current value of the rolling system timer (1msec) LO word
001547  001755        
001548  001756  func sys_T_HI(), 1;
001549  001757  // Syntax: sys_T_HI();
001550  001758  // Usage : t := sys_T_HI();
001551  001759  // Notes : return the current value of the rolling system timer (1msec) HI word
001552  001760        
001553  001761  func sys_SetTimer("timernum","value"), 0;
001554  001762  // Syntax: sys_SetTimer("timernum", "value");
001555  001763  // Usage : sys_SetTimer(TIMER5, 10000);
001556  001764  // Notes : set a countdown on the selected timer, or 'top up' if required.
001557  001765  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001558  001766  //       : Maximum timeout period is 65.535 seconds
001559  001767  //       : A timer can be read with the sys_GetTimer("timernum") function
001560  001768        
001561  001769  func sys_GetTimer("timernum"), 1;
001562  001770  // Syntax: t := sys_GetTimer("timernum");
001563  001771  // Usage : t := sys_GetTimer(TIMER3);
001564  001772  // Notes : returns 0 if timer has expired, or the current countdown value.
001565  001773  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001566  001774  //       : Maximum timeout period is 65.535 seconds
001567  001775  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001568  001776        
001569  001777  func sys_SetTimerEvent("timernum","function"), 1;
001570  001778  // Syntax: sys_SetTimerFunction("timernum", "function");
001571  001779  // Usage : sys_SetTimer(TIMER5, myfunc);
001572  001780  // Notes : set a function to be called for selected timer.
001573  001781  //       : When the timer reaches zero, the function is called.
001574  001782  //       : The called function must not have any parameters
001575  001783  //       : sys_SetTimerEvent returns any previous event function
001576  001784  //       : address, or zero if there was no previous function.
001577  001785        
001578  001786  func sys_EventQueue(), 1;
001579  001787  // Syntax: sys_EventQueue();
001580  001788  // Usage : tasks := sys_EventQueue();
001581  001789  // Notes : returns the max number of events that were pending
001582  001790  //       : in the timer queue since the last call to this function.
001583  001791  //       : This can be used to assess timer event overhead burden,
001584  001792  //       : especially after or during a sys_EventsPostpone action.
001585  001793        
001586  001794  func sys_EventsPostpone(), 0;
001587  001795  // Syntax: sys_EventPostpone();
001588  001796  // Usage : sys_EventPostpone();   // postpone the event queue
001589  001797  // Notes : postpone any events until the sys_EventResume function is executed
001590  001798  //       : The timer event queue will continue to queue events, but no action
001591  001799  //       : will take place untill a sys_EventResume function is encountered.
001592  001800  //       : The queue will continue to receive up to 32 events before discarding
001593  001801  //       : any further events. This function is required to allow a sequence of
001594  001802  //       : instructions or functions to occur that would otherwise be corrupted
001595  001803  //       : by an event occuring during the sequence of instructions or functions.
001596  001804  //       : A good example of this is when you set a position to print, if there
001597  001805  //       : was no way of locking the current sequence, an event may occur which
001598  001806  //       : does a similar thing, and a contention would occur - printing to
001599  001807  //       : the wrong position. This function should be used wisely, if any action
001600  001808  //       : that is required would take considerable time, it is better to disable
001601  001809  //       : any conflicting event functions with a bypass flag, then restart the
001602  001810  //       : conflicting event by re-issuing a timer value.
001603  001811        
001604  001812  func sys_EventsResume(), 0;
001605  001813  // Syntax: sys_EventsResume();
001606  001814  // Usage : sys_EventsResume();   // resume the event queue
001607  001815  // Notes : resume any postponed events. The queue will try to execute any timer
001608  001816  //       : events that were incurred during the postponed period.
001609  001817        
001610  001818        
001611  001819  func sys_Sleep("units"), 1;
001612  001820  // Syntax: t := sys_Sleep("units");
001613  001821  // Usage : t := sys_Sleep(10);
001614  001822  // Notes : sets the display into low power mode for a period of time.
001615  001823  //       : Touching the touch screen will also wake from sleep.
001616  001824  //       : Returns remaining sleep units.
001617  001825        
001618  001826  func iterator("offset"), 0;
001619  001827  // Syntax: t :=  iterator("offset");
001620  001828  // Usage : t :=  iterator(10);
001621  001829  // Notes : set the iterator size for ++/--
001622  001830  //       : The next postinc,postdec,preinc of predec will alter
001623  001831  //       : by the specified value.
001624  001832  //       : The offset will return to 1 after the next operation.
001625  001833        
001626  001834        
001627  001835        
001628  001836        
001629  001837  //------------------------------------------------------------------//
001630  001838  //         Touch Screen Function Prototypes
001631  001839  //------------------------------------------------------------------//
001632  001840        
001633  001841  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001634  001842  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001635  001843  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001636  001844  // Notes : Specifies a new touch detect region on the screen
001637  001845  //       : such that only touch activity in that region will
001638  001846  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001639  001847        
001640  001848  func touch_Set("mode"), 0;
001641  001849  // Syntax: touch_Set(mode);
001642  001850  // Usage : touch_Set(arg);
001643  001851  // Notes : Sets various Touch Screen related parameters
001644  001852  //       :
001645  001853  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001646  001854  //       : touch_Set(TOUCH_ENABLE);
001647  001855  //       : Enables and initialises Touch Screen hardware
001648  001856  //       :
001649  001857  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001650  001858  //       : touch_Set(TOUCH_DISABLE );
001651  001859  //       : Disables the Touch Screen
001652  001860  //       : Note: Touch Screen runs in the background and disabling
001653  001861  //       : it when not in use will free up extra resources
001654  001862  //       : such as 4DVM CPU cycles.
001655  001863  //       :
001656  001864  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001657  001865  //       : touch_Set(TOUCH_REGIONDEFAULT);
001658  001866  //       : This will reset the current active region to default
001659  001867  //       : to the full screen without the application having to
001660  001868  //       : set a new active region for the full screen.
001661  001869  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001662  001870  //       : that requre to be interfaced with an external pointing
001663  001871  //       : device, values that are poked into TOUCH_DRIVE will be
001664  001872  //       : read with the touch_Get() function)
001665  001873        
001666  001874        
001667  001875  func touch_Get("mode"), 1;
001668  001876  // Syntax: touch_Get(mode);
001669  001877  // Usage : arg1 := touch_Get(arg);
001670  001878  // Notes : Returns various Touch Screen parameters to caller
001671  001879  //       :
001672  001880  //       : mode = TOUCH_STATUS  (mode 0)
001673  001881  //       : var := touch_Get(TOUCH_STATUS);
001674  001882  //       : Returns the various states of the touch screen
001675  001883  //       : 0 = NOTOUCH
001676  001884  //       : 1 = TOUCH_PRESSED
001677  001885  //       : 2 = TOUCH_RELEASED
001678  001886  //       : 3 = TOUCH_MOVING
001679  001887  //       :
001680  001888  //       : mode = TOUCH_GETX   (mode 1)
001681  001889  //       : var := touch_Get(TOUCH_GETX);
001682  001890  //       : Returns the X coordinates of the touch
001683  001891  //       :
001684  001892  //       : mode = TOUCH_GETY   (mode 2)
001685  001893  //       : var := touch_Get(TOUCH_GETY);
001686  001894  //       : Returns the Y coordinates of the touch
001687  001895        
001688  001896  //------------------------------------------------------------------//
001689  001897  //        CTYPE Function Prototypes
001690  001898  //------------------------------------------------------------------//
001691  001899        
001692  001900  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001693  001901  // Syntax: isdigit("char");
001694  001902  // Usage : Var := isdigit(ch);
001695  001903  // Notes : char specifies the ascii character for the test
001696  001904  //     : 0 : char is not an ascii digit.
001697  001905  //     : 1 : char is an ascii digit..
001698  001906  //     : Valid range is "0123456789"
001699  001907        
001700  001908  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001701  001909  // Syntax: isxdigit("char");
001702  001910  // Usage : Var := isxdigit(ch);
001703  001911  // Notes : char specifies the ascii character for the test
001704  001912  //     : 0 : char is not an ascii hexadecimal digit.
001705  001913  //     : 1 : char is an ascii hexadecimal digit..
001706  001914  //     : Valid range is "0123456789ABCDEF"
001707  001915        
001708  001916  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001709  001917  // Syntax: isupper("char");
001710  001918  // Usage : Var := isupper(ch);
001711  001919  // Notes : char specifies the ascii character for the test
001712  001920  //     : 0 : char is not an ascii upper-case letter.
001713  001921  //     : 1 : char is an ascii upper-case letter.
001714  001922  //     : Valid range is "ABCD....WXYZ"
001715  001923        
001716  001924  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001717  001925  // Syntax: islower("char");
001718  001926  // Usage : Var := islower(ch);
001719  001927  // Notes : char specifies the ascii character for the test
001720  001928  //     : 0 : char is not an ascii lower-case letter.
001721  001929  //     : 1 : char is an ascii lower-case letter.
001722  001930  //     : Valid range is "abcd....wxyz"
001723  001931        
001724  001932  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001725  001933  // Syntax: isalpha("char");
001726  001934  // Usage : Var := isalpha(ch);
001727  001935  // Notes : char specifies the ascii character for the test
001728  001936  //     : 0 : char is not an ascii lower or upper case letter.
001729  001937  //     : 1 : char is an ascii lower or upper case letter.
001730  001938  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001731  001939        
001732  001940  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001733  001941  // Syntax: isalnum("char");
001734  001942  // Usage : Var := isalnum(ch);
001735  001943  // Notes : char specifies the ascii character for the test
001736  001944  //     : 0 : char is not an ascii alphanumeric character.
001737  001945  //     : 1 : char is an ascii alphanumeric character.
001738  001946  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001739  001947        
001740  001948  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001741  001949  // Syntax: isprint("char");
001742  001950  // Usage : Var := isprint(ch);
001743  001951  // Notes : char specifies the ascii character for the test
001744  001952  //     : 0 : char is not a printable ascii character.
001745  001953  //     : 1 : char is a printable ascii character.
001746  001954  //     : Valid range is "0x20...0x7F"
001747  001955        
001748  001956  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001749  001957  // Syntax: isspace("char");
001750  001958  // Usage : Var := isspace(ch);
001751  001959  // Notes : char specifies the ascii character for the test
001752  001960  //     : 0 : char is not a space type character.
001753  001961  //     : 1 : char is a space type character.
001754  001962  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001755  001963        
001756  001964  //unformatted
001757  001965  func iswhite("char"), 1;    //
001758  001966  // Syntax: iswhite("char");
001759  001967  // Usage : Var := iswhite(ch);
001760  001968  // Notes : char specifies the ascii character for the test
001761  001969  //     : 0 : char is not a space or tab character.
001762  001970  //     : 1 : char is not a space or tab character.
001763  001971  //     : Valid range is space or tab
001764  001972        
001765  001973  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001766  001974  // Syntax: toupper("char");
001767  001975  // Usage : Var := toupper(ch);
001768  001976  // Notes : char specifies the ascii character for the test
001769  001977  //     : "ABCD....XYZ" : if character is a lower case letter.
001770  001978  //     : char : if character is not a lower case letter.
001771  001979  //     : Valid range is "abcd....wxyz"
001772  001980        
001773  001981  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001774  001982  // Syntax: tolower("char");
001775  001983  // Usage : Var := tolower(ch);
001776  001984  // Notes : char specifies the ascii character for the test
001777  001985  //     : "abcd....xyz" : if character is an upper case letter.
001778  001986  //     : char : if character is not an upper case letter.
001779  001987  //     : Valid range is "ABCD....WXYZ"
001780  001988        
001781  001989  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001782  001990  // Syntax: LObyte(var);
001783  001991  // Usage : myVar := LObyte(myvar2);
001784  001992  // Notes : var specifies the user variable
001785  001993  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001786  001994        
001787  001995  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001788  001996  // Syntax: HIbyte(var);
001789  001997  // Usage : myVar := HIbyte(myvar2);
001790  001998  // Notes : var specifies the user variable
001791  001999  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001792  002000        
001793  002001        
001794  002002  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001795  002003  // Syntax: ByteSwap(var);
001796  002004  // Usage : myVar := ByteSwap(myvar2);
001797  002005  // Notes : var specifies the user variable
001798  002006  //     : Returns the endian swapped value of a 16 bit variable
001799  002007        
001800  002008        
001801  002009  //------------------------------------------------------------------//
001802  002010  //        Memory Allocation Function Prototypes
001803  002011  //------------------------------------------------------------------//
001804  002012        
001805  002013  func mem_Alloc("size"), 1;
001806  002014  // Syntax: mem_Alloc(bytesize);
001807  002015  // Usage : myvar := mem_Alloc(100);
001808  002016  // Notes : Allocate a block of memory to pointer myvar
001809  002017  //       : The allocated memory contains garbage but is a fast allocation.
001810  002018  //       : The block must later be released with mem_Free();
001811  002019  //       : returns 0 if function fails
001812  002020        
001813  002021  func mem_AllocV("size"), 1;
001814  002022  // Syntax: mem_AllocV(bytesize);
001815  002023  // Usage : myvar := mem_AllocV(100);
001816  002024  // Notes : Allocate a block of memory to pointer myvar
001817  002025  //       : The block of memory is filled with signature values
001818  002026  //       : the block starts with A5,5A then fills with incrementing
001819  002027  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001820  002028  //       : This can be helpful when debugging
001821  002029  //       : The block must later be released with mem_Free();
001822  002030  //       : returns 0 if function fails
001823  002031        
001824  002032  func mem_AllocZ("size"), 1;
001825  002033  // Syntax: mem_AllocZ(bytesize);
001826  002034  // Usage : myvar := mem_AllocC(100);
001827  002035  // Notes : Allocate a zeroed block of memory to pointer myvar
001828  002036  //       : The block of memory is filled with zeroes
001829  002037  //       : The block must later be released with mem_Free();
001830  002038  //       : returns 0 if function fails
001831  002039        
001832  002040  func mem_Realloc("ptr", "size"), 1;
001833  002041  // Syntax: myvar := mem_Realloc("ptr", "size");
001834  002042  // Usage : myvar := mem_Realloc(ptr, size);
001835  002043  // Notes : The function may move the memory block to a new location,
001836  002044  //       : in which case the new location is returned.
001837  002045  //       : The content of the memory block is preserved up to the lesser
001838  002046  //       : of the new and old sizes, even if the block is moved.
001839  002047  //       : If the new size is larger, the value of the newly allocated
001840  002048  //       : portion is indeterminate. In case that ptr is NULL,
001841  002049  //       : the function behaves exactly as mem_Alloc, assigning a new block
001842  002050  //       : of size bytes and returning a pointer to the beginning of it.
001843  002051  //       : In case that the size is 0, the memory previously allocated in
001844  002052  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001845  002053  //       : pointer is returned.
001846  002054        
001847  002055  func mem_Free("allocation"), 1;
001848  002056  // Syntax: myvar := mem_Free(allocation);
001849  002057  // Usage : myvar := mem_Free(myvar);
001850  002058  // Notes : De-allocate a block of memory previously created with
001851  002059  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001852  002060  //       : returns 0 if function fails
001853  002061        
001854  002062  func mem_Heap(), 1;
001855  002063  // Syntax: myvar := mem_Heap();
001856  002064  // Usage : myvar := mem_Heap();
001857  002065  // Notes : returns bytecount available in heap
001858  002066  //       :
001859  002067        
001860  002068  func mem_Set("ptr","char","size"), 1;
001861  002069  // Syntax: mem_Set(ptr,char,bytesize);
001862  002070  // Usage : mem_Set(p, 'A', 100);
001863  002071  // Notes : fill a block of memory with a byte value
001864  002072  //       : returns ptr
001865  002073        
001866  002074  func mem_Copy("src", "dest", "bytecount"), 1;
001867  002075  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001868  002076  // Usage : myvar := mem_Copy(p1, p2, 100);
001869  002077  // Notes : copy a word aligned block of memory from src to dest
001870  002078  //       : Note that count is a byte count, this facilitates
001871  002079  //       : copying word aligned byte arrays when using word
001872  002080  //       : aliggned packed strings.
001873  002081  //       : returns src
001874  002082        
001875  002083  func mem_Compare("ptr1","ptr2","count"), 1;
001876  002084  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001877  002085  // Usage : myvar := mem_Compare(p1, p2, 100);
001878  002086  // Notes : compare blocks of memory at src, dest
001879  002087  //       : returns 0 if we have a match
001880  002088        
001881  002089  //------------------------------------------------------------------//
001882  002090  //        FAT16 Function Prototypes
001883  002091  //------------------------------------------------------------------//
001884  002092        
001885  002093  func file_Error(), 1;
001886  002094  // Syntax: myvar := file_Error();
001887  002095  // Usage : e := file_Error();
001888  002096  // Notes : return the most recent file error.
001889  002097  //       :
001890  002098        
001891  002099  func file_Count("filename"), 1;
001892  002100  // Syntax: count := file_Count("filename");
001893  002101  // Usage : count := file_Count("*.4dg");
001894  002102  // Notes : returns number of files found that match the criteria
001895  002103        
001896  002104  func file_Dir("filename"), 1;
001897  002105  // Syntax: count := file_Dir("filename");
001898  002106  // Usage : count := file_Dir("*.4dg");
001899  002107  // Notes : streams a string of filenames that agree with the search key
001900  002108  //       : returns number of files found that match the criteria
001901  002109        
001902  002110  func file_FindFirst("fname"), 1;
001903  002111  // Syntax: res := file_FindFirst("fname");
001904  002112  // Usage : if (file_FindFirst("*.4xe") ....
001905  002113  // Notes : returns true if at least 1 file exists
001906  002114  //       : that satisfies the file argument.
001907  002115  //       : Wildcards are usually used so if
001908  002116  //       : file_FindFirst returns true, further
001909  002117  //       : tests can be made using file_FindNext();
001910  002118  //       : to find all the files that match the
001911  002119  //       : wildcard class. Note that the stream behaviour
001912  002120  //       : is the same as file_Dir.
001913  002121  //       :
001914  002122        
001915  002123  func file_FindNext(), 1;
001916  002124  // Syntax: res := file_FindNext();
001917  002125  // Usage : while ((file_FindNext()) ....
001918  002126  // Notes : returns true if more file exists
001919  002127  //       : that satisfies the file argument
001920  002128  //       : that was given for  file_FindFirst.
001921  002129  //       : Wildcards must be used for
001922  002130  //       : file_FindFirst, else this function will
001923  002131  //       : always return zero as the only occurence
001924  002132  //       : will have already been found.
001925  002133  //       : Note that the stream behaviour
001926  002134  //       : is the same as file_Dir.
001927  002135  //       :
001928  002136        
001929  002137  func file_Exists("fname"), 1;
001930  002138  // Syntax: res := file_Exists("fname"),
001931  002139  // Usage : if(file_Exists("myfile") ....
001932  002140  // Notes : returns true if file exists
001933  002141  //       :
001934  002142        
001935  002143  func file_Open("fname", "mode"), 1;
001936  002144  // Syntax: handle := file_Open("fname","mode"),
001937  002145  // Usage : handle := file_Open("myfile.txt", 'r');
001938  002146  // Notes : returns handle if file exists
001939  002147  //       :
001940  002148        
001941  002149  func file_Close("handle"), 1;
001942  002150  // Syntax: res := file_Close("handle");
001943  002151  // Usage : res := file_Close(hnd1);
001944  002152  // Notes : returns true if file closed ok
001945  002153  //       :
001946  002154        
001947  002155  func file_Read("*dest", "size", "handle"), 1;
001948  002156  // Syntax: res := file_Read("*dest", "size", "handle"),
001949  002157  // Usage : res := file_Read(memblock,20,hnd1);
001950  002158  // Notes : returns number of characters read
001951  002159  //       : if "dest" is zero, data is read direct to GRAM window
001952  002160  //       :
001953  002161        
001954  002162        
001955  002163  func file_Seek("handle", "HiWord", "LoWord"), 1;
001956  002164  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
001957  002165  // Usage : res := file_Seek(hSource, 0, 0x1234);
001958  002166  // Notes : set file position to 0x00001234 (byte position 4660)
001959  002167  //       : for the file handle so subsequent data may be read
001960  002168  //       : from that position onwards with file_GetC(...),
001961  002169  //       : file_GetW(...) or file_GetS(...), or an image
001962  002170  //       : can be displayed with file_Image(...)
001963  002171  // Notes : returns true if ok, usually ignored
001964  002172        
001965  002173  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001966  002174  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
001967  002175  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
001968  002176  // Notes : set file seek position to 123000
001969  002177  //       : for the file handle so subsequent data may be read
001970  002178  //       : from that record position onwards with file_GetC(...),
001971  002179  //       : file_GetW(...) or file_GetS(...), or an image
001972  002180  //       : can be displayed with file_Image(...)
001973  002181  // Notes : returns true if ok, usually ignored
001974  002182        
001975  002183  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
001976  002184  // Syntax: file_Tell("handle", &HiWord, &LoWord);
001977  002185  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
001978  002186  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
001979  002187  //       : returns true if function succeeded
001980  002188        
001981  002189  func file_Write("*source", "size", "handle"), 1;
001982  002190  // Syntax: res := fwrite("*source", "size", "handle"),
001983  002191  // Usage : res := fwrite(memblock, 20, hnd1);
001984  002192  // Notes : returns number of bytes written
001985  002193  //       :
001986  002194        
001987  002195  func file_Size("handle", "&HiWord", "&LoWord"), 1;
001988  002196  // Syntax: file_Size("handle", &HiWord, &LoWord);
001989  002197  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
001990  002198  // Notes : Reads the 32 bit file size and stores it into 2 variables.
001991  002199  //       : returns true if function succeeded
001992  002200        
001993  002201  func file_Image("x", "y", "handle"), 1;
001994  002202  // Syntax: file_Image(x, y, handle);
001995  002203  // Usage : file_Image(10, 10, hnd1);
001996  002204  // Notes : Display an image from a file at the current file position.
001997  002205  //       : The image is displayed at x,y (with respect to top left corner).
001998  002206  //       : If there is more than 1 image in the file, it can be
001999  002207  //       : accessed with file_Seek(...)
002000  002208        
002001  002209  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002002  002210  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002003  002211  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002004  002212  // Notes : Save a image from screen to file at the current file position.
002005  002213  //       : The image can later be displayed with file_Image(...);
002006  002214  //       : The file may be opened in append mode to accumulate multiple
002007  002215  //       : images. Later, the images can be accessed with file_Seek(...);
002008  002216  //       : Note that the image will be sector aligned.
002009  002217  //       : All image headers must start on a sector boundary.
002010  002218  //       : The image is saved from x, y (with respect to top left corner)
002011  002219  //       : and the capture area is determined by "width" and "height".
002012  002220  //       : returns 0 if function succeeded
002013  002221        
002014  002222  func file_PutC("char","handle"), 1;
002015  002223  // Syntax: file_PutC("char", "handle");
002016  002224  // Usage : file_PutC('x', hndl);
002017  002225  // Notes : returns true if function succeeded
002018  002226        
002019  002227  func file_GetC("handle"), 1;
002020  002228  // Syntax: file_GetC("handle");
002021  002229  // Usage : mychar := fgetC("handle");
002022  002230  // Notes : returns next char from file
002023  002231        
002024  002232  func file_PutW("word","handle"), 1;
002025  002233  // Syntax: file_PutW("word","handle");
002026  002234  // Usage : file_PutW(0x1234, hndl);
002027  002235  // Notes : returns true if function succeeded
002028  002236        
002029  002237  func file_GetW("handle"), 1;
002030  002238  // Syntax: file_GetW("handle");
002031  002239  // Usage : myword := fgetW("handle");
002032  002240  // Notes : returns next word in file
002033  002241        
002034  002242  func file_PutS("*source", "handle"), 1;
002035  002243  // Syntax: res := file_Puts("*source", "handle"),
002036  002244  // Usage : res := file_Puts(mystring, hnd1);
002037  002245  // Notes : returns number of characters written
002038  002246  //       :
002039  002247        
002040  002248  func file_GetS("*string", "size", "handle"), 1;
002041  002249  // Syntax: res := file_Gets("*string", "size", "handle");
002042  002250  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002043  002251  // Notes : get a string from a file
002044  002252  //       : returns pointer to string or null if failed.
002045  002253  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002046  002254  //       : NB:- only reads up to "size-1" characters into "string"
002047  002255  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002048  002256  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002049  002257  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002050  002258  //       : C] It reaches the end of file
002051  002259  //       : D] A read error occurs.
002052  002260        
002053  002261        
002054  002262  func file_Erase("fname"), 1;
002055  002263  // Syntax: res := file_Erase("fname");
002056  002264  // Usage : res := file_Erase("myfile.txt");
002057  002265  // Notes : returns true if successful
002058  002266  //       :
002059  002267        
002060  002268  func file_Rewind("handle"), 1;
002061  002269  // Syntax: res := file_Rewind("handle");
002062  002270  // Usage : res := file_Rewind(hnd1);
002063  002271  // Notes : returns true if file rewound ok (usually ignored)
002064  002272  //       : resets the file pointer the the beginning of the open file.
002065  002273        
002066  002274  func file_LoadFunction("fname.4xe"), 1;
002067  002275  // Syntax: res := file_LoadFunction("fname.4fn");
002068  002276  // Usage : myfunc := file_LoadFunction(myfuncname);
002069  002277  // Notes : Load a function or program from disk and
002070  002278  //       : return a function pointer to the allocation.
002071  002279  //       : The function can then be invoked just like any other
002072  002280  //       : function would be called via a function pointer.
002073  002281  //       : Parameters may be passed to it in a conventional way.
002074  002282  //       : The function may be discarded at any time when no
002075  002283  //       : longer required, thus freeing its memory resources.
002076  002284  //       : The loaded function can be discarded with mem_Free(..)
002077  002285  //       : eg:
002078  002286  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002079  002287  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002080  002288  //       : then elsewhere in your program:-
002081  002289  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002082  002290  //       : if(res == QUIT_APPLICATION) goto exitApp;
002083  002291  //       : Later in your program, when popupWindow is no longer
002084  002292  //       : required for the application:-
002085  002293  //       : res := mem_Free(popupWindow);
002086  002294  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002087  002295  //       : The callers stack is shared by the loaded function,
002088  002296  //       : however any global variables in the loaded function
002089  002297  //       : are private to that function.
002090  002298  //
002091  002299        
002092  002300  func file_Run("fname.4xe", "arglistptr"), 1;
002093  002301  // Syntax: res := file_Run("fname.4xe","arglistptr");
002094  002302  // Usage : res := file_Run(fname, argptr);
002095  002303  // Notes : current program releases any allocated memory but
002096  002304  //       : retains the stack and global memory.
002097  002305  //       : If arglistptr is 0, no arguments are passed, else
002098  002306  //       : arglist points to an array, the first element being
002099  002307  //       : the number of elements in the array.
002100  002308  //       : func 'main' in the called program accepts
002101  002309  //       : the arguments, if any. THe arguments can only
002102  002310  //       : be passed by value, no pointers or references can be
002103  002311  //       : used as all memory is cleared before the file
002104  002312  //       : is loaded. Refer to file_Exec and file_LoadFunction
002105  002313  //       : for functions that can pass by reference.
002106  002314        
002107  002315  func file_Exec("fname.4xe", "arglistptr"), 1;
002108  002316  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002109  002317  // Usage : res := file_Exec("fname.4xe","arglistptr");
002110  002318  // Notes : returns like a function, current program
002111  002319  //       : calling program is kept active and control returns to it.
002112  002320  //       : If arglistptr is 0, no arguments are passed, else
002113  002321  //       : arglist points to an array, the first element being
002114  002322  //       : the number of elements in the array.
002115  002323  //       : func 'main' in the called program accepts the arguments.
002116  002324  //       : This function is similar to file_LoadFunction(...), however,
002117  002325  //       : the function argument list is passed by pointer, and
002118  002326  //       : the memory consumed by the function is released as
002119  002327  //       : soon as the function completes.
002120  002328        
002121  002329  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002122  002330  // Syntax	: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002123  002331  // Usage	: hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002124  002332  // Notes	: Reads a control file to create an image list.
002125  002333  // 	: Returns NULL if function fails.
002126  002334  // 	: Returns a handle (pointer to the memory allocation) to the
002127  002335  // 	: image control list that has been created.
002128  002336  // 	: "fname1" is the control list filename "*.dat"
002129  002337  // 	: "fname2" is the image filename "*.gci"
002130  002338  // 	: "mode" is 0 for FAT based GCI and DAT with quick load and slower for each display
002131  002339  // 	: "mode" is 1 for FAT based GCI and DAT with slower load and faster for each display
002132  002340  // 	: "mode" is 2 for FAT based DAT with RAW GCI
002133  002341  // 	: "mode" is 3 for Flash based 'file system' GCI (GCIF) with itegerated DAT and other file types
002134  002342  // 	: "fname1" and "fname2" are then the Flash high and low words of the GFIC start location.
002135  002343        
002136  002344  // Notes : This function Calculates the size of a chunk of memory required for
002137  002345  //       : a image list and populates it from the image control file ("*.dat")
002138  002346  //       : therefore, when imagelist is no longer required, you must de-allocate
002139  002347  //       : the image list memory by using eg:- mem_Free(hImagelist);
002140  002348  //       : to restore the heap.
002141  002349  //       :
002142  002350  //       : mode 0:- it is assumed that there is a graphics file with the
002143  002351  //       : file extension "fname2.gci". In this case, the images have been stored
002144  002352  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002145  002353  //       : "fname1.dat" file are saved in the image control so that the image control
002146  002354  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002147  002355  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002148  002356  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002149  002357  //       : for the file offsets and save them in the relevant entries in the image control.
002150  002358  //       : The penalty is that images take longer to find when displayed due to file_Seek
002151  002359  //       : overheads.
002152  002360  //
002153  002361  //       : mode 1:- it is assumed that there is a graphics file with the
002154  002362  //       : file extension "fname2.gci". In this case, the images have been stored
002155  002363  //       : in a FAT16 file concurrently, and the offset of the images are saved
002156  002364  //       : in the image control so that image file (*.gci) can be mapped to directly.
002157  002365  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002158  002366  //       : internally. This means that there is no seek time penalty, however, the
002159  002367  //       : image list takes a lot longer to build, as all the seeking is done at control
002160  002368  //       : build time.
002161  002369        
002162  002370  //       : mode 2:- the graphics file with the is placed in a partitioned area
002163  002371  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002164  002372  //       : disk, and the absolute address of the images are saved in the DAT file
002165  002373  //       : This is the fastest operation of the image control as there is no seeking
002166  002374  //       : or other disk activity taking place.
002167  002375        
002168  002376  func file_Mount(), 1;
002169  002377  // Syntax: r := file_Mount();
002170  002378  // Usage : r := file_Mount();
002171  002379  // Notes : Create a control block for FAT16 and mount the File System
002172  002380        
002173  002381  func file_Unmount(), 0;
002174  002382  // Syntax: file_Unmount();
002175  002383  // Usage : file_Unmount();
002176  002384  // Notes : release any control block and buffers for FAT16
002177  002385  //       : and unmount the File System
002178  002386        
002179  002387  func file_PlayWAV("fname1"), 1;
002180  002388  // Syntax: file_PlayWAV("fname1");
002181  002389  // Usage : file_PlayWAV("ding.wav");
002182  002390  // Notes : Play a wave file with filename "fname1"
002183  002391  //       : This function automatically grabs a chunk
002184  002392  //       : of memory for a file buffer, and a wave
002185  002393  //       : buffer. The minimum memory requirement is
002186  002394  //       : about 580 bytes for the disk io service and
002187  002395  //       : a minimum wave buffer size of 1024. The siz
002188  002396  //       : of the wave buffer allocation
002189  002397  //       : can be increased by the snd_BufSize function.
002190  002398  //       : The default size 1024 bytes.
002191  002399  //       : NB the memory is only required during the
002192  002400  //       : duration of play, and is automatically
002193  002401  //       : released while not in use.
002194  002402  //       : See the Sound Class services for other associated controls.
002195  002403  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002196  002404  //       : If errors occured, the folling is returned
002197  002405  //       : -7  : Insufficient memory available for WAV buffer and file
002198  002406  //       : -6  : cant play this rate
002199  002407  //       : -5  : no data chunk found in first rsector
002200  002408  //       : -4  : no format data
002201  002409  //       : -3  : no wave chunk signature
002202  002410  //       : -2  : bad wave file format
002203  002411  //       : -1  : file not found
002204  002412        
002205  002413        
002206  002414        
002207  002415  //------------------------------------------------------------------//
002208  002416  //        Sound Class Services
002209  002417  //------------------------------------------------------------------//
002210  002418        
002211  002419  func snd_Volume("var"), 0;
002212  002420  // Syntax: snd_Volume("var");
002213  002421  // Usage : snd_Volume(30);
002214  002422  // Notes : set sound playback volume.  Var must
002215  002423  //       : be in the range from 8 (min volume)
002216  002424  //       : to 127 (max volume). If var is less
002217  002425  //       : than 8 volume is set to 8, and if
002218  002426  //       : var > 127 it is set to 127.
002219  002427        
002220  002428  func snd_Pitch("pitch"), 1;
002221  002429  // func snd_Pitch("freq"), 1;
002222  002430  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002223  002431  // Notes : sets the samples playback rate to a different frequency
002224  002432  //       : The minimum value is 4khz
002225  002433  //       : Setting the pitch to zero restores the original sample rate
002226  002434  //       : Return value is the samples original sample rate.
002227  002435        
002228  002436  func snd_BufSize("var"), 0;
002229  002437  // Syntax: snd_BufSize("var");
002230  002438  // Usage : snd_BufSize(2);
002231  002439  // Notes : specify the a memory chunk size for the wavefile buffer.
002232  002440  //       : default size 1024 bytes.
002233  002441  //       : 0 = 1024 bytes (default)
002234  002442  //       : 1 = 2048 bytes
002235  002443  //       : 2 = 4096 bytes
002236  002444  //       : 3 = 8192 bytes
002237  002445        
002238  002446  func snd_Stop(), 0;
002239  002447  // Syntax: snd_Stop();
002240  002448  // Usage : snd_Stop();
002241  002449  // Notes : stop any sound that is playing, releasing
002242  002450  //       : buffers and closes any open wav file.
002243  002451        
002244  002452  func snd_Pause(), 0;
002245  002453  // Syntax: snd_Pause();
002246  002454  // Usage : snd_Pause();
002247  002455  // Notes : pauses any sound that is playing, does nothing
002248  002456  //       : until sound is resumed with snd_Continue().
002249  002457  //       : The sample cam be terminated with snd_Stop.
002250  002458  //       : buffers and closes any open wav file.
002251  002459        
002252  002460  func snd_Continue(), 0;
002253  002461  // Syntax: snd_Continue();
002254  002462  // Usage : snd_Continue();
002255  002463  // Notes : resume any sound that is paused by snd_Pause.
002256  002464        
002257  002465  func snd_Playing(), 1;
002258  002466  // Syntax: snd_Playing();
002259  002467  // Usage : r := snd_Playing();
002260  002468  // Notes : returns 0 if sound has finished playing,
002261  002469  //       : else return number of 512 byte blocks to go.
002262  002470        
002263  002471        
002264  002472        
002265  002473  //------------------------------------------------------------------//
002266  002474  //        String Class Services
002267  002475  //------------------------------------------------------------------//
002268  002476        
002269  002477  func str_Ptr("&var"), 1;
002270  002478  // Syntax: str_Ptr(&var);
002271  002479  // Usage : p := str_Ptr(&var);
002272  002480  // Notes : return a byte pointer to a word region
002273  002481        
002274  002482  func str_GetD("&ptr", "&var"), 1;
002275  002483  // Syntax: str_GetD(&ptr, &var);
002276  002484  // Usage : ok := str_GetD(&ptr, &var);
002277  002485  // Notes : convert number in a string to DWORD ( myvar[2] )
002278  002486  //       : returns true if function succeeds, advancing ptr
002279  002487        
002280  002488  func str_GetW("&ptr", "&var"), 1;
002281  002489  // Syntax: str_GetW(&ptr, &var);
002282  002490  // Usage : ok := str_GetW(&ptr, &var);
002283  002491  // Notes : convert number in a string to WORD ( myvar )
002284  002492  //       : returns true if function succeeds, advancing ptr
002285  002493        
002286  002494  func str_GetHexW("&ptr", "&var"), 1;
002287  002495  // Syntax: str_GetHexW(&ptr, &var);
002288  002496  // Usage : ok := str_GetHexW(&ptr, &var);
002289  002497  // Notes : convert HEX number in a string to WORD ( myvar )
002290  002498  //       : returns true if function succeeds, advancing ptr
002291  002499        
002292  002500  func str_GetC("&ptr", "&var"), 1;
002293  002501  // Syntax: str_GetC(&ptr, &var);
002294  002502  // Usage : ok := str_GetC(&ptr, &var);
002295  002503  // Notes : get a valid ascii char in a string to WORD ( myvar )
002296  002504  //       : returns true if function succeeds, advancing ptr
002297  002505        
002298  002506  func str_GetByte("ptr"), 1;
002299  002507  // Syntax: str_GetByte(ptr);
002300  002508  // Usage : myvar := str_GetByte(ptr);
002301  002509  // Notes : get a byte to myvar
002302  002510  //       : returns value
002303  002511        
002304  002512  func str_GetWord("ptr"), 1;
002305  002513  // Syntax: GetWord(ptr);
002306  002514  // Usage : GetWord(ptr);
002307  002515  // Notes : get a word to myvar
002308  002516  //       : returns value
002309  002517        
002310  002518  func str_PutByte("ptr","val"), 0;
002311  002519  // Syntax: str_PutByte(ptr);
002312  002520  // Usage : myvar := str_PutByte(ptr);
002313  002521  // Notes : put a byte at ptr
002314  002522  //       : returns value
002315  002523        
002316  002524  func str_PutWord("ptr","val"), 0;
002317  002525  // Syntax: str_PutWord("ptr","val");
002318  002526  // Usage : str_PutWord(p,100);
002319  002527  // Notes : put word 100 at current pointer location
002320  002528  //       : returns value
002321  002529        
002322  002530  func str_Match("&ptr", "*str"), 1;
002323  002531  // Syntax: str_Match(&ptr, *str);
002324  002532  // Usage : r := str_Match(&p, "hello");
002325  002533  // Notes : Case sensitive match
002326  002534  //       : returns true if function succeded, andvancing pointer to position past
002327  002535  //       : the matched item. Note that any whitespace characters are skipped
002328  002536  //       : in the source string prior to the test.
002329  002537        
002330  002538  func str_MatchI("&ptr", "*str"), 1;
002331  002539  // Syntax: str_MatchI(&ptr, *str);
002332  002540  // Usage : r := str_MatchI(&p, "hello");
002333  002541  // Notes : Case insensitive match
002334  002542  //       : returns true if function succeded, andvancing pointer to position past
002335  002543  //       : the matched item. Note that any whitespace characters are skipped
002336  002544  //       : in the source string prior to the test.
002337  002545        
002338  002546  func str_Find("&ptr", "*str"), 1;
002339  002547  // Syntax: str_Find(&ptr, *str);
002340  002548  // Usage : n := str_Find(&p, "hello");
002341  002549  // Notes : given the address of a pointer to a source string as the
002342  002550  //       : first argument, and a pointer to a test string as the second
002343  002551  //       : argument, attempt to find the position of the matching string
002344  002552  //       : in the source string. The test is performed with case sensitivity.
002345  002553  //       : return 0 if not found, else returns the address of the first
002346  002554  //       : character of the match. NB:- The source pointer is not altered.
002347  002555        
002348  002556  func str_FindI("&ptr", "*str"), 1;
002349  002557  // Syntax: str_Find(&ptr, *str);
002350  002558  // Usage : n := str_Find(&p, "hello");
002351  002559  // Notes : given the address of a pointer to a source string as the
002352  002560  //       : first argument, and a pointer to a test string as the second
002353  002561  //       : argument, attempt to find the position of the matching string
002354  002562  //       : in the source string. The test is performed with no case
002355  002563  //       : sensitivity, eg upper and lower case chars are accepted.
002356  002564  //       : return 0 if not found, else returns the address of the first
002357  002565  //       : character of the match. NB:- The source pointer is not altered.
002358  002566        
002359  002567  func str_Length("ptr"), 1;
002360  002568  // Syntax: str_Length(ptr);
002361  002569  // Usage : len := str_Ptr(mystring);
002362  002570  // Notes : return the length of a byte aligned string excluding terminator
002363  002571        
002364  002572  func str_Printf("&ptr", "*format"), 1;
002365  002573  // Syntax: str_Printf("&ptr", "*format");
002366  002574  // Usage : r := str_Printf(&p, "%8s");
002367  002575  // Notes : refer to documentation
002368  002576  //       :
002369  002577        
002370  002578  func str_Cat("dest","src"), 1;
002371  002579  // Syntax: str_Append("&dest","&src");
002372  002580  // Usage : str_Append(&buf,"Hello");
002373  002581  // Notes : Appends a copy of the source string to the destination string.
002374  002582  //       : The terminating null character in destination is overwritten by
002375  002583  //       : the first character of source, and a new null-character is appended
002376  002584  //       : at the end of the new string formed by the concatenation of both in destination.
002377  002585  //       : returns destination.
002378  002586        
002379  002587  func str_CatN("dest","src","count"), 1;
002380  002588  // Syntax: str_Append("&dest","&src","count");
002381  002589  // Usage : str_Append(&buf,"Monday",3);
002382  002590  // Notes : Appends a copy of the source string to the destination string.
002383  002591  //       : The number of characters copied is limited by "count".
002384  002592  //       : The terminating null character in destination is overwritten by
002385  002593  //       : the first character of source, and a new null-character is appended
002386  002594  //       : at the end of the new string formed by the concatenation of both in destination.
002387  002595  //       : returns destination.
002388  002596        
002389  002597        
002390  002598  func sys_StoreTouchCalibration(), 1;
002391  002599  // Syntax: sys_StoreTouchCalibration();
002392  002600  // Usage : r := sys_StoreTouchCalibration();
002393  002601  // Notes : Store the touch calibration values in non-volatile memory.
002394  002602  //       : Returns true if the values have been accepted and stored,
002395  002603  //       : else returns false if write could not be performed, or
002396  002604  //       : touch calibration values are improbable.
002397  002605  //       : The values that are stored are obtained from:-
002398  002606  //     : TOUCH_XMINCAL             78  // touch calibration value
002399  002607  //     : TOUCH_YMINCAL             79  // touch calibration value
002400  002608  //       : TOUCH_XMAXCAL             80  // touch calibration value
002401  002609  //       : TOUCH_YMAXCAL             81  // touch calibration value
002402  002610  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002403  002611  //       : This function is not supported on uVGA, Capicitive touch
002404  002612  //       : and 4.3" resistive touch modules.
002405  002613        
002406  002614        
002407  002615  func unicode_page("charbeg","charend","charoffset"), 1;
002408  002616  // Syntax: unicode_page("charbeg","charend","charoffset");
002409  002617  // Usage : eg:  F_Traditional_0x20_0xFF
002410  002618  // Notes : After selecting a unicode image control with txt_FontID,
002411  002619  //       : this function is called to set the required font within the
002412  002620  //       : unicode set. The file "Unicode.inc" contains wrappers for
002413  002621  //       : this function, and it is not normally called directly.
002414  002622  //       : Returns count of characters in the set.
002415  002623  //       : Refer to "Unicode.inc" for further information.
002416  002624        
002417  002625        
002418  002626  func EVE_SP(), 1;
002419  002627  // Syntax: EVE_SP();
002420  002628  // Usage : eg:  print(EVE_SP());
002421  002629  // Notes : Used for debugging to assess the current stack level,
002422  002630  //       : mainly for checking stack leaks
002423  002631        
002424  002632  func EVE_SSIZE(), 1;
002425  002633  // Syntax: EVE_SSIZE();
002426  002634  // Usage : eg:  print(EVE_SSIZE());
002427  002635  // Notes : Used to get the stack size,
002428  002636  //       : mainly for debugging purposes
002429  002637        
002430  002638        
002431  002639  // uVGAII extended functions
002432  002640  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002433  002641  // Syntax: disp_Sync(line);
002434  002642  // Usage : disp_Sync(480);
002435  002643  // Notes : Waits till the hardware gets to a certain line.
002436  002644  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002437  002645  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002438  002646  //       : depending on the graphics operation. The higher the value, the slower
002439  002647  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002440  002648  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002441  002649  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002442  002650  //       : be slowest (as its actually right at the end of the blanking period) and 508
002443  002651  //       : will cause a hangup situation as it is above the highes scanline value.
002444  002652  //       : Currently, this function is only supported on displays with SSD1963 driver.
002445  002653        
002446  002654        
002447  002655  // New functions added to PmmC v2.8
002448  002656  //================================================================
002449  002657  func CY(), 1;
002450  002658  // Syntax: CY();
002451  002659  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002452  002660  //       : print(myvar," "CY(),"\n");           // carry = 1
002453  002661  // Notes : This function returns the carry status of an
002454  002662  // unsigned overflow from any 16 or 32bit additions or sutractions.
002455  002663  //================================================================
002456  002664        
002457  002665        
002458  002666  //================================================================
002459  002667  func str_ByteMove("src", "dest", "count"), 1;
002460  002668  // func str_ByteMove("src", "dest", "count"), 1;
002461  002669  // Syntax   : str_ByteMove(src, dest, bytecount);
002462  002670  // Input    : STR *source points to byte aligned source.
002463  002671  //          : STR *dest   points to byte aligned destination.
002464  002672  //          : VAR count   number of bytes to transfer.
002465  002673  // Usage    : nextpos := str_ByteMove(s, d, 100);
002466  002674  // Notes    : copy bytes from "src" to "dest", stopping only
002467  002675  //          : when "count" is exhausted.
002468  002676  //          : No terminator is appended, it is purely a
002469  002677  //          : byte copy, and any zeroes encountered will
002470  002678  //          : also be copied.
002471  002679  // Returns  : returns a pointer to the end of the destination
002472  002680  //          : (which is "dest" + "count")
002473  002681  //================================================================
002474  002682        
002475  002683        
002476  002684  //================================================================
002477  002685  func str_Copy("dest", "src"), 1;
002478  002686  // Syntax   : str_Copy(dest, src);
002479  002687  // Input    : STR *dest   points to byte aligned destination.
002480  002688  //          : STR *source points to byte aligned source.
002481  002689  // Usage    : nextplace := str_Copy(d, s);
002482  002690  // Notes    : copy a string from "src" to "dest", stopping only
002483  002691  //          : when the end of source string "src" is encountered
002484  002692  //          : (0x00 terminator).
002485  002693  //          : The terminator is always appended, even if "src" is
002486  002694  //          : an empty string.
002487  002695  // Returns  : returns a pointer to the 0x00 string terminator at
002488  002696  //          : end of "dest" (which is "dest" + str_Length(src); )
002489  002697  //================================================================
002490  002698        
002491  002699  //================================================================
002492  002700  func str_CopyN("dest", "src", "count"), 1;
002493  002701  // Syntax   : str_CopyN(dest, src, bytecount);
002494  002702  // Input    : STR *dest   points to byte aligned destination.
002495  002703  //          : STR *source points to byte aligned source.
002496  002704  //          : VAR count   max number of chars to copy.
002497  002705  // Usage    : nextplace := str_CopyN(d, s, 100);
002498  002706  // Notes    : copy a string from "src" to "dest", stopping only
002499  002707  //          : when "count" is exhausted, or end of source
002500  002708  //          : string "str" is encountered (0x00 string terminator).
002501  002709  //          : The terminator is always appended, even if
002502  002710  //          : "count" is zero, or "src" is a null string.
002503  002711  // Returns  : returns a pointer to the 0x00 string terminator
002504  002712  //          : (which is "dest" + whatever was copied)
002505  002713  //================================================================
002506  002714        
002507  002715  //================================================================
002508  002716  func umul_1616("&res32", "val1", "val2"), 1;
002509  002717  // Syntax   : umul_1616(&res32, varA, varB);
002510  002718  // Input    : DWORD *result   points to 32bit result register.
002511  002719  //          : VAR   val1  16bit register or constant
002512  002720  //          : VAR   val2  16bit register or constant
002513  002721  // Usage    : var res32[2];
002514  002722  //          : umul_1616(&res32, myvar, 50000);
002515  002723  // Notes    : performs an unsigned multiply of 2 x 16bit values
002516  002724  //          : placing the 32bit result in a 2 word array.
002517  002725  // Returns  : the pointer to the 32bit result.
002518  002726  //          : carry and overflow are not affected.
002519  002727  //================================================================
002520  002728        
002521  002729  //================================================================
002522  002730  func uadd_3232("&res32", "&val1", "&val2"), 1;
002523  002731  // Syntax   : cmp_3232(&res32, &varA, &varB);
002524  002732  // Input    : DWORD *res32 points to optional result (or zero for compare)
002525  002733  //          : DWORD *val1 points to 32bit augend
002526  002734  //          : DWORD *val2 points to 32bit addend
002527  002735  // Usage    : var res32[2];
002528  002736  //          : res := cmp_3232(res32, val1, val2);
002529  002737  // Notes    : performs an unsigned addition of 2 x 32bit values
002530  002738  //          : placing the 32bit result in a 2 word array.
002531  002739  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002532  002740  //          ; carry flag is also set on 32bit unsigned overflow
002533  002741  //          ; and can be read with the CY() function.
002534  002742  //================================================================
002535  002743        
002536  002744  //================================================================
002537  002745  func usub_3232("&res32", "&val1", "&val2"), 1;
002538  002746  // Syntax   : cmp_3232(&res32, &varA, &varB);
002539  002747  // Input    : DWORD *res32 points to optional result (or zero for compare)
002540  002748  //          : DWORD *val1 points to first 32bit minuend
002541  002749  //          : DWORD *val2 points to 32bit subtrahend
002542  002750  // Usage    : var res32[2];
002543  002751  //          : res := cmp_3232(res32, val1, val2);
002544  002752  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002545  002753  //          : placing the 32bit result in a 2 word array.
002546  002754  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002547  002755  //          ; carry flag is also set on 32bit unsigned underflow
002548  002756  //          ; and can be read with the CY() function.
002549  002757  //================================================================
002550  002758        
002551  002759  //================================================================
002552  002760  func ucmp_3232("&val1", "&val2"), 1;
002553  002761  // Syntax   : cmp_3232(&varA, &varB);
002554  002762  // Input    : DWORD *val1 points to 32bit minuend
002555  002763  //          : DWORD *val2 points to 32bit sutrahend
002556  002764  // Usage    : res := cmp_3232(val1, val2);
002557  002765  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002558  002766  //          : The result of the subtraction is returned.
002559  002767  // Returns  : 0  if equal
002560  002768  //          : 1  if val1 > val2
002561  002769  //          : -1 if val1 < val2
002562  002770  //          : This function does not affect the carry flag.
002563  002771  //================================================================
002564  002772        
002565  002773  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002566  002774  // Syntax: disp_Disconnect();                  New in v3.8
002567  002775  // Usage : disp_Disconnect();
002568  002776  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002569  002777  //       : its lowest possible power consumption. Use after disabling peripheral power
002570  002778  //       : to ensure the minimal power usage by the display.
002571  002779  //       : disp_Init() should be used to reinitialise the display.
002572  002780        
002573  002781  func reserved(), 0;                            
002574  002782        
002575  002783  func sys_DeepSleep("units"), 1;
002576  002784  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002577  002785  // Usage : t := sys_DeepSleep(10);
002578  002786  // Notes : sets the display and processor into lowest power mode for a period of time.
002579  002787  //       : When returning from DeepSleep the display should be reinitialised
002580  002788  //       : with disp_Init().
002581  002789  //       : Touching the touch screen will also wake from sleep.
002582  002790  //       : Returns remaining sleep units.
002583  002791        
002584  002792  func sys_PmmC(), 1;
002585  002793  // Syntax: sys_PmmC();
002586  002794  // Usage : to(mystring); sys_PmmC();   // save PmmC name and revision string to buffer, new in v4.6
002587  002795  // Notes : print the system PmmC name and revision eg "Picaso\n4.6"
002588  002796  //       : Can be captured to a buffer using the to( function
002589  002797  //       : Returns PmmC version as a hex number, eg 0x46
002590  002798        
002591  002799  func sys_Driver(), 0;
002592  002800  // Syntax: sys_Driver();
002593  002801  // Usage : to(mystring); sys_Driver();   // save Driver name and date string to buffer, new in v4.6
002594  002802  // Notes : print the system PmmC name and revision eg "uLCD-32PTU"
002595  002803  //       : Can be captured to a buffer using the to( function
002596  002804  //       : Returns nothing.
002597  002805        
002598  002806  func OW_Reset("pin"), 1;                             // issue 1wire reset command
002599  002807  // Syntax   : OW_Reset(PA0);
002600  002808  // Usage    : OW_Reset(PA0);
002601  002809  // Notes    : Only available on PA0 to PA13
002602  002810  //          : Resets  ONEWIRE device
002603  002811  //          : Returns the status, 0 = ACK.
002604  002812  //          :
002605  002813        
002606  002814  func OW_Read("pin"), 1;                              // read data from 1wire bus
002607  002815  // Syntax   : OW_Read(PA0);
002608  002816  // Usage    : arg1 := OW_Read(PA0);
002609  002817  // Notes    : Only available on PA0 to PA13
002610  002818  //          : Reads value of the ONEWIRE pin
002611  002819  //          : that was previously selected for ONEWIRE comms.
002612  002820  //          :
002613  002821  //          : pin = 0 : the next byte from the ONEWIRE bus
002614  002822        
002615  002823  func OW_Read9("pin"), 1;                             // read data from 1wire bus, 9bit mode
002616  002824  // Syntax   : OW_Read9(PA0);
002617  002825  // Usage    : OW_Read9(PA0);
002618  002826  // Notes    : Only available on PA0 to PA13
002619  002827  //          : Reads 9 bit value of the appropriate ONEWIRE pin
002620  002828  //          : that was previously selected for ONEWIRE comms.
002621  002829  //          :
002622  002830  //          : read the 9 bits from the ONEWIRE bus
002623  002831        
002624  002832  func OW_Write("pin", "value"), 0;                      // write value to 1wire device
002625  002833  // Syntax   : OW_Write(PA0, arg);
002626  002834  // Usage    : OW_Write(PA0, arg);
002627  002835  // Notes    : Only available on PA0 to PA13
002628  002836  //          : Sends ONEWIRE data on the appropriate
002629  002837  //          : pin that was previously  selected as ONEWIRE comms.
002630  002838  //          :
002631  002839  //          : write arg to the ONEWIRE bus
002632  002840        
002633  002841  func snd_Freq("Freq", "Duration"), 1;
002634  002842  // Syntax	: snd_Freq("Freq", "Duration");
002635  002843  // Usage	: r := snd_Freq(1000, 2000);
002636  002844  // Notes	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002637  002845  // 	: else return True.
002638  002846  // 	: Minimum Freq is 20
002639  002847  // 	: This will produce a pure Square wave and is designed for driving
002640  002848  // 	: Piezo transducers which require this sort of drive. It can be used
002641  002849  // 	: directly with high impedience speakers.
002642  002850        
002643  002851  func gfx_SpriteSet("bitmaps", "colours", "palette"), 0;
002644  002852  // Syntax   : gfx_SpriteSet("bitmaps", "colours", "palette");
002645  002853  // Usage    : gfx_SpriteSet(mysprites, mycolours, mypalette);
002646  002854  // Notes    : 3 sets of data are required by the sprite generator,
002647  002855  //          : this function sets the internal pointers for the 3 parts.
002648  002856  //          : 1] the bitmaps for the sprites,
002649  002857  //          : 2] the colour lookup table (CLUT),
002650  002858  //          : 3] the 4 colour palettes.
002651  002859        
002652  002860        
002653  002861  func gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage"), 0;
002654  002862  // Syntax 	: gfx_BlitSprite("spritenumber", "palette", "xpos", "ypos", "orientation", "preimage");
002655  002863  // Usage 	: gfx_BlitSprite(1,2,10,10,SOUTH,0);  // example show a cherry upside down using the third palette of mypalette
002656  002864  // Notes 	: Places the required sprite bitmap at the origin xpos, ypos using the required 4 colour palette.
002657  002865  //  	: orientation determines in which direction the sprite will be displayed.
002658  002866  //    	: if preimage exists it should be large enough to hold the entire image 'underneath' the sprite.
002659  002867        
002660  002868  func gfx_ReadGRAMarea("x1", "y1", "x2", "y2", "ptr"), 1;
002661  002869  // Syntax  : gfx_ReadGRAMarea(x1, y1, x2, y2, ptr);
002662  002870  // Usage   : anArrayPtr := gfx_ReadGRAMarea(10, 10, 50, 50, 0);  // read rectangular area to array, let the function make the array for me
002663  002871  // Notes   : reads an arbitrary rectangular area from the display to an array.
002664  002872  //         : If "ptr" is 0, the correctly sized array is created, in which case
002665  002873  //         : it is up to the caller to eventually destroy it. Otherwise "ptr"
002666  002874  //         : is expected to point to a correctly sized array.
002667  002875  //         : NB if an array is supplied, its size must be large enough, and may
002668  002876  //         : be calculated:-
002669  002877  //         : bytecount := ( (ABS(x2-x1)+1) * (ABS(y2-y1) + 1)) * 2;     // calc array size for mem_Alloc (which allocates byte storage)
002670  002878  //         : wordcount := ( (ABS(x2-x1)+1) *  ABS(y2-y1);             // calc array size for fixed word array
002671  002879  // Returns : A pointer to the created aray, or the users array.
002672  002880  //         : In the case of ptr=0, if there is insufficient
002673  002881  //         : memory to create the array, zero is returned
002674  002882        
002675  002883        
002676  002884  func gfx_WriteGRAMarea("x1", "y1", "x2", "y2", "ptr"), 0;
002677  002885  // Syntax  : gfx_WriteGRAMarea(x1, y1, x2, y2, ptr), 0;
002678  002886  // Usage   : gfx_WriteGRAMarea(20, 20, 50, 50, anArrayPtr);   // write an array back to the rectangular area
002679  002887  // Notes   : "ptr" points to the array to be written.
002680  002888  // Returns : nothing
002681  002889        
002682  002890  func rect_Intersect("&rect1", "&rect2"), 1;
002683  002891  // Syntax   : rect_Intersect(&rect1, &rect2);
002684  002892  // Usage    : rect_Intersect(box1, box2);
002685  002893  // Notes    : return true if any part of rect1 is within rect2
002686  002894  //          : each rectangle is an array of 4 words in the format:-
002687  002895  //	    : element 0 = RECT_LEFT			
002688  002896  //	    : element 1 = RECT_TOP			
002689  002897  //	    : element 2 = RECT_WIDTH 		
002690  002898  //	    : element 3 = RECT_HEIGHT 
002691  002899  //          : This function is ideal for use as a collision detector.		
002692  002900        
002693  002901  func rect_Within("&rect1", "&rect2"), 1;
002694  002902  // Syntax   : rect_Within(&rect1, &rect2);
002695  002903  // Usage    : rect_Within(box1, box2);
002696  002904  // Notes    : return true if rect1 is fully within rect2
002697  002905  //          : each rectangle is an array of 4 words in the format:-
002698  002906  //	    : element 0 = RECT_LEFT			
002699  002907  //	    : element 1 = RECT_TOP			
002700  002908  //	    : element 2 = RECT_WIDTH
002701  002909  //	    : element 3 = RECT_HEIGHT 
002702  002910        
002703  002911  func snd_RTTTL("TunePtr",), 1;                           // play a RTTTL tune string
002704  002912  // Syntax	: snd_RTTTL(TunePtr);
002705  002913  // Usage	: snd_RTTTL("...notes...");
002706  002914  // Notes	: Play an RTTTL tune string from a data statement or a direct string
002707  002915  // 	: Returns 0 if note cannot be played because a Freq is playing, or sound pin is not set
002708  002916        
002709  002917  func joystick("Pin"), 1;                                     // read the joystick value
002710  002918  // Syntax   : Joystick("Pin");
002711  002919  // Usage    : var := Joystick(IO1_PIN);
002712  002920  // *Notes   : Returned values are:-
002713  002921  //          :    JOY_RELEASED 0
002714  002922  //          :    JOY_UP       1
002715  002923  //          :    JOY_LEFT     2
002716  002924  //          :    JOY_DOWN     3
002717  002925  //          :    JOY_RIGHT    4
002718  002926  //          :    JOY_BTNB     5
002719  002927  //          :    JOY_BTNA     6
002720  002928        
002721  002929  func gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour"), 0;         // display an Annular ring segment
002722  002930  // Syntax 	: gfx_RingSegment("x", "y", "Rad1", "Rad2", "starta", "enda", "colour") ;
002723  002931  // Usage 	: gfx_RingSegment(x, y, starta, enda, rx, w, colour) ;
002724  002932  // Notes 	: Draw a Segment of a ring at x, y from rad1 to rad2 starting at starta to enda
002725  002933  // 	: in colour.
002726  002934  //
002727  002935        
002728  002936  func gfx_AngularMeter("value", "&MeterRam", "&MeterDef"), 0;                           // draw an angular meter scale and value
002729  002937  // Syntax 	: gfx_AngularMeter("value", "&MeterRam", "&MeterDef") ;
002730  002938  // Usage 	: gfx_AngularMeter(value, MeterRam, MeterDef) ;
002731  002939  // Notes 	: Draw an Angular Meter as defined by MeterDef (if required), using MeterRam positioning at
002732  002940  // 	: position value. See the reference for the MeterDef values
002733  002941  //
002734  002942        
002735  002943  // AngularMeter constants
002736  002944  #CONST
002737  002995  #END
002738  002996        
002739  002997  #constant PANEL2_FILLED 0x8000
002740  002997  #constant PANEL2_FILLED 0x8000
002741  002998        
002742  002999  func gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf"), 0;                           // draw a windows style 3D panel
002743  003000  // Syntax 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002744  003001  // Usage 	: gfx_Panel2("state", "x", "y", "width", "height", "w1", "w2", "cl", "cr", "cf") ;
002745  003002  // Notes	: Draws a panel2 (groupbox) at screen location defined by
002746  003003  // 	: x, y, width and height with left colour "cl", right colour "cr" and option fill colour "cf".
002747  003004  // 	:  w1 and w2 define the width of the outer and inner borders.
002748  003005  // 	:         state = 0 : recessed
002749  003006  // 	:         state = 1 : raised
002750  003007  // 	: 	  or state with PANEL2_FILLED to draw the fill
002751  003008        
002752  003009  func gfx_Needle("value", "&NeedleRam", "&NeedleDef"), 0;                           // draw a needle on a meter base
002753  003010  // Syntax 	: gfx_Needle("value", "&NeedleRam", "&NeedleDef") ;
002754  003011  // Usage 	: gfx_Needle(value, NeedleRam, NeedleDef) ;
002755  003012  // Notes 	: Draw a Needle as defined by NeedleDef (if required), using NeedleRam positioning at
002756  003013  // 	: position value. See the reference for the NeedleDef values
002757  003014  //
002758  003015        
002759  003016  #CONST
002760  003038  #END
002761  003039        
002762  003040  #CONST
002763  003047  #END
002764  003048        
002765  003049  func gfx_Dial("value", "&DialRam", "&DialDef"), 0;                           // draw a Dial / knob
002766  003050  // Syntax 	: gfx_Dial("value", "&DialRam", "&DialDef") ;
002767  003051  // Usage 	: gfx_Dial(value, DialRam, DialDef) ;
002768  003052  // Notes 	: Draw a Dial as defined by DialDef (if required), using DialRam positioning at
002769  003053  // 	: position value. See the reference for the DialDef values
002770  003054  //
002771  003055        
002772  003056  #CONST
002773  003114  #END
002774  003115        
002775  003116  func gfx_Gauge("value", "&GaugeRam", "&GaugeDef"), 0;                           // draw a gauge
002776  003117  // Syntax 	: gfx_Gauge("value", "&GaugeRam", "&GaugeDef") ;
002777  003118  // Usage 	: gfx_Gauge(value, GaugeRam, GaugeDef) ;
002778  003119  // Notes 	: Draw a Gauge as defined by GaugeDef (if required), using GaugeRam positioning at
002779  003120  // 	: position value. See the reference for the GaugeDef values
002780  003121  //
002781  003122        
002782  003123  #CONST
002783  003148  #END
002784  003149        
002785  003150  // widget_* functions
002786  003151  //
002787  003152  #CONST
002788  003185  #END
002789  003186        
002790  003187  func gfx_RoundGradient("style", "left", "top", "right", "bottom", "radius", "color1", "color2"), 0;
002791  003188  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, radius, colr1, colr2);
002792  003189  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
002793  003190  // Notes   : Draws a graduated colour rounded rectangle at the specified co-ordinate.
002794  003191  //         : X1 may equal X2, and Y1 = Y2 allowing allowing the function
002795  003192  //         : to be used for rounded panels, rounded buttons, circular buttons.
002796  003193  //         : "style" specifies the drawing mode
002797  003194  //         :     GRAD_DOWN         // gradient changes in the vertical direction
002798  003195  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
002799  003196  //         :     GRAD_UP           // gradient changes in the vertical direction
002800  003197  //         :     GRAD_LEFT         // gradient change in the horizontal direction
002801  003198  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
002802  003199  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
002803  003200  //         : Bounding rectangle is x1-radius, y1-radius, x2+radius, y2+radius.
002804  003201  // Returns : nothing.
002805  003202        
002806  003203        
002807  003204  //------------------------------------------------------------------//
002808  003205  //     gradient control constants                                   //
002809  003206  //------------------------------------------------------------------//
002810  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002811  003207  #constant GRAD_DOWN         0x20    // gradient changes in the vertical direction
002812  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002813  003208  #constant GRAD_RIGHT        0x30    // gradient change in the horizontal direction
002814  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002815  003209  #constant GRAD_UP           0x40    // gradient changes in the vertical direction
002816  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002817  003210  #constant GRAD_LEFT         0x50    // gradient change in the horizontal direction
002818  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002819  003211  #constant GRAD_WAVE_VER     0x60    // gradient wave in the vertical direction
002820  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002821  003212  #constant GRAD_WAVE_HOR     0x70    // gradient wave in the horizontal direction
002822  003213        
002823  003214  #CONST
002824  003217  #END
002825  003218        
002826  003219  #CONST
002827  003251  #END
002828  003252        
002829  003253  func gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef"), 0;                           // draw a value to a series of 7 segment led Digits
002830  003254  // Syntax 	: gfx_LedDigits("value", "&LedDigitRam", "&LedDigitDef");
002831  003255  // Usage 	: gfx_LedDigits(value, LedDigitRam, LedDigitDef);
002832  003256  // Notes 	: Draw a series of 7 segment Led Digits as defined by LedDigitDef, using LedDigitRam positioning at
002833  003257  // 	: position value. See the reference for LedDigitDef values.
002834  003258  //
002835  003259        
002836  003260  func gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value"), 0;                           // draw a single 7 segment led digit
002837  003261  // Syntax 	: gfx_LedDigit("x", "y", "digitsize", "oncolour", "offcolour", "value");
002838  003262  // Usage 	: gfx_LedDigit(x, y, digitsize, oncolour, offcolour, value);
002839  003263  // Notes 	: Draws a single 7 segment led Digit at x, y of size digitsize using oncolour and offcolour.
002840  003264  // 	: The value can be 0-9 (0-9), A-F (0x0a-0x0f), blank(0x10) and - (0x11).
002841  003265  //      : Or value with LEDDIGIT_F_SHOW_DP to show a decimal point, LEDDIGIT_F_DP_COMMA to make the Decimal
002842  003266  // 	: point a comma and LEDDIGIT_F_DP_ON to turn the decimal point on
002843  003267  // 	:
002844  003268  // 	: LEDDIGIT_F_SET_SEGMENTS can be used to turn value into a series of bits to turn on individual segments
002845  003269  //      : eg LEDDIGIT_F_SET_SEGMENTS + 9 will turn on the top and bottom segments. Again LEDDIGIT_F_SHOW_DP and
002846  003270  // 	: LEDDIGIT_F_DP_COMMA can be used, but in this case the DP is the 8th segment. 
002847  003271  // Returns : nothing.
002848  003272        
002849  003273  func gfx_RoundRect("x1", "y1", "x2", "y2", "rad", "color"), 0;
002850  003274  // Syntax  : gfx_RoundRect(x1, y1, x2, y2, radius, colour);
002851  003275  // Usage   : gfx_RoundRect(120, 120, 160, 160, 8, GRAY); // draw a tab like object
002852  003276  // Notes   : Draws a filled rectangle at the given co-ordinates with rounded corners
002853  003277  //         : determined by "radius". 
002854  003278  //         : Bounding rectangle is x1-rad, y1-rad, x2+rad, y2+rad.
002855  003279  // Returns : nothing.
002856  003280        
002857  003281  func putstrCentred("xc", "yc", "string"), 0;
002858  003282  // Syntax  : putstrCentred(x, y, "string"),
002859  003283  // Usage   : putstrCentred(100, 100, "HELLO");
002860  003284  // Notes   : Print a string centred at position x, y
002861  003285  //         : "String" may be a string constant, or pointer to a word aligned string.
002862  003286  // Returns : nothing.
002863  003287        
002864  003288  func widget_Create("count"), 1;
002865  003289  // Syntax 	: widget_Create("count"),
002866  003290  // Usage  	: widget_Create(count);
002867  003291  // Notes  	: Creates a widget Control capable of hoolding count elements and returns
002868  003292  //        	: a handle for the control.
002869  003293  // Returns	: Widget control handle.
002870  003294        
002871  003295  func widget_Add("hndl", "index", "widget"), 1;
002872  003296  // Syntax 	: widget_Add("hndl", "index", "widget"),
002873  003297  // Usage  	: widget_Add(hndl, index, widget);
002874  003298  // Notes  	: Add a widget ram entry "widget" into index "index" of the widget control referenced
002875  003299  //        	: by "hndl".
002876  003300  // Returns	: ssnothing.
002877  003301        
002878  003302  func widget_Delete("hndl", "index"), 1;
002879  003303  // Syntax 	: widget_Delete("hndl", "index"),
002880  003304  // Usage  	: widget_Delete(hndl, index);
002881  003305  // Notes  	: Delete widget ram entry "index" from the widget control referenced by "hndl".
002882  003306  // Returns	: sssnothing.
002883  003307        
002884  003308  func widget_Show("hndl", "index"), 1;
002885  003309  // Syntax	: widget_Show(handle, index);
002886  003310  // Usage	: display a flash resident image entry.
002887  003311  // Returns	: TRUE if successful, return value usually ignored.
002888  003312        
002889  003313  func widget_LoadFlash("Extra"), 1;
002890  003314  // Syntax	: hImagelist := widget_LoadFlash("Extra") ;
002891  003315  // Usage 	: hImagelist := widget_LoadFlash(0);
002892  003316  // Notes	: Reads the flash control file to create an widget list.
002893  003317  //      	: Returns NULL if function fails.
002894  003318  //      	: Returns a handle (pointer to the memory allocation) to the
002895  003319  //      	: widget control list that has been created.
002896  003320  //      	: "Extra" is the number of extra widget controls to be created
002897  003321  //      	: beyond the count in flash memory
002898  003322  // Returns 	: pointer to Widget control, or null if failed.
002899  003323        
002900  003324  func widget_Realloc("handle", "n"), 1;
002901  003325  // Syntax	: widget_Realloc(handle, n);
002902  003326  // Usage 	: Resizes a widget control to contain n entries, allowing it to be expanded or
002903  003327  //      	: condensed. Doing this unnecessarily can lead to RAM fragmentation. It is
002904  003328  //             	: much better to allocate widget controls once with the desired number of entries.
002905  003329  // Returns	: new handle to widget control.
002906  003330        
002907  003331  func widget_GetWord("hndl", "index", "offset"), 1;
002908  003332  // Syntax	: myvar := widget_GetWord("handle", "index", "offset");
002909  003333  // Usage 	: myvar := widget_GetWord(hndl, 5, WIDGET_YPOS);
002910  003334  // Notes 	: returns specified word (0-14) from a widget entry
002911  003335  //       	: refer to widget control entry offsets.
002912  003336        
002913  003337  func widget_Setposition("hndl", "index", "xpos", "ypos"), 1;
002914  003338  // Syntax	: widget_SetPosition(handle, index, xpos, ypos);
002915  003339  // Usage 	: r := widget_SetPosition(hImageList, imagenum, x, y);
002916  003340  // Notes 	: set the position of the widget control
002917  003341  //       	: returns true if index was ok and function was successful.
002918  003342        
002919  003343  func widget_Enable("hndl", "index"), 1;
002920  003344  // Syntax	: widget_Enable(handle, index);
002921  003345  // Usage 	: r := widget_Enable(hImageList, imagenum);
002922  003346  // Notes 	: enable an item in a widget control.
002923  003347  // Returns     	: true if index was ok and function was successful.
002924  003348        
002925  003349  func widget_Disable("hndl", "index"), 1;
002926  003350  // Syntax	: widget_Disable(handle, index);
002927  003351  // Usage 	: r := widget_Disable(hImageList, imagenum);
002928  003352  // Notes 	: disable an inetm in a widget control.
002929  003353  // Returns      : true if index was ok and function was successful.
002930  003354        
002931  003355  func widget_SetWord("hndl", "index", "offset", "value"), 1;
002932  003356  // Syntax: widget_SetWord(handle, index, offset, word);
002933  003357  // Usage : widget_SetWord(hndl, 5, IMAGE_XPOS, 10);
002934  003358  // Notes : set specified word (0-7) in a image entry
002935  003359  //       : returns TRUE if successful, return value usually ignored.
002936  003360        
002937  003361  func widget_SetAttributes("hndl", "index", "value"), 1;
002938  003362  // Syntax: widget_SetAttributes("handle", "index","offset");
002939  003363  // Usage : widget_SetAttributes(hndl, 5, I_TOPMOST);
002940  003364  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
002941  003365  //       : of an image control entry. "value" refers to various bits in
002942  003366  //       : the image control entry (see image attribute flags).
002943  003367  //       : A '1' bit in the "value" field SETS the respective bit
002944  003368  //       : in the IMAGE_FLAGS field of the image control entry.
002945  003369  //       : returns TRUE if successful, return value usually ignored.
002946  003370        
002947  003371  func widget_ClearAttributes("hndl", "index", "value"), 1;
002948  003372  // Syntax: widget_ClearAttributes("handle", "index","offset");
002949  003373  // Usage : widget_ClearAttributes(hndl, 5, I_TOPMOST);
002950  003374  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
002951  003375  //       : of an image control entry. "value" refers to various bits in
002952  003376  //       : the image control entry (see image attribute flags)
002953  003377  //       : a '1' bit in the "value" field CLEARS the respective bit
002954  003378  //       : in the IMAGE_FLAGS field of the image control entry.
002955  003379  //       : returns TRUE if successful, return value usually ignored.
002956  003380        
002957  003381  func widget_Touched("hndl", "index"), 1;
002958  003382  // Syntax: r := widget_Touched(handle, index);
002959  003383  // Usage : widget_Touched(hndl, 17);
002960  003384  //       : returns -1 if image not touched, or returns index
002961  003385  // Notes : if index is passed as -1, function tests all images,
002962  003386  //       : and returns -1 if image not touched, or returns index.
002963  003387        
002964  003388  func widget_FontID("id"), 1;                   // text font ID for flash based font
002965  003389  // Syntax: widget_FontID(id);
002966  003390  // Usage : widget_FontID(0);
002967  003391  //       : returns id of previous font
002968  003392        
002969  003393  #CONST
002970  003431  #END
002971  003432        
002972  003433  func gfx_Slider5("value", "&SliderRam", "&SliderDef"), 0;                           // draw a slider
002973  003434  // Syntax 	: gfx_Slider5("value", "&SliderRam", "&SliderDef") ;
002974  003435  // Usage 	: gfx_Slider5(value, SliderRam, SliderDef) ;
002975  003436  // Notes 	: Draw a Slider as defined by SliderDef (if required), using SliderRam positioning at
002976  003437  // 	: position value. See the reference for the SliderDef values
002977  003438  //
002978  003439        
002979  003440  func gfx_Surround("x1", "y1", "x2", "y2", "rad1", "rad2", "color"), 0;
002980  003441  // Syntax  : gfx_Surround(x1, y1, x2, y2, radius1, radius1, colour);
002981  003442  // Usage   : gfx_Surround(120, 120, 160, 160, 8, 0, GRAY); // rounded surround frame
002982  003443  // Notes   : Draws a outline rectangle at the given co-ordinates with rounded corners
002983  003444  //         : determined by "radius1". "radius2" sets the radius of the outer rounded rectangle.
002984  003445  //         : If "radius1" is zero, the inner rectangle will have square corners.
002985  003446  //         : Bounding rectangle is x1-rad1-rad2, y1-rad1-rad2, x2+rad1+rad2, y2+rad1+rad2.
002986  003447  // Returns : nothing.
002987  003448        
002988  003449  /////////////////////
002989  003450  #CONST
002990  003469  #END
002991  003470        
002992  003471  func gfx_Switch("state", "&SwitchRam", "&SwitchDef"), 0;                           // draw a switch
002993  003472  // Syntax 	: gfx_Switch("state", "&SwitchRam", "&SwitchDef") ;
002994  003473  // Usage 	: gfx_Switch(state, SwitchRam, SwitchDef) ;
002995  003474  // Notes 	: Draw a Switch as defined by SwitchDef (if required), using SwitchRam positioning at
002996  003475  // 	: position value. See the reference for the SwitchDef values
002997  003476  //
002998  003477        
002999  003478  #CONST
003000  003507  #END
003001  003508        
003002  003509  func gfx_Button4("state", "&gfx_ButtonRam", "&gfx_ButtonDef"), 0;                           // draw a button
003003  003510  // Syntax 	: gfx_Button4("state", "&ButtonRam", "&ButtonDef") ;
003004  003511  // Usage 	: gfx_Button4(state, ButtonRam, ButtonDef) ;
003005  003512  // Notes 	: Draw a Button as defined by ButtonDef (if required), using ButtonRam positioning at
003006  003513  // 	: position value. See the reference for the ButtonDef values
003007  003514  //
003008  003515        
003009  003516  #CONST
003010  003531  #END
003011  003532        
003012  003533  func gfx_Led("state", "&LedRam", "&LedDef"), 0;                           // draw an LED
003013  003534  // Syntax 	: gfx_Led("state", "&LedRam", "&LedDef") ;
003014  003535  // Usage 	: gfx_Led(state, LedRam, LedDef) ;
003015  003536  // Notes 	: Draw a Led as defined by LedDef (if required), using LedRam positioning in
003016  003537  // 	: state state. See the reference for the LedDef values
003017  003538  //
003018  003539        
003019  003540  #CONST
003020  003558  #END
003021  003559  #CONST
003022  003577  #END
003023  003578        
003024  003579  func gfx_Scale("&ScaleRam", "&ScaleDef"), 0;                           // draw a Scale
003025  003580  // Syntax 	: gfx_Scale("&ScaleRam", "&ScaleDef") ;
003026  003581  // Usage 	: gfx_Scale(ScaleRam, ScaleDef) ;
003027  003582  // Notes 	: Draw a Scale as defined by ScaleDef, setting LedRam for use in touch processing.
003028  003583  // 	: See the reference for the ScaleDef values. If touch processing is not required 0 may be used as the SclaleRam parameter.
003029  003584  //
003030  003585        
003031  003586  #CONST
003032  003590  #END
003033  003591        
003034  003592  #CONST
003035  003612  #END
003036  003613        
003037  003614  func gfx_RulerGauge("state", "&RulerGaugeRam", "&RulerGaugeDef"), 0;                           // draw a Ruler Gauge
003038  003615  // Syntax 	: gfx_Led("position", "&RulerGaugeRam", "&RulerGaugeDef") ;
003039  003616  // Usage 	: gfx_Led(position, RulerGaugeRam, RulerGaugeDef) ;
003040  003617  // Notes 	: Draw a RulerGauge as defined by RulerGaugeDef (if required), using RulerGaugeRam positioning at
003041  003618  // 	: position value. See the reference for the RulerGaugeDef values
003042  003619  //
003043  003620        
003044  003621  #CONST
003045  003631  #END
003046  003632        
003047  003633  func file_CheckUpdate("Filename", "Options"), 1;                           // check and/or update the program running in Flash
003048  003634  // Syntax 	: file_CheckUpdate("Filename", "Options") ;
003049  003635  // Usage 	: file_CheckUpdate("thisfile.4xe", CheckUpdate_Check) ;
003050  003636  // Notes 	: Check and/or update the program running in flash using the specified file on uSD.
003051  003637  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003052  003638  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003053  003639  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003054  003640  //
003055  003641  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003056  003642  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003057  003643  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003058  003644  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003059  003645  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003060  003646  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003061  003647        
003062  003648  func udiv_3232("res32", "val1", "val2"), 1;
003063  003649  // Syntax   : udiv_1616(res32, varA, varB);
003064  003650  // Input    : DWORD *result   points to 32bit result register.
003065  003651  //          : DWORD   val1  pointer to 32bit value (dividend)
003066  003652  //          : DWORD   val2  pointer to 32bit value (divisor)
003067  003653  // Usage    : var res32[2];
003068  003654  //          : umul_1616(res32, myvar, 50000);
003069  003655  // Notes    : performs an unsigned division of 2 x 32bit values
003070  003656  //          : placing the 32bit result in a 2 word array.
003071  003657  // Returns  : the pointer to the 32bit result.
003072  003658  //          : carry and overflow are not affected.
003073  003659        
003074  003660  func gfx_Gradient("style", "left", "top", "right", "bottom", "color1", "color2"), 0;
003075  003661  // Syntax  : gfx_Gradient(style, x1, y1, x2, y2, colr1, colr2);
003076  003662  // Usage   : gfx_Gradient(GRAD_WAVE_VER, 100, 100, 230, 120, BLACK, WHITE);
003077  003663  // Notes   : Draws a graduated colour rectangle at the specified co-ordinate.
003078  003664  //         : "style" specifies the drawing mode
003079  003665  //         :     GRAD_DOWN         // gradient changes in the vertical direction
003080  003666  //         :     GRAD_RIGHT        // gradient change in the horizontal direction
003081  003667  //         :     GRAD_UP           // gradient changes in the vertical direction
003082  003668  //         :     GRAD_LEFT         // gradient change in the horizontal direction
003083  003669  //         :     GRAD_WAVE_VER     // gradient wave in the vertical direction
003084  003670  //         :     GRAD_WAVE_HOR     // gradient wave in the horizontal direction
003085  003671  // Returns : nothing.
003086  003672        
003087  003673  func I2C2_Open("speed"), 1;
003088  003674  // Syntax : I2C2_Openx(speed),
003089  003675  // Usage  : I2C2_Open(I2C_MED);
003090  003676  // Notes : configures the I2C1 module
003091  003677  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003092  003678  // Returns: True if successful
003093  003679        
003094  003680        
003095  003681  func I2C3_Open("speed"), 1;
003096  003682  // Syntax : I2C3_Openx(speed),
003097  003683  // Usage  : I2C3_Open(I2C_MED);
003098  003684  // Notes : configures the I2C1 module
003099  003685  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
003100  003686  // Returns: True if successful
003101  003687        
003102  003688  func I2C2_Close(), 0;
003103  003689  // Usage : I2C2_Close();
003104  003690  // Notes : disables the I2C2 module.
003105  003691        
003106  003692  func I2C3_Close(), 0;
003107  003693  // Usage : I2C3_Close();
003108  003694  // Notes : disables the I2C3 module.
003109  003695        
003110  003696  func I2C2_Start(), 1;
003111  003697  // Syntax: I2C2_Start();
003112  003698  // Usage : I2C2_Start();
003113  003699  // Notes : generates a Start condition.
003114  003700  //       : returns true if successful (usually ignored)
003115  003701        
003116  003702  func I2C3_Start(), 1;
003117  003703  // Syntax: I2C3_Start();
003118  003704  // Usage : I2C3_Start();
003119  003705  // Notes : generates a Start condition.
003120  003706  //       : returns true if successful (usually ignored)
003121  003707        
003122  003708  func I2C2_Stop(), 1;
003123  003709  // Syntax: I2C2_Stop();
003124  003710  // Usage : I2C2_Stop();
003125  003711  // Notes : generates a Stop condition.
003126  003712  //       : returns true if successful (usually ignored)
003127  003713        
003128  003714  func I2C3_Stop(), 1;
003129  003715  // Syntax: I2C3_Stop();
003130  003716  // Usage : I2C3_Stop();
003131  003717  // Notes : generates a Stop condition.
003132  003718  //       : returns true if successful (usually ignored)
003133  003719        
003134  003720  func I2C2_Restart(), 1;
003135  003721  // Syntax: I2C2_Restart();
003136  003722  // Usage : I2C2_Restart();
003137  003723  // Notes : generates a Restart condition.
003138  003724  //       : returns true if successful (usually ignored)
003139  003725        
003140  003726  func I2C3_Restart(), 1;
003141  003727  // Syntax: I2C3_Restart();
003142  003728  // Usage : I2C3_Restart();
003143  003729  // Notes : generates a Restart condition.
003144  003730  //       : returns true if successful (usually ignored)
003145  003731        
003146  003732  func I2C2_Read(), 1;
003147  003733  // Syntax: I2C2_Read();
003148  003734  // Usage : ch := I2C2_Read();
003149  003735  // Notes : reads a single byte from the I2C Bus.
003150  003736        
003151  003737  func I2C3_Read(), 1;
003152  003738  // Syntax: I2C3_Read();
003153  003739  // Usage : ch := I2C3_Read();
003154  003740  // Notes : reads a single byte from the I2C Bus.
003155  003741        
003156  003742  func I2C2_Write("byte"), 1;
003157  003743  // Syntax: I2C2_Write(byte);
003158  003744  // Usage : r := I2C2_Write(ch);
003159  003745  // Notes : is used to write a byte to the I2C bus.
003160  003746  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003161  003747        
003162  003748  func I2C3_Write("byte"), 1;
003163  003749  // Syntax: I2C3_Write(byte);
003164  003750  // Usage : r := I2C3_Write(ch);
003165  003751  // Notes : is used to write a byte to the I2C bus.
003166  003752  //       : Returns 0 if failed, 1 if no ack, 2 if ack
003167  003753        
003168  003754  func I2C2_Ack(), 0;
003169  003755  // Syntax: I2C2_Ack();
003170  003756  // Usage : I2C2_Ack();
003171  003757  // Notes : generates the acknowledge condition.
003172  003758        
003173  003759  func I2C3_Ack(), 0;
003174  003760  // Syntax: I2C3_Ack();
003175  003761  // Usage : I2C3_Ack();
003176  003762  // Notes : generates the acknowledge condition.
003177  003763        
003178  003764  func I2C2_Nack(), 0;
003179  003765  // Syntax: I2C2_Nack();
003180  003766  // Usage : I2C2_Nack();
003181  003767  // Notes : generates the negative acknowledge condition.
003182  003768        
003183  003769  func I2C3_Nack(), 0;
003184  003770  // Syntax: I2C3_Nack();
003185  003771  // Usage : I2C3_Nack();
003186  003772  // Notes : generates the negative acknowledge condition.
003187  003773        
003188  003774  func I2C2_AckStatus(), 1;
003189  003775  // Syntax: I2C2_AckStatus();
003190  003776  // Usage : r := I2C2_AckStatus();
003191  003777  // Notes : returns the ACK status from the device.
003192  003778        
003193  003779  func I2C3_AckStatus(), 1;
003194  003780  // Syntax: I2C3_AckStatus();
003195  003781  // Usage : r := I2C3_AckStatus();
003196  003782  // Notes : returns the ACK status from the device.
003197  003783        
003198  003784  func I2C2_AckPoll("control"), 1;
003199  003785  // Syntax: I2C2_AckPoll();
003200  003786  // Usage : r := I2C2_AckPoll(0xA0);
003201  003787  // Notes : waits for a device to return from ACK polling.
003202  003788        
003203  003789  func I2C3_AckPoll("control"), 1;
003204  003790  // Syntax: I2C3_AckPoll();
003205  003791  // Usage : r := I2C3_AckPoll(0xA0);
003206  003792  // Notes : waits for a device to return from ACK polling.
003207  003793        
003208  003794  func I2C2_Idle(), 1;
003209  003795  // Syntax : I2C2_Idle();
003210  003796  // Usage  : r := I2C2_Idle();
003211  003797  // Notes  : waits until the I2C Bus is Inactive.
003212  003798  //        : Times out if bus not idle within 1 second
003213  003799  // Returns: TRUE if successful, else failed (timed out)
003214  003800        
003215  003801  func I2C3_Idle(), 1;
003216  003802  // Syntax : I2C3_Idle();
003217  003803  // Usage  : r := I2C3_Idle();
003218  003804  // Notes  : waits until the I2C Bus is Inactive.
003219  003805  //        : Times out if bus not idle within 1 second
003220  003806  // Returns: TRUE if successful, else failed (timed out)
003221  003807        
003222  003808  func I2C2_Gets("buffer", "size"), 1;
003223  003809  // Syntax: I2C2_Gets("buffer", "size");
003224  003810  // Usage : r := I2C2_Gets(mybuf, 16);
003225  003811  // Notes : only reads up to "size" characters into "buffer"
003226  003812  //       : Reads up to asciiz terminator including terminator
003227  003813        
003228  003814  func I2C3_Gets("buffer", "size"), 1;
003229  003815  // Syntax: I2C3_Gets("buffer", "size");
003230  003816  // Usage : r := I2C3_Gets(mybuf, 16);
003231  003817  // Notes : only reads up to "size" characters into "buffer"
003232  003818  //       : Reads up to asciiz terminator including terminator
003233  003819        
003234  003820  func I2C2_Getn("buffer", "size"), 1;
003235  003821  // Syntax: I2C2_Gets("buffer", "size");
003236  003822  // Usage : r := I2C2_Gets(mybuf, 16);
003237  003823  // Notes : reads "size" bytes into "buffer"
003238  003824  //       :
003239  003825        
003240  003826  func I2C3_Getn("buffer", "size"), 1;
003241  003827  // Syntax: I2C3_Gets("buffer", "size");
003242  003828  // Usage : r := I2C3_Gets(mybuf, 16);
003243  003829  // Notes : reads "size" bytes into "buffer"
003244  003830  //       :
003245  003831        
003246  003832  func I2C2_Puts("buffer"), 1;
003247  003833  // Syntax: I2C2_Puts("buffer");
003248  003834  // Usage : r := I2C2_Puts(mybuf);
003249  003835  // Notes : writes an asciiz string to the I2C device
003250  003836  //       : returns count of characters written
003251  003837        
003252  003838  func I2C3_Puts("buffer"), 1;
003253  003839  // Syntax: I2C3_Puts("buffer");
003254  003840  // Usage : r := I2C3_Puts(mybuf);
003255  003841  // Notes : writes an asciiz string to the I2C device
003256  003842  //       : returns count of characters written
003257  003843        
003258  003844  func I2C2_Putn("buffer", "count"), 1;
003259  003845  // Syntax: I2C2_Putn("buffer","count");
003260  003846  // Usage : r := I2C2_Puts(mybuf,10);
003261  003847  // Notes : writes up to "size" bytes to the I2C device
003262  003848  //       : returns number of bytes written
003263  003849        
003264  003850  func I2C3_Putn("buffer", "count"), 1;
003265  003851  // Syntax: I2C3_Putn("buffer","count");
003266  003852  // Usage : r := I2C3_Puts(mybuf,10);
003267  003853  // Notes : writes up to "size" bytes to the I2C device
003268  003854  //       : returns number of bytes written
003269  003855        
003270  003856  func gfx_XYrotToVal("x","y","base","mina","maxa","minv","maxv"), 1;         // convert a rotational x/y postion to a value
003271  003857  // Usage	: gfx_XYrotToVal(x,y,XYROT_EAST,starta,enda,minv,maxv)
003272  003858  // Notes	: Convert a rotational angle into a value
003273  003859  // 	: Calculates a position for a rotary input starting at mina and continuing to maxa. both angles must be greater than 0.
003274  003860  // 	: Base can be XYROT_EAST, used for internal widgets, or XYROT_SOUTH, used for GCI widgets.
003275  003861  // 	: Returns a value from minv to maxv
003276  003862        
003277  003863  func gfx_XYlinToVal("x","y","base","minpos","maxpos","minv","maxv"), 1;         // convert a linear x/y postion to a value
003278  003864  // Usage	: gfx_XYrotToVal(x,y,XYLIN_X,startp,endp,minv,maxv)
003279  003865  // Notes	: Convert a linear position into a value
003280  003866  // 	: Calculates a position for a linear input starting at minpos and continuing to maxpos. 
003281  003867  // 	: Base can be XYLIN_X, to use the x value for calculations, or XYLIN_Y, to use the y value.
003282  003868  // 	: Returns a value from minv to maxv
003283  003869        
003284  003870  func media_InitSpeed("Speed"), 1;                     // initialize uSD card at a given speed
003285  003871  // Usage	: media_Init(SPI_SPEED15);
003286  003872  // Notes	: Initialise uSD CARD at a specified speed
003287  003873  // 	: Response: 0 = No Card
003288  003874  // 	:           1 = Card Initialised
003289  003875  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003290  003876        
003291  003877  func file_MountSpeed("Speed"), 1;                     // mount a uSD card at a given speed
003292  003878  // Syntax	: r := file_Mount(SPI_SPEED15);
003293  003879  // Usage	: r := file_Mount(SPI_SPEED15);
003294  003880  // Notes	: Create a control block for FAT16 and mount the File System at the specified speed
003295  003881  // 	: speed can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003296  003882        
003297  003883  func img_FileRead("*dest", "size", "handle", "index"), 1;
003298  003884  // Syntax: res := img_FileRead("*dest", "size", "handle", "index"),
003299  003885  // Usage : res := img_FileRead(memblock,20,hnd1);
003300  003886  // Notes : returns number of characters read
003301  003887  //       : if "dest" is zero, data is read direct to GRAM window
003302  003888  //       :
003303  003889        
003304  003890  func img_FileSeek("handle", "index", "HiWord", "LoWord"), 1;
003305  003891  // Syntax: res := img_FileSeek("handle", "index", "HiWord", "LoWord")
003306  003892  // Usage : res := img_FileSeek(hSource, 0, 0x1234);
003307  003893  // Notes : set file position to 0x00001234 (byte position 4660)
003308  003894  //       : for the file handle so subsequent data may be read
003309  003895  //       : from that position onwards with img_FileGetC(...),
003310  003896  //       : img_FileGetW(...) or img_FileGetS(...)
003311  003897  // Notes : returns true if ok, usually ignored
003312  003898        
003313  003899  func img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003314  003900  // Syntax: img_FileIndex("handle", "index", "HiSize", "LoSize","recordnum"), 1;
003315  003901  // Usage : res := img_FileIndex(hsource, 0, 1000, 123), 1;
003316  003902  // Notes : set file seek position to 123000
003317  003903  //       : for the file handle so subsequent data may be read
003318  003904  //       : from that record position onwards with img_FileGetC(...),
003319  003905  //       : img_FileGetW(...) or img_FileGetS(...)
003320  003906  // Notes : returns true if ok, usually ignored
003321  003907        
003322  003908  func img_FileTell("handle", "index", "&HiWord", "&LoWord"), 1;
003323  003909  // Syntax: img_FileTell("handle", "index", &HiWord, &LoWord);
003324  003910  // Usage : img_FileTell(fhndl, &SizeHi, &SizeLo);
003325  003911  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
003326  003912  //       : returns true if function succeeded
003327  003913        
003328  003914  func img_FileSize("handle", "index", "&HiWord", "&LoWord"), 1;
003329  003915  // Syntax: img_FileSize("handle", "index", &HiWord, &LoWord);
003330  003916  // Usage : img_FileSize(fhndl, &SizeHi, &SizeLo);
003331  003917  // Notes : Reads the 32 bit file size and stores it into 2 variables.
003332  003918  //       : returns true if function succeeded
003333  003919        
003334  003920  func img_FileGetC("handle", "index"), 1;
003335  003921  // Syntax: img_FileGetC("handle", "index");
003336  003922  // Usage : mychar := fgetC("handle", "index");
003337  003923  // Notes : returns next char from file
003338  003924        
003339  003925  func img_FileGetW("handle", "index"), 1;
003340  003926  // Syntax: img_FileGetW("handle", "index");
003341  003927  // Usage : myword := fgetW("handle", "index");
003342  003928  // Notes : returns next word in file
003343  003929        
003344  003930  func img_FileGetS("*string", "size", "handle", "index"), 1;
003345  003931  // Syntax: res := img_FileGets("*string", "size", "handle", "index");
003346  003932  // Usage : res := img_FileGets(mystr , 81, hnd1); // read up to 80 chars
003347  003933  // Notes : get a string from a file
003348  003934  //       : returns pointer to string or null if failed.
003349  003935  //       : img_FileGetS(...) automatically appends a null-terminator to the data read.
003350  003936  //       : NB:- only reads up to "size-1" characters into "string"
003351  003937  //       : img_FileGetS(...) will stop reading when any of the following conditions are true:
003352  003938  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
003353  003939  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
003354  003940  //       : C] It reaches the end of file
003355  003941  //       : D] A read error occurs.
003356  003942        
003357  003943  func img_FileRewind("handle", "index"), 1;
003358  003944  // Syntax: res := img_FileRewind("handle", "index");
003359  003945  // Usage : res := img_FileRewind(hnd1);
003360  003946  // Notes : returns true if file rewound ok (usually ignored)
003361  003947  //       : resets the file pointer the the beginning of the open file.
003362  003948        
003363  003949  func img_FileLoadFunction("handle", "index"), 1;
003364  003950  // Syntax: res := img_FileLoadFunction("handle", "index");
003365  003951  // Usage : myfunc := img_FileLoadFunction("handle", "index");
003366  003952  // Notes : Load a function or program from disk and
003367  003953  //       : return a function pointer to the allocation.
003368  003954  //       : The function can then be invoked just like any other
003369  003955  //       : function would be called via a function pointer.
003370  003956  //       : Parameters may be passed to it in a conventional way.
003371  003957  //       : The function may be discarded at any time when no
003372  003958  //       : longer required, thus freeing its memory resources.
003373  003959  //       : The loaded function can be discarded with mem_Free(..)
003374  003960  //       : eg:
003375  003961  //       : popupWindow := img_FileLoadFunction("handle", "index");
003376  003962  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
003377  003963  //       : then elsewhere in your program:-
003378  003964  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
003379  003965  //       : if(res == QUIT_APPLICATION) goto exitApp;
003380  003966  //       : Later in your program, when popupWindow is no longer
003381  003967  //       : required for the application:-
003382  003968  //       : res := mem_Free(popupWindow);
003383  003969  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
003384  003970  //       : The callers stack is shared by the loaded function,
003385  003971  //       : however any global variables in the loaded function
003386  003972  //       : are private to that function.
003387  003973  //
003388  003974        
003389  003975  func img_FileRun("handle", "index", "arglistptr"), 1;
003390  003976  // Syntax: res := img_FileRun("handle", "index","arglistptr");
003391  003977  // Usage : res := img_FileRun("handle", "index", argptr);
003392  003978  // Notes : current program releases any allocated memory but
003393  003979  //       : retains the stack and global memory.
003394  003980  //       : If arglistptr is 0, no arguments are passed, else
003395  003981  //       : arglist points to an array, the first element being
003396  003982  //       : the number of elements in the array.
003397  003983  //       : func 'main' in the called program accepts
003398  003984  //       : the arguments, if any. THe arguments can only
003399  003985  //       : be passed by value, no pointers or references can be
003400  003986  //       : used as all memory is cleared before the file
003401  003987  //       : is loaded. Refer to img_FileExec and img_FileLoadFunction
003402  003988  //       : for functions that can pass by reference.
003403  003989        
003404  003990  func img_FileExec("handle", "index", "arglistptr"), 1;
003405  003991  // Syntax: res := img_FileExec("handle", "index","arglistptr");
003406  003992  // Usage : res := img_FileExec("handle", "index","arglistptr");
003407  003993  // Notes : returns like a function, current program
003408  003994  //       : calling program is kept active and control returns to it.
003409  003995  //       : If arglistptr is 0, no arguments are passed, else
003410  003996  //       : arglist points to an array, the first element being
003411  003997  //       : the number of elements in the array.
003412  003998  //       : func 'main' in the called program accepts the arguments.
003413  003999  //       : This function is similar to img_FileLoadFunction(...), however,
003414  004000  //       : the function argument list is passed by pointer, and
003415  004001  //       : the memory consumed by the function is released as
003416  004002  //       : soon as the function completes.
003417  004003        
003418  004004  func img_FilePlayWAV("handle", "index"), 1;
003419  004005  // Syntax: img_FilePlayWAV("handle", "index");
003420  004006  // Usage : img_FilePlayWAV("handle", "index");
003421  004007  // Notes : Play a wave file at index "index" in the filesystem "handle"
003422  004008  //       : This function automatically grabs a chunk
003423  004009  //       : of memory for a file buffer, and a wave
003424  004010  //       : buffer. The minimum memory requirement is
003425  004011  //       : about 580 bytes for the disk io service and
003426  004012  //       : a minimum wave buffer size of 1024. The siz
003427  004013  //       : of the wave buffer allocation
003428  004014  //       : can be increased by the snd_BufSize function.
003429  004015  //       : The default size 1024 bytes.
003430  004016  //       : NB the memory is only required during the
003431  004017  //       : duration of play, and is automatically
003432  004018  //       : released while not in use.
003433  004019  //       : See the Sound Class services for other associated controls.
003434  004020  //       : If there are no errors, returns number of blocks to play (1 to 32767)
003435  004021  //       : If errors occured, the folling is returned
003436  004022  //       : -7  : Insufficient memory available for WAV buffer and file
003437  004023  //       : -6  : cant play this rate
003438  004024  //       : -5  : no data chunk found in first rsector
003439  004025  //       : -4  : no format data
003440  004026  //       : -3  : no wave chunk signature
003441  004027  //       : -2  : bad wave file format
003442  004028  //       : -1  : file not found
003443  004029        
003444  004030  func img_TxtFontID("handle", "index"), 1;                   // 2  text font ID (0 = system font)
003445  004031  // Syntax: img_TxtFontID("handle", "index");
003446  004032  // Usage : img_TxtFontID("handle", "index");
003447  004033  // Notes : Set the font to a font held in the image file system
003448  004034        
003449  004035  func img_FileCheckUpdate("handle", "index", "Options"), 1;                           // check and/or update the program running in Flash
003450  004036  // Syntax 	: img_FileCheckUpdate("handle", "index", "Options") ;
003451  004037  // Usage 	: img_FileCheckUpdate("handle", "index", CheckUpdate_Check) ;
003452  004038  // Notes 	: Check and/or update the program running in flash using the specified file in Flash memory.
003453  004039  // 	: CHECKUPDATE_QUERY	: Checks the specified file and compares its DateTime to the program running in Flash.
003454  004040  // 	: CHECKUPDATE_UPDATENEWER	: Updates the program in Flash and resets the display if the program on uSD is newer.
003455  004041  // 	: CHECKUPDATE_UPDATEALWAYS	: Always updates the program in Flash and resets the display.
003456  004042  //
003457  004043  // Returns : nothing, if update occurs and the program is running from Flash, as display is reset after update.
003458  004044  // 	: CHECKUPDATE_NOFILE	: The specified file does not exist, or uSD not initialised.
003459  004045  // 	: CHECKUPDATE_NEWFILE	: The specified file is newer than the file running in Flash.
003460  004046  // 	: CHECKUPDATE_OLDFILE	: The specified file is equal to or older than the file running in Flash.
003461  004047  // 	: CHECKUPDATE_INVALIDFILE	: The specified file is not a valid .4xe or .4fn
003462  004048  // 	: CHECKUPDATE_UPDATEDONE	: An update was performed and the program is running from RAM
003463  004049        
003464  004050  func flash_Block32Erase(), 1;            // erase the required 32k flash block
003465  004051  // Syntax	: flash_Block32Erase();
003466  004052  // Usage	: flash_Block32Erase();
003467  004053  // Notes	: Erase the 32KB flash block including the currently set address
003468  004054  // 	: This uses the 0x52 command.
003469  004055        
003470  004056  func flash_Sector4Erase(), 1;            // erase the required 4k flash sector
003471  004057  // Syntax: flash_Sector4Erase();
003472  004058  // Usage : flash_Sector4Erase();
003473  004059  // Notes	: Erase the 4KB flash sector including the currently set address
003474  004060  // 	: This uses the 0x20 command.
003475  004061        
003476  004062  func com_Mode("8" ,"N", "1", "comport"), 1 ;
003477  004063  // Syntax	: comx_Mode("databits", "parity", "Stopbits", "comport");
003478  004064  // Usage	: comx_Mode(8, 'N', 1, COM0);                        // set COM0 to 8N1
003479  004065  // *Notes	: Data Bits must be 8
003480  004066  // 	: Parity may be 'N', 'O' or 'E'.
003481  004067  // 	: Stop Bits may be 1 or 2.
003482  004068  // 	: returns true if mode was acceptable
003483  004069        
003484  004070  func img_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in a Flash GCI
003485  004071  // Syntax: img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003486  004072  // Usage : img_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003487  004073  // Notes	: Load and call the Function found at index "idx" in the Flash GCI identified by "Hndl". 
003488  004074  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003489  004075  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003490  004076  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003491  004077  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003492  004078  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003493  004079  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003494  004080  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003495  004081  // 	: Returns 0 if successful.
003496  004082        
003497  004083  func img_FunctionFreeCache("handle"), 0 ;                                 // Free all cached Flash GCI Functions 
003498  004084  // Syntax: img_FunctionFreeCache(hndl);
003499  004085  // Usage : img_FunctionFreeCache(hndl);
003500  004086  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003501  004087  // 	: Flash GCI.
003502  004088        
003503  004089  func crc_CSUM_8("buf","count"), 1;                      // given a pointer to a buffer and a byte count, calculate the 8bit LRC
003504  004090  // *Notes   : (if you calculate all of the incoming data
003505  004091  //          : INCLUDING the CRC, the result should be 0x00
003506  004092  //          : This is equivalent to simple addition of all bytes
003507  004093  //          : and returning the negated sum an 8 bit value.
003508  004094  //          : For the standard test string "123456789",
003509  004095  //          : crc_CSUM_8 will return 0x0023.
003510  004096        
003511  004097  func gfx_GradientShape("GradientRAM", "HorzVert", "OuterWidth", "X", "Y", "W", "H", "TLrad", "TRrad", "BLrad", "BRrad", "Darken", "OuterColor", "OuterType", "OuterLevel", "InnerColor", "InnerType", "InnerLevel", "Split"), 0 ;
003512  004098  // Syntax 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003513  004099  // Usage 	: gfx_GradientShape(GradientRAM, HorzVert, OuterWidth, X, Y, W, H, TLrad, TRrad, BLrad, BRrad, Darken, OuterColor, OuterType, OuterLevel, InnerColor, InnerType, InnerLevel, Split) ;
003514  004100  // Notes 	: Produce a shaped color gradient using the supplied parameters.0
003515  004101  // 	: GradientRAM	This Function requires a quantity or RAM to work. It also needs to be initialised and it's size varies accoring to the largest corner radius. Multiple gradient shape calls can
003516  004102  // 	: 	share the same GradientRAM. eg gradientRAM[29+91*2] := [-1,-1,-9999,0,0,91] ;  Would support a maximum radius of 90 degrees, note the 91 in two places.
003517  004103  // 	: HorzVert	Horizontal or Vertical -- 0 or 1
003518  004104  // 	: OuterWidth	Outer gradient width 0 to ...
003519  004105  // 	: X	x co-ordinate
003520  004106  // 	: Y	y co-ordinate
003521  004107  // 	: W	width
003522  004108  // 	: H	height
003523  004109  // 	: LTrad	Top left corner radius
003524  004110  // 	: TRrad	Top right corner radius
003525  004111  // 	: BLrad	Bottom left radius
003526  004112  // 	: BRrad	Bottom right radius
003527  004113  // 	: Darken	Darken both colours by a value. Can be a -ve value to lighten
003528  004114  // 	: OuterCol	Outer Gradient colour
003529  004115  // 	: OuterType	Outer Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003530  004116  // 	: OuterLevel	Outer Gradient level 0 - 63
003531  004117  // 	: InnerCol	Inner Gradient colour
003532  004118  // 	: InnerType	Inner Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003533  004119  // 	: InnerLevel	Inner Gradient level 0 - 63
003534  004120  // 	: Split	Split gradient, 0 - no split, 1 - top, 2 - bottom 
003535  004121  // 
003536  004122  // Returns	: nothing
003537  004123        
003538  004124        
003539  004125  func gfx_GradientColor("Type", "Darken", "Level", "H", "Pos", "Color"), 1 ;
003540  004126  // Syntax 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003541  004127  // Usage 	: gfx_GradientColor(Type, Darken, Level, H, Pos, Color)
003542  004128  // Notes 	: Given the parameters, adjust the input color to produce the output color.
003543  004129  // 	: Type	Gradient type (0 - 3 horizontal, +4 vertical) 0 - Raised, 1 - Sunken, 2 - Raised flatter middle, 3 - Sunken flatter middle
003544  004130  // 	: Darken	Darken colour by a value. Can be a -ve value to lighten
003545  004131  // 	: Level	Gradient level 0 - 63
003546  004132  // 	: H	Height of the object that gradient is applied
003547  004133  // 	: Pos	Position in the height that gradient is calculated
003548  004134  // 	: Color	Source colour that gradient is applied to
003549  004135  // 
003550  004136  // Returns	: Color after Adjustment.
003551  004137        
003552  004138  func gfx_GradTriangleFilled("X0", "Y0", "X1", "Y1", "X2", "Y2", "SolidCol", "GradientCol", "GradientHeight", "GradientY", "GradientLevel", "Type"), 0;
003553  004139  // Syntax 	: gfx_GradTriangleFilled(X0, Y0, X1, Y1, X2, Y2, SolidCol, GradientCol, GradientHeight, GradientY, GradientLevel, Type);
003554  004140  // Usage 	: gfx_GradTriangleFilled(10, 10, 10, 100, 100, 100 ,YELLOW, DARKKHAKI, 100, 10, 30, 1);
003555  004141  // Notes 	: Produce a triangle with or without a gradient.
003556  004142  // 	: X0	First triangle point x coordinate
003557  004143  // 	: Y0	First triangle point y coordinate
003558  004144  // 	: X1	Second triangle point x coordinate
003559  004145  // 	: Y1	Second triangle point y coordinate
003560  004146  // 	: X2	Third triangle point x coordinate
003561  004147  // 	: Y2	Third triangle point y coordinate
003562  004148  // 	: SolidCol	Colour that will be used if the Solid or Gradient parameter is set to 0
003563  004149  // 	: GradientCol	Colour that will be used if the Solid or Gradient parameter is set to 1
003564  004150  // 	: GradientHeight	Height of the area that the gradient will be calculated. Can be larger than the triangle
003565  004151  // 	: GradientY	Position on the Y axis that the gradient will be calculated from with respect to triangle position
003566  004152  // 	: GradientLevel	Level of gradient applied
003567  004153  // 	: Type	Select wether solid triangle or gardient triangle is drawn. 
003568  004154        
003569  004155  func media_InitFlash("Command"), 1;                    // initialize Flash Memory
003570  004156  // Usage	: media_InitFlash();
003571  004157  // Notes	: Initialise Flash Memory 
003572  004158  // 	: Response: 0 = Normally ignored, but should be 0
003573  004159  // 	:           1 = a uSD Card has been Initialised, you should not use this command for uSD cards
003574  004160  // 	: Note that for systems with SPI Flash the response will be 0, however, this function needs to be called to 
003575  004161  // 	: init the Flash memory chip.
003576  004162  // 	: Command	The command used to set the flash memory into 4 byte addressing mode
003577  004163  // 	: FLASH_ADDR_DEF_COMMAND	The default command will be used (0xB7)
003578  004164  // 	: FLASH_ADDR_ALWAYS_4BYTE	No command will be sent (for chips permantly in 4 byte mode)
003579  004165  // 	: else this command will be sent to enter 4 Byte Addressing mode, if the capacity of the chip appears to
003580  004166  // 	: be greater than 16MB. Requires the JEDEC approved response to the 'FLASH READ ID' (0x9F) command.
003581  004167        
003582  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003583  004168  #constant media_Init4 media_InitFlash	    // media_Init4 deprecated
003584  004169        
003585  004170  func file_RunSpeed("Speed", "fname.4xe", "arglistptr"), 1;
003586  004171  // Syntax	: res := file_Run(SPI_SPEED15, "fname.4xe","arglistptr");
003587  004172  // Usage	: res := file_Run(SPI_SPEED15, fname, argptr);
003588  004173  // Notes	: current program releases any allocated memory but
003589  004174  // 	: retains the stack and global memory.
003590  004175  // 	: If arglistptr is 0, no arguments are passed, else
003591  004176  // 	: arglist points to an array, the first element being
003592  004177  // 	: the number of elements in the array.
003593  004178  // 	: func 'main' in the called program accepts
003594  004179  // 	: the arguments, if any. The arguments can only
003595  004180  // 	: be passed by value, no pointers or references can be
003596  004181  // 	: used as all memory is cleared before the file
003597  004182  // 	: is loaded. Refer to file_Exec and file_LoadFunction
003598  004183  // 	: for functions that can pass by reference.
003599  004184  // 	: Speed specifies the File System is mounted at the specified speed
003600  004185  // 	: can be from SPI_SPEED0 (slowest) to SPI_SPEED15 (fastest)
003601  004186        
003602  004187  func I2CS_Open("Addr", "RdBuf", "RdBufSize", "WrBuf", "WrBufSize", "WaitOption"), 0;  // Open I2C Slave
003603  004188  // Usage	: I2CS_Open(Addr, RdBuf, RdBufS, WrBuf, WrBufs, 0xaa);
003604  004189  // Notes	: Initialize and open the I2C Slave 
003605  004190  // 	: The slave ACKs any transmissions from the master until the read buffer fills
003606  004191  // 	: The slave NAKs any receives by the master until the write buffer is released, or is empty
003607  004192  // 	: Addr	The I2C Address for this Slave
003608  004193  // 	: RdBuf	The buffer for receiving 'commands' from the master
003609  004194  // 	: RdBufSize	The size of the receive buffer 
003610  004195  // 	: WrBuf	The buffer for sending 'responses' to the master
003611  004196  // 	: WrBufSize	The size of the write buffer
003612  004197  // 	: WaitOption	The character to send when no data is available, or all sent, or with I2C_CLOCK_STRETCHING to use clock stretching 
003613  004198  // 	: Response: None
003614  004199        
003615  004200  func I2CS_Close(), 0;          // Close I2C Slave
003616  004201  // Usage	: I2CS_Close();
003617  004202  // Notes	: Closes the I2C Slave 
003618  004203  // 	: Response: None
003619  004204        
003620  004205  func I2CS_Write("Byte"), 0;      // Write byte to output buffer
003621  004206  // Usage	: I2CS_Write("Byte");
003622  004207  // Notes	: Writes a byte to the I2C Slave Write Buffer
003623  004208  // 	: When everything to be written to the Master is in the write buffer, the buffer should be released
003624  004209  // 	: with I2CS_Release()
003625  004210  // 	: Response: None
003626  004211        
003627  004212  func I2CS_Count(), 1;          // Count of bytes in input buffer
003628  004213  // Usage	: I2CS_Count();
003629  004214  // Notes	: Retrieve the number of bytes available in the I2C Slave's read buffer
003630  004215  // 	: Response: Number of bytes in the buffer
003631  004216        
003632  004217  func I2CS_Read(), 1;           // Read byte from Read Buffer
003633  004218  // Usage	: I2CS_Read();
003634  004219  // Notes	: Read a byte from the I2C Slave's read buffer
003635  004220  // 	: Response: byte read from buffer
003636  004221        
003637  004222  func I2CS_Release(), 0;        // Release output buffer to enable Master to read
003638  004223  // Usage	: I2CS_Release();
003639  004224  // Notes	: Release an accumulated I2C Slave write buffer for sending to the master
003640  004225  // 	: Response: None
003641  004226        
003642  004227  func I2CS_Overflow(), 1;        // Check for any overflow in the read or write processes
003643  004228  // Usage	: I2CS_Overflow();
003644  004229  // Notes	: Check for any overflow in the read or write processes, the error is automatically
003645  004230  // 	: Reset at the start of the next I2CS_Write() or the last I2CS_Read() for the current buffer.
003646  004231  // 	: Response: Overflow flags
003647  004232  // 	: 0x01 : The host has sent more data than the I2CS_Read() buffer can hold
003648  004233  // 	: 0x02 : The host has read all the data the I2CS_Write() buffer contained
003649  004234  // 	: 0x04 : The host has read more data than the I2CS_Write() buffer contained
003650  004235        
003651  004236  func com_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003652  004237  // Usage	: com_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003653  004238  // Usage	: com_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003654  004239  // Notes	: initialize a serial buffer for the COM0 output.
003655  004240  // 	: The program must declare a var array as a circular buffer.
003656  004241  // 	: When a TX buffer is declared for comms, the transmission
003657  004242  // 	: of characters becomes non blocking. If the buffer has
003658  004243  // 	: insufficient space to accept the next character from a
003659  004244  // 	: serout_x() function, the excess characters will be ignored,
003660  004245  // 	: and the com_Full_x() error will be asserted.   If the
003661  004246  // 	: TX buffer is no longer required, just set the buffer pointer
003662  004247  // 	: to zero, the size in this case doesnt matter and is ignored.
003663  004248  // 	: The function can resize or reallocated to another buffer at
003664  004249  // 	: any time. The buffer is flushed before any changes are made.
003665  004250  // 	: "pin" designates an IO pin to control a bi-directional
003666  004251  // 	: control device for half duplex mode. "pin" will go HI at the
003667  004252  // 	: start of a transmission, and will return low after the final
003668  004253  // 	: byte is transmitted. If not required, just set "pin" to zero.
003669  004254        
003670  004255  func com_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003671  004256  // Syntax	: com_InitBrk(buffer, bufsize, qualifier);
003672  004257  // Usage1	: com_InitBrk(mybuf, 20, 0);
003673  004258  // Usage2	: com_InitBrk(mybuf, 20, ':');
003674  004259  // Notes	: initialize a serial capture buffer for the comms input
003675  004260  // 	: The program must declare a var array as a circular buffer.
003676  004261  // 	: Usage1 declares a circular buffer which will continually
003677  004262  // 	: buffer characters.
003678  004263  // 	: Usage2 must receive ':' before any characters will
003679  004264  // 	: accumulate in the buffer.
003680  004265        
003681  004266  //------------------------------------------------------------------//
003682  004267  //     break control constant                                       //
003683  004268  //------------------------------------------------------------------//
003684  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003685  004269  #constant BREAK      0xFFFD    // interpretation of the break signal
003686  004270        
003687  004271  func disp_Refresh(), 0;  // Refresh an ePaper display
003688  004272  // Syntax	: disp_Refresh();
003689  004273  // Usage	: disp_Refresh();
003690  004274  // Notes	: This command is only applicable to ePaper displays.
003691  004275  // 	: Refresh an ePaper display
003692  004276  // 	: After updating the RAM in an ePaper display thuis commmand is used
003693  004277  // 	: to place the contents of the RAM onto the ePaper.
003694  004278        
003695  004279  func disp_Busy(), 1;  // Check the busy status of an ePaper display
003696  004280  // Syntax	: disp_Busy();
003697  004281  // Usage	: disp_Busy();
003698  004282  // Notes	: This command is only applicable to ePaper displays.
003699  004283  // 	: Return the busy status of an ePaper display
003700  004284  // 
003701  004285  // Returns	: 1 if the display is busy, 0 otherwise
003702  004286        
003703  004287  //=========================================================================================================
003704  004288  // Internal FLASH memory functions
003705  004289  //=========================================================================================================
003706  004290  func intflash_GetByte("ptr"), 1;
003707  004291  // Syntax   : intflash_GetByte(ptr);
003708  004292  // Usage    : myvar := intflash_GetByte(1); // read the first byte from internal flash
003709  004293  // Notes    : Reads a single byte from internal flash.
003710  004294  // Returns  : the byte value from the location
003711  004295        
003712  004296        
003713  004297  func intflash_GetWord("ptr"), 1;
003714  004298  // Syntax   : intflash_GetWord(ptr);
003715  004299  // Usage    : myvar := intflash_GetWord(0x0000); // read first word from internal flash
003716  004300  // Notes    : Reads a single word from any internal flash location.
003717  004301  //          : The pointer is byte aligned.
003718  004302  // Returns  : the byte value from the location
003719  004303        
003720  004304        
003721  004305  func intflash_Copy("ptr", "dest", "count"), 1;
003722  004306  // Syntax   : intflash_Copy(ptr, dest, count);
003723  004307  // Usage    : myvar := intflash_Copy(0x123, mybuf, 20); // read 20 bytes from internal flash starting from 0x123
003724  004308  // Notes    : Copies bytes from any internal flash locations to a user buffer.
003725  004309  //          : The destination pointer is byte aligned, so a str_Ptr must be raised to get correct address.
003726  004310  // Returns  : the count of bytes transferred.
003727  004311        
003728  004312  func intflash_WriteBlock("sourceptr", "Size"), 1;
003729  004313  // Syntax   : intflash_WriteBlock(pbuf);
003730  004314  // Usage    : result := intflash_WriteBlock(buffer); // store the 2k buffer 
003731  004315  // Notes    : Copies a buffer to NVM. Size bytes are written. A maximum of 2048 bytes can be written.
003732  004316  // Returns  : returns true if the function succeeded.
003733  004317        
003734  004318  func intflash_FunctionCall("handle", "index", "state", "&FunctionRam", "&FunctionDef", "FunctionArgCount", "FunctionArgStringMap"), 1;                  // Call a function in internal flash
003735  004319  // Syntax: intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003736  004320  // Usage : intflash_FunctionCall(hndl, idx, state, FncRam, FncDef, FncArgCnt, FncStrMap);
003737  004321  // Notes	: Load and call the Function found at index "idx" in the internal flash widget identified by "Hndl". 
003738  004322  // 	: Parameters "State", "&FunctionRam", "&FunctionDef", "&FunctionDef" are passed. The first two parameters are passed
003739  004323  // 	: "as is", since the third parameter is normally in flash and one programs flash is not accessible from another
003740  004324  // 	: "FunctionArgCount" constants are copied into a RAM array and passed to the Function. "FunctionStringMap" is a bit array
003741  004325  // 	: of the indexes containing single and multiple strings offset by 8. eg 0x0100 means parameter 8 is a single string, 0x0002 means
003742  004326  // 	: paramter 9 is an array of strings with parameter 8 containing the count.
003743  004327  // 	: Any Function called this way is loaded into RAM and left there. RAM is managed using an LRU mechanism and
003744  004328  // 	: the least recently used entry is freed if there is not enough Heap to load the desired function.
003745  004329  // 	: Returns 0 if successful.
003746  004330        
003747  004331  func intflash_FunctionFreeCache("handle"), 0 ;                                 // Free all cached internal Flash Functions 
003748  004332  // Syntax: img_FunctionFreeCache(hndl);
003749  004333  // Usage : img_FunctionFreeCache(hndl);
003750  004334  // Notes	: Frees any RAM allocated to caching of functions located in the specified
003751  004335  // 	: widget handle.
003752  004336        
003753  004337  func com1_TXbufferBrk("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
003754  004338  // Usage	: com1_TXbufferBrk(mybuf, 1024, IO3_PIN);    // set the TX buffer, using IO3_PIN for turnaround
003755  004339  // Usage	: com1_TXbufferBrk(0, 0, 0);             // revert to non buffered service
003756  004340  // Notes	: initialize a serial buffer for the COM1 output.
003757  004341  // 	: The program must declare a var array as a circular buffer.
003758  004342  // 	: When a TX buffer is declared for comms, the transmission
003759  004343  // 	: of characters becomes non blocking. If the buffer has
003760  004344  // 	: insufficient space to accept the next character from a
003761  004345  // 	: serout_x() function, the excess characters will be ignored,
003762  004346  // 	: and the com_Full_x() error will be asserted.   If the
003763  004347  // 	: TX buffer is no longer required, just set the buffer pointer
003764  004348  // 	: to zero, the size in this case doesnt matter and is ignored.
003765  004349  // 	: The function can resize or reallocated to another buffer at
003766  004350  // 	: any time. The buffer is flushed before any changes are made.
003767  004351  // 	: "pin" designates an IO pin to control a bi-directional
003768  004352  // 	: control device for half duplex mode. "pin" will go HI at the
003769  004353  // 	: start of a transmission, and will return low after the final
003770  004354  // 	: byte is transmitted. If not required, just set "pin" to zero.
003771  004355        
003772  004356  func com1_InitBrk("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
003773  004357  // Syntax	: com1_InitBrk(buffer, bufsize, qualifier);
003774  004358  // Usage1	: com1_InitBrk(mybuf, 20, 0);
003775  004359  // Usage2	: com1_InitBrk(mybuf, 20, ':');
003776  004360  // Notes	: initialize a serial capture buffer for the comms input
003777  004361  // 	: The program must declare a var array as a circular buffer.
003778  004362  // 	: Usage1 declares a circular buffer which will continually
003779  004363  // 	: buffer characters.
003780  004364  // 	: Usage2 must receive ':' before any characters will
003781  004365  // 	: accumulate in the buffer.
003782  004366        
003783  004367  //------------------------------------------------------------------//
003784  004368  // CONSTANTS
003785  004369  //------------------------------------------------------------------//
003786  004370        
003787  004371  #CONST
003788  004500  #END
003789  004501        
003790  004502  // generic constants
003791  004503  #CONST
003792  004514  #END
003793  004515        
003794  004516  // other constants
003795  004517  #CONST
003796  004520  #END
003797  004521        
003798  004522  //------------------------------------------------------------------------------
003799  004523  // Pin related constants
003800  004524  //------------------------------------------------------------------------------
003801  004525  #CONST
003802  004547  #END
003803  004548        
003804  004549  //------------------------------------------------------------------------------
003805  004550  //gfx_Set() related constants
003806  004551  //------------------------------------------------------------------------------
003807  004552  #CONST
003808  004569  #END
003809  004570        
003810  004571        
003811  004572  //gfx_Get() related constants
003812  004573  #CONST
003813  004582  #END
003814  004583        
003815  004584        
003816  004585        
003817  004586        
003818  004587  #CONST
003819  004600  #END
003820  004601        
003821  004602        
003822  004603  #CONST
003823  004625  #END
003824  004626        
003825  004627  //------------------------------------------------------------------------------
003826  004628  //txt_Set() related constants
003827  004629  //------------------------------------------------------------------------------
003828  004630  #CONST
003829  004649  #END
003830  004650        
003831  004651        
003832  004652        
003833  004653  //------------------------------------------------------------------------------
003834  004654  //txt_Set() related arguments
003835  004655  // NB:- FONT4 must be inherited if required,
003836  004656  // eg #inherit "FONT4.fnt"
003837  004657  //------------------------------------------------------------------------------
003838  004658  #CONST
003839  004670  #END
003840  004671        
003841  004672        
003842  004673        
003843  004674  //touch_Set() related constants
003844  004675  #CONST
003845  004679  #END
003846  004680        
003847  004681  //touch_Get() related constants
003848  004682  #CONST
003849  004690  #END
003850  004691        
003851  004692  // image control offset related constants
003852  004693  #CONST
003853  004700  #END
003854  004701        
003855  004702  // image attribute flags
003856  004703  // for img_SetAttributes(...) and img_ClearAttributes(...)
003857  004704  #CONST
003858  004718  #END
003859  004719        
003860  004720        
003861  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003862  004721  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
003863  004722        
003864  004723  // image control entry offsets
003865  004724  #CONST
003866  004739  #END
003867  004740        
003868  004741  #CONST
003869  004759  #END
003870  004760        
003871  004761        
003872  004762        
003873  004763        
003874  004764  #CONST
003875  004784  #END
003876  004785        
003877  004786        
003878  004787        
003879  004788  // timer control  related constants
003880  004789  #CONST
003881  004798  #END
003882  004799        
003883  004800  // I2C timing related constants
003884  004801  #CONST
003885  004805  #END
003886  004806        
003887  004807        
003888  004808  // spi_Init(...)  mode arguments
003889  004809  #CONST
003890  004832  #END
003891  004833        
003892  004834  //------------------------------------------------------------------------------
003893  004835  // system WORD variables accesible with peekW and pokeW or pointer access
003894  004836  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
003895  004837  // can also be accessed with peekW and pokeW
003896  004838  //------------------------------------------------------------------------------
003897  004839        
003898  004840  #CONST
003899  004934  #END
003900  004935        
003901  004936  //------------------------------------------------------------------------------
003902  004937  // FILEIO Error Code Constants
003903  004938  //------------------------------------------------------------------------------
003904  004939  #CONST
003905  004965  #END
003906  004966        
003907  004967  //==================================================================================================
003908  004968        
003909  004969        
003910  004970        
003911  000013      #ENDIF
003912  000014        
003913  000015        
003914  000016  //===========================================================================================
003915  000017        
003916  000018        
003917  000002        
003918  000003  //#constant OLDCOMPILE
003919  000004        
003920  000005        
003921  000006        
003922  000007        
003923  000008        
003924  000009  // generated 3/7/2023 5:26:36 PM
003925  000010  // uSDRequired:- 1   InternalRequired:- 1   InherentsInProgFlash:- 0   GciFlashFS:- 1   InherentWidgets:- 0   InternalObjects:- 14   GciFlashFiles:- 1
003926  000011        
003927  000012        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

003928  000013  #inherit "4DGL_16bitColours.fnc"
003929  000013  #inherit "4DGL_16bitColours.fnc"
003930  000004  */
003931  000005        
003932  000006        
003933  000007        
003934  000008  #CONST
003935  000149  #END
003936  000150        
003937  000014        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

003938  000015  #inherit "VisualConst.inc"
003939  000015  #inherit "VisualConst.inc"
003940  000001  // Line Patterns
003941  000002  #constant  LPCOARSE    0xF0F0
003942  000002  #constant  LPCOARSE    0xF0F0
003943  000003  #constant  LPMEDIUM    0x3333
003944  000003  #constant  LPMEDIUM    0x3333
003945  000004  #constant  LPFINE      0xAAAA
003946  000004  #constant  LPFINE      0xAAAA
003947  000005  #constant  LPDASHDOT   0x03CF
003948  000005  #constant  LPDASHDOT   0x03CF
003949  000006  #constant  LPDASHDOTDOT 0x0333
003950  000006  #constant  LPDASHDOTDOT 0x0333
003951  000007  #constant  LPSOLID     0x0000
003952  000007  #constant  LPSOLID     0x0000
003953  000016        
003954  000017        
file C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGaugeConst.inc

003955  000018  #inherit "SprinterGaugeConst.inc"
003956  000018  #inherit "SprinterGaugeConst.inc"
003957  000001  // File generated 3/7/2023 5:26:31 PM
003958  000002  // Warning! This is a generated file, any manual changes will be
003959  000003  // lost during the next generation.
003960  000004        
003961  000005  #constant  Strings2Count    1
003962  000005  #constant  Strings2Count    1
003963  000006  #constant  Strings2Size     17
003964  000006  #constant  Strings2Size     17
003965  000007  #constant  Strings0Count    1
003966  000007  #constant  Strings0Count    1
003967  000008  #constant  Strings0Size     22
003968  000008  #constant  Strings0Size     22
003969  000009  #constant  Strings4Count    1
003970  000009  #constant  Strings4Count    1
003971  000010  #constant  Strings4Size     6
003972  000010  #constant  Strings4Size     6
003973  000011  #constant  Strings5Count    1
003974  000011  #constant  Strings5Count    1
003975  000012  #constant  Strings5Size     6
003976  000012  #constant  Strings5Size     6
003977  000013  #constant  Strings7Count    1
003978  000013  #constant  Strings7Count    1
003979  000014  #constant  Strings7Size     14
003980  000014  #constant  Strings7Size     14
003981  000015  #constant  Strings9Count    1
003982  000015  #constant  Strings9Count    1
003983  000016  #constant  Strings9Size     7
003984  000016  #constant  Strings9Size     7
003985  000017  #constant  Strings10Count    1
003986  000017  #constant  Strings10Count    1
003987  000018  #constant  Strings10Size     6
003988  000018  #constant  Strings10Size     6
003989  000019  #constant  Strings11Count    1
003990  000019  #constant  Strings11Count    1
003991  000020  #constant  Strings11Size     15
003992  000020  #constant  Strings11Size     15
003993  000021  #constant  Strings12Count    1
003994  000021  #constant  Strings12Count    1
003995  000022  #constant  Strings12Size     17
003996  000022  #constant  Strings12Size     17
003997  000023  #constant  Strings15Count    1
003998  000023  #constant  Strings15Count    1
003999  000024  #constant  Strings15Size     13
004000  000024  #constant  Strings15Size     13
004001  000025  #constant  Strings16Count    1
004002  000025  #constant  Strings16Count    1
004003  000026  #constant  Strings16Size     13
004004  000026  #constant  Strings16Size     13
004005  000027  #constant  Strings18Count    1
004006  000027  #constant  Strings18Count    1
004007  000028  #constant  Strings18Size     5
004008  000028  #constant  Strings18Size     5
004009  000029  #constant  Strings19Count    1
004010  000029  #constant  Strings19Count    1
004011  000030  #constant  Strings19Size     5
004012  000030  #constant  Strings19Size     5
004013  000031  #constant  Strings20Count    1
004014  000031  #constant  Strings20Count    1
004015  000032  #constant  Strings20Size     5
004016  000032  #constant  Strings20Size     5
004017  000033  #constant  Strings21Count    1
004018  000033  #constant  Strings21Count    1
004019  000034  #constant  Strings21Size     7
004020  000034  #constant  Strings21Size     7
004021  000035  #constant  Strings22Count    1
004022  000035  #constant  Strings22Count    1
004023  000036  #constant  Strings22Size     13
004024  000036  #constant  Strings22Size     13
004025  000037  #constant  Strings23Count    1
004026  000037  #constant  Strings23Count    1
004027  000038  #constant  Strings23Size     7
004028  000038  #constant  Strings23Size     7
004029  000039  #constant  Strings24Count    1
004030  000039  #constant  Strings24Count    1
004031  000040  #constant  Strings24Size     12
004032  000040  #constant  Strings24Size     12
004033  000041  #constant  Strings13Count    1
004034  000041  #constant  Strings13Count    1
004035  000042  #constant  Strings13Size     7
004036  000042  #constant  Strings13Size     7
004037  000043  #constant  Strings14Count    1
004038  000043  #constant  Strings14Count    1
004039  000044  #constant  Strings14Size     16
004040  000044  #constant  Strings14Size     16
004041  000045  #constant  Strings25Count    1
004042  000045  #constant  Strings25Count    1
004043  000046  #constant  Strings25Size     7
004044  000046  #constant  Strings25Size     7
004045  000047  #constant  Strings26Count    1
004046  000047  #constant  Strings26Count    1
004047  000048  #constant  Strings26Size     17
004048  000048  #constant  Strings26Size     17
004049  000049  #constant  Strings17Count    1
004050  000049  #constant  Strings17Count    1
004051  000050  #constant  Strings17Size     5
004052  000050  #constant  Strings17Size     5
004053  000051  #constant  Strings3Count    1
004054  000051  #constant  Strings3Count    1
004055  000052  #constant  Strings3Size     5
004056  000052  #constant  Strings3Size     5
004057  000053  #constant  Strings6Count    1
004058  000053  #constant  Strings6Count    1
004059  000054  #constant  Strings6Size     12
004060  000054  #constant  Strings6Size     12
004061  000055  #constant  Strings27Count    1
004062  000055  #constant  Strings27Count    1
004063  000056  #constant  Strings27Size     3
004064  000056  #constant  Strings27Size     3
004065  000057  #constant  Strings28Count    1
004066  000057  #constant  Strings28Count    1
004067  000058  #constant  Strings28Size     10
004068  000058  #constant  Strings28Size     10
004069  000059  #constant  Strings8Count    1
004070  000059  #constant  Strings8Count    1
004071  000060  #constant  Strings8Size     13
004072  000060  #constant  Strings8Size     13
004073  000061  #constant  Strings29Count    1
004074  000061  #constant  Strings29Count    1
004075  000062  #constant  Strings29Size     5
004076  000062  #constant  Strings29Size     5
004077  000063  #constant  Strings30Count    1
004078  000063  #constant  Strings30Count    1
004079  000064  #constant  Strings30Size     5
004080  000064  #constant  Strings30Size     5
004081  000065  #constant  Strings31Count    1
004082  000065  #constant  Strings31Count    1
004083  000066  #constant  Strings31Size     13
004084  000066  #constant  Strings31Size     13
004085  000067  #constant  Strings1Count    1
004086  000067  #constant  Strings1Count    1
004087  000068  #constant  Strings1Size     12
004088  000068  #constant  Strings1Size     12
004089  000069  #constant  Strings32Count    1
004090  000069  #constant  Strings32Count    1
004091  000070  #constant  Strings32Size     7
004092  000070  #constant  Strings32Size     7
004093  000071  #constant  Strings33Count    1
004094  000071  #constant  Strings33Count    1
004095  000072  #constant  Strings33Size     13
004096  000072  #constant  Strings33Size     13
004097  000073  #constant  Strings34Count    0
004098  000073  #constant  Strings34Count    0
004099  000074  #constant  Strings34Size     1
004100  000074  #constant  Strings34Size     1
004101  000075  #constant  Strings35Count    1
004102  000075  #constant  Strings35Count    1
004103  000076  #constant  Strings35Size     17
004104  000076  #constant  Strings35Size     17
004105  000077  #constant  Strings36Count    0
004106  000077  #constant  Strings36Count    0
004107  000078  #constant  Strings36Size     1
004108  000078  #constant  Strings36Size     1
004109  000079  #constant  IFONT_OFFSET     37
004110  000079  #constant  IFONT_OFFSET     37
004111  000080  // object indexes into WIDGET pointer
004112  000081  #CONST
004113  000096  #END
004114  000097        
004115  000098  // object indexes into ImageControl
004116  000099  #CONST
004117  000139  #END
004118  000140        
004119  000141        
004120  000142  #constant  Strings2StartH   0x0
004121  000142  #constant  Strings2StartH   0x0
004122  000143  #constant  Strings2StartL   0x0
004123  000143  #constant  Strings2StartL   0x0
004124  000144  #constant  Strings0StartH   0x0
004125  000144  #constant  Strings0StartH   0x0
004126  000145  #constant  Strings0StartL   0x200
004127  000145  #constant  Strings0StartL   0x200
004128  000146  #constant  Strings4StartH   0x0
004129  000146  #constant  Strings4StartH   0x0
004130  000147  #constant  Strings4StartL   0x400
004131  000147  #constant  Strings4StartL   0x400
004132  000148  #constant  Strings5StartH   0x0
004133  000148  #constant  Strings5StartH   0x0
004134  000149  #constant  Strings5StartL   0x600
004135  000149  #constant  Strings5StartL   0x600
004136  000150  #constant  Strings7StartH   0x0
004137  000150  #constant  Strings7StartH   0x0
004138  000151  #constant  Strings7StartL   0x800
004139  000151  #constant  Strings7StartL   0x800
004140  000152  #constant  Strings9StartH   0x0
004141  000152  #constant  Strings9StartH   0x0
004142  000153  #constant  Strings9StartL   0xA00
004143  000153  #constant  Strings9StartL   0xA00
004144  000154  #constant  Strings10StartH   0x0
004145  000154  #constant  Strings10StartH   0x0
004146  000155  #constant  Strings10StartL   0xC00
004147  000155  #constant  Strings10StartL   0xC00
004148  000156  #constant  Strings11StartH   0x0
004149  000156  #constant  Strings11StartH   0x0
004150  000157  #constant  Strings11StartL   0xE00
004151  000157  #constant  Strings11StartL   0xE00
004152  000158  #constant  Strings12StartH   0x0
004153  000158  #constant  Strings12StartH   0x0
004154  000159  #constant  Strings12StartL   0x1000
004155  000159  #constant  Strings12StartL   0x1000
004156  000160  #constant  Strings15StartH   0x0
004157  000160  #constant  Strings15StartH   0x0
004158  000161  #constant  Strings15StartL   0x1200
004159  000161  #constant  Strings15StartL   0x1200
004160  000162  #constant  Strings16StartH   0x0
004161  000162  #constant  Strings16StartH   0x0
004162  000163  #constant  Strings16StartL   0x1400
004163  000163  #constant  Strings16StartL   0x1400
004164  000164  #constant  Strings18StartH   0x0
004165  000164  #constant  Strings18StartH   0x0
004166  000165  #constant  Strings18StartL   0x1600
004167  000165  #constant  Strings18StartL   0x1600
004168  000166  #constant  Strings19StartH   0x0
004169  000166  #constant  Strings19StartH   0x0
004170  000167  #constant  Strings19StartL   0x1800
004171  000167  #constant  Strings19StartL   0x1800
004172  000168  #constant  Strings20StartH   0x0
004173  000168  #constant  Strings20StartH   0x0
004174  000169  #constant  Strings20StartL   0x1A00
004175  000169  #constant  Strings20StartL   0x1A00
004176  000170  #constant  Strings21StartH   0x0
004177  000170  #constant  Strings21StartH   0x0
004178  000171  #constant  Strings21StartL   0x1C00
004179  000171  #constant  Strings21StartL   0x1C00
004180  000172  #constant  Strings22StartH   0x0
004181  000172  #constant  Strings22StartH   0x0
004182  000173  #constant  Strings22StartL   0x1E00
004183  000173  #constant  Strings22StartL   0x1E00
004184  000174  #constant  Strings23StartH   0x0
004185  000174  #constant  Strings23StartH   0x0
004186  000175  #constant  Strings23StartL   0x2000
004187  000175  #constant  Strings23StartL   0x2000
004188  000176  #constant  Strings24StartH   0x0
004189  000176  #constant  Strings24StartH   0x0
004190  000177  #constant  Strings24StartL   0x2200
004191  000177  #constant  Strings24StartL   0x2200
004192  000178  #constant  Strings13StartH   0x0
004193  000178  #constant  Strings13StartH   0x0
004194  000179  #constant  Strings13StartL   0x2400
004195  000179  #constant  Strings13StartL   0x2400
004196  000180  #constant  Strings14StartH   0x0
004197  000180  #constant  Strings14StartH   0x0
004198  000181  #constant  Strings14StartL   0x2600
004199  000181  #constant  Strings14StartL   0x2600
004200  000182  #constant  Strings25StartH   0x0
004201  000182  #constant  Strings25StartH   0x0
004202  000183  #constant  Strings25StartL   0x2800
004203  000183  #constant  Strings25StartL   0x2800
004204  000184  #constant  Strings26StartH   0x0
004205  000184  #constant  Strings26StartH   0x0
004206  000185  #constant  Strings26StartL   0x2A00
004207  000185  #constant  Strings26StartL   0x2A00
004208  000186  #constant  Strings17StartH   0x0
004209  000186  #constant  Strings17StartH   0x0
004210  000187  #constant  Strings17StartL   0x2C00
004211  000187  #constant  Strings17StartL   0x2C00
004212  000188  #constant  Strings3StartH   0x0
004213  000188  #constant  Strings3StartH   0x0
004214  000189  #constant  Strings3StartL   0x2E00
004215  000189  #constant  Strings3StartL   0x2E00
004216  000190  #constant  Strings6StartH   0x0
004217  000190  #constant  Strings6StartH   0x0
004218  000191  #constant  Strings6StartL   0x3000
004219  000191  #constant  Strings6StartL   0x3000
004220  000192  #constant  Strings27StartH   0x0
004221  000192  #constant  Strings27StartH   0x0
004222  000193  #constant  Strings27StartL   0x3200
004223  000193  #constant  Strings27StartL   0x3200
004224  000194  #constant  Strings28StartH   0x0
004225  000194  #constant  Strings28StartH   0x0
004226  000195  #constant  Strings28StartL   0x3400
004227  000195  #constant  Strings28StartL   0x3400
004228  000196  #constant  Strings8StartH   0x0
004229  000196  #constant  Strings8StartH   0x0
004230  000197  #constant  Strings8StartL   0x3600
004231  000197  #constant  Strings8StartL   0x3600
004232  000198  #constant  Strings29StartH   0x0
004233  000198  #constant  Strings29StartH   0x0
004234  000199  #constant  Strings29StartL   0x3800
004235  000199  #constant  Strings29StartL   0x3800
004236  000200  #constant  Strings30StartH   0x0
004237  000200  #constant  Strings30StartH   0x0
004238  000201  #constant  Strings30StartL   0x3A00
004239  000201  #constant  Strings30StartL   0x3A00
004240  000202  #constant  Strings31StartH   0x0
004241  000202  #constant  Strings31StartH   0x0
004242  000203  #constant  Strings31StartL   0x3C00
004243  000203  #constant  Strings31StartL   0x3C00
004244  000204  #constant  Strings1StartH   0x0
004245  000204  #constant  Strings1StartH   0x0
004246  000205  #constant  Strings1StartL   0x3E00
004247  000205  #constant  Strings1StartL   0x3E00
004248  000206  #constant  Strings32StartH   0x0
004249  000206  #constant  Strings32StartH   0x0
004250  000207  #constant  Strings32StartL   0x4000
004251  000207  #constant  Strings32StartL   0x4000
004252  000208  #constant  Strings33StartH   0x0
004253  000208  #constant  Strings33StartH   0x0
004254  000209  #constant  Strings33StartL   0x4200
004255  000209  #constant  Strings33StartL   0x4200
004256  000210  #constant  Strings34StartH   0x0
004257  000210  #constant  Strings34StartH   0x0
004258  000211  #constant  Strings34StartL   0x4400
004259  000211  #constant  Strings34StartL   0x4400
004260  000212  #constant  Strings35StartH   0x0
004261  000212  #constant  Strings35StartH   0x0
004262  000213  #constant  Strings35StartL   0x4600
004263  000213  #constant  Strings35StartL   0x4600
004264  000214  #constant  Strings36StartH   0x0
004265  000214  #constant  Strings36StartH   0x0
004266  000215  #constant  Strings36StartL   0x4800
004267  000215  #constant  Strings36StartL   0x4800
004268  000216        
004269  000217  #constant  ffsEndUnits4k    0x0075  // First unused 4k Sector on Flash
004270  000217  #constant  ffsEndUnits4k    0x0075  // First unused 4k Sector on Flash
004271  000218  #constant  ffsEnd4kH        0x0007  // Address of first unused 4k Sector on Flash, High
004272  000218  #constant  ffsEnd4kH        0x0007  // Address of first unused 4k Sector on Flash, High
004273  000219  #constant  ffsEnd4kL        0x5000  // Address of first unused 4k Sector on Flash, Low
004274  000219  #constant  ffsEnd4kL        0x5000  // Address of first unused 4k Sector on Flash, Low
004275  000220  #constant  ffsEndUnits32k   0x000F  // First unused 32k Block on Flash
004276  000220  #constant  ffsEndUnits32k   0x000F  // First unused 32k Block on Flash
004277  000221  #constant  ffsEnd32kH       0x0007  // Address of first unused 32k Block on Flash, High
004278  000221  #constant  ffsEnd32kH       0x0007  // Address of first unused 32k Block on Flash, High
004279  000222  #constant  ffsEnd32kL       0x8000  // Address of first unused 32k Block on Flash, Low
004280  000222  #constant  ffsEnd32kL       0x8000  // Address of first unused 32k Block on Flash, Low
004281  000223  #constant  ffsEndUnits64k   0x0008  // First unused 64k Block on Flash
004282  000223  #constant  ffsEndUnits64k   0x0008  // First unused 64k Block on Flash
004283  000224  #constant  ffsEnd64kH       0x0008  // Address of first unused 64k Block on Flash, High
004284  000224  #constant  ffsEnd64kH       0x0008  // Address of first unused 64k Block on Flash, High
004285  000225  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
004286  000225  #constant  ffsEnd64kL       0x0000  // Address of first unused 64k Block on Flash, Low
004287  000226        
004288  000227  #IFNOT EXISTS NOGLOBALS
004289  000228  var hndl ;
004290  000229  #ENDIF
004291  000019        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\CLPrintStringsGciFS.inc

004292  000020  #inherit "CLPrintStringsGciFS.inc"
004293  000020  #inherit "CLPrintStringsGciFS.inc"
004294  000001  func PrintStrings(var ID, var *msgid, var String)
004295  000002      var StringID, i, ch, offs32[2], res32[2] ;
004296  000003      StringID := oStringss[1+ID] ;
004297  000004      if (String)
004298  000005          stringsCV[ID] := -1 ;
004299  000006      else
004300  000007          stringsCV[ID] := msgid ;
004301  000008      endif
004302  000009      if ((StringID == -1) || (*(StringID + Ofs_String_Form) != CurrentForm)) return ;
004303  000010      i := *(StringID + Ofs_String_GciFSFontIdx) ;
004304  000011      if (i < 0)
004305  000012  //to(COM0) ; print("CLP Font Flash ", -1-i, "\n") ;
004306  000013          img_TxtFontID(0xffff, -1-i) ;
004307  000014      else
004308  000015  //to(COM0) ; print("CLP Font Internal ", i, "\n") ;
004309  000016          txt_FontID(i) ;
004310  000017      endif
004311  000018      txt_Attributes(*(StringID + Ofs_String_FontAttribs)) ; // >> 4 fix for r25,6,7,8 PmmC
004312  000019  //    txt_Opacity(*(StringID + STTransparent)) ;
004313  000020        
004314  000021      if (*(StringID + Ofs_String_Transparent))
004315  000022          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), *(StringID + Ofs_String_BGColor));
004316  000023      else if (FormBGcolors[CurrentForm] != ColorBGimage)
004317  000024          gfx_RectangleFilled(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2), FormBGcolors[CurrentForm]);
004318  000025      else
004319  000026          gfx_ClipWindow(*(StringID + Ofs_String_x1), *(StringID + Ofs_String_y1), *(StringID + Ofs_String_x2), *(StringID + Ofs_String_y2)) ;
004320  000027          gfx_Clipping(ON) ;
004321  000028          img_Show(hndl,FormStartIndex[CurrentForm]) ;
004322  000029          gfx_Clipping(OFF) ;
004323  000030        
004324  000031      endif
004325  000032        
004326  000033      txt_FGcolour(*(StringID + Ofs_String_FGColor)) ;
004327  000034      txt_BGcolour(*(StringID + Ofs_String_BGColor)) ;
004328  000035      txt_Opacity(TRANSPARENT);                // 8  text OPAQUE or TRANSPARENT
004329  000036        
004330  000037      gfx_MoveTo(*(StringID + Ofs_String_x1) , *(StringID + Ofs_String_y1)) ;
004331  000038        
004332  000039      if (String)
004333  000040          i := 0 ;
004334  000041          ch := msgid[i++] ;
004335  000042          while (ch != 0)
004336  000043              putch(ch) ;
004337  000044              ch := msgid[i++] ;
004338  000045          wend
004339  000046      else
004340  000047          umul_1616(offs32, *(StringID + Ofs_String_Size), msgid);
004341  000048          res32[1] := *(StringID + Ofs_String_StartH) ;
004342  000049          res32[0] := *(StringID + Ofs_String_StartL) ;
004343  000050          uadd_3232(res32,res32,offs32) ;
004344  000051          img_FileSeek(hndl, iTextStrings, res32[1], res32[0]);
004345  000052          repeat
004346  000053              if (*(StringID + Ofs_String_Ansi))
004347  000054                  ch := img_FileGetC(hndl, iTextStrings) ;
004348  000055              else
004349  000056                  ch := img_FileGetW(hndl, iTextStrings) ;
004350  000057              endif
004351  000058              putch(ch) ;
004352  000059          until (ch == 0) ;
004353  000060      endif
004354  000061        
004355  000062  endfunc
004356  000063        
004357  000021        
004358  000022  #constant IPDatasize 22
004359  000022  #constant IPDatasize 22
004360  000023        
004361  000024  #CONST
004362  000028  #END
004363  000029        
004364  000030        
004365  000031        
004366  000032  #CONST
004367  000175  #END
004368  000176        
004369  000308  #END
4370  0BF8
4371  0BF9
4372  0BFA
4373  0BFB
4374  0BFC
4375  0BFD
4376  0BFE
4377  0BFF
4378  0C00
4379  0C01
4380  0C02
4381  0C03
4382  0C04
4383  0C05
4384  0C06
4385  0C07
4386  0C08
4387  0C09
4388  0C0A
4389  0C0B
4390  0C0C
4391  0C0D
4392  0C0E
4393  0C0F
4394  0C10
4395  0C11
4396  0C12
4397  0C13
4398  0C14
4399  0C15
4400  0C16
4401  0C17
4402  0C18
4403  0C19
4404  0C1A
4405  0C1B
4406  0C1C
4407  0C1D
4408  0C1E
4409  0C1F
4410  0C20
4411  0C21
4412  0C22
4413  0C23
4414  0C24
4415  0C25
4416  0C26
4417  0C27
4418  0C28
4419  0C29
4420  0C2A
4421  0C2B
4422  0C2C
4423  0C2D
4424  0C2E
4425  0C2F
4426  0C30
4427  0C31
4428  0C32
4429  0C33
4430  0C34
4431  0C35
4432  0C36
4433  0C37
4434  0C38
4435  0C39
4436  0C3A
4437  0C3B
4438  0C3C
4439  0C3D
4440  0C3E
4441  0C3F
4442  0C40
4443  0C41
4444  0C42
4445  0C43
4446  0C44
4447  0C45
4448  0C46
4449  0C47
4450  0C48
4451  0C49
4452  0C4A
4453  0C4B
4454  0C4C
4455  0C4D
4456  0C4E
4457  0C4F
4458  0C50
4459  0C51
4460  0C52
4461  0C53
4462  0C54
4463  0C55
4464  0C56
4465  0C57
4466  0C58
4467  0C59
4468  0C5A
4469  0C5B
4470  0C5C
4471  0C5D
4472  0C5E
4473  0C5F
4474  0C60
4475  0C61
4476  0C62
4477  0C63
4478  0C64
4479  0C65
4480  0C66
4481  0C67
4482  0C68
4483  0C69
4484  0C6A
4485  0C6B
4486  0C6C
4487  0C6D
4488  0C6E
4489  0C6F
4490  0C70
4491  0C71
4492  0C72
4493  0C73
4494  0C74
4495  0C75
4496  0C76
4497  0C77
4498  0C78
4499  0C79
4500  0C7A
4501  0C7B
4502  0C7C
4503  0C7D
4504  0C7E
4505  0C7F
4506  0C80
4507  0C81
4508  0C82
4509  0C83
4510  0C84
4511  0C85
4512  0C86
4513  0C87
4514  0C88
4515  0C89
4516  0C8A
4517  0C8B
4518  0C8C
4519  0C8D
4520  0C8E
4521  0C8F
4522  0C90
4523  0C91
4524  0C92
4525  0C93
4526  0C94
4527  0C95
4528  0C96
4529  0C97
4530  0C98
4531  0C99
4532  0C9A
4533  0C9B
4534  0C9C
4535  0C9D
4536  0C9E
4537  0C9F
4538  0CA0
4539  0CA1
4540  0CA2
4541  0CA3
4542  0CA4
4543  0CA5
4544  0CA6
4545  0CA7
4546  0CA8
4547  0CA9
4548  0CAA
4549  0CAB
4550  0CAC
4551  0CAD
4552  0CAE
4553  0CAF
4554  0CB0
4555  0CB1
4556  0CB2
4557  0CB3
4558  0CB4
4559  0CB5
4560  0CB6
4561  0CB7
4562  0CB8
4563  0CB9
4564  0CBA
4565  0CBB
4566  0CBC
4567  0CBD
4568  0CBE
4569  0CBF
4570  0CC0
4571  0CC1
4572  0CC2
4573  0CC3
4574  0CC4
4575  0CC5
4576  0CC6
4577  0CC7
4578  0CC8
4579  0CC9
4580  0CCA
4581  0CCB
4582  0CCC
4583  0CCD
4584  0CCE
4585  0CCF
4586  0CD0
4587  0CD1
4588  0CD2
4589  0CD3
4590  0CD4
4591  0CD5
4592  0CD6
4593  0CD7
4594  0CD8
4595  0CD9
4596  0CDA
4597  0CDB
4598  0CDC
4599  0CDD
4600  0CDE
4601  0CDF
4602  0CE0
4603  0CE1
4604  0CE2
4605  0CE3
4606  0CE4
4607  0CE5
4608  0CE6
4609  0CE7
4610  0CE8
4611  0CE9
4612  0CEA
4613  0CEB
4614  0CEC
4615  0CED
4616  0CEE
4617  0CEF
4618  0CF0
4619  0CF1
4620  0CF2
4621  0CF3
4622  0CF4
4623  0CF5
4624  0CF6
4625  0CF7
4626  0CF8
4627  0CF9
4628  0CFA
4629  0CFB
4630  0CFC
4631  0CFD
4632  0CFE
4633  0CFF
4634  0D00
4635  0D01
4636  0D02
4637  0D03
4638  0D04
4639  0D05
4640  0D06
4641  0D07
4642  0D08
4643  0D09
4644  0D0A
4645  0D0B
4646  0D0C
4647  0D0D
4648  0D0E
4649  0D0F
4650  0D10
4651  0D11
4652  0D12
4653  0D13
4654  0D14
4655  0D15
4656  0D16
4657  0D17
4658  0D18
4659  0D19
4660  0D1A
4661  0D1B
4662  0D1C
4663  0D1D
4664  0D1E
4665  0D1F
4666  0D20
4667  0D21
4668  0D22
4669  0D23
4670  0D24
4671  0D25
4672  0D26
4673  0D27
4674  0D28
4675  0D29
4676  0D2A
4677  0D2B
4678  0D2C
4679  0D2D
4680  0D2E
4681  0D2F
4682  0D30
4683  0D31
4684  0D32
4685  0D33
4686  0D34
4687  0D35
4688  0D36
4689  0D37
4690  0D38
4691  0D39
4692  0D3A
4693  0D3B
4694  0D3C
4695  0D3D
4696  0D3E
4697  0D3F
4698  0D40
4699  0D41
4700  0D42
4701  0D43
4702  0D44
4703  0D45
4704  0D46
4705  0D47
4706  0D48
4707  0D49
4708  0D4A
4709  0D4B
4710  0D4C
4711  0D4D
4712  0D4E
4713  0D4F
4714  0D50
4715  0D51
4716  0D52
4717  0D53
4718  0D54
4719  0D55
4720  0D56
4721  0D57
4722  0D58
4723  0D59
4724  0D5A
4725  0D5B
4726  0D5C
4727  0D5D
4728  0D5E
4729  0D5F
4730  0D60
4731  0D61
4732  0D62
4733  0D63
4734  0D64
4735  0D65
4736  0D66
4737  0D67
4738  0D68
4739  0D69
4740  0D6A
4741  0D6B
4742  0D6C
4743  0D6D
4744  0D6E
4745  0D6F
4746  0D70
4747  0D71
4748  0D72
4749  0D73
4750  0D74
4751  0D75
4752  0D76
4753  0D77
4754  0D78
4755  0D79
4756  0D7A
4757  0D7B
4758  0D7C
4759  0D7D
4760  0D7E
4761  0D7F
4762  0D80
4763  0D81
4764  0D82
4765  0D83
4766  0D84
4767  0D85
4768  0D86
4769  0D87
4770  0D88
4771  0D89
4772  0D8A
4773  0D8B
4774  0D8C
4775  0D8D
4776  0D8E
4777  0D8F
4778  0D90
4779  0D91
4780  0D92
4781  0D93
4782  0D94
4783  0D95
4784  0D96
4785  0D97
4786  0D98
4787  0D99
4788  0D9A
4789  0D9B
4790  0D9C
4791  0D9D
4792  0D9E
4793  0D9F
4794  0DA0
4795  0DA1
4796  0DA2
4797  0DA3
4798  0DA4
4799  0DA5
4800  0DA6
4801  0DA7
4802  0DA8
4803  0DA9
4804  0DAA
4805  0DAB
4806  0DAC
4807  0DAD
4808  0DAE
4809  0DAF
4810  0DB0
4811  0DB1
4812  0DB2
4813  0DB3
4814  0DB4
4815  0DB5
4816  0DB6
4817  0DB7
4818  0DB8
4819  0DB9
4820  0DBA
4821  0DBB
4822  0DBC
4823  0DBD
4824  0DBE
4825  0DBF
4826  0DC0
4827  0DC1
4828  0DC2
4829  0DC3
4830  0DC4
4831  0DC5
4832  0DC6
4833  0DC7
4834  0DC8
4835  0DC9
4836  0DCA
4837  0DCB
4838  0DCC
4839  0DCD
4840  0DCE
4841  0DCF
4842  0DD0
4843  0DD1
4844  0DD2
4845  0DD3
4846  0DD4
4847  0DD5
4848  0DD6
4849  0DD7
4850  0DD8
4851  0DD9
4852  0DDA
4853  0DDB
4854  0DDC
4855  0DDD
4856  0DDE
4857  0DDF
4858  0DE0
4859  0DE1
4860  0DE2
4861  0DE3
4862  0DE4
4863  0DE5
4864  0DE6
4865  0DE7
4866  0DE8
4867  0DE9
4868  0DEA
4869  0DEB
4870  0DEC
4871  0DED
4872  0DEE
4873  0DEF
4874  0DF0
4875  0DF1
4876  0DF2
4877  0DF3
4878  0DF4
4879  0DF5
4880  0DF6
4881  0DF7
4882  0DF8
4883  0DF9
4884  0DFA
4885  0DFB
4886  0DFC
4887  0DFD
4888  0DFE
4889  0DFF
4890  0E00
4891  0E01
4892  0E02
4893  0E03
4894  0E04
4895  0E05
4896  0E06
4897  0E07
4898  0E08
4899  0E09
4900  0E0A
4901  0E0B
4902  0E0C
4903  0E0D
4904  0E0E
4905  0E0F
4906  0E10
4907  0E11
4908  0E12
4909  0E13
4910  0E14
4911  0E15
4912  0E16
4913  0E17
4914  0E18
4915  0E19
4916  0E1A
4917  0E1B
4918  0E1C
4919  0E1D
4920  0E1E
4921  0E1F
4922  0E20
4923  0E21
4924  0E22
4925  0E23
4926  0E24
4927  0E25
4928  0E26
4929  0E27
4930  0E28
4931  0E29
4932  0E2A
4933  0E2B
4934  0E2C
4935  0E2D
4936  0E2E
4937  0E2F
4938  0E30
4939  0E31
4940  0E32
4941  0E33
4942  0E34
4943  0E35
4944  0E36
4945  0E37
4946  0E38
4947  0E39
4948  0E3A
4949  0E3B
4950  0E3C
4951  0E3D
4952  0E3E
4953  0E3F
4954  0E40
4955  0E41
4956  0E42
4957  0E43
4958  0E44
4959  0E45
4960  0E46
4961  0E47
4962  0E48
4963  0E49
4964  0E4A
4965  0E4B
4966  0E4C
4967  0E4D
4968  0E4E
4969  0E4F
4970  0E50
4971  0E51
4972  0E52
4973  0E53
4974  0E54
4975  0E55
4976  0E56
4977  0E57
4978  0E58
4979  0E59
4980  0E5A
4981  0E5B
4982  0E5C
4983  0E5D
4984  0E5E
4985  0E5F
4986  0E60
4987  0E61
4988  0E62
4989  0E63
4990  0E64
4991  0E65
4992  0E66
4993  0E67
4994  0E68
4995  0E69
4996  0E6A
4997  0E6B
4998  0E6C
4999  0E6D
5000  0E6E
5001  0E6F
5002  0E70
5003  0E71
5004  0E72
5005  0E73
5006  0E74
5007  0E75
5008  0E76
5009  0E77
5010  0E78
5011  0E79
5012  0E7A
5013  0E7B
5014  0E7C
5015  0E7D
5016  0E7E
5017  0E7F
5018  0E80
5019  0E81
5020  0E82
5021  0E83
5022  0E84
5023  0E85
5024  0E86
5025  0E87
5026  0E88
5027  0E89
5028  0E8A
5029  0E8B
5030  0E8C
5031  0E8D
5032  0E8E
5033  0E8F
5034  0E90
5035  0E91
5036  0E92
5037  0E93
5038  0E94
5039  0E95
5040  0E96
5041  0E97
5042  0E98
5043  0E99
5044  0E9A
5045  0E9B
5046  0E9C
5047  0E9D
5048  0E9E
5049  0E9F
5050  0EA0
5051  0EA1
5052  0EA2
5053  0EA3
5054  0EA4
5055  0EA5
5056  0EA6
5057  0EA7
5058  0EA8
5059  0EA9
5060  0EAA
5061  0EAB
5062  0EAC
5063  0EAD
5064  0EAE
5065  0EAF
5066  0EB0
5067  0EB1
5068  0EB2
5069  0EB3
5070  0EB4
5071  0EB5
5072  0EB6
5073  0EB7
5074  0EB8
5075  0EB9
5076  0EBA
5077  0EBB
5078  0EBC
5079  0EBD
5080  0EBE
5081  0EBF
5082  0EC0
5083  0EC1
5084  0EC2
5085  0EC3
5086  0EC4
5087  0EC5
5088  0EC6
5089  0EC7
5090  0EC8
5091  0EC9
5092  0ECA
5093  0ECB
5094  0ECC
5095  0ECD
5096  0ECE
5097  0ECF
5098  0ED0
5099  0ED1
5100  0ED2
5101  0ED3
5102  0ED4
5103  0ED5
5104  0ED6
5105  0ED7
5106  0ED8
5107  0ED9
5108  0EDA
5109  0EDB
5110  0EDC
5111  0EDD
5112  0EDE
5113  0EDF
5114  0EE0
5115  0EE1
5116  0EE2
5117  0EE3
5118  0EE4
5119  0EE5
5120  0EE6
5121  0EE7
5122  0EE8
5123  0EE9
5124  0EEA
5125  0EEB
5126  0EEC
5127  0EED
5128  0EEE
5129  0EEF
5130  0EF0
5131  0EF1
5132  0EF2
5133  0EF3
5134  0EF4
5135  0EF5
5136  0EF6
5137  0EF7
5138  0EF8
5139  0EF9
5140  0EFA
5141  0EFB
5142  0EFC
5143  0EFD
5144  0EFE
5145  0EFF
5146  0F00
5147  0F01
5148  0F02
5149  0F03
5150  0F04
5151  0F05
5152  0F06
5153  0F07
5154  0F08
5155  0F09
5156  0F0A
5157  0F0B
5158  0F0C
5159  0F0D
5160  0F0E
5161  0F0F
5162  0F10
5163  0F11
5164  0F12
5165  0F13
5166  0F14
5167  0F15
5168  0F16
5169  0F17
5170  0F18
5171  0F19
5172  0F1A
5173  0F1B
5174  0F1C
5175  0F1D
5176  0F1E
5177  0F1F
5178  0F20
5179  0F21
5180  0F22
5181  0F23
5182  0F24
5183  0F25
5184  0F26
5185  0F27
5186  0F28
5187  0F29
5188  0F2A
5189  0F2B
5190  0F2C
5191  0F2D
5192  0F2E
5193  0F2F
5194  0F30
5195  0F31
5196  0F32
5197  0F33
5198  0F34
5199  0F35
5200  0F36
5201  0F37
5202  0F38
5203  0F39
5204  0F3A
5205  0F3B
5206  0F3C
5207  0F3D
5208  0F3E
5209  0F3F
5210  0F40
5211  0F41
5212  0F42
5213  0F43
5214  0F44
5215  0F45
5216  0F46
5217  0F47
5218  0F48
5219  0F49
5220  0F4A
5221  0F4B
5222  0F4C
5223  0F4D
5224  0F4E
5225  0F4F
5226  0F50
5227  0F51
5228  0F52
5229  0F53
5230  0F54
5231  0F55
5232  0F56
5233  0F57
5234  0F58
5235  0F59
5236  0F5A
5237  0F5B
5238  0F5C
5239  0F5D
5240  0F5E
5241  0F5F
5242  0F60
5243  0F61
5244  0F62
5245  0F63
5246  0F64
5247  0F65
5248  0F66
5249  0F67
5250  0F68
5251  0F69
5252  0F6A
5253  0F6B
5254  0F6C
5255  0F6D
5256  0F6E
5257  0F6F
5258  0F70
5259  0F71
5260  0F72
5261  0F73
5262  0F74
5263  0F75
5264  0F76
5265  0F77
5266  0F78
5267  0F79
5268  0F7A
5269  0F7B
5270  0F7C
5271  0F7D
5272  0F7E
5273  0F7F
5274  0F80
5275  0F81
5276  0F82
5277  0F83
5278  0F84
5279  0F85
5280  0F86
5281  0F87
5282  0F88
5283  0F89
5284  0F8A
5285  0F8B
5286  0F8C
5287  0F8D
5288  0F8E
5289  0F8F
5290  0F90
5291  0F91
5292  0F92
5293  0F93
5294  0F94
5295  0F95
5296  0F96
5297  0F97
5298  0F98
5299  0F99
5300  0F9A
5301  0F9B
5302  0F9C
5303  0F9D
5304  0F9E
5305  0F9F
5306  0FA0
5307  0FA1
5308  0FA2
5309  0FA3
5310  0FA4
5311  0FA5
5312  0FA6
5313  0FA7
5314  0FA8
5315  0FA9
5316  0FAA
5317  0FAB
5318  0FAC
5319  0FAD
5320  0FAE
5321  0FAF
5322  0FB0
5323  0FB1
5324  0FB2
5325  0FB3
5326  0FB4
5327  0FB5
5328  0FB6
5329  0FB7
5330  0FB8
5331  0FB9
5332  0FBA
5333  0FBB
5334  0FBC
5335  0FBD
5336  0FBE
5337  0FBF
5338  0FC0
5339  0FC1
5340  0FC2
5341  0FC3
5342  0FC4
5343  0FC5
5344  0FC6
5345  0FC7
5346  0FC8
5347  0FC9
5348  0FCA
5349  0FCB
5350  0FCC
5351  0FCD
5352  0FCE
5353  0FCF
5354  0FD0
5355  0FD1
5356  0FD2
5357  0FD3
5358  0FD4
5359  0FD5
5360  0FD6
5361  0FD7
5362  0FD8
5363  0FD9
5364  0FDA
5365  0FDB
5366  0FDC
5367  0FDD
5368  0FDE
5369  0FDF
5370  0FE0
5371  0FE1
5372  0FE2
5373  0FE3
5374  0FE4
5375  0FE5
5376  0FE6
5377  0FE7
5378  0FE8
5379  0FE9
5380  0FEA
5381  0FEB
5382  0FEC
5383  0FED
5384  0FEE
5385  0FEF
5386  0FF0
5387  0FF1
5388  0FF2
5389  0FF3
5390  0FF4
5391  0FF5
5392  0FF6
5393  0FF7
5394  0FF8
5395  0FF9
5396  0FFA
5397  0FFB
5398  0FFC
5399  0FFD
5400  0FFE
5401  0FFF
5402  1000
5403  1001
5404  1002
5405  1003
5406  1004
5407  1005
5408  1006
5409  1007
5410  1008
5411  1009
5412  100A
5413  100B
5414  100C
5415  100D
5416  100E
5417  100F
5418  1010
5419  1011
5420  1012
5421  1013
5422  1014
5423  1015
5424  1016
5425  1017
5426  1018
5427  1019
5428  101A
5429  101B
5430  101C
5431  101D
5432  101E
5433  101F
5434  1020
5435  1021
5436  1022
5437  1023
5438  1024
5439  1025
5440  1026
5441  1027
5442  1028
5443  1029
5444  102A
5445  102B
5446  102C
5447  102D
5448  102E
5449  102F
5450  1030
5451  1031
5452  1032
5453  1033
5454  1034
5455  1035
5456  1036
5457  1037
5458  1038
5459  1039
5460  103A
5461  103B
5462  103C
5463  103D
5464  103E
5465  103F
5466  1040
5467  1041
5468  1042
5469  1043
5470  1044
5471  1045
5472  1046
5473  1047
5474  1048
5475  1049
5476  104A
5477  104B
5478  104C
5479  104D
5480  104E
5481  104F
5482  1050
5483  1051
5484  1052
5485  1053
5486  1054
5487  1055
5488  1056
5489  1057
5490  1058
5491  1059
5492  105A
5493  105B
5494  105C
5495  105D
5496  105E
5497  105F
5498  1060
5499  1061
5500  1062
5501  1063
5502  1064
5503  1065
5504  1066
5505  1067
5506  1068
5507  1069
5508  106A
5509  106B
5510  106C
5511  106D
5512  106E
5513  106F
5514  1070
5515  1071
5516  1072
5517  1073
5518  1074
5519  1075
5520  1076
5521  1077
5522  1078
5523  1079
5524  107A
5525  107B
5526  107C
5527  107D
5528  107E
5529  107F
5530  1080
5531  1081
5532  1082
5533  1083
5534  1084
5535  1085
5536  1086
5537  1087
5538  1088
5539  1089
5540  108A
5541  108B
5542  108C
5543  108D
5544  108E
5545  108F
5546  1090
5547  1091
5548  1092
5549  1093
5550  1094
5551  1095
5552  1096
5553  1097
5554  1098
5555  1099
5556  109A
5557  109B
5558  109C
5559  109D
5560  109E
5561  109F
5562  10A0
5563  10A1
5564  10A2
5565  10A3
5566  10A4
5567  10A5
5568  10A6
5569  10A7
5570  10A8
5571  10A9
5572  10AA
5573  10AB
5574  10AC
5575  10AD
5576  10AE
5577  10AF
5578  10B0
5579  10B1
5580  10B2
5581  10B3
5582  10B4
5583  10B5
5584  10B6
5585  10B7
5586  10B8
5587  10B9
5588  10BA
5589  10BB
5590  10BC
5591  10BD
5592  10BE
5593  10BF
5594  10C0
5595  10C1
5596  10C2
5597  10C3
5598  10C4
5599  10C5
5600  10C6
5601  10C7
5602  10C8
5603  10C9
5604  10CA
5605  10CB
5606  10CC
5607  10CD
5608  10CE
5609  10CF
5610  10D0
5611  10D1
5612  10D2
5613  10D3
5614  10D4
5615  10D5
5616  10D6
5617  10D7
5618  10D8
5619  10D9
5620  10DA
5621  10DB
5622  10DC
5623  10DD
5624  10DE
5625  10DF
5626  10E0
5627  10E1
5628  10E2
5629  10E3
5630  10E4
5631  10E5
5632  10E6
5633  10E7
5634  10E8
5635  10E9
5636  10EA
5637  10EB
5638  10EC
5639  10ED
5640  10EE
5641  10EF
5642  10F0
5643  10F1
5644  10F2
5645  10F3
5646  10F4
5647  10F5
5648  10F6
5649  10F7
5650  10F8
5651  10F9
5652  10FA
5653  10FB
5654  10FC
5655  10FD
5656  10FE
5657  10FF
5658  1100
5659  1101
5660  1102
5661  1103
5662  1104
5663  1105
5664  1106
5665  1107
5666  1108
5667  1109
5668  110A
5669  110B
5670  110C
5671  110D
5672  110E
5673  110F
5674  1110
5675  1111
5676  1112
5677  1113
5678  1114
5679  1115
5680  1116
5681  1117
5682  1118
5683  1119
5684  111A
5685  111B
5686  111C
5687  111D
5688  111E
5689  111F
5690  1120
5691  1121
5692  1122
5693  1123
5694  1124
5695  1125
5696  1126
5697  1127
5698  1128
5699  1129
5700  112A
5701  112B
5702  112C
5703  112D
5704  112E
5705  112F
5706  1130
5707  1131
5708  1132
5709  1133
5710  1134
5711  1135
5712  1136
5713  1137
5714  1138
5715  1139
5716  113A
5717  113B
5718  113C
5719  113D
5720  113E
5721  113F
5722  1140
5723  1141
5724  1142
5725  1143
5726  1144
5727  1145
5728  1146
5729  1147
5730  1148
5731  1149
5732  114A
5733  114B
5734  114C
5735  114D
5736  114E
5737  114F
5738  1150
5739  1151
5740  1152
5741  1153
5742  1154
5743  1155
5744  1156
5745  1157
5746  1158
5747  1159
5748  115A
5749  115B
5750  115C
5751  115D
5752  115E
5753  115F
5754  1160
5755  1161
5756  1162
5757  1163
5758  1164
5759  1165
5760  1166
5761  1167
5762  1168
5763  1169
5764  116A
5765  116B
5766  116C
5767  116D
5768  116E
5769  116F
5770  1170
5771  1171
5772  1172
5773  1173
5774  1174
5775  1175
5776  1176
5777  1177
5778  1178
5779  1179
5780  117A
5781  117B
5782  117C
5783  117D
5784  117E
5785  117F
5786  1180
5787  1181
5788  1182
5789  1183
5790  1184
5791  1185
5792  1186
5793  1187
5794  1188
5795  1189
5796  118A
5797  118B
5798  118C
5799  118D
5800  118E
5801  118F
5802  1190
5803  1191
5804  1192
5805  1193
5806  1194
5807  1195
5808  1196
5809  1197
5810  1198
5811  1199
5812  119A
5813  119B
5814  119C
5815  119D
5816  119E
5817  119F
5818  11A0
5819  11A1
5820  11A2
5821  11A3
5822  11A4
5823  11A5
5824  11A6
5825  11A7
5826  11A8
5827  11A9
5828  11AA
5829  11AB
5830  11AC
5831  11AD
5832  11AE
5833  11AF
5834  11B0
5835  11B1
5836  11B2
5837  11B3
5838  11B4
5839  11B5
5840  11B6
5841  11B7
5842  11B8
5843  11B9
5844  11BA
5845  11BB
5846  11BC
5847  11BD
5848  11BE
5849  11BF
5850  11C0
5851  11C1
5852  11C2
5853  11C3
5854  11C4
5855  11C5
5856  11C6
5857  11C7
5858  11C8
5859  11C9
5860  11CA
5861  11CB
5862  11CC
5863  11CD
5864  11CE
5865  11CF
5866  11D0
5867  11D1
5868  11D2
5869  11D3
5870  11D4
5871  11D5
5872  11D6
5873  11D7
5874  11D8
5875  11D9
5876  11DA
5877  11DB
5878  11DC
5879  11DD
5880  11DE
5881  11DF
5882  11E0
5883  11E1
5884  11E2
5885  11E3
5886  11E4
5887  11E5
5888  11E6
5889  11E7
5890  11E8
5891  11E9
5892  11EA
5893  11EB
5894  11EC
5895  11ED
5896  11EE
5897  11EF
5898  11F0
5899  11F1
5900  11F2
5901  11F3
5902  11F4
5903  11F5
5904  11F6
5905  11F7
5906  11F8
5907  11F9
5908  11FA
5909  11FB
5910  11FC
5911  11FD
5912  11FE
5913  11FF
5914  1200
5915  1201
5916  1202
5917  1203
5918  1204
5919  1205
5920  1206
5921  1207
5922  1208
5923  1209
5924  120A
5925  120B
5926  120C
5927  120D
5928  120E
5929  120F
5930  1210
5931  1211
5932  1212
5933  1213
5934  1214
5935  1215
5936  1216
5937  1217
5938  1218
5939  1219
5940  121A
5941  121B
5942  121C
5943  121D
5944  121E
5945  121F
5946  1220
5947  1221
5948  1222
5949  1223
5950  1224
5951  1225
5952  1226
5953  1227
5954  1228
5955  1229
5956  122A
5957  122B
5958  122C
5959  122D
5960  122E
5961  122F
5962  1230
5963  1231
5964  1232
5965  1233
5966  1234
5967  1235
5968  1236
5969  1237
5970  1238
5971  1239
5972  123A
5973  123B
5974  123C
5975  123D
5976  123E
5977  123F
5978  1240
5979  1241
5980  1242
5981  1243
5982  1244
5983  1245
5984  1246
5985  1247
5986  1248
5987  1249
5988  124A
5989  124B
5990  124C
5991  124D
5992  124E
5993  124F
5994  1250
5995  1251
5996  1252
5997  1253
5998  1254
5999  1255
6000  1256
6001  1257
6002  1258
6003  1259
6004  125A
6005  125B
6006  125C
6007  125D
6008  125E
6009  125F
6010  1260
6011  1261
6012  1262
6013  1263
6014  1264
6015  1265
6016  1266
6017  1267
6018  1268
6019  1269
6020  126A
6021  126B
6022  126C
6023  126D
6024  126E
6025  126F
6026  1270
6027  1271
6028  1272
6029  1273
6030  1274
6031  1275
6032  1276
6033  1277
6034  1278
6035  1279
6036  127A
6037  127B
6038  127C
6039  127D
6040  127E
6041  127F
6042  1280
6043  1281
6044  1282
6045  1283
6046  1284
6047  1285
6048  1286
6049  1287
6050  1288
6051  1289
6052  128A
6053  128B
6054  128C
6055  128D
6056  128E
6057  128F
6058  1290
6059  1291
6060  1292
6061  1293
6062  1294
6063  1295
6064  1296
6065  1297
6066  1298
6067  1299
6068  129A
6069  129B
6070  129C
6071  129D
6072  129E
6073  129F
6074  12A0
6075  12A1
6076  12A2
6077  12A3
6078  12A4
6079  12A5
6080  12A6
6081  12A7
6082  12A8
6083  12A9
6084  12AA
6085  12AB
6086  12AC
6087  12AD
6088  12AE
6089  12AF
6090  12B0
6091  12B1
6092  12B2
6093  12B3
6094  12B4
6095  12B5
6096  12B6
6097  12B7
6098  12B8
6099  12B9
6100  12BA
6101  12BB
6102  12BC
6103  12BD
6104  12BE
6105  12BF
6106  12C0
6107  12C1
6108  12C2
6109  12C3
6110  12C4
6111  12C5
6112  12C6
6113  12C7
6114  12C8
6115  12C9
6116  12CA
6117  12CB
6118  12CC
6119  12CD
6120  12CE
6121  12CF
6122  12D0
6123  12D1
6124  12D2
6125  12D3
6126  12D4
6127  12D5
6128  12D6
6129  12D7
6130  12D8
6131  12D9
6132  12DA
6133  12DB
6134  12DC
6135  12DD
6136  12DE
6137  12DF
6138  12E0
6139  12E1
6140  12E2
6141  12E3
6142  12E4
6143  12E5
6144  12E6
6145  12E7
6146  12E8
6147  12E9
6148  12EA
6149  12EB
6150  12EC
6151  12ED
6152  12EE
6153  12EF
6154  12F0
6155  12F1
6156  12F2
6157  12F3
6158  12F4
6159  12F5
6160  12F6
6161  12F7
6162  12F8
6163  12F9
6164  12FA
6165  12FB
6166  12FC
6167  12FD
6168  12FE
6169  12FF
6170  1300
6171  1301
6172  1302
6173  1303
6174  1304
6175  1305
6176  1306
6177  1307
6178  1308
6179  1309
6180  130A
6181  130B
6182  130C
6183  130D
6184  130E
6185  130F
6186  1310
6187  1311
6188  1312
6189  1313
6190  1314
6191  1315
6192  1316
6193  1317
6194  1318
6195  1319
6196  131A
6197  131B
6198  131C
6199  131D
6200  131E
6201  131F
6202  1320
6203  1321
6204  1322
6205  1323
6206  1324
6207  1325
6208  1326
6209  1327
6210  1328
6211  1329
6212  132A
6213  132B
6214  132C
6215  132D
6216  132E
6217  132F
6218  1330
6219  1331
6220  1332
6221  1333
6222  1334
6223  1335
6224  1336
6225  1337
6226  1338
6227  1339
6228  133A
6229  133B
6230  133C
6231  133D
6232  133E
6233  133F
6234  1340
6235  1341
6236  1342
6237  1343
6238  1344
6239  1345
6240  1346
6241  1347
6242  1348
6243  1349
6244  134A
6245  134B
6246  134C
6247  134D
6248  134E
6249  134F
6250  1350
6251  1351
6252  1352
6253  1353
6254  1354
6255  1355
6256  1356
6257  1357
6258  1358
6259  1359
6260  135A
6261  135B
6262  135C
6263  135D
6264  135E
6265  135F
6266  1360
6267  1361
6268  1362
6269  1363
6270  1364
6271  1365
6272  1366
6273  1367
6274  1368
6275  1369
6276  136A
6277  136B
6278  136C
6279  136D
6280  136E
6281  136F
6282  1370
6283  1371
6284  1372
6285  1373
6286  1374
6287  1375
6288  1376
6289  1377
6290  1378
6291  1379
6292  137A
6293  137B
6294  137C
6295  137D
6296  137E
6297  137F
6298  1380
6299  1381
6300  1382
6301  1383
6302  1384
6303  1385
6304  1386
6305  1387
6306  1388
6307  1389
6308  138A
6309  138B
6310  138C
6311  138D
6312  138E
6313  138F
6314  1390
6315  1391
6316  1392
6317  1393
6318  1394
6319  1395
6320  1396
6321  1397
6322  1398
6323  1399
6324  139A
6325  139B
6326  139C
6327  139D
6328  139E
6329  139F
6330  13A0
6331  13A1
6332  13A2
6333  13A3
6334  13A4
6335  13A5
6336  13A6
6337  13A7
6338  13A8
6339  13A9
6340  13AA
6341  13AB
6342  13AC
6343  13AD
6344  13AE
6345  13AF
6346  13B0
6347  13B1
6348  13B2
6349  13B3
6350  13B4
6351  13B5
6352  13B6
6353  13B7
6354  13B8
6355  13B9
6356  13BA
6357  13BB
6358  13BC
6359  13BD
6360  13BE
6361  13BF
6362  13C0
6363  13C1
6364  13C2
6365  13C3
6366  13C4
6367  13C5
6368  13C6
6369  13C7
6370  13C8
6371  13C9
6372  13CA
6373  13CB
6374  13CC
6375  13CD
6376  13CE
6377  13CF
6378  13D0
6379  13D1
6380  13D2
6381  13D3
6382  13D4
6383  13D5
6384  13D6
6385  13D7
6386  13D8
6387  13D9
6388  13DA
6389  13DB
6390  13DC
6391  13DD
6392  13DE
6393  13DF
6394  13E0
6395  13E1
6396  13E2
6397  13E3
6398  13E4
6399  13E5
6400  13E6
6401  13E7
6402  13E8
6403  13E9
6404  13EA
6405  13EB
6406  13EC
6407  13ED
6408  13EE
6409  13EF
6410  13F0
6411  13F1
6412  13F2
6413  13F3
6414  13F4
6415  13F5
6416  13F6
6417  13F7
6418  13F8
6419  13F9
6420  13FA
6421  13FB
6422  13FC
6423  13FD
6424  13FE
6425  13FF
6426  1400
6427  1401
6428  1402
6429  1403
6430  1404
6431  1405
6432  1406
6433  1407
6434  1408
6435  1409
6436  140A
6437  140B
6438  140C
6439  140D
6440  140E
6441  140F
6442  1410
6443  1411
6444  1412
6445  1413
6446  1414
6447  1415
6448  1416
6449  1417
6450  1418
6451  1419
6452  141A
6453  141B
6454  141C
6455  141D
6456  141E
6457  141F
6458  1420
6459  1421
6460  1422
6461  1423
6462  1424
6463  1425
6464  1426
6465  1427
6466  1428
6467  1429
6468  142A
6469  142B
6470  142C
6471  142D
6472  142E
6473  142F
6474  1430
6475  1431
6476  1432
6477  1433
6478  1434
6479  1435
6480  1436
6481  1437
6482  1438
6483  1439
6484  143A
6485  143B
6486  143C
6487  143D
6488  143E
6489  143F
6490  1440
6491  1441
6492  1442
6493  1443
6494  1444
6495  1445
6496  1446
6497  1447
6498  1448
6499  1449
6500  144A
6501  144B
6502  144C
6503  144D
6504  144E
6505  144F
6506  1450
6507  1451
6508  1452
6509  1453
6510  1454
6511  1455
6512  1456
6513  1457
6514  1458
6515  1459
6516  145A
6517  145B
6518  145C
6519  145D
6520  145E
6521  145F
6522  1460
6523  1461
6524  1462
6525  1463
6526  1464
6527  1465
6528  1466
6529  1467
6530  1468
6531  1469
6532  146A
6533  146B
6534  146C
6535  146D
6536  146E
6537  146F
6538  1470
6539  1471
6540  1472
6541  1473
6542  1474
6543  1475
6544  1476
6545  1477
6546  1478
6547  1479
6548  147A
6549  147B
6550  147C
6551  147D
6552  147E
6553  147F
6554  1480
6555  1481
6556  1482
6557  1483
6558  1484
6559  1485
6560  1486
6561  1487
6562  1488
6563  1489
6564  148A
6565  148B
6566  148C
6567  148D
6568  148E
6569  148F
6570  1490
6571  1491
6572  1492
6573  1493
6574  1494
6575  1495
6576  1496
6577  1497
6578  1498
6579  1499
6580  149A
6581  149B
6582  149C
6583  149D
6584  149E
6585  149F
6586  14A0
6587  14A1
6588  14A2
6589  14A3
6590  14A4
6591  14A5
6592  14A6
6593  14A7
6594  14A8
6595  14A9
6596  14AA
6597  14AB
6598  14AC
6599  14AD
6600  14AE
6601  14AF
6602  14B0
6603  14B1
6604  14B2
6605  14B3
6606  14B4
6607  14B5
6608  14B6
6609  14B7
6610  14B8
6611  14B9
6612  14BA
6613  14BB
6614  14BC
6615  14BD
6616  14BE
6617  14BF
6618  14C0
6619  14C1
6620  14C2
6621  14C3
6622  14C4
6623  14C5
6624  14C6
6625  14C7
6626  14C8
6627  14C9
6628  14CA
6629  14CB
6630  14CC
6631  14CD
6632  14CE
6633  14CF
6634  14D0
6635  14D1
6636  14D2
6637  14D3
6638  14D4
6639  14D5
6640  14D6
6641  14D7
6642  14D8
6643  14D9
6644  14DA
6645  14DB
6646  14DC
6647  14DD
6648  14DE
6649  14DF
6650  14E0
6651  14E1
6652  14E2
6653  14E3
6654  14E4
6655  14E5
6656  14E6
6657  14E7
6658  14E8
6659  14E9
6660  14EA
6661  14EB
6662  14EC
6663  14ED
6664  14EE
6665  14EF
6666  14F0
6667  14F1
6668  14F2
6669  14F3
6670  14F4
6671  14F5
6672  14F6
6673  14F7
6674  14F8
6675  14F9
6676  14FA
6677  14FB
6678  14FC
6679  14FD
6680  14FE
6681  14FF
6682  1500
6683  1501
6684  1502
6685  1503
6686  1504
6687  1505
6688  1506
6689  1507
6690  1508
6691  1509
6692  150A
6693  150B
6694  150C
6695  150D
6696  150E
6697  150F
6698  1510
6699  1511
6700  1512
6701  1513
6702  1514
6703  1515
6704  1516
6705  1517
6706  1518
6707  1519
6708  151A
6709  151B
6710  151C
6711  151D
6712  151E
6713  151F
6714  1520
6715  1521
6716  1522
6717  1523
6718  1524
6719  1525
6720  1526
6721  1527
6722  1528
6723  1529
6724  152A
6725  152B
6726  152C
6727  152D
6728  152E
6729  152F
6730  1530
6731  1531
6732  1532
6733  1533
6734  1534
6735  1535
6736  1536
6737  1537
6738  1538
6739  1539
6740  153A
6741  153B
6742  153C
6743  153D
6744  153E
6745  153F
6746  1540
6747  1541
6748  1542
6749  1543
6750  1544
6751  1545
6752  1546
6753  1547
6754  1548
6755  1549
6756  154A
6757  154B
6758  154C
6759  154D
6760  154E
6761  154F
6762  1550
6763  1551
6764  1552
6765  1553
6766  1554
6767  1555
6768  1556
6769  1557
6770  1558
6771  1559
6772  155A
6773  155B
6774  155C
6775  155D
6776  155E
6777  155F
6778  1560
6779  1561
6780  1562
6781  1563
6782  1564
6783  1565
6784  1566
6785  1567
6786  1568
6787  1569
6788  156A
6789  156B
6790  156C
6791  156D
6792  156E
6793  156F
6794  1570
6795  1571
6796  1572
6797  1573
6798  1574
6799  1575
6800  1576
6801  1577
6802  1578
6803  1579
6804  157A
6805  157B
6806  157C
6807  157D
6808  157E
6809  157F
6810  1580
6811  1581
6812  1582
6813  1583
6814  1584
6815  1585
6816  1586
6817  1587
6818  1588
6819  1589
6820  158A
6821  158B
6822  158C
6823  158D
6824  158E
6825  158F
6826  1590
6827  1591
6828  1592
6829  1593
6830  1594
6831  1595
6832  1596
6833  1597
6834  1598
6835  1599
6836  159A
6837  159B
6838  159C
6839  159D
6840  159E
6841  159F
6842  15A0
6843  15A1
6844  15A2
6845  15A3
6846  15A4
6847  15A5
6848  15A6
6849  15A7
6850  15A8
6851  15A9
6852  15AA
6853  15AB
6854  15AC
6855  15AD
6856  15AE
6857  15AF
6858  15B0
6859  15B1
6860  15B2
6861  15B3
6862  15B4
6863  15B5
6864  15B6
6865  15B7
6866  15B8
6867  15B9
6868  15BA
6869  15BB
6870  15BC
6871  15BD
6872  15BE
6873  15BF
6874  15C0
6875  15C1
6876  15C2
6877  15C3
6878  15C4
6879  15C5
6880  15C6
6881  15C7
6882  15C8
6883  15C9
6884  15CA
6885  15CB
6886  15CC
6887  15CD
6888  15CE
6889  15CF
6890  15D0
6891  15D1
6892  15D2
6893  15D3
6894  15D4
6895  15D5
6896  15D6
6897  15D7
6898  15D8
6899  15D9
6900  15DA
6901  15DB
6902  15DC
6903  15DD
6904  15DE
6905  15DF
6906  15E0
6907  15E1
6908  15E2
6909  15E3
6910  15E4
6911  15E5
6912  15E6
6913  15E7
6914  15E8
6915  15E9
6916  15EA
6917  15EB
6918  15EC
6919  15ED
6920  15EE
6921  15EF
6922  15F0
6923  15F1
6924  15F2
6925  15F3
6926  15F4
6927  15F5
6928  15F6
6929  15F7
6930  15F8
6931  15F9
6932  15FA
6933  15FB
6934  15FC
6935  15FD
6936  15FE
6937  15FF
6938  1600
6939  1601
6940  1602
6941  1603
6942  1604
6943  1605
6944  1606
6945  1607
6946  1608
6947  1609
6948  160A
6949  160B
6950  160C
6951  160D
6952  160E
6953  160F
6954  1610
6955  1611
6956  1612
6957  1613
6958  1614
6959  1615
6960  1616
6961  1617
6962  1618
6963  1619
6964  161A
6965  161B
6966  161C
6967  161D
6968  161E
6969  161F
6970  1620
6971  1621
6972  1622
6973  1623
6974  1624
6975  1625
6976  1626
6977  1627
6978  1628
6979  1629
6980  162A
6981  162B
6982  162C
6983  162D
6984  162E
6985  162F
6986  1630
6987  1631
6988  1632
6989  1633
6990  1634
6991  1635
6992  1636
6993  1637
6994  1638
6995  1639
6996  163A
6997  163B
6998  163C
6999  163D
7000  163E
7001  163F
7002  1640
7003  1641
7004  1642
7005  1643
7006  1644
7007  1645
7008  1646
7009  1647
7010  1648
7011  1649
7012  164A
7013  164B
7014  164C
7015  164D
7016  164E
7017  164F
7018  1650
7019  1651
7020  1652
7021  1653
7022  1654
7023  1655
7024  1656
7025  1657
7026  1658
7027  1659
7028  165A
7029  165B
7030  165C
7031  165D
7032  165E
7033  165F
7034  1660
7035  1661
7036  1662
7037  1663
7038  1664
7039  1665
7040  1666
7041  1667
7042  1668
7043  1669
7044  166A
7045  166B
7046  166C
7047  166D
7048  166E
7049  166F
7050  1670
7051  1671
7052  1672
7053  1673
7054  1674
7055  1675
7056  1676
7057  1677
7058  1678
7059  1679
7060  167A
7061  167B
7062  167C
7063  167D
7064  167E
7065  167F
7066  1680
7067  1681
7068  1682
7069  1683
7070  1684
7071  1685
7072  1686
7073  1687
7074  1688
7075  1689
7076  168A
7077  168B
7078  168C
7079  168D
7080  168E
7081  168F
7082  1690
7083  1691
7084  1692
7085  1693
7086  1694
7087  1695
7088  1696
7089  1697
7090  1698
7091  1699
7092  169A
7093  169B
7094  169C
7095  169D
7096  169E
7097  169F
7098  16A0
7099  16A1
7100  16A2
7101  16A3
7102  16A4
7103  16A5
7104  16A6
7105  16A7
7106  16A8
7107  16A9
7108  16AA
7109  16AB
7110  16AC
7111  16AD
7112  16AE
7113  16AF
7114  16B0
7115  16B1
7116  16B2
7117  16B3
7118  16B4
7119  16B5
7120  16B6
7121  16B7
7122  16B8
7123  16B9
7124  16BA
7125  16BB
7126  16BC
7127  16BD
7128  16BE
7129  16BF
7130  16C0
7131  16C1
7132  16C2
7133  16C3
7134  16C4
7135  16C5
7136  16C6
7137  16C7
7138  16C8
7139  16C9
7140  16CA
7141  16CB
7142  16CC
7143  16CD
7144  16CE
7145  16CF
7146  16D0
7147  16D1
7148  16D2
7149  16D3
7150  16D4
7151  16D5
7152  16D6
7153  16D7
7154  16D8
7155  16D9
7156  16DA
7157  16DB
7158  16DC
7159  16DD
7160  16DE
7161  16DF
7162  16E0
7163  16E1
7164  16E2
7165  16E3
7166  16E4
7167  16E5
7168  16E6
7169  16E7
7170  16E8
7171  16E9
7172  16EA
7173  16EB
7174  16EC
7175  16ED
7176  16EE
7177  16EF
7178  16F0
7179  16F1
7180  16F2
7181  16F3
7182  16F4
7183  16F5
7184  16F6
7185  16F7
7186  16F8
7187  16F9
7188  16FA
7189  16FB
7190  16FC
7191  16FD
7192  16FE
7193  16FF
7194  1700
7195  1701
7196  1702
7197  1703
7198  1704
7199  1705
7200  1706
7201  1707
7202  1708
7203  1709
7204  170A
7205  170B
7206  170C
7207  170D
7208  170E
7209  170F
7210  1710
7211  1711
7212  1712
7213  1713
7214  1714
7215  1715
7216  1716
7217  1717
7218  1718
7219  1719
7220  171A
7221  171B
7222  171C
7223  171D
7224  171E
7225  171F
7226  1720
7227  1721
7228  1722
7229  1723
7230  1724
7231  1725
7232  1726
7233  1727
7234  1728
7235  1729
7236  172A
7237  172B
7238  172C
7239  172D
7240  172E
7241  172F
7242  1730
7243  1731
7244  1732
7245  1733
7246  1734
7247  1735
7248  1736
7249  1737
7250  1738
7251  1739
7252  173A
7253  173B
7254  173C
7255  173D
7256  173E
7257  173F
7258  1740
7259  1741
7260  1742
7261  1743
7262  1744
7263  1745
7264  1746
7265  1747
7266  1748
7267  1749
7268  174A
7269  174B
7270  174C
7271  174D
7272  174E
7273  174F
7274  1750
7275  1751
7276  1752
7277  1753
7278  1754
7279  1755
7280  1756
7281  1757
7282  1758
7283  1759
7284  175A
7285  175B
7286  175C
7287  175D
7288  175E
7289  175F
7290  1760
7291  1761
7292  1762
7293  1763
7294  1764
7295  1765
7296  1766
7297  1767
7298  1768
7299  1769
7300  176A
7301  176B
7302  176C
7303  176D
7304  176E
7305  176F
7306  1770
7307  1771
7308  1772
7309  1773
7310  1774
7311  1775
7312  1776
7313  1777
7314  1778
7315  1779
7316  177A
7317  177B
7318  177C
7319  177D
7320  177E
7321  177F
7322  1780
7323  1781
7324  1782
7325  1783
7326  1784
7327  1785
7328  1786
7329  1787
7330  1788
7331  1789
7332  178A
7333  178B
7334  178C
7335  178D
7336  178E
7337  178F
7338  1790
7339  1791
7340  1792
7341  1793
7342  1794
7343  1795
7344  1796
7345  1797
7346  1798
7347  1799
7348  179A
7349  179B
7350  179C
7351  179D
7352  179E
7353  179F
7354  17A0
7355  17A1
7356  17A2
7357  17A3
7358  17A4
7359  17A5
7360  17A6
7361  17A7
7362  17A8
7363  17A9
7364  17AA
7365  17AB
7366  17AC
7367  17AD
7368  17AE
7369  17AF
7370  17B0
7371  17B1
7372  17B2
7373  17B3
7374  17B4
7375  17B5
7376  17B6
7377  17B7
7378  17B8
7379  17B9
7380  17BA
7381  17BB
7382  17BC
7383  17BD
7384  17BE
7385  17BF
7386  17C0
7387  17C1
7388  17C2
7389  17C3
7390  17C4
7391  17C5
7392  17C6
7393  17C7
7394  17C8
7395  17C9
7396  17CA
7397  17CB
7398  17CC
7399  17CD
7400  17CE
7401  17CF
7402  17D0
7403  17D1
7404  17D2
7405  17D3
7406  17D4
7407  17D5
7408  17D6
7409  17D7
7410  17D8
7411  17D9
7412  17DA
7413  17DB
7414  17DC
7415  17DD
7416  17DE
7417  17DF
7418  17E0
7419  17E1
7420  17E2
7421  17E3
7422  17E4
7423  17E5
7424  17E6
7425  17E7
7426  17E8
7427  17E9
007428  000309        
007429  000310      var vIAngularMeter0[WIDGET_RAM_SPACE] ;
007430  000311      var vIAngularMeter1[WIDGET_RAM_SPACE] ;
007431  000312      var vIAngularMeter3[WIDGET_RAM_SPACE] ;
007432  000313      var vILedDigits1[WIDGET_RAM_SPACE+2] ;
007433  000314      var vILedDigits2[WIDGET_RAM_SPACE+2] ;
007434  000315      var vILedDigits3[WIDGET_RAM_SPACE+2] ;
007435  000316      var vIAngularMeter2[WIDGET_RAM_SPACE] ;
007436  000317      var vILedDigits4[WIDGET_RAM_SPACE+2] ;
007437  000318      var vILedDigits6[WIDGET_RAM_SPACE+2] ;
007438  000319      var vILedDigits7[WIDGET_RAM_SPACE+2] ;
007439  000320      var vILedDigits8[WIDGET_RAM_SPACE+2] ;
007440  000321      var vILedDigits5[WIDGET_RAM_SPACE+2] ;
007441  000322      var vILedDigits9[WIDGET_RAM_SPACE+2] ;
007442  000323      var vILedDigits0[WIDGET_RAM_SPACE+2] ;
007443  000324  var stringsCV[37] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], hstrings ;
7444  0C42
7445  0C43
7446  0C44
7447  0C45
7448  0C46
7449  0C47
7450  0C48
7451  0C49
7452  0C4A
7453  0C4B
7454  0C4C
7455  0C4D
7456  0C4E
7457  0C4F
7458  0C50
7459  0C51
7460  0C52
7461  0C53
7462  0C54
7463  0C55
7464  0C56
7465  0C57
7466  0C58
7467  0C59
7468  0C5A
7469  0C5B
7470  0C5C
7471  0C5D
7472  0C5E
7473  0C5F
7474  0C60
7475  0C61
7476  0C62
7477  0C63
7478  0C64
7479  0C65
7480  0C66
7481  0C67
7482  0C68
7483  0C69
7484  0C6A
7485  0C6B
7486  0C6C
7487  0C6D
7488  0C6E
7489  0C6F
7490  0C70
7491  0C71
7492  0C72
7493  0C73
7494  0C74
7495  0C75
7496  0C76
7497  0C77
7498  0C78
7499  0C79
7500  0C7A
7501  0C7B
7502  0C7C
7503  0C7D
7504  0C7E
7505  0C7F
7506  0C80
7507  0C81
7508  0C82
7509  0C83
7510  0C84
7511  0C85
7512  0C86
7513  0C87
7514  0C88
7515  0C89
7516  0C8A
7517  0C8B
007518  000325  // Start P2.inc
007519  000326  var vObjects[MaxIntObjects+1] ;              // address of RAM objects
007520  000327  var GObjectIdx, GObjectFunc, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings ;
007521  000328  var oObjects[MaxTotObjects+1] ;                 // address of objects
007522  000329  var CurrentForm, oldn, ImageTouched ;
007523  000330  var TouchXpos, TouchYpos ;
007524  000331  var GObjectType, TouchState, CurInputData, pInputIndex ;
007525  000332  var comRX[40], cmd[CMDLenMAX] ;
007526  000333        
007527  000334  var InputCS, OutputCS ;
007528  000335        
007529  000336  // > ? Constant/Global/Data ? <
007530  000337        
007531  000338  func addressInternalWidget(var idx var iponly)
007532  000339      var i, j ;
007533  000340  //to(COM0) ; print("Address Int ", idx, " ") ; pause(2) ;
007534  000341      GObjectIdx := xobj2iobj[idx] ;
007535  000342      GObjectType := (GObjectIdx>>8) ;                          // extract object type
007536  000343      i := oObjects[GObjectType] ;                              // i is address of list of all objects of this type
007537  000344      GObjectIdx &= 0xff ;
007538  000345      //GObjectIdx *= 2 ;
007539  000346      j := GObjectIdx * 2 ;
007540  000347      GObjectDATA := i[j + 2] ;                                 // address of this object
007541  000348      i := vObjects[GObjectType-tiAngularMeter] ;               // i is address of list of all ram objects of his type
007542  000349      GObjectRAM := i[j] ;                                      // address of this objects' ram
007543  000350      i := GObjectType-tiAngularMeter ;
007544  000351      GObjectFunc := gfxInternals[i] ; // address function
007545  000352      GObjectParms := gfxIntParms[i] ;
007546  000353      GObjectStrings := gfxIntStrings[i] ;
007547  000354  //to(COM0) ; print([HEX4] GObjectFunc, " ", [HEX4] GObjectRAM, " ", [HEX4] GObjectDATA, " ", GObjectType, " ", GObjectIdx, "\r\n") ;
007548  000355  //    GObjectFunc(0, GObjectRAM, GObjectDATA) ;
007549  000356  endfunc
007550  000357        
007551  000358  func seroutCS(var op)
007552  000359      serout(op) ;
007553  000360      OutputCS ^= op ;
007554  000361  endfunc
007555  000362        
007556  000363  func nak0()
007557  000364      serout(NAK) ;
007558  000365      InputCS := 0 ;
007559  000366  endfunc
007560  000367        
007561  000368  func seroutOcs()
007562  000369      serout(OutputCS) ;
007563  000370      OutputCS := 0 ;
007564  000371  endfunc
007565  000372        
007566  000373  func SendReport(var id, var objt, var objn, var val)
007567  000374      seroutCS(id) ;
007568  000375      seroutCS(objt) ;
007569  000376      seroutCS(objn) ;
007570  000377      seroutCS(val >> 8) ; // first 8 bits
007571  000378      seroutCS(val) ;
007572  000379      seroutOcs() ;
007573  000380  endfunc
007574  000381        
007575  000382        
007576  000383  func ReadObject(var ObjectType, var ObjectIdx)
007577  000384      var j, k, Objects ;
007578  000385      if ((ObjectType >= tiLedDigitsH) && (ObjectType <= tiLinearInput))
007579  000386          j := ObjectIdx *2 ;
007580  000387          k := vObjects[ObjectType-tiAngularMeter] ;               // k is address of list of all ram objects of his type
007581  000388          k := k[j] ;                                              // k is address of this objects' ram
007582  000389          if (ObjectType == tiLedDigit)
007583  000390              k := k[0] ;
007584  000391          else 
007585  000392              k := k[WIDGET_VAL1] ;
007586  000393          endif
007587  000394  //gfx_MoveTo(0,0); txt_Opacity(OPAQUE) ; print(ObjectType, " ", ObjectIdx, " ", k," ") ;
007588  000395      else
007589  000396      Objects := *(oObjects+ObjectType) ;
007590  000397        
007591  000398      j := 2 + ObjectIdx * 2 + Objects ;
007592  000399       if (ObjectType == tForm)
007593  000400          k := CurrentForm ;
007594  000401      else if (ObjectType == tStrings)
007595  000402          k := stringsCV[ObjectIdx];
007596  000403          else
007597  000404          k := img_GetWord(hndl, *j, IMAGE_INDEX);
007598  000405          if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
007599  000406                                                                                                                                                      // determine if button is momentary or not which is needed for correct answer.
007600  000407      endif
007601  000408      endif
007602  000409      SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
007603  000410  endfunc
007604  000411        
007605  000412  var wp ;
007606  000413        
007607  000414        
007608  000415  func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
007609  000416      var i, j, k, Objects ;
007610  000417  //    ObjectType &= 0x3f ; Why was his there? Anibuttons? Complex cascades?
007611  000418      if (ObjectType == tForm)
007612  000419          ActivateForm(ObjectIdx) ;
007613  000420          return ;
007614  000421      endif
007615  000422      Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
007616  000423      i := *(Objects) ;
007617  000424      if ((ObjectType >= tiAngularMeter) && (ObjectType <= tiLinearInput))
007618  000425          i := oObjects[ObjectType] ;                              // f is address of list of all objects of this type
007619  000426          j := ObjectIdx *2 ;
007620  000427          i := i[j + 2] ;                         // f is address of this object
007621  000428          k := vObjects[ObjectType-tiAngularMeter] ;               // a is address of list of all ram objects of his type
007622  000429          k := k[j] ;                             // a is address of this objects' ram
007623  000430              j := ObjectType-tiAngularMeter ;
007624  000431              Objects := gfxInternals[j] ;           // locate function address   
007625  000432              Objects(NewVal, k, i) ; 
007626  000433          return ;
007627  000434      endif
007628  000435      switch (ObjectType)
007629  000436          case tWinButton :
007630  000437              j := InputControls[oWinButtons[ObjectIdx+1]] ;
007631  000438              break ;
007632  000439          case tUserButton :
007633  000440              j := InputControls[oUserButtons[ObjectIdx+1]] ;
007634  000441              break ;
007635  000442          default : j := -1 ;
007636  000443      endswitch
007637  000444        
007638  000445      if (j != -1)
007639  000446          k := img_GetWord(hndl, i , IMAGE_INDEX) ;
007640  000447          if (   (k == -1)                    // currently disabled
007641  000448              && (NewVal != -1) )             // and don't want it disabled
007642  000449              img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);    // enable touch
007643  000450          else if (   (k != -1)               // currently enabled
007644  000451                   && (NewVal == -1) )        // and want it disabled
007645  000452              img_SetWord(hndl, i, IMAGE_INDEX, 0xffff) ;       // make invisible
007646  000453              img_SetAttributes(hndl, i, I_TOUCH_DISABLE);      // and disable touch
007647  000454              if (img_GetWord(hndl,i,IMAGE_FLAGS) & I_ENABLED)  // only clear if we are enabled (i.e. on current form) 
007648  000455                  if (FormBGcolors[CurrentForm] != ColorBGimage)
007649  000456                      gfx_RectangleFilled(img_GetWord(hndl, i, IMAGE_XPOS), img_GetWord(hndl, i, IMAGE_YPOS),
007650  000457                                          img_GetWord(hndl, i, IMAGE_XPOS) + img_GetWord(hndl, i, IMAGE_WIDTH),
007651  000458                                          img_GetWord(hndl, i, IMAGE_YPOS) + img_GetWord(hndl, i, IMAGE_HEIGHT), FormBGcolors[CurrentForm]);
007652  000459                  else
007653  000460                      gfx_ClipWindow(img_GetWord(hndl, i, IMAGE_XPOS), img_GetWord(hndl, i, IMAGE_YPOS),
007654  000461                                     img_GetWord(hndl, i, IMAGE_XPOS) + img_GetWord(hndl, i, IMAGE_WIDTH),
007655  000462                                     img_GetWord(hndl, i, IMAGE_YPOS) + img_GetWord(hndl, i, IMAGE_HEIGHT)) ;
007656  000463                      gfx_Clipping(ON) ;
007657  000464                      img_Show(hndl,FormStartIndex[CurrentForm]) ;
007658  000465                      gfx_Clipping(OFF) ;
007659  000466                  endif
007660  000467              endif
007661  000468              return ;
007662  000469          else
007663  000470              NewVal := NewVal << 1 ;
007664  000471              if (OVF())      // button group index change
007665  000472                  if (*(j+InputData+Ofs_IPD_P1))
007666  000473                      k &= 1 ;    // mask off old group index for momentary
007667  000474                  else
007668  000475                      k &= 3 ;    // mask off old group index for toggle
007669  000476                  endif
007670  000477              else            // normal set
007671  000478                  if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
007672  000479                  k &= 0xfffc ;    // retain only group index for state set
007673  000480              endif
007674  000481              NewVal |= k ;
007675  000482              endif
007676  000483  //        endif
007677  000484          endif
007678  000485        
007679  000486          if (ObjectType == tStrings)
007680  000487              PrintStrings(ObjectIdx, NewVal, 0);
007681  000488              return ;
007682  000489          endif
007683  000490      img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
007684  000491      img_Show(hndl, i) ; // will only display if form is current
007685  000492      return ; // compiler bug circumvention!
007686  000493  endfunc
007687  000494        
007688  000495  func TurnOffButtons(var group)
007689  000496      var j, k, l, m, n, o, p;
007690  000497      m := GObjectIdx ;     // save as will be clobbered
007691  000498      n := GObjectType ;     // save as will be clobbered
007692  000499      for (j := 0; j < nInputs; j++)
007693  000500          k := j*IPDatasize ;
007694  000501          if (*(InputData+k+Ofs_IPD_P2) == group)
007695  000502              l := -1 ;
007696  000503               if (*(InputData+k) == tWinButton)
007697  000504                  l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007698  000505                  if (img_GetWord(hndl, l, IMAGE_INDEX) != 0xffff)
007699  000506                  img_SetWord(hndl, l, IMAGE_INDEX, 0);
007700  000507                  img_Show(hndl, l);      // only shows on current form
007701  000508                  endif
007702  000509        
007703  000510              else if (*(InputData+k) == tUserButton)
007704  000511                  l := oUserButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
007705  000512                  if (img_GetWord(hndl, l, IMAGE_INDEX) != 0xffff)
007706  000513                  img_SetWord(hndl, l, IMAGE_INDEX, img_GetWord(hndl, l, IMAGE_INDEX) & 0xfffc );
007707  000514                  img_Show(hndl, l);      // only shows on current form
007708  000515                  endif
007709  000516              endif
007710  000517          endif
007711  000518      next
007712  000519      GObjectIdx := m ;     // Restore
007713  000520      GObjectType := n ;    // Restore
007714  000521  endfunc
007715  000522        
007716  000523        
007717  000524        
007718  000525        
007719  000526  func ActivateForm(var newform)
007720  000527      var i, j, *p ;
007721  000528        
007722  000529          widget_Disable(wp, ALL) ;
007723  000530      if (CurrentForm != -1) // deactivate old form, by disabling all inputs
007724  000531          for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
007725  000532              if (img_GetWord(hndl, i, IMAGE_TAG))
007726  000533                  img_Disable(hndl,i) ;
007727  000534              endif
007728  000535          next
007729  000536      endif
007730  000537      CurrentForm := newform ;
007731  000538      // display newform image or clear to image color
007732  000539      if (FormBGcolors[CurrentForm] != ColorBGimage)
007733  000540          gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
007734  000541          gfx_Cls() ;
007735  000542          DoGFXObjects() ;                                    // display GFX 'widgets'
007736  000543      endif
007737  000544        
007738  000545      // enable inputs
007739  000546      for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
007740  000547          j := img_GetWord(hndl, i, IMAGE_TAG) ;
007741  000548          if (j)
007742  000549              j-- ;
007743  000550              img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
007744  000551              //if (j != tKeyboard)
007745  000552              if (img_GetWord(hndl, i, IMAGE_INDEX) != 0xffff)
007746  000553              if (((j <= tWinButton) || (j >= t4Dbutton)) && (j != tSmartGauge) )               // enable inputs
007747  000554                  img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
007748  000555              endif
007749  000556              img_Show(hndl,i) ; // show initialy, if required
007750  000557              endif
007751  000558              if (j == tForm)
007752  000559                  DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
007753  000560              endif
007754  000561          endif
007755  000562      next
007756  000563        
007757  000564      // enable inputs
007758  000565         var a, f ; 
007759  000576  */
007760  000577      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007761  000578          addressInternalWidget(i, 0) ;
007762  000579          widget_Enable(wp,i) ;
007763  000580          if (GObjectType != tiLabelB) widget_ClearAttributes(wp,i,WIDGET_F_INITIALISED) ; // don't clear initialised for tiLabelB
007764  000581                  j := GObjectRAM[WIDGET_VAL1] ;
007765  000582                  GObjectFunc(j, GObjectRAM, GObjectDATA) ; 
007766  000583      next
007767  000584      for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
007768  000585          if (InternalInputControls[i] != -1)
007769  000586              widget_SetAttributes(wp,i,WIDGET_F_TOUCH_ENABLE) ;
007770  000587          endif
007771  000588      next
007772  000589        
007773  000590      for (i := 0; i < nStrings; i++)
007774  000591          if (stringsCV[i] != -1)
007775  000592              WriteObject(tStrings, i, stringsCV[i]) ;
007776  000593          endif
007777  000594      next
007778  000595        
007779  000596  endfunc
007780  000597        
007781  000598  func UpdateObjects(var newval)
007782  000599      var IPidx, otherOBJ, oldvalue ;
007783  000600      if (GObjectType < tiLedDigitsH)
007784  000601          oldvalue := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ;
007785  000602      else
007786  000603          oldvalue := GObjectRAM[WIDGET_VAL1] ;
007787  000604      endif
007788  000605      if ( ( oldvalue != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
007789  000606        
007790  000607      if (GObjectType < tiLedDigitsH)
007791  000608          img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
007792  000609              img_Show(hndl, *(pInputIndex));      // only shows on current form
007793  000610      else
007794  000611          WriteObject(GObjectType, GObjectIdx, newval) ;
007795  000612      endif
007796  000613          if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
007797  000614              if (*(CurInputData+Ofs_IPD_P1))
007798  000615                  newval &= 1;
007799  000616              else
007800  000617                  newval &= 3;
007801  000618              endif
007802  000619              if (newval > 1) newval := 1;
007803  000620          endif
007804  000621          IPidx := *(CurInputData+TouchState) ;
007805  000622          while(IPidx != 0)
007806  000623              otherOBJ := IPidx + InputData;
007807  000624              if (*(otherOBJ) == OT_REPORT)
007808  000625                  SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
007809  000626              else if (*(otherOBJ) == OT_MAGIC)
007810  000627                  IPidx := *(otherOBJ+Ofs_IPD_P5) ;
007811  000628                  IPidx(newval) ;
007812  000629  //            else if (TouchState == *(otherOBJ+Ofs_IPD_P4))  // test prior to Workshop 6.5.0.0
007813  000630              else if ((TouchState == *(otherOBJ+Ofs_IPD_P4)) || (*(CurInputData+Ofs_IPD_P1) && ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))))
007814  000631                  if (*(otherOBJ) == OT_ACTIVATE)
007815  000632                      ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
007816  000633                      GObjectType := tForm ;
007817  000634                  else if (*(otherOBJ) == OT_SETCONST)
007818  000635                      newval := *(otherOBJ+Ofs_IPD_P3) ;
007819  000636                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007820  000637                  else if (*(otherOBJ) == OT_SETANOTHER)
007821  000638                      WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
007822  000639                  else if (*(otherOBJ) == OT_PREVFRAME)
007823  000640                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
007824  000641                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
007825  000642                      endif
007826  000643                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007827  000644                  else if (*(otherOBJ) == OT_NEXTFRAME)
007828  000645                      if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
007829  000646                          WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
007830  000647                      endif
007831  000648                      newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
007832  000649                  else if (*(otherOBJ) == OT_PREVSTRING)
007833  000650                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)])
007834  000651                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]-1) ;
007835  000652                      endif
007836  000653                  else if (*(otherOBJ) == OT_NEXTSTRING)
007837  000654                      if (stringsCV[*(otherOBJ+Ofs_IPD_P2)] < *(otherOBJ+Ofs_IPD_P3)) // fix IPD_P2 not filled in yet
007838  000655                          WriteObject(tStrings,*(otherOBJ+Ofs_IPD_P2),stringsCV[*(otherOBJ+Ofs_IPD_P2)]+1) ;
007839  000656                      endif
007840  000657                  endif
007841  000658              endif
007842  000659              IPidx := *(otherOBJ+TouchState) ;
007843  000660          wend
007844  000661      endif
007845  000662  endfunc
007846  000663        
007847  000664  // End P2.inc
007848  000665  func DoGFXObjects()
007849  000666  endfunc
007850  000667        
007851  000668  // Start P3.inc
007852  000669  func main()
007853  000670      var comTX[50], cmdi, i, j, TouchStatus ;
007854  000671        
007855  000672        
007856  000673      gfx_ScreenMode(LANDSCAPE) ;
007857  000674        
007858  000675      media_InitFlash(FLASH_ADDR_DEF_COMMAND) ;
007859  000676        
007860  000677        
007861  000678  //    gfx_MoveTo(0, 0);
007862  000679  //    print(mem_Heap()," ") ;
007863  000680  //    gfx_TransparentColour(0x0020);
007864  000681  //    gfx_Transparency(ON);
007865  000682        
007866  000683        
007867  000684      // open image control
007868  000685      hndl := file_LoadImageControl(0, 0, 3);
007869  000686        
007870  000687      // init 'constants'
007871  000688  // End P3.inc
007872  000689        
007873  000690      oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
007874  000691      oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
007875  000692      oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
007876  000693      oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
007877  000694      oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
007878  000695      oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
007879  000696      oObjects[tWinButton] := oWinButtons ;
007880  000697      oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
007881  000698      oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
007882  000699      oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
007883  000700      oObjects[tForm] := oForms ;
007884  000701      oObjects[tGauge] := oGauges ;
007885  000702      oObjects[tImage] := oImages ;
007886  000703      oObjects[tKeyboard] := oDipSwitchs ; // dummy as no object there
007887  000704      oObjects[tLed] := oDipSwitchs ; // dummy as no object there
007888  000705      oObjects[tLeddigits] := oDipSwitchs ; // dummy as no object there
007889  000706      oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
007890  000707      oObjects[tStrings] := oStringss ;
007891  000708      oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
007892  000709      oObjects[tUserled] := oUserleds ;
007893  000710      oObjects[tVideo] := oDipSwitchs ; // dummy as no object there
007894  000711      oObjects[tStaticText] := oStaticTexts ;
007895  000712      oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
007896  000713      oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
007897  000714      oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
007898  000715      oObjects[tTank] := oDipSwitchs ; // dummy as no object there
007899  000716      oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
007900  000717      oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
007901  000718      oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
007902  000719      oObjects[t4Dbutton] := oDipSwitchs ; // dummy as no object there
007903  000720      oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
007904  000721      oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
007905  000722      oObjects[tUserButton] := oUserButtons ;
007906  000723      oObjects[tMagicObject] := oDipSwitchs ; // dummy as no object there
007907  000724      oObjects[tSmartGauge] := oDipSwitchs ; // dummy as no object there
007908  000725      oObjects[tSmartSlider] := oDipSwitchs ; // dummy as no object there
007909  000726      oObjects[tSmartKnob] := oDipSwitchs ; // dummy as no object there
007910  000727      oObjects[tiLedDigitsH] := oDipSwitchs ; // dummy as no object there
007911  000728      oObjects[tiAngularMeter] := oiAngularMeters ;
007912  000729      oObjects[tiGauge] := oDipSwitchs ; // dummy as no object there
007913  000730      oObjects[tiLabelB] := oDipSwitchs ; // dummy as no object there
007914  000731      oObjects[tiUserGauge] := oDipSwitchs ; // dummy as no object there
007915  000732      oObjects[tiMediaGauge] := oDipSwitchs ; // dummy as no object there
007916  000733      oObjects[tiMediaThermometer] := oDipSwitchs ; // dummy as no object there
007917  000734      oObjects[tiLed] := oDipSwitchs ; // dummy as no object there
007918  000735      oObjects[tiMediaLed] := oDipSwitchs ; // dummy as no object there
007919  000736      oObjects[tiLedDigits] := oiLedDigitss ;
007920  000737      oObjects[tiNeedle] := oDipSwitchs ; // dummy as no object there
007921  000738      oObjects[tiRuler] := oDipSwitchs ; // dummy as no object there
007922  000739      oObjects[tiLedDigit] := oDipSwitchs ; // dummy as no object there
007923  000740      oObjects[tiButtonD] := oDipSwitchs ; // dummy as no object there
007924  000741      oObjects[tiButtonE] := oDipSwitchs ; // dummy as no object there
007925  000742      oObjects[tiMediaButton] := oDipSwitchs ; // dummy as no object there
007926  000743      oObjects[tiToggleInput] := oDipSwitchs ; // dummy as no object there
007927  000744      oObjects[tiDial] := oDipSwitchs ; // dummy as no object there
007928  000745      oObjects[tiMediaRotary] := oDipSwitchs ; // dummy as no object there
007929  000746      oObjects[tiRotaryInput] := oDipSwitchs ; // dummy as no object there
007930  000747      oObjects[tiSwitch] := oDipSwitchs ; // dummy as no object there
007931  000748      oObjects[tiSwitchB] := oDipSwitchs ; // dummy as no object there
007932  000749      oObjects[tiSliderE] := oDipSwitchs ; // dummy as no object there
007933  000750      oObjects[tiMediaSlider] := oDipSwitchs ; // dummy as no object there
007934  000751      oObjects[tiSliderH] := oDipSwitchs ; // dummy as no object there
007935  000752      oObjects[tiSliderG] := oDipSwitchs ; // dummy as no object there
007936  000753      oObjects[tiSliderF] := oDipSwitchs ; // dummy as no object there
007937  000754      oObjects[tiSliderD] := oDipSwitchs ; // dummy as no object there
007938  000755      oObjects[tiSliderC] := oDipSwitchs ; // dummy as no object there
007939  000756      oObjects[tiLinearInput] := oDipSwitchs ; // dummy as no object there
007940  000757      vObjects[0] := oiviAngularMeter ;
007941  000758      vObjects[8] := oiviLedDigits ;
007942  000759  // Start P4.inc
007943  000760      wp := widget_Create(14) ;
007944  000761      for (i := 0; i < 14; i++)
007945  000762  	addressInternalWidget(i, 0) ;
007946  000763          if (GObjectType != tiLedDigit) widget_Add(wp, i, GObjectRAM) ;    // don't add tiLedDigit objects as they are only 1 word long
007947  000764      next
007948  000765        
007949  000766      // init comms
007950  000767      com_Init(comRX,CMDLenMAX,0);
007951  000768      com_SetBaud(COM0,19886);
007952  000769      com_TXbuffer(comTX, 100, 0);
007953  000770      // tag 'real' objects
007954  000771      for (i := 0; i <= MaxTotObjects; i++)
007955  000772          if (   (i != tSounds)
007956  000773              && (i != tTimer)
007957  000774              && (i != tPinOutput)
007958  000775              && (i != tMagicObject)
007959  000776              && (i != tPinInput) )
007960  000777              TouchXpos := oObjects[i] ;
007961  000778              TouchYpos := *(TouchXpos) ;
007962  000779              for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
007963  000780                  oldn := *(TouchXpos+ImageTouched*2) ;
007964  000781                  img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
007965  000782                  if (oldn != -1)
007966  000783                      img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
007967  000784                      img_Disable(hndl, oldn) ;
007968  000785                  endif
007969  000786              next
007970  000787          endif
007971  000788      next
007972  000789        
007973  000790      // display initial form
007974  000791      CurrentForm := -1 ;
007975  000792  // End P4.inc
007976  000793  // Start P5.inc
007977  000794      ActivateForm(5) ; // need to change this according to first actual form
007978  000795        
007979  000796  // End P5.inc
007980  000797  // Start P6.inc px44
007981  000798      touch_Set(TOUCH_ENABLE);                            // enable the touch screen
007982  000799      oldn := -1 ;
007983  000800      repeat
007984  000801        
007985  000802          // check comms for command, how to NAK invalid command
007986  000803          if (com_Count() != 0)
007987  000804              i := serin() ;
007988  000805              InputCS ^= i ;               // update checksum
007989  000806              if (   (cmdi > 2)
007990  000807                  && (cmd[0] == WRITE_STRU) )
007991  000808                  j := (cmdi-1) >> 1 + 2 ;
007992  000809                  if (j == CMDLenMAX)    // max length exceeded
007993  000810                      nak0() ;
007994  000811                      cmdi := -1 ;
007995  000812                  else if (cmdi & 1)
007996  000813                      cmd[j] := i ;
007997  000814                      if (cmd[2] == 0)    // if string complete
007998  000815                          if (InputCS)
007999  000816                              nak0() ;
008000  000817                          else
008001  000818                              if (cmd[0] == WRITE_STRU)
008002  000819                              cmd[j] := 0 ;                     // terminate it
008003  000820                              PrintStrings(cmd[1], &cmd[3], 1) ;
008004  000821                              serout(ACK) ;
008005  000822                              else
008006  000823                              endif
008007  000824                          endif
008008  000825                          cmdi := -1 ;
008009  000826                      endif
008010  000827                  else
008011  000828                      cmd[j] := cmd[j] << 8 + i ;
008012  000829                      cmd[2]-- ;          // dec length
008013  000830                  endif
008014  000831                  cmdi++ ;
008015  000832              else // not unicode string
008016  000833                  cmd[cmdi++] := i ;
008017  000834                   if ((cmd[0] == WRITE_STR) || (cmd[0] == WRITE_LABEL) )                  // Ansi String or Label
008018  000835                      if (cmdi == CMDLenMAX)      // max length exceeded
008019  000836                          nak0() ;
008020  000837                          cmdi := 0 ;
008021  000838                      else if (cmdi > 2)
008022  000839                          if (cmd[2] == -1)
008023  000840                              if (InputCS)
008024  000841                                  nak0() ;
008025  000842                              else
008026  000843                                  if ((cmd[0] == WRITE_STR) || (cmd[0] == WRITE_LABEL))
008027  000844                                  cmd[cmdi-1] := 0 ;                     // terminate it
008028  000845                                  PrintStrings(cmd[1], &cmd[3], 1) ;
008029  000846                                  serout(ACK) ;
008030  000847                                  else
008031  000848                                  endif
008032  000849                              endif
008033  000850                              cmdi := 0 ;
008034  000851                          else
008035  000852                              cmd[2]-- ;          // dec length
008036  000853                          endif
008037  000854                      endif
008038  000855                  else if (   (cmd[0] == READ_OBJ)
008039  000856                           && (cmdi == 4)         )
008040  000857                      if (InputCS)
008041  000858                          nak0() ;
008042  000859                      else
008043  000860                          ReadObject(cmd[1], cmd[2]) ;
008044  000861                      endif
008045  000862                      cmdi := 0 ;
008046  000863                  else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
008047  000864                           && (cmdi == 6)          )
008048  000865                      if (InputCS)
008049  000866                          nak0() ;
008050  000867                      else
008051  000868                          WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
008052  000869                          serout(ACK) ;
008053  000870                      endif
008054  000871                      cmdi := 0 ;
008055  000872                  else if (   (cmd[0] == WRITE_CONTRAST)
008056  000873                           && (cmdi == 3)         )
008057  000874                      if (InputCS)
008058  000875                          nak0() ;
008059  000876                      else
008060  000877                          gfx_Contrast(cmd[1]) ;
008061  000878                          serout(ACK) ;
008062  000879                      endif
008063  000880                      cmdi := 0 ;
008064  000881                  else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
008065  000882                      nak0() ;
008066  000883                      cmdi := 0 ;
008067  000884                  endif
008068  000885              endif   // not unicode string
008069  000886          endif   // a character is available
008070  000887        
008071  000888        
008072  000889      // touch code processing
008073  000890        
008074  000891          TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
008075  000892          if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
008076  000893              ImageTouched := img_Touched(hndl,-1) ;
008077  000894              if (ImageTouched == -1)
008078  000895                  ImageTouched := widget_Touched(wp, ALL) ;
008079  000896                  if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
008080  000897              endif
008081  000898              if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
008082  000899                  TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
008083  000900              endif
008084  000901              if (TouchStatus != TOUCH_RELEASED)        // if not released
008085  000902                  if (oldn != -1)
008086  000903                      ImageTouched := oldn ;
008087  000904                  else
008088  000905                      if (oldn != ImageTouched)
008089  000906                  oldn := ImageTouched ;
008090  000907                          TouchStatus := TOUCH_PRESSED ;
008091  000908                      endif
008092  000909                  endif
008093  000910                  TouchXpos  := touch_Get(TOUCH_GETX);
008094  000911                  TouchYpos  := touch_Get(TOUCH_GETY);
008095  000912                  TouchState := Ofs_IPD_DOWN ;
008096  000913              else
008097  000914                  ImageTouched := oldn ;                     // simulate release of what we touched
008098  000915                  oldn := -1 ;                    // prevent double release
008099  000916                  TouchState := Ofs_IPD_RELEASE ;
008100  000917              endif
008101  000918              if (ImageTouched >= 0)
008102  000919                          CurInputData := InputControls[ImageTouched] + InputData;
008103  000920                          GObjectType := *(CurInputData) ;
008104  000921                          if (GObjectType == tSmartSlider)
008105  000922                              i := tTrackbar ; // GSlider ;
008106  000923                          else if (GObjectType == tSmartKnob)
008107  000924                              i := tKnob ;
008108  000925                          else if (GObjectType >= t4Dbutton) 
008109  000926                              i := GObjectType - 23 ; // adjust to ensure next in gosub
008110  000927                          else 
008111  000928                              i := GObjectType ;
008112  000929                          endif
008113  000930                          gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
008114  000931                          ImageTouched := -1 ; // show processed here
008115  000932              endif
008116  000933              if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
008117  000934              if (ImageTouched >= 0)
008118  000935  //print(ImageTouched," ") ;
008119  000936  //                        CurInputData := InternalInputControls[ImageTouched] + InternalInputData;
008120  000937                          CurInputData := InternalInputControls[ImageTouched] + InputData;
008121  000938  //                        GObjectType := *(CurInputData) ;
008122  000939  //                        i := GObjectType ;
008123  000940  //                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
008124  000941  //                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
008125  000942                          addressInternalWidget(ImageTouched, 0) ;
008126  000943  //                        i := xobj2iiobj[ImageTouched] ;                            // address object type and hash from ram index
008127  000944  //                        GObjectIdx := i & 0xff ;
008128  000945  //                        GObjectType := (i>>8) ;                                   // extract object type
008129  000946                          if (GObjectType <= tiToggleInput) 
008130  000947                              i := 0 ;
008131  000948                          else if (GObjectType <= tiRotaryInput) 
008132  000949                              i := 1 ;
008133  000950                          else if (GObjectType <= tiSwitchB) 
008134  000951                              i := 2 ;
008135  000952                          else 
008136  000953                              i := 3 ;
008137  000954                          endif
008138  000955  //to(COM0) ; print(i, "\r\n") ;  
008139  000956        
008140  000957                          gosub (i), (ciButton, ciDial, ciSwitch, ciSlider) ;
008141  000958        
008142  000959        
008143  000960  //            ImageTouched := widget_Touched(wp, ALL) ;
008144  000961              endif
008145  000962          endif
008146  000963   //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it
008147  000964        
008148  000965          sys_EventsResume() ;
008149  000966      forever
008150  000967        
008151  000968  ciSwitch:
008152  000969  cDipswitch:
008153  000970        
008154  000971  cKnob:
008155  000972  ciDial:
008156  000973        
008157  000974  cRockerswitch:
008158  000975        
008159  000976  cRotaryswitch:
008160  000977        
008161  000978  cSlider:
008162  000979  cTrackbar:
008163  000980  ciSlider:
008164  000981        
008165  000982  ciButton:
008166  000983        
008167  000984  c4DButton:
008168  000985  cUserButton:
008169  000986  cWinbutton:
008170  000987      pInputIndex := oObjects[GObjectType]  + *(CurInputData+Ofs_IPD_OBJVIDX) ;
008171  000988      i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
008172  000989  CommonButtons:
008173  000990      if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
008174  000991          if (TouchStatus == TOUCH_RELEASED)
008175  000992              i &= 0xfffe ;
008176  000993              TouchState == Ofs_IPD_DOWN ;
008177  000994          else
008178  000995              i |= 1 ;
008179  000996              TouchState == Ofs_IPD_RELEASE ;
008180  000997          endif
008181  000998      else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
008182  000999          if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
008183  001000              if ((i & 3) == 3)
008184  001001                  i &= 0xfffc ;
008185  001002              else
008186  001003                  i++ ;
008187  001004              endif
008188  001005          else
008189  001006              i |= 1 ;                                      // make down regardless of current state
008190  001007          endif
008191  001008      else                        // group action, up all other buttons on touch press, reports 0 for button down
008192  001009          if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
008193  001010              TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
008194  001011          endif
008195  001012          if (GObjectType < tiLedDigits)
008196  001013              i := (i & 0xfffc) | 2 ;         // uSD button, four, grouping and blocking states
008197  001014          else
008198  001015              i := 1 ;                        // Internal button two states
008199  001016          endif
008200  001017      endif
008201  001018        
008202  001019      UpdateObjects(i) ;
008203  001020  endsub ;
008204  001021        
008205  001022  cAniButton:
008206  001023        
008207  001024  cColorPicker:
008208  001025        
008209  001026  endfunc
008210  001027  // End P6.inc
Notice: variable 'GObjectRAM' is being indexed (line 603 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'IPidx' requires 1 argument (line 628 file:SprinterGauge.4DGenieS)
Notice: variable 'GObjectRAM' is being indexed (line 581 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'GObjectFunc' requires 3 arguments (line 582 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'ActivateForm' is never used (line 527 file:SprinterGauge.4DGenieS)
Notice: local var 'a' in func 'ActivateForm' is never used (line 565 file:SprinterGauge.4DGenieS)
Notice: local var 'f' in func 'ActivateForm' is never used (line 565 file:SprinterGauge.4DGenieS)
Notice: local var 'o' in func 'TurnOffButtons' is never used (line 496 file:SprinterGauge.4DGenieS)
Notice: local var 'p' in func 'TurnOffButtons' is never used (line 496 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 427 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 429 file:SprinterGauge.4DGenieS)
Notice: Check that the function called via pointer  'Objects' requires 3 arguments (line 432 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 388 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 390 file:SprinterGauge.4DGenieS)
Notice: variable 'k' is being indexed (line 392 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 347 file:SprinterGauge.4DGenieS)
Notice: variable 'i' is being indexed (line 349 file:SprinterGauge.4DGenieS)
Notice: function argument 'iponly' in func 'addressInternalWidget' is never used (line 338 file:SprinterGauge.4DGenieS)


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXFLASH                           128  0x00000080 (const dword)  (not used)
__MAXMEM                           30290  0x00007652 (const dword)  (usage 1)
__MAXPROG                          32750  0x00007fee (const dword)  (usage 1)
__PLATFORM                             4  0x00000004 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ACK                                    6  0x00000006 (const dword)  (usage 12)
ActivateForm                        6192  0x00001830 (User func) args[1] r=0  (usage 9)
addressInternalWidget               8064  0x00001f80 (User func) args[2] r=0  (usage 9)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (usage 6)
ANALOGUE                               2  0x00000002 (const dword)  (not used)
ANGULAR_bgcol                         66  0x00000042 (const dword)  (not used)
ANGULAR_c1                            24  0x00000018 (const dword)  (not used)
ANGULAR_c2                            26  0x0000001a (const dword)  (not used)
ANGULAR_c3                            28  0x0000001c (const dword)  (not used)
ANGULAR_capcol                        46  0x0000002e (const dword)  (not used)
ANGULAR_capfnt                        44  0x0000002c (const dword)  (not used)
ANGULAR_capofsx                       48  0x00000030 (const dword)  (not used)
ANGULAR_capofsy                       50  0x00000032 (const dword)  (not used)
ANGULAR_Caption                       52  0x00000034 (const dword)  (not used)
ANGULAR_cxx                           62  0x0000003e (const dword)  (not used)
ANGULAR_cyx                           64  0x00000040 (const dword)  (not used)
ANGULAR_F_BG_TRANSPARENT             N/A         N/A (macro)   0x0002   (not used)
ANGULAR_F_LABEL_STRINGS              N/A         N/A (macro)   0x0001   (not used)
ANGULAR_F_TEXT_PCT_COLOUR            N/A         N/A (macro)   0x0008   (not used)
ANGULAR_F_TICK_PCT_COLOUR            N/A         N/A (macro)   0x0004   (not used)
ANGULAR_flags                         42  0x0000002a (const dword)  (not used)
ANGULAR_h                             60  0x0000003c (const dword)  (not used)
ANGULAR_incro                         30  0x0000001e (const dword)  (not used)
ANGULAR_labcol                        36  0x00000024 (const dword)  (not used)
ANGULAR_labfnt                        34  0x00000022 (const dword)  (not used)
ANGULAR_labofs                        38  0x00000026 (const dword)  (not used)
ANGULAR_labs                          32  0x00000020 (const dword)  (not used)
ANGULAR_labstr                        40  0x00000028 (const dword)  (not used)
ANGULAR_maxa                          70  0x00000046 (const dword)  (not used)
ANGULAR_maxv                          74  0x0000004a (const dword)  (not used)
ANGULAR_mina                          68  0x00000044 (const dword)  (not used)
ANGULAR_minv                          72  0x00000048 (const dword)  (not used)
ANGULAR_p1                            20  0x00000014 (const dword)  (not used)
ANGULAR_p2                            22  0x00000016 (const dword)  (not used)
ANGULAR_ri                             2  0x00000002 (const dword)  (not used)
ANGULAR_ro                             0  0x00000000 (const dword)  (not used)
ANGULAR_tc                            18  0x00000012 (const dword)  (not used)
ANGULAR_tcks                           4  0x00000004 (const dword)  (not used)
ANGULAR_tiszl                         12  0x0000000c (const dword)  (not used)
ANGULAR_tiszs                         14  0x0000000e (const dword)  (not used)
ANGULAR_tkl                            6  0x00000006 (const dword)  (not used)
ANGULAR_toszl                          8  0x00000008 (const dword)  (not used)
ANGULAR_toszs                         10  0x0000000a (const dword)  (not used)
ANGULAR_tw                            16  0x00000010 (const dword)  (not used)
ANGULAR_w                             58  0x0000003a (const dword)  (not used)
ANGULAR_x                             54  0x00000036 (const dword)  (not used)
ANGULAR_y                             56  0x00000038 (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                          24  0x00000018 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (usage 3)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 123)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BREAK                              65533  0x0000fffd (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON4_BC0                           12  0x0000000c (const dword)  (not used)
BUTTON4_BC1                           14  0x0000000e (const dword)  (not used)
BUTTON4_BR1                           28  0x0000001c (const dword)  (not used)
BUTTON4_BR2                           30  0x0000001e (const dword)  (not used)
BUTTON4_BRG                           32  0x00000020 (const dword)  (not used)
BUTTON4_CAP                           26  0x0000001a (const dword)  (not used)
BUTTON4_FC0                           28  0x0000001c (const dword)  (not used)
BUTTON4_FC1                           30  0x0000001e (const dword)  (not used)
BUTTON4_FST                           32  0x00000020 (const dword)  (not used)
BUTTON4_FSZ                           34  0x00000022 (const dword)  (not used)
BUTTON4_IB1                           16  0x00000010 (const dword)  (not used)
BUTTON4_IB2                           18  0x00000012 (const dword)  (not used)
BUTTON4_IG0                           20  0x00000014 (const dword)  (not used)
BUTTON4_IG1                           22  0x00000016 (const dword)  (not used)
BUTTON4_OB1                            6  0x00000006 (const dword)  (not used)
BUTTON4_OB2                            8  0x00000008 (const dword)  (not used)
BUTTON4_OBG                           10  0x0000000a (const dword)  (not used)
BUTTON4_rad                            4  0x00000004 (const dword)  (not used)
BUTTON4_TPC                           24  0x00000018 (const dword)  (not used)
BUTTON4_XP                             0  0x00000000 (const dword)  (not used)
BUTTON4_YP                             2  0x00000002 (const dword)  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
c4DButton                         UNRESOLVED  (not used)
C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
cAniButton                        UNRESOLVED  (not used)
cColorPicker                      UNRESOLVED  (not used)
cDipswitch                        UNRESOLVED  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHECKUPDATE_INVALIDFILE                5  0x00000005 (const dword)  (not used)
CHECKUPDATE_NEWFILE                    1  0x00000001 (const dword)  (not used)
CHECKUPDATE_NOFILE                     4  0x00000004 (const dword)  (not used)
CHECKUPDATE_OLDFILE                    2  0x00000002 (const dword)  (not used)
CHECKUPDATE_QUERY                      1  0x00000001 (const dword)  (not used)
CHECKUPDATE_UPDATEALWAYS               3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATEDONE                 3  0x00000003 (const dword)  (not used)
CHECKUPDATE_UPDATENEWER                2  0x00000002 (const dword)  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
ciButton                          UNRESOLVED  (not used)
ciDial                            UNRESOLVED  (not used)
ciSlider                          UNRESOLVED  (not used)
ciSwitch                          UNRESOLVED  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
cKnob                             UNRESOLVED  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
cmd                                  700  0x000002bc (mem) word[80] (global)  (usage 90)
CMDLenMAX                             80  0x00000050 (const dword)  (usage 12)
ColorBGimage                          32  0x00000020 (const dword)  (usage 12)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (usage 3)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_InitBrk                        -427  0xfffffe55 (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferBrk                    -426  0xfffffe56 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 3)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 3)
com_InitBrk                         -417  0xfffffe5f (PmmC func) args[3] r=0  (not used)
com_Mode                            -400  0xfffffe70 (PmmC func) args[4] r=1  (not used)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 3)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (usage 3)
com_TXbufferBrk                     -416  0xfffffe60 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
comRX                                620  0x0000026c (mem) word[40] (global)  (usage 3)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
crc_CSUM_8                          -403  0xfffffe6d (PmmC func) args[2] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
cRockerswitch                     UNRESOLVED  (not used)
cRotaryswitch                     UNRESOLVED  (not used)
cSlider                           UNRESOLVED  (not used)
cTrackbar                         UNRESOLVED  (not used)
CurInputData                         616  0x00000268 (mem) word (global)  (usage 30)
CurrentForm                          602  0x0000025a (mem) word (global)  (usage 63)
cUserButton                       UNRESOLVED  (not used)
cWinbutton                        UNRESOLVED  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIAL_bevColour                        28  0x0000001c (const dword)  (not used)
DIAL_bevColour2                       30  0x0000001e (const dword)  (not used)
DIAL_bevSize                          26  0x0000001a (const dword)  (not used)
DIAL_bgcolour                         22  0x00000016 (const dword)  (not used)
DIAL_capcol                           72  0x00000048 (const dword)  (not used)
DIAL_capfnt                           70  0x00000046 (const dword)  (not used)
DIAL_capofsx                          74  0x0000004a (const dword)  (not used)
DIAL_capofsy                          76  0x0000004c (const dword)  (not used)
DIAL_caption                          78  0x0000004e (const dword)  (not used)
DIAL_colour                           24  0x00000018 (const dword)  (not used)
DIAL_cx                                8  0x00000008 (const dword)  (not used)
DIAL_cy                               10  0x0000000a (const dword)  (not used)
DIAL_F_BG_TRANSPARENT                N/A         N/A (macro)   0x0002   (not used)
DIAL_F_HANDLE_CIRCLE                 N/A         N/A (macro)   0x0000   (not used)
DIAL_F_HANDLE_LINE                   N/A         N/A (macro)   0x0030   (not used)
DIAL_F_HANDLE_RECTANGLE              N/A         N/A (macro)   0x0020   (not used)
DIAL_F_HANDLE_STYLE                  N/A         N/A (macro)   0x00f0   (not used)
DIAL_F_HANDLE_TRIANGLE               N/A         N/A (macro)   0x0010   (not used)
DIAL_F_INDICATOR_CIRCLE              N/A         N/A (macro)   0x0000   (not used)
DIAL_F_INDICATOR_LINE                N/A         N/A (macro)   0x0300   (not used)
DIAL_F_INDICATOR_RECTANGLE           N/A         N/A (macro)   0x0200   (not used)
DIAL_F_INDICATOR_STYLE               N/A         N/A (macro)   0x0f00   (not used)
DIAL_F_INDICATOR_TRIANGLE            N/A         N/A (macro)   0x0100   (not used)
DIAL_F_LABEL_STRINGS                 N/A         N/A (macro)   0x0001   (not used)
DIAL_flags                            80  0x00000050 (const dword)  (not used)
DIAL_h                                 6  0x00000006 (const dword)  (not used)
DIAL_handlecolour                     54  0x00000036 (const dword)  (not used)
DIAL_handlelength                     58  0x0000003a (const dword)  (not used)
DIAL_handlesize                       56  0x00000038 (const dword)  (not used)
DIAL_indc1h                           42  0x0000002a (const dword)  (not used)
DIAL_indc1l                           36  0x00000024 (const dword)  (not used)
DIAL_indc2h                           44  0x0000002c (const dword)  (not used)
DIAL_indc2l                           38  0x00000026 (const dword)  (not used)
DIAL_indc3h                           46  0x0000002e (const dword)  (not used)
DIAL_indc3l                           40  0x00000028 (const dword)  (not used)
DIAL_indlength                        52  0x00000034 (const dword)  (not used)
DIAL_indOffset                        48  0x00000030 (const dword)  (not used)
DIAL_indp1                            32  0x00000020 (const dword)  (not used)
DIAL_indp2                            34  0x00000022 (const dword)  (not used)
DIAL_indsize                          50  0x00000032 (const dword)  (not used)
DIAL_labcolour                        60  0x0000003c (const dword)  (not used)
DIAL_labcount                         66  0x00000042 (const dword)  (not used)
DIAL_labfont                          62  0x0000003e (const dword)  (not used)
DIAL_labofs                           64  0x00000040 (const dword)  (not used)
DIAL_labstr                           68  0x00000044 (const dword)  (not used)
DIAL_maxa                             16  0x00000010 (const dword)  (not used)
DIAL_maxv                             20  0x00000014 (const dword)  (not used)
DIAL_mina                             14  0x0000000e (const dword)  (not used)
DIAL_minv                             18  0x00000012 (const dword)  (not used)
DIAL_rad                              12  0x0000000c (const dword)  (not used)
DIAL_w                                 4  0x00000004 (const dword)  (not used)
DIAL_x                                 0  0x00000000 (const dword)  (not used)
DIAL_y                                 2  0x00000002 (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Busy                           -419  0xfffffe5d (PmmC func) args[0] r=1  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[2] r=1  (not used)
disp_Refresh                        -418  0xfffffe5e (PmmC func) args[0] r=0  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DoGFXObjects                        5445  0x00001545 (User func) args[0] r=0  (usage 6)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
EAST                                   3  0x00000003 (const dword)  (not used)
EAST_MIRRORED                          7  0x00000007 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
ffsEnd32kH                             7  0x00000007 (const dword)  (not used)
ffsEnd32kL                         32768  0x00008000 (const dword)  (not used)
ffsEnd4kH                              7  0x00000007 (const dword)  (not used)
ffsEnd4kL                          20480  0x00005000 (const dword)  (not used)
ffsEnd64kH                             8  0x00000008 (const dword)  (not used)
ffsEnd64kL                             0  0x00000000 (const dword)  (not used)
ffsEndUnits32k                        15  0x0000000f (const dword)  (not used)
ffsEndUnits4k                        117  0x00000075 (const dword)  (not used)
ffsEndUnits64k                         8  0x00000008 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_CheckUpdate                    -344  0xfffffea8 (PmmC func) args[2] r=1  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (not used)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (not used)
file_MountSpeed                     -382  0xfffffe82 (PmmC func) args[1] r=1  (not used)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_RunSpeed                       -408  0xfffffe68 (PmmC func) args[3] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
FLASH_ADDR_ALWAYS_4BYTE            65534  0x0000fffe (const dword)  (not used)
FLASH_ADDR_DEF_COMMAND             65535  0x0000ffff (const dword)  (usage 3)
flash_Block32Erase                  -398  0xfffffe72 (PmmC func) args[0] r=1  (not used)
flash_Block64Erase                  -157  0xffffff63 (PmmC func) args[0] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_Sector4Erase                  -399  0xfffffe71 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FormBGcolors                        3047  0x00000be7FormBGcolors                        3047  0x00000be7 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 14)
FormBGcolors                      UNRESOLVED  (usage 4)
FormEndIndex                         871  0x00000367FormEndIndex                         871  0x00000367 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
FormStartIndex                       857  0x00000359FormStartIndex                       857  0x00000359 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 10)
FormStartIndex                    UNRESOLVED  (usage 2)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAUGE_COLOR                           18  0x00000012 (const dword)  (not used)
GAUGE_F_HORZ                         N/A         N/A (macro)    0x0002   (not used)
GAUGE_F_TOPRIGHT                     N/A         N/A (macro)    0x0001   (not used)
GAUGE_FLAGS                           36  0x00000024 (const dword)  (not used)
GAUGE_H                                6  0x00000006 (const dword)  (not used)
GAUGE_MAXV                            12  0x0000000c (const dword)  (not used)
GAUGE_MINV                            10  0x0000000a (const dword)  (not used)
GAUGE_P1                              34  0x00000022 (const dword)  (not used)
GAUGE_P1H                             22  0x00000016 (const dword)  (not used)
GAUGE_P1L                             20  0x00000014 (const dword)  (not used)
GAUGE_P2                              32  0x00000020 (const dword)  (not used)
GAUGE_P2H                             26  0x0000001a (const dword)  (not used)
GAUGE_P2L                             24  0x00000018 (const dword)  (not used)
GAUGE_P3H                             30  0x0000001e (const dword)  (not used)
GAUGE_P3L                             28  0x0000001c (const dword)  (not used)
GAUGE_SPACING                         16  0x00000010 (const dword)  (not used)
GAUGE_T                                8  0x00000008 (const dword)  (not used)
GAUGE_TICKH                           14  0x0000000e (const dword)  (not used)
GAUGE_W                                4  0x00000004 (const dword)  (not used)
GAUGE_X                                0  0x00000000 (const dword)  (not used)
GAUGE_Y                                2  0x00000002 (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_AngularMeter                    -312  0xfffffec8 (PmmC func) args[3] r=0  (usage 3)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
gfx_BlitSprite                      -304  0xfffffed0 (PmmC func) args[6] r=0  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
gfx_Button4                         -340  0xfffffeac (PmmC func) args[3] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 12)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 6)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 3)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (usage 3)
gfx_Dial                            -315  0xfffffec5 (PmmC func) args[3] r=0  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Gauge                           -316  0xfffffec4 (PmmC func) args[3] r=0  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
gfx_Gradient                        -346  0xfffffea6 (PmmC func) args[7] r=0  (not used)
gfx_GradientColor                   -405  0xfffffe6b (PmmC func) args[6] r=1  (not used)
gfx_GradientShape                   -404  0xfffffe6c (PmmC func) args[19] r=0  (not used)
gfx_GradTriangleFilled              -406  0xfffffe6a (PmmC func) args[12] r=0  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
gfx_Led                             -341  0xfffffeab (PmmC func) args[3] r=0  (not used)
gfx_LedDigit                        -319  0xfffffec1 (PmmC func) args[6] r=0  (not used)
gfx_LedDigits                       -318  0xfffffec2 (PmmC func) args[3] r=0  (usage 3)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_Needle                          -314  0xfffffec6 (PmmC func) args[3] r=0  (not used)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_Panel2                          -313  0xfffffec7 (PmmC func) args[10] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
gfx_ReadGRAMarea                    -305  0xfffffecf (PmmC func) args[5] r=1  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 9)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_RingSegment                     -311  0xfffffec9 (PmmC func) args[7] r=0  (not used)
gfx_RoundGradient                   -317  0xfffffec3 (PmmC func) args[8] r=0  (not used)
gfx_RoundRect                       -320  0xfffffec0 (PmmC func) args[6] r=0  (not used)
gfx_RulerGauge                      -343  0xfffffea9 (PmmC func) args[3] r=0  (not used)
gfx_Scale                           -342  0xfffffeaa (PmmC func) args[2] r=0  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
gfx_Slider5                         -337  0xfffffeaf (PmmC func) args[3] r=0  (not used)
gfx_SpriteSet                       -303  0xfffffed1 (PmmC func) args[3] r=0  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
gfx_Surround                        -338  0xfffffeae (PmmC func) args[7] r=0  (not used)
gfx_Switch                          -339  0xfffffead (PmmC func) args[3] r=0  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
gfx_WriteGRAMarea                   -306  0xfffffece (PmmC func) args[5] r=0  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
gfx_XYlinToVal                      -380  0xfffffe84 (PmmC func) args[7] r=1  (not used)
gfx_XYrotToVal                      -379  0xfffffe85 (PmmC func) args[7] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
gfxInternals                           7  0x00000007gfxInternals                           7  0x00000007 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
gfxIntParms                           65  0x00000041gfxIntParms                           65  0x00000041 (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
gfxIntStrings                        123  0x0000007bgfxIntStrings                        123  0x0000007b (mem) word[29] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GObjectDATA                          460  0x000001cc (mem) word (global)  (usage 6)
GObjectFunc                          456  0x000001c8 (mem) word (global)  (usage 6)
GObjectIdx                           454  0x000001c6 (mem) word (global)  (usage 21)
GObjectParms                         462  0x000001ce (mem) word (global)  (usage 3)
GObjectRAM                           458  0x000001ca (mem) word (global)  (usage 15)
GObjectStrings                       464  0x000001d0 (mem) word (global)  (usage 3)
GObjectType                          612  0x00000264 (mem) word (global)  (usage 90)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAD_DOWN                             32  0x00000020 (const dword)  (not used)
GRAD_LEFT                             80  0x00000050 (const dword)  (not used)
GRAD_RIGHT                            48  0x00000030 (const dword)  (not used)
GRAD_UP                               64  0x00000040 (const dword)  (not used)
GRAD_WAVE_HOR                        112  0x00000070 (const dword)  (not used)
GRAD_WAVE_VER                         96  0x00000060 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (usage 12)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 162)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
hstrings                             396  0x0000018c (mem) word (global)Notice: global var 'hstrings' is never used
  (not used)
I2C1                               63520  0x0000f820 (const dword)  (not used)
I2C1_Ack                            -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C1_AckPoll                        -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C1_AckStatus                      -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C1_Close                          -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C1_Getn                           -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C1_Gets                           -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C1_Idle                           -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C1_Nack                           -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C1_Open                           -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C1_Putn                           -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C1_Puts                           -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C1_Read                           -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C1_Restart                        -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C1_Start                          -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C1_Stop                           -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C1_Write                          -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I2C2                               63521  0x0000f821 (const dword)  (not used)
I2C2_Ack                            -361  0xfffffe97 (PmmC func) args[0] r=0  (not used)
I2C2_AckPoll                        -367  0xfffffe91 (PmmC func) args[1] r=1  (not used)
I2C2_AckStatus                      -365  0xfffffe93 (PmmC func) args[0] r=1  (not used)
I2C2_Close                          -349  0xfffffea3 (PmmC func) args[0] r=0  (not used)
I2C2_Getn                           -373  0xfffffe8b (PmmC func) args[2] r=1  (not used)
I2C2_Gets                           -371  0xfffffe8d (PmmC func) args[2] r=1  (not used)
I2C2_Idle                           -369  0xfffffe8f (PmmC func) args[0] r=1  (not used)
I2C2_Nack                           -363  0xfffffe95 (PmmC func) args[0] r=0  (not used)
I2C2_Open                           -347  0xfffffea5 (PmmC func) args[1] r=1  (not used)
I2C2_Putn                           -377  0xfffffe87 (PmmC func) args[2] r=1  (not used)
I2C2_Puts                           -375  0xfffffe89 (PmmC func) args[1] r=1  (not used)
I2C2_Read                           -357  0xfffffe9b (PmmC func) args[0] r=1  (not used)
I2C2_Restart                        -355  0xfffffe9d (PmmC func) args[0] r=1  (not used)
I2C2_Start                          -351  0xfffffea1 (PmmC func) args[0] r=1  (not used)
I2C2_Stop                           -353  0xfffffe9f (PmmC func) args[0] r=1  (not used)
I2C2_Write                          -359  0xfffffe99 (PmmC func) args[1] r=1  (not used)
I2C3                               63522  0x0000f822 (const dword)  (not used)
I2C3_Ack                            -362  0xfffffe96 (PmmC func) args[0] r=0  (not used)
I2C3_AckPoll                        -368  0xfffffe90 (PmmC func) args[1] r=1  (not used)
I2C3_AckStatus                      -366  0xfffffe92 (PmmC func) args[0] r=1  (not used)
I2C3_Close                          -350  0xfffffea2 (PmmC func) args[0] r=0  (not used)
I2C3_Getn                           -374  0xfffffe8a (PmmC func) args[2] r=1  (not used)
I2C3_Gets                           -372  0xfffffe8c (PmmC func) args[2] r=1  (not used)
I2C3_Idle                           -370  0xfffffe8e (PmmC func) args[0] r=1  (not used)
I2C3_Nack                           -364  0xfffffe94 (PmmC func) args[0] r=0  (not used)
I2C3_Open                           -348  0xfffffea4 (PmmC func) args[1] r=1  (not used)
I2C3_Putn                           -378  0xfffffe86 (PmmC func) args[2] r=1  (not used)
I2C3_Puts                           -376  0xfffffe88 (PmmC func) args[1] r=1  (not used)
I2C3_Read                           -358  0xfffffe9a (PmmC func) args[0] r=1  (not used)
I2C3_Restart                        -356  0xfffffe9c (PmmC func) args[0] r=1  (not used)
I2C3_Start                          -352  0xfffffea0 (PmmC func) args[0] r=1  (not used)
I2C3_Stop                           -354  0xfffffe9e (PmmC func) args[0] r=1  (not used)
I2C3_Write                          -360  0xfffffe98 (PmmC func) args[1] r=1  (not used)
I2C_CLOCK_STRETCHING               32768  0x00008000 (const dword)  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2CS_Close                          -410  0xfffffe66 (PmmC func) args[0] r=0  (not used)
I2CS_Count                          -412  0xfffffe64 (PmmC func) args[0] r=1  (not used)
I2CS_Open                           -409  0xfffffe67 (PmmC func) args[6] r=0  (not used)
I2CS_Overflow                       -415  0xfffffe61 (PmmC func) args[0] r=1  (not used)
I2CS_Read                           -413  0xfffffe63 (PmmC func) args[0] r=1  (not used)
I2CS_Release                        -414  0xfffffe62 (PmmC func) args[0] r=0  (not used)
I2CS_Write                          -411  0xfffffe65 (PmmC func) args[1] r=0  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (usage 6)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (usage 3)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 12)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
IFONT_OFFSET                          37  0x00000025 (const dword)  (not used)
iFontStrings10                        36  0x00000024 (const ??? 0)  (usage 46)
iFontStrings2                         35  0x00000023 (const ??? 0)  (usage 16)
iFontStrings8                         37  0x00000025 (const ??? 0)  (usage 12)
iForm5                                27  0x0000001b (const ??? 0)  (usage 3)
iFormEndIndex                        899  0x00000383iFormEndIndex                        899  0x00000383 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iFormStartIndex                      885  0x00000375iFormStartIndex                      885  0x00000375 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
iGauge0                                1  0x00000001 (const ??? 0)  (usage 3)
iGauge1                               10  0x0000000a (const ??? 0)  (usage 3)
iGauge2                               11  0x0000000b (const ??? 0)  (usage 3)
iGauge3                               12  0x0000000c (const ??? 0)  (usage 3)
iIAngularMeter0                        0  0x00000000 (const ??? 0)  (not used)
IIAngularMeter0                      237  0x000000edIIAngularMeter0                      237  0x000000ed (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter1                        1  0x00000001 (const ??? 0)  (not used)
IIAngularMeter1                      338  0x00000152IIAngularMeter1                      338  0x00000152 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter2                        6  0x00000006 (const ??? 0)  (not used)
IIAngularMeter2                      603  0x0000025bIIAngularMeter2                      603  0x0000025b (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iIAngularMeter3                        2  0x00000002 (const ??? 0)  (not used)
IIAngularMeter3                      438  0x000001b6IIAngularMeter3                      438  0x000001b6 (mem) word[48] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits0                          13  0x0000000d (const ??? 0)  (not used)
IILedDigits0                         835  0x00000343IILedDigits0                         835  0x00000343 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits1                           3  0x00000003 (const ??? 0)  (not used)
IILedDigits1                         537  0x00000219IILedDigits1                         537  0x00000219 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits2                           4  0x00000004 (const ??? 0)  (not used)
IILedDigits2                         559  0x0000022fIILedDigits2                         559  0x0000022f (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits3                           5  0x00000005 (const ??? 0)  (not used)
IILedDigits3                         581  0x00000245IILedDigits3                         581  0x00000245 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits4                           7  0x00000007 (const ??? 0)  (not used)
IILedDigits4                         703  0x000002bfIILedDigits4                         703  0x000002bf (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits5                          11  0x0000000b (const ??? 0)  (not used)
IILedDigits5                         791  0x00000317IILedDigits5                         791  0x00000317 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits6                           8  0x00000008 (const ??? 0)  (not used)
IILedDigits6                         725  0x000002d5IILedDigits6                         725  0x000002d5 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits7                           9  0x00000009 (const ??? 0)  (not used)
IILedDigits7                         747  0x000002ebIILedDigits7                         747  0x000002eb (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits8                          10  0x0000000a (const ??? 0)  (not used)
IILedDigits8                         769  0x00000301IILedDigits8                         769  0x00000301 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iILedDigits9                          12  0x0000000c (const ??? 0)  (not used)
IILedDigits9                         813  0x0000032dIILedDigits9                         813  0x0000032d (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iImage0                                0  0x00000000 (const ??? 0)  (usage 3)
iImage1                                2  0x00000002 (const ??? 0)  (usage 3)
iImage10                              13  0x0000000d (const ??? 0)  (usage 3)
iImage3                                3  0x00000003 (const ??? 0)  (usage 3)
iImage4                                4  0x00000004 (const ??? 0)  (usage 3)
iImage5                                6  0x00000006 (const ??? 0)  (usage 3)
iImage6                                5  0x00000005 (const ??? 0)  (usage 3)
iImage7                                7  0x00000007 (const ??? 0)  (usage 3)
iImage8                                8  0x00000008 (const ??? 0)  (usage 3)
iImage9                                9  0x00000009 (const ??? 0)  (usage 3)
ILINEARIP_COLOR1                      12  0x0000000c (const dword)  (not used)
ILINEARIP_COLOR2                      14  0x0000000e (const dword)  (not used)
ILINEARIP_COLOR3                      16  0x00000010 (const dword)  (not used)
ILINEARIP_COLOR4                      18  0x00000012 (const dword)  (not used)
ILINEARIP_COLOR5                      20  0x00000014 (const dword)  (not used)
ILINEARIP_COLOR6                      22  0x00000016 (const dword)  (not used)
ILINEARIP_H                            6  0x00000006 (const dword)  (not used)
ILINEARIP_INDEX                        8  0x00000008 (const dword)  (not used)
ILINEARIP_MAXVAL                      42  0x0000002a (const dword)  (not used)
ILINEARIP_MINVAL                      44  0x0000002c (const dword)  (not used)
ILINEARIP_OFFSET_BR                   46  0x0000002e (const dword)  (not used)
ILINEARIP_OFFSET_TL                   48  0x00000030 (const dword)  (not used)
ILINEARIP_ORIENTATION                 10  0x0000000a (const dword)  (not used)
ILINEARIP_TEXT1                       36  0x00000024 (const dword)  (not used)
ILINEARIP_TEXT2                       38  0x00000026 (const dword)  (not used)
ILINEARIP_TEXT3                       40  0x00000028 (const dword)  (not used)
ILINEARIP_VALUE1                      24  0x00000018 (const dword)  (not used)
ILINEARIP_VALUE2                      26  0x0000001a (const dword)  (not used)
ILINEARIP_VALUE3                      28  0x0000001c (const dword)  (not used)
ILINEARIP_VALUE4                      30  0x0000001e (const dword)  (not used)
ILINEARIP_VALUE5                      32  0x00000020 (const dword)  (not used)
ILINEARIP_VALUE6                      34  0x00000022 (const dword)  (not used)
ILINEARIP_W                            4  0x00000004 (const dword)  (not used)
ILINEARIP_X                            0  0x00000000 (const dword)  (not used)
ILINEARIP_Y                            2  0x00000002 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (usage 3)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (usage 6)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 57)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (usage 9)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (usage 6)
IMAGE_XPOS                             2  0x00000002 (const dword)  (usage 12)
IMAGE_YPOS                             3  0x00000003 (const dword)  (usage 12)
ImageTouched                         606  0x0000025e (mem) word (global)  (usage 72)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 6)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (usage 6)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
img_FileCheckUpdate                 -397  0xfffffe73 (PmmC func) args[3] r=1  (not used)
img_FileExec                        -394  0xfffffe76 (PmmC func) args[3] r=1  (not used)
img_FileGetC                        -388  0xfffffe7c (PmmC func) args[2] r=1  (usage 3)
img_FileGetS                        -390  0xfffffe7a (PmmC func) args[4] r=1  (not used)
img_FileGetW                        -389  0xfffffe7b (PmmC func) args[2] r=1  (usage 3)
img_FileIndex                       -385  0xfffffe7f (PmmC func) args[5] r=1  (not used)
img_FileLoadFunction                -392  0xfffffe78 (PmmC func) args[2] r=1  (not used)
img_FilePlayWAV                     -395  0xfffffe75 (PmmC func) args[2] r=1  (not used)
img_FileRead                        -383  0xfffffe81 (PmmC func) args[4] r=1  (not used)
img_FileRewind                      -391  0xfffffe79 (PmmC func) args[2] r=1  (not used)
img_FileRun                         -393  0xfffffe77 (PmmC func) args[3] r=1  (not used)
img_FileSeek                        -384  0xfffffe80 (PmmC func) args[4] r=1  (usage 3)
img_FileSize                        -387  0xfffffe7d (PmmC func) args[4] r=1  (not used)
img_FileTell                        -386  0xfffffe7e (PmmC func) args[4] r=1  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
img_FunctionCall                    -401  0xfffffe6f (PmmC func) args[7] r=1  (not used)
img_FunctionFreeCache               -402  0xfffffe6e (PmmC func) args[1] r=0  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (usage 87)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (usage 9)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 18)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 21)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
img_TxtFontID                       -396  0xfffffe74 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
InputControls                        913  0x00000391InputControls                        913  0x00000391 (mem) word[35] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
InputCS                              860  0x0000035c (mem) word (global)  (usage 21)
InputData                           1011  0x000003f3InputData                           1011  0x000003f3 (mem) word[396] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 33)
InternalInputControls                983  0x000003d7InternalInputControls                983  0x000003d7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 6)
intflash_Copy                       -422  0xfffffe5a (PmmC func) args[3] r=1  (not used)
intflash_FunctionCall               -424  0xfffffe58 (PmmC func) args[7] r=1  (not used)
intflash_FunctionFreeCache          -425  0xfffffe57 (PmmC func) args[1] r=0  (not used)
intflash_GetByte                    -420  0xfffffe5c (PmmC func) args[1] r=1  (not used)
intflash_GetWord                    -421  0xfffffe5b (PmmC func) args[1] r=1  (not used)
intflash_WriteBlock                 -423  0xfffffe59 (PmmC func) args[2] r=1  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO10_PIN                              10  0x0000000a (const dword)  (not used)
IO11_PIN                              11  0x0000000b (const dword)  (not used)
IO12_PIN                              12  0x0000000c (const dword)  (not used)
IO13_PIN                              13  0x0000000d (const dword)  (not used)
IO14_PIN                              14  0x0000000e (const dword)  (not used)
IO15_PIN                              15  0x0000000f (const dword)  (not used)
IO16_PIN                              16  0x00000010 (const dword)  (not used)
IO17_PIN                              17  0x00000011 (const dword)  (not used)
IO18_PIN                              18  0x00000012 (const dword)  (not used)
IO19_PIN                              19  0x00000013 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
IO6_PIN                                6  0x00000006 (const dword)  (not used)
IO7_PIN                                7  0x00000007 (const dword)  (not used)
IO8_PIN                                8  0x00000008 (const dword)  (not used)
IO9_PIN                                9  0x00000009 (const dword)  (not used)
IPDatasize                            22  0x00000016 (const dword)  (usage 3)
IROTARYIP_COLOR1                      10  0x0000000a (const dword)  (not used)
IROTARYIP_COLOR2                      12  0x0000000c (const dword)  (not used)
IROTARYIP_COLOR3                      14  0x0000000e (const dword)  (not used)
IROTARYIP_COLOR4                      16  0x00000010 (const dword)  (not used)
IROTARYIP_COLOR5                      18  0x00000012 (const dword)  (not used)
IROTARYIP_COLOR6                      20  0x00000014 (const dword)  (not used)
IROTARYIP_H                            6  0x00000006 (const dword)  (not used)
IROTARYIP_INDEX                        8  0x00000008 (const dword)  (not used)
IROTARYIP_MAXANGLE                    40  0x00000028 (const dword)  (not used)
IROTARYIP_MAXVALUE                    42  0x0000002a (const dword)  (not used)
IROTARYIP_MINANGLE                    44  0x0000002c (const dword)  (not used)
IROTARYIP_MINVALUE                    46  0x0000002e (const dword)  (not used)
IROTARYIP_TEXT1                       34  0x00000022 (const dword)  (not used)
IROTARYIP_TEXT2                       36  0x00000024 (const dword)  (not used)
IROTARYIP_TEXT3                       38  0x00000026 (const dword)  (not used)
IROTARYIP_VALUE1                      22  0x00000016 (const dword)  (not used)
IROTARYIP_VALUE2                      24  0x00000018 (const dword)  (not used)
IROTARYIP_VALUE3                      26  0x0000001a (const dword)  (not used)
IROTARYIP_VALUE4                      28  0x0000001c (const dword)  (not used)
IROTARYIP_VALUE5                      30  0x0000001e (const dword)  (not used)
IROTARYIP_VALUE6                      32  0x00000020 (const dword)  (not used)
IROTARYIP_W                            4  0x00000004 (const dword)  (not used)
IROTARYIP_X                            0  0x00000000 (const dword)  (not used)
IROTARYIP_Y                            2  0x00000002 (const dword)  (not used)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStatictext0                          28  0x0000001c (const ??? 0)  (usage 3)
iStrings0                           1803  0x0000070biStrings0                           1803  0x0000070b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings1                           1831  0x00000727iStrings1                           1831  0x00000727 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings10                          2083  0x00000823iStrings10                          2083  0x00000823 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings11                          2111  0x0000083fiStrings11                          2111  0x0000083f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings12                          2139  0x0000085biStrings12                          2139  0x0000085b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings13                          2167  0x00000877iStrings13                          2167  0x00000877 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings14                          2195  0x00000893iStrings14                          2195  0x00000893 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings15                          2223  0x000008afiStrings15                          2223  0x000008af (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings16                          2251  0x000008cbiStrings16                          2251  0x000008cb (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings17                          2279  0x000008e7iStrings17                          2279  0x000008e7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings18                          2307  0x00000903iStrings18                          2307  0x00000903 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings19                          2335  0x0000091fiStrings19                          2335  0x0000091f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings2                           1859  0x00000743iStrings2                           1859  0x00000743 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings20                          2363  0x0000093biStrings20                          2363  0x0000093b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings21                          2391  0x00000957iStrings21                          2391  0x00000957 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings22                          2419  0x00000973iStrings22                          2419  0x00000973 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings23                          2447  0x0000098fiStrings23                          2447  0x0000098f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings24                          2475  0x000009abiStrings24                          2475  0x000009ab (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings25                          2503  0x000009c7iStrings25                          2503  0x000009c7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings26                          2531  0x000009e3iStrings26                          2531  0x000009e3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings27                          2559  0x000009ffiStrings27                          2559  0x000009ff (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings28                          2587  0x00000a1biStrings28                          2587  0x00000a1b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings29                          2615  0x00000a37iStrings29                          2615  0x00000a37 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings3                           1887  0x0000075fiStrings3                           1887  0x0000075f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings30                          2643  0x00000a53iStrings30                          2643  0x00000a53 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings31                          2671  0x00000a6fiStrings31                          2671  0x00000a6f (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings32                          2699  0x00000a8biStrings32                          2699  0x00000a8b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings33                          2727  0x00000aa7iStrings33                          2727  0x00000aa7 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings34                          2755  0x00000ac3iStrings34                          2755  0x00000ac3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings35                          2783  0x00000adfiStrings35                          2783  0x00000adf (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings36                          2811  0x00000afbiStrings36                          2811  0x00000afb (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings4                           1915  0x0000077biStrings4                           1915  0x0000077b (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings5                           1943  0x00000797iStrings5                           1943  0x00000797 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings6                           1971  0x000007b3iStrings6                           1971  0x000007b3 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings7                           1999  0x000007cfiStrings7                           1999  0x000007cf (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings8                           2027  0x000007ebiStrings8                           2027  0x000007eb (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
iStrings9                           2055  0x00000807iStrings9                           2055  0x00000807 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iTextStrings                          38  0x00000026 (const ??? 0)  (usage 9)
ITOGGLEIP_COLOR1                      10  0x0000000a (const dword)  (not used)
ITOGGLEIP_COLOR2                      12  0x0000000c (const dword)  (not used)
ITOGGLEIP_COLOR3                      14  0x0000000e (const dword)  (not used)
ITOGGLEIP_COLOR4                      16  0x00000010 (const dword)  (not used)
ITOGGLEIP_COLOR5                      18  0x00000012 (const dword)  (not used)
ITOGGLEIP_COLOR6                      20  0x00000014 (const dword)  (not used)
ITOGGLEIP_H                            6  0x00000006 (const dword)  (not used)
ITOGGLEIP_INDEX                        8  0x00000008 (const dword)  (not used)
ITOGGLEIP_MATRIX                      40  0x00000028 (const dword)  (not used)
ITOGGLEIP_MOMENTARY                   42  0x0000002a (const dword)  (not used)
ITOGGLEIP_TEXT1                       34  0x00000022 (const dword)  (not used)
ITOGGLEIP_TEXT2                       36  0x00000024 (const dword)  (not used)
ITOGGLEIP_TEXT3                       38  0x00000026 (const dword)  (not used)
ITOGGLEIP_VALUE1                      22  0x00000016 (const dword)  (not used)
ITOGGLEIP_VALUE2                      24  0x00000018 (const dword)  (not used)
ITOGGLEIP_VALUE3                      26  0x0000001a (const dword)  (not used)
ITOGGLEIP_VALUE4                      28  0x0000001c (const dword)  (not used)
ITOGGLEIP_VALUE5                      30  0x0000001e (const dword)  (not used)
ITOGGLEIP_VALUE6                      32  0x00000020 (const dword)  (not used)
ITOGGLEIP_W                            4  0x00000004 (const dword)  (not used)
ITOGGLEIP_X                            0  0x00000000 (const dword)  (not used)
ITOGGLEIP_Y                            2  0x00000002 (const dword)  (not used)
iUserbutton0                          16  0x00000010 (const ??? 0)  (usage 3)
iUserbutton1                          14  0x0000000e (const ??? 0)  (usage 3)
iUserbutton10                         20  0x00000014 (const ??? 0)  (usage 3)
iUserbutton11                         24  0x00000018 (const ??? 0)  (usage 3)
iUserbutton2                          34  0x00000022 (const ??? 0)  (usage 3)
iUserbutton3                          18  0x00000012 (const ??? 0)  (usage 3)
iUserbutton4                          21  0x00000015 (const ??? 0)  (usage 3)
iUserbutton5                          17  0x00000011 (const ??? 0)  (usage 3)
iUserbutton6                          25  0x00000019 (const ??? 0)  (usage 3)
iUserbutton7                          26  0x0000001a (const ??? 0)  (usage 3)
iUserbutton8                          19  0x00000013 (const ??? 0)  (usage 3)
iUserbutton9                          29  0x0000001d (const ??? 0)  (usage 3)
IUSERGAUGE_COLOR1                     10  0x0000000a (const dword)  (not used)
IUSERGAUGE_COLOR2                     12  0x0000000c (const dword)  (not used)
IUSERGAUGE_COLOR3                     14  0x0000000e (const dword)  (not used)
IUSERGAUGE_COLOR4                     16  0x00000010 (const dword)  (not used)
IUSERGAUGE_COLOR5                     18  0x00000012 (const dword)  (not used)
IUSERGAUGE_COLOR6                     20  0x00000014 (const dword)  (not used)
IUSERGAUGE_H                           6  0x00000006 (const dword)  (not used)
IUSERGAUGE_INDEX                       8  0x00000008 (const dword)  (not used)
IUSERGAUGE_TEXT1                      34  0x00000022 (const dword)  (not used)
IUSERGAUGE_TEXT2                      36  0x00000024 (const dword)  (not used)
IUSERGAUGE_TEXT3                      38  0x00000026 (const dword)  (not used)
IUSERGAUGE_VALUE1                     22  0x00000016 (const dword)  (not used)
IUSERGAUGE_VALUE2                     24  0x00000018 (const dword)  (not used)
IUSERGAUGE_VALUE3                     26  0x0000001a (const dword)  (not used)
IUSERGAUGE_VALUE4                     28  0x0000001c (const dword)  (not used)
IUSERGAUGE_VALUE5                     30  0x0000001e (const dword)  (not used)
IUSERGAUGE_VALUE6                     32  0x00000020 (const dword)  (not used)
IUSERGAUGE_W                           4  0x00000004 (const dword)  (not used)
IUSERGAUGE_X                           0  0x00000000 (const dword)  (not used)
IUSERGAUGE_Y                           2  0x00000002 (const dword)  (not used)
iUserled0                             15  0x0000000f (const ??? 0)  (usage 3)
IVORY                              65534  0x0000fffe (const dword)  (not used)
iWinbutton0                           22  0x00000016 (const ??? 0)  (usage 3)
iWinbutton1                           23  0x00000017 (const ??? 0)  (usage 3)
iWinbutton2                           30  0x0000001e (const ??? 0)  (usage 3)
iWinbutton3                           31  0x0000001f (const ??? 0)  (usage 3)
iWinbutton4                           32  0x00000020 (const ??? 0)  (usage 3)
iWinbutton5                           33  0x00000021 (const ??? 0)  (usage 3)
JOY_BTNA                               6  0x00000006 (const dword)  (not used)
JOY_BTNB                               5  0x00000005 (const dword)  (not used)
JOY_DOWN                               3  0x00000003 (const dword)  (not used)
JOY_FIRE                               5  0x00000005 (const dword)  (not used)
JOY_LEFT                               2  0x00000002 (const dword)  (not used)
JOY_RELEASED                           0  0x00000000 (const dword)  (not used)
JOY_RIGHT                              4  0x00000004 (const dword)  (not used)
JOY_UP                                 1  0x00000001 (const dword)  (not used)
joystick                            -310  0xfffffeca (PmmC func) args[1] r=1  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
kKeyboardKeystrokes                 3061  0x00000bf5kKeyboardKeystrokes                 3061  0x00000bf5 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LED1_cbe                              10  0x0000000a (const dword)  (not used)
LED1_cbs                               8  0x00000008 (const dword)  (not used)
LED1_cOff                             16  0x00000010 (const dword)  (not used)
LED1_cOn                              14  0x0000000e (const dword)  (not used)
LED1_cs                               12  0x0000000c (const dword)  (not used)
LED1_h                                 6  0x00000006 (const dword)  (not used)
LED1_iBr                              18  0x00000012 (const dword)  (not used)
LED1_iLr                              22  0x00000016 (const dword)  (not used)
LED1_oBr                              20  0x00000014 (const dword)  (not used)
LED1_oLr                              24  0x00000018 (const dword)  (not used)
LED1_sh                               26  0x0000001a (const dword)  (not used)
LED1_w                                 4  0x00000004 (const dword)  (not used)
LED1_x                                 0  0x00000000 (const dword)  (not used)
LED1_y                                 2  0x00000002 (const dword)  (not used)
LEDDIGIT_F_DP_COMMA                  N/A         N/A (macro)   0x0400   (not used)
LEDDIGIT_F_DP_ON                     N/A         N/A (macro)   0x0200   (not used)
LEDDIGIT_F_SET_SEGMENTS              N/A         N/A (macro)   0x1000   (not used)
LEDDIGIT_F_SHOW_DP                   N/A         N/A (macro)   0x0800   (not used)
LEDDIGITS_decimals                    10  0x0000000a (const dword)  (not used)
LEDDIGITS_digits                       8  0x00000008 (const dword)  (not used)
LEDDIGITS_digsize                     14  0x0000000e (const dword)  (not used)
LEDDIGITS_F_DP_COMMA                 N/A         N/A (macro)   0x0040   (not used)
LEDDIGITS_F_DP_DOT                   N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_FIXED                    N/A         N/A (macro)   0x0002   (not used)
LEDDIGITS_F_FLOAT                    N/A         N/A (macro)   0x0008   (not used)
LEDDIGITS_F_FLOATFORMATS             N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_GENERAL                  N/A         N/A (macro)   0x0003   (not used)
LEDDIGITS_F_INT16                    N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_INT32                    N/A         N/A (macro)   0x0004   (not used)
LEDDIGITS_F_LEADING0                 N/A         N/A (macro)   0x0020   (not used)
LEDDIGITS_F_LEADINGb                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_F_SCIENTIFIC               N/A         N/A (macro)   0x0001   (not used)
LEDDIGITS_F_SIGNED                   N/A         N/A (macro)   0x0010   (not used)
LEDDIGITS_F_TYPES                    N/A         N/A (macro)   0x000c   (not used)
LEDDIGITS_F_UNSIGNED                 N/A         N/A (macro)   0x0000   (not used)
LEDDIGITS_flags                       20  0x00000014 (const dword)  (not used)
LEDDIGITS_gap                         12  0x0000000c (const dword)  (not used)
LEDDIGITS_h                            6  0x00000006 (const dword)  (not used)
LEDDIGITS_offcolour                   18  0x00000012 (const dword)  (not used)
LEDDIGITS_oncolour                    16  0x00000010 (const dword)  (not used)
LEDDIGITS_w                            4  0x00000004 (const dword)  (not used)
LEDDIGITS_x                            0  0x00000000 (const dword)  (not used)
LEDDIGITS_y                            2  0x00000002 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIAngularMeter0                      333  0x0000014dLIAngularMeter0                      333  0x0000014d (mem) byte[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter0                   UNRESOLVED  (usage 2)
LIAngularMeter1                      434  0x000001b2LIAngularMeter1                      434  0x000001b2 (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter1                   UNRESOLVED  (usage 2)
LIAngularMeter2                      699  0x000002bbLIAngularMeter2                      699  0x000002bb (mem) byte[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter2                   UNRESOLVED  (usage 2)
LIAngularMeter3                      534  0x00000216LIAngularMeter3                      534  0x00000216 (mem) byte[3] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 1)
LIAngularMeter3                   UNRESOLVED  (usage 2)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                3186  0x00000c72 (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MaxIntObjects                         27  0x0000001b (const dword)  (usage 3)
MaxTotObjects                         67  0x00000043 (const dword)  (usage 6)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_Init4                         -407  0xfffffe69 (const dword)  (not used)
media_InitFlash                     -407  0xfffffe69 (PmmC func) args[1] r=1  (usage 6)
media_InitSpeed                     -381  0xfffffe83 (PmmC func) args[1] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAK                                   21  0x00000015 (const dword)  (usage 3)
nak0                                8029  0x00001f5d (User func) args[0] r=0  (usage 24)
nAniTimers                             0  0x00000000 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NEEDLE_bgcol                          12  0x0000000c (const dword)  (not used)
NEEDLE_ccol                           36  0x00000024 (const dword)  (not used)
NEEDLE_colour                         32  0x00000020 (const dword)  (not used)
NEEDLE_crad                           34  0x00000022 (const dword)  (not used)
NEEDLE_cxx                             8  0x00000008 (const dword)  (not used)
NEEDLE_cyx                            10  0x0000000a (const dword)  (not used)
NEEDLE_extra                          30  0x0000001e (const dword)  (not used)
NEEDLE_F_DOUBLETRIANGLE                4  0x00000004 (const dword)  (not used)
NEEDLE_F_LINE                          0  0x00000000 (const dword)  (not used)
NEEDLE_F_POINTRECTANGLE                2  0x00000002 (const dword)  (not used)
NEEDLE_F_RECTANGLE                     1  0x00000001 (const dword)  (not used)
NEEDLE_F_ROUNDEDRECTANGLE              5  0x00000005 (const dword)  (not used)
NEEDLE_F_TRIANGLE                      3  0x00000003 (const dword)  (not used)
NEEDLE_h                               6  0x00000006 (const dword)  (not used)
NEEDLE_icol                           40  0x00000028 (const dword)  (not used)
NEEDLE_irad                           38  0x00000026 (const dword)  (not used)
NEEDLE_len                            22  0x00000016 (const dword)  (not used)
NEEDLE_maxa                           16  0x00000010 (const dword)  (not used)
NEEDLE_maxv                           20  0x00000014 (const dword)  (not used)
NEEDLE_mina                           14  0x0000000e (const dword)  (not used)
NEEDLE_minv                           18  0x00000012 (const dword)  (not used)
NEEDLE_offs                           26  0x0000001a (const dword)  (not used)
NEEDLE_rad                            28  0x0000001c (const dword)  (not used)
NEEDLE_style                          24  0x00000018 (const dword)  (not used)
NEEDLE_w                               4  0x00000004 (const dword)  (not used)
NEEDLE_x                               0  0x00000000 (const dword)  (not used)
NEEDLE_y                               2  0x00000002 (const dword)  (not used)
nInputs                               36  0x00000024 (const dword)  (usage 3)
nObjects                              35  0x00000023 (const dword)  (not used)
NORTH                                  0  0x00000000 (const dword)  (not used)
NORTH_MIRRORED                         4  0x00000004 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
nStrings                              37  0x00000025 (const dword)  (usage 3)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
oDipSwitchs                         2839  0x00000b17oDipSwitchs                         2839  0x00000b17 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 171)
OFF                                    0  0x00000000 (const dword)  (usage 6)
oForms                              2855  0x00000b27oForms                              2855  0x00000b27 (mem) word[8] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
Ofs_Digits_Digits                      2  0x00000002 (const dword)  (not used)
Ofs_Digits_LeadingBlanks               8  0x00000008 (const dword)  (not used)
Ofs_Digits_Left                        0  0x00000000 (const dword)  (not used)
Ofs_Digits_MinDigits                   4  0x00000004 (const dword)  (not used)
Ofs_Digits_Widthdigit                  6  0x00000006 (const dword)  (not used)
Ofs_IPD_DOWN                          16  0x00000010 (const dword)  (usage 6)
Ofs_IPD_OBJVIDX                       20  0x00000014 (const dword)  (usage 12)
Ofs_IPD_P1                             2  0x00000002 (const dword)  (usage 18)
Ofs_IPD_P2                             4  0x00000004 (const dword)  (usage 48)
Ofs_IPD_P3                             6  0x00000006 (const dword)  (usage 9)
Ofs_IPD_P4                             8  0x00000008 (const dword)  (usage 3)
Ofs_IPD_P5                            10  0x0000000a (const dword)  (usage 9)
Ofs_IPD_P6                            12  0x0000000c (const dword)  (usage 18)
Ofs_IPD_P7                            14  0x0000000e (const dword)  (not used)
Ofs_IPD_RELEASE                       18  0x00000012 (const dword)  (usage 9)
Ofs_String_Ansi                       22  0x00000016 (const dword)  (usage 3)
Ofs_String_BGColor                    16  0x00000010 (const dword)  (usage 6)
Ofs_String_FGColor                    14  0x0000000e (const dword)  (usage 3)
Ofs_String_FontAttribs                18  0x00000012 (const dword)  (usage 3)
Ofs_String_Form                       24  0x00000018 (const dword)  (usage 3)
Ofs_String_GciFSFontIdx               26  0x0000001a (const dword)  (usage 3)
Ofs_String_Size                        4  0x00000004 (const dword)  (usage 3)
Ofs_String_StartH                      0  0x00000000 (const dword)  (usage 3)
Ofs_String_StartL                      2  0x00000002 (const dword)  (usage 3)
Ofs_String_Transparent                20  0x00000014 (const dword)  (usage 3)
Ofs_String_x1                          6  0x00000006 (const dword)  (usage 12)
Ofs_String_x2                         10  0x0000000a (const dword)  (usage 9)
Ofs_String_y1                          8  0x00000008 (const dword)  (usage 12)
Ofs_String_y2                         12  0x0000000c (const dword)  (usage 9)
oGauges                             2871  0x00000b37oGauges                             2871  0x00000b37 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiAngularMeters                     3015  0x00000bc7oiAngularMeters                     3015  0x00000bc7 (mem) word[5] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiLedDigitss                        3025  0x00000bd1oiLedDigitss                        3025  0x00000bd1 (mem) word[11] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oImages                             2881  0x00000b41oImages                             2881  0x00000b41 (mem) word[12] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviAngularMeter                     181  0x000000b5oiviAngularMeter                     181  0x000000b5 (mem) word[4] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oiviLedDigits                        189  0x000000bdoiviLedDigits                        189  0x000000bd (mem) word[10] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
oldn                                 604  0x0000025c (mem) word (global)  (usage 42)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 6)
oObjects                             466  0x000001d2 (mem) word[68] (global)  (usage 219)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
oStaticTexts                        2985  0x00000ba9oStaticTexts                        2985  0x00000ba9 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
oStringss                           2905  0x00000b59oStringss                           2905  0x00000b59 (mem) word[38] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 4)
oStringss                         UNRESOLVED  (usage 2)
OT_ACTIVATE                          103  0x00000067 (const dword)  (usage 3)
OT_MAGIC                             108  0x0000006c (const dword)  (usage 3)
OT_NEXTFRAME                         104  0x00000068 (const dword)  (usage 3)
OT_NEXTSTRING                        106  0x0000006a (const dword)  (usage 3)
OT_PREVFRAME                         105  0x00000069 (const dword)  (usage 3)
OT_PREVSTRING                        107  0x0000006b (const dword)  (usage 3)
OT_REPORT                            100  0x00000064 (const dword)  (usage 57)
OT_SETANOTHER                        102  0x00000066 (const dword)  (usage 3)
OT_SETCONST                          101  0x00000065 (const dword)  (usage 3)
oUserButtons                        2989  0x00000badoUserButtons                        2989  0x00000bad (mem) word[13] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
oUserleds                           2981  0x00000ba5oUserleds                           2981  0x00000ba5 (mem) word[2] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OutputCS                             862  0x0000035e (mem) word (global)  (usage 9)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (usage 3)
OW_Read                             -299  0xfffffed5 (PmmC func) args[1] r=1  (not used)
OW_Read9                            -300  0xfffffed4 (PmmC func) args[1] r=1  (not used)
OW_Reset                            -298  0xfffffed6 (PmmC func) args[1] r=1  (not used)
OW_Write                            -301  0xfffffed3 (PmmC func) args[2] r=0  (not used)
oWinButtons                         2841  0x00000b19oWinButtons                         2841  0x00000b19 (mem) word[7] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 9)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL2_FILLED                      32768  0x00008000 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (not used)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
pInputIndex                          618  0x0000026a (mem) word (global)  (usage 15)
PIXXI                                  4  0x00000004 (const dword)  (usage 3)
PIXXI44_FUNCTIONS                      0  0x00000000 (const ??? 0)  (not used)
PIXXI_44_CHIP                          5  0x00000005 (const ??? 0)  (not used)
pixxiLCD_39P4CT                        0  0x00000000 (const ??? 0)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
PrintStrings                        8199  0x00002007 (User func) args[3] r=0  (usage 9)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 6)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (not used)
putstrCentred                       -321  0xfffffebf (PmmC func) args[3] r=0  (not used)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_OBJ                               0  0x00000000 (const dword)  (usage 3)
ReadCmd                              128  0x00000080 (const dword)  (not used)
ReadObject                          7729  0x00001e31 (User func) args[2] r=0  (usage 3)
RECT_HEIGHT                            3  0x00000003 (const dword)  (not used)
rect_Intersect                      -307  0xfffffecd (PmmC func) args[2] r=1  (not used)
RECT_LEFT                              0  0x00000000 (const dword)  (not used)
RECT_TOP                               1  0x00000001 (const dword)  (not used)
RECT_WIDTH                             2  0x00000002 (const dword)  (not used)
rect_Within                         -308  0xfffffecc (PmmC func) args[2] r=1  (not used)
RED                                63488  0x0000f800 (const dword)  (usage 21)
REPORT_EVENT                           7  0x00000007 (const dword)  (usage 3)
REPORT_MAGIC_EVENT_BYTES              10  0x0000000a (const dword)  (not used)
REPORT_MAGIC_EVENT_DBYTES             11  0x0000000b (const dword)  (not used)
REPORT_OBJ                             5  0x00000005 (const dword)  (usage 3)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
rKeyboardRoutines                   3063  0x00000bf7rKeyboardRoutines                   3063  0x00000bf7 (mem) word[1] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RULERGAUGE_F_ORIENT_VERT               2  0x00000002 (const dword)  (not used)
RULERGAUGE_F_TICKS_BOTTOM              0  0x00000000 (const dword)  (not used)
RULERGAUGE_F_TICKS_TOP                 1  0x00000001 (const dword)  (not used)
RULERGAUGE_HC                         24  0x00000018 (const dword)  (not used)
RULERGAUGE_height                      6  0x00000006 (const dword)  (not used)
RULERGAUGE_IC                         30  0x0000001e (const dword)  (not used)
RULERGAUGE_LC                         22  0x00000016 (const dword)  (not used)
RULERGAUGE_majorTickSize              16  0x00000010 (const dword)  (not used)
RULERGAUGE_MC                         26  0x0000001a (const dword)  (not used)
RULERGAUGE_medium                     18  0x00000012 (const dword)  (not used)
RULERGAUGE_minorTicks                 12  0x0000000c (const dword)  (not used)
RULERGAUGE_minorTickSize              14  0x0000000e (const dword)  (not used)
RULERGAUGE_options                    32  0x00000020 (const dword)  (not used)
RULERGAUGE_range                       8  0x00000008 (const dword)  (not used)
RULERGAUGE_TC                         28  0x0000001c (const dword)  (not used)
RULERGAUGE_threshold                  20  0x00000014 (const dword)  (not used)
RULERGAUGE_ticks                      10  0x0000000a (const dword)  (not used)
RULERGAUGE_width                       4  0x00000004 (const dword)  (not used)
RULERGAUGE_XP                          0  0x00000000 (const dword)  (not used)
RULERGAUGE_YP                          2  0x00000002 (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCALE_BC                              20  0x00000014 (const dword)  (not used)
SCALE_BR                             N/A         N/A (macro)    0x0002   (not used)
SCALE_CenterGap                       26  0x0000001a (const dword)  (not used)
SCALE_CENTRE                         N/A         N/A (macro)    0x0003   (not used)
SCALE_END_ALIGN                      N/A         N/A (macro)    0x0020   (not used)
SCALE_FONT                            24  0x00000018 (const dword)  (not used)
SCALE_HIDE_ZERO                      N/A         N/A (macro)    0x0000   (not used)
SCALE_HORZ                           N/A         N/A (macro)    0x0000   (not used)
SCALE_length                           4  0x00000004 (const dword)  (not used)
SCALE_max                              8  0x00000008 (const dword)  (not used)
SCALE_min                              6  0x00000006 (const dword)  (not used)
SCALE_NO_END_ALIGN                   N/A         N/A (macro)    0x0000   (not used)
SCALE_NONE                           N/A         N/A (macro)    0x0000   (not used)
SCALE_SHOW_ZERO                      N/A         N/A (macro)    0x0040   (not used)
SCALE_TC                              18  0x00000012 (const dword)  (not used)
SCALE_ticklength                      12  0x0000000c (const dword)  (not used)
SCALE_ticklengthMinor                 16  0x00000010 (const dword)  (not used)
SCALE_ticks                           10  0x0000000a (const dword)  (not used)
SCALE_TICKS_BOTH                     N/A         N/A (macro)    0x000c   (not used)
SCALE_TICKS_BR                       N/A         N/A (macro)    0x0008   (not used)
SCALE_TICKS_NONE                     N/A         N/A (macro)    0x0000   (not used)
SCALE_TICKS_TL                       N/A         N/A (macro)    0x0004   (not used)
SCALE_ticksMinor                      14  0x0000000e (const dword)  (not used)
SCALE_TL                             N/A         N/A (macro)    0x0001   (not used)
SCALE_type                            28  0x0000001c (const dword)  (not used)
SCALE_VERT                           N/A         N/A (macro)    0x0010   (not used)
SCALE_XC                              22  0x00000016 (const dword)  (not used)
SCALE_XP                               0  0x00000000 (const dword)  (not used)
SCALE_YP                               2  0x00000002 (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
SendReport                          7962  0x00001f1a (User func) args[4] r=0  (usage 6)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 3)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serinX                               N/A         N/A (macro) serin   (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (usage 21)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
seroutCS                            8045  0x00001f6d (User func) args[1] r=0  (usage 15)
seroutOcs                           8012  0x00001f4c (User func) args[0] r=0  (usage 3)
seroutX                              N/A         N/A (macro) serout   (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (usage 12)
SLIDER5_base_color                    14  0x0000000e (const dword)  (not used)
SLIDER5_F_ORIENT_VERT                N/A         N/A (macro)     0x0001    /* Switch orientation (0 - horizontal, 1 - vertical) */   (not used)
SLIDER5_F_PROGRESSBAR                N/A         N/A (macro)     0x0008    /* Progress Bar mode */   (not used)
SLIDER5_F_TICKS                      N/A         N/A (macro)     0x0002    /* Enable Marker Ticks*/   (not used)
SLIDER5_F_VALUE_IND                  N/A         N/A (macro)     0x0004    /* Enable slider value indicator */   (not used)
SLIDER5_font_c                        38  0x00000026 (const dword)  (not used)
SLIDER5_font_s                        36  0x00000024 (const dword)  (not used)
SLIDER5_knob_f_c_1                    46  0x0000002e (const dword)  (not used)
SLIDER5_knob_f_c_2                    48  0x00000030 (const dword)  (not used)
SLIDER5_knob_f_g                      50  0x00000032 (const dword)  (not used)
SLIDER5_knob_o_c_1                    40  0x00000028 (const dword)  (not used)
SLIDER5_knob_o_c_2                    42  0x0000002a (const dword)  (not used)
SLIDER5_knob_o_g                      44  0x0000002c (const dword)  (not used)
SLIDER5_len                            4  0x00000004 (const dword)  (not used)
SLIDER5_max_val                       12  0x0000000c (const dword)  (not used)
SLIDER5_min_val                       10  0x0000000a (const dword)  (not used)
SLIDER5_num_ticks_L_1                 24  0x00000018 (const dword)  (not used)
SLIDER5_num_ticks_L_2                 26  0x0000001a (const dword)  (not used)
SLIDER5_options                        8  0x00000008 (const dword)  (not used)
SLIDER5_thk                            6  0x00000006 (const dword)  (not used)
SLIDER5_tick_maj_c                    30  0x0000001e (const dword)  (not used)
SLIDER5_tick_maj_l                    28  0x0000001c (const dword)  (not used)
SLIDER5_tick_min_c                    34  0x00000022 (const dword)  (not used)
SLIDER5_tick_min_l                    32  0x00000020 (const dword)  (not used)
SLIDER5_total_tick_B_R                22  0x00000016 (const dword)  (not used)
SLIDER5_total_tick_T_L                20  0x00000014 (const dword)  (not used)
SLIDER5_track_color                   18  0x00000012 (const dword)  (not used)
SLIDER5_track_empty                   16  0x00000010 (const dword)  (not used)
SLIDER5_x_pos                          0  0x00000000 (const dword)  (not used)
SLIDER5_y_pos                          2  0x00000002 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Freq                            -302  0xfffffed2 (PmmC func) args[2] r=1  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_RTTTL                           -309  0xfffffecb (PmmC func) args[1] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
SOUND                                  3  0x00000003 (const dword)  (not used)
SOUTH                                  1  0x00000001 (const dword)  (not used)
SOUTH_MIRRORED                         5  0x00000005 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SPEED0                             0  0x00000000 (const dword)  (not used)
SPI_SPEED1                             1  0x00000001 (const dword)  (not used)
SPI_SPEED10                           10  0x0000000a (const dword)  (not used)
SPI_SPEED11                           11  0x0000000b (const dword)  (not used)
SPI_SPEED12                           12  0x0000000c (const dword)  (not used)
SPI_SPEED13                           13  0x0000000d (const dword)  (not used)
SPI_SPEED14                           14  0x0000000e (const dword)  (not used)
SPI_SPEED15                           15  0x0000000f (const dword)  (not used)
SPI_SPEED2                             2  0x00000002 (const dword)  (not used)
SPI_SPEED3                             3  0x00000003 (const dword)  (not used)
SPI_SPEED4                             4  0x00000004 (const dword)  (not used)
SPI_SPEED5                             5  0x00000005 (const dword)  (not used)
SPI_SPEED6                             6  0x00000006 (const dword)  (not used)
SPI_SPEED7                             7  0x00000007 (const dword)  (not used)
SPI_SPEED8                             8  0x00000008 (const dword)  (not used)
SPI_SPEED9                             9  0x00000009 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
Strings0Count                          1  0x00000001 (const dword)  (not used)
Strings0Size                          22  0x00000016 (const dword)  (usage 3)
Strings0StartH                         0  0x00000000 (const dword)  (usage 3)
Strings0StartL                       512  0x00000200 (const dword)  (usage 3)
Strings10Count                         1  0x00000001 (const dword)  (not used)
Strings10Size                          6  0x00000006 (const dword)  (usage 3)
Strings10StartH                        0  0x00000000 (const dword)  (usage 3)
Strings10StartL                     3072  0x00000c00 (const dword)  (usage 3)
Strings11Count                         1  0x00000001 (const dword)  (not used)
Strings11Size                         15  0x0000000f (const dword)  (usage 3)
Strings11StartH                        0  0x00000000 (const dword)  (usage 3)
Strings11StartL                     3584  0x00000e00 (const dword)  (usage 3)
Strings12Count                         1  0x00000001 (const dword)  (not used)
Strings12Size                         17  0x00000011 (const dword)  (usage 3)
Strings12StartH                        0  0x00000000 (const dword)  (usage 3)
Strings12StartL                     4096  0x00001000 (const dword)  (usage 3)
Strings13Count                         1  0x00000001 (const dword)  (not used)
Strings13Size                          7  0x00000007 (const dword)  (usage 3)
Strings13StartH                        0  0x00000000 (const dword)  (usage 3)
Strings13StartL                     9216  0x00002400 (const dword)  (usage 3)
Strings14Count                         1  0x00000001 (const dword)  (not used)
Strings14Size                         16  0x00000010 (const dword)  (usage 3)
Strings14StartH                        0  0x00000000 (const dword)  (usage 3)
Strings14StartL                     9728  0x00002600 (const dword)  (usage 3)
Strings15Count                         1  0x00000001 (const dword)  (not used)
Strings15Size                         13  0x0000000d (const dword)  (usage 3)
Strings15StartH                        0  0x00000000 (const dword)  (usage 3)
Strings15StartL                     4608  0x00001200 (const dword)  (usage 3)
Strings16Count                         1  0x00000001 (const dword)  (not used)
Strings16Size                         13  0x0000000d (const dword)  (usage 3)
Strings16StartH                        0  0x00000000 (const dword)  (usage 3)
Strings16StartL                     5120  0x00001400 (const dword)  (usage 3)
Strings17Count                         1  0x00000001 (const dword)  (not used)
Strings17Size                          5  0x00000005 (const dword)  (usage 3)
Strings17StartH                        0  0x00000000 (const dword)  (usage 3)
Strings17StartL                    11264  0x00002c00 (const dword)  (usage 3)
Strings18Count                         1  0x00000001 (const dword)  (not used)
Strings18Size                          5  0x00000005 (const dword)  (usage 3)
Strings18StartH                        0  0x00000000 (const dword)  (usage 3)
Strings18StartL                     5632  0x00001600 (const dword)  (usage 3)
Strings19Count                         1  0x00000001 (const dword)  (not used)
Strings19Size                          5  0x00000005 (const dword)  (usage 3)
Strings19StartH                        0  0x00000000 (const dword)  (usage 3)
Strings19StartL                     6144  0x00001800 (const dword)  (usage 3)
Strings1Count                          1  0x00000001 (const dword)  (not used)
Strings1Size                          12  0x0000000c (const dword)  (usage 3)
Strings1StartH                         0  0x00000000 (const dword)  (usage 3)
Strings1StartL                     15872  0x00003e00 (const dword)  (usage 3)
Strings20Count                         1  0x00000001 (const dword)  (not used)
Strings20Size                          5  0x00000005 (const dword)  (usage 3)
Strings20StartH                        0  0x00000000 (const dword)  (usage 3)
Strings20StartL                     6656  0x00001a00 (const dword)  (usage 3)
Strings21Count                         1  0x00000001 (const dword)  (not used)
Strings21Size                          7  0x00000007 (const dword)  (usage 3)
Strings21StartH                        0  0x00000000 (const dword)  (usage 3)
Strings21StartL                     7168  0x00001c00 (const dword)  (usage 3)
Strings22Count                         1  0x00000001 (const dword)  (not used)
Strings22Size                         13  0x0000000d (const dword)  (usage 3)
Strings22StartH                        0  0x00000000 (const dword)  (usage 3)
Strings22StartL                     7680  0x00001e00 (const dword)  (usage 3)
Strings23Count                         1  0x00000001 (const dword)  (not used)
Strings23Size                          7  0x00000007 (const dword)  (usage 3)
Strings23StartH                        0  0x00000000 (const dword)  (usage 3)
Strings23StartL                     8192  0x00002000 (const dword)  (usage 3)
Strings24Count                         1  0x00000001 (const dword)  (not used)
Strings24Size                         12  0x0000000c (const dword)  (usage 3)
Strings24StartH                        0  0x00000000 (const dword)  (usage 3)
Strings24StartL                     8704  0x00002200 (const dword)  (usage 3)
Strings25Count                         1  0x00000001 (const dword)  (not used)
Strings25Size                          7  0x00000007 (const dword)  (usage 3)
Strings25StartH                        0  0x00000000 (const dword)  (usage 3)
Strings25StartL                    10240  0x00002800 (const dword)  (usage 3)
Strings26Count                         1  0x00000001 (const dword)  (not used)
Strings26Size                         17  0x00000011 (const dword)  (usage 3)
Strings26StartH                        0  0x00000000 (const dword)  (usage 3)
Strings26StartL                    10752  0x00002a00 (const dword)  (usage 3)
Strings27Count                         1  0x00000001 (const dword)  (not used)
Strings27Size                          3  0x00000003 (const dword)  (usage 3)
Strings27StartH                        0  0x00000000 (const dword)  (usage 3)
Strings27StartL                    12800  0x00003200 (const dword)  (usage 3)
Strings28Count                         1  0x00000001 (const dword)  (not used)
Strings28Size                         10  0x0000000a (const dword)  (usage 3)
Strings28StartH                        0  0x00000000 (const dword)  (usage 3)
Strings28StartL                    13312  0x00003400 (const dword)  (usage 3)
Strings29Count                         1  0x00000001 (const dword)  (not used)
Strings29Size                          5  0x00000005 (const dword)  (usage 3)
Strings29StartH                        0  0x00000000 (const dword)  (usage 3)
Strings29StartL                    14336  0x00003800 (const dword)  (usage 3)
Strings2Count                          1  0x00000001 (const dword)  (not used)
Strings2Size                          17  0x00000011 (const dword)  (usage 3)
Strings2StartH                         0  0x00000000 (const dword)  (usage 3)
Strings2StartL                         0  0x00000000 (const dword)  (usage 3)
Strings30Count                         1  0x00000001 (const dword)  (not used)
Strings30Size                          5  0x00000005 (const dword)  (usage 3)
Strings30StartH                        0  0x00000000 (const dword)  (usage 3)
Strings30StartL                    14848  0x00003a00 (const dword)  (usage 3)
Strings31Count                         1  0x00000001 (const dword)  (not used)
Strings31Size                         13  0x0000000d (const dword)  (usage 3)
Strings31StartH                        0  0x00000000 (const dword)  (usage 3)
Strings31StartL                    15360  0x00003c00 (const dword)  (usage 3)
Strings32Count                         1  0x00000001 (const dword)  (not used)
Strings32Size                          7  0x00000007 (const dword)  (usage 3)
Strings32StartH                        0  0x00000000 (const dword)  (usage 3)
Strings32StartL                    16384  0x00004000 (const dword)  (usage 3)
Strings33Count                         1  0x00000001 (const dword)  (not used)
Strings33Size                         13  0x0000000d (const dword)  (usage 3)
Strings33StartH                        0  0x00000000 (const dword)  (usage 3)
Strings33StartL                    16896  0x00004200 (const dword)  (usage 3)
Strings34Count                         0  0x00000000 (const dword)  (not used)
Strings34Size                          1  0x00000001 (const dword)  (usage 3)
Strings34StartH                        0  0x00000000 (const dword)  (usage 3)
Strings34StartL                    17408  0x00004400 (const dword)  (usage 3)
Strings35Count                         1  0x00000001 (const dword)  (not used)
Strings35Size                         17  0x00000011 (const dword)  (usage 3)
Strings35StartH                        0  0x00000000 (const dword)  (usage 3)
Strings35StartL                    17920  0x00004600 (const dword)  (usage 3)
Strings36Count                         0  0x00000000 (const dword)  (not used)
Strings36Size                          1  0x00000001 (const dword)  (usage 3)
Strings36StartH                        0  0x00000000 (const dword)  (usage 3)
Strings36StartL                    18432  0x00004800 (const dword)  (usage 3)
Strings3Count                          1  0x00000001 (const dword)  (not used)
Strings3Size                           5  0x00000005 (const dword)  (usage 3)
Strings3StartH                         0  0x00000000 (const dword)  (usage 3)
Strings3StartL                     11776  0x00002e00 (const dword)  (usage 3)
Strings4Count                          1  0x00000001 (const dword)  (not used)
Strings4Size                           6  0x00000006 (const dword)  (usage 3)
Strings4StartH                         0  0x00000000 (const dword)  (usage 3)
Strings4StartL                      1024  0x00000400 (const dword)  (usage 3)
Strings5Count                          1  0x00000001 (const dword)  (not used)
Strings5Size                           6  0x00000006 (const dword)  (usage 3)
Strings5StartH                         0  0x00000000 (const dword)  (usage 3)
Strings5StartL                      1536  0x00000600 (const dword)  (usage 3)
Strings6Count                          1  0x00000001 (const dword)  (not used)
Strings6Size                          12  0x0000000c (const dword)  (usage 3)
Strings6StartH                         0  0x00000000 (const dword)  (usage 3)
Strings6StartL                     12288  0x00003000 (const dword)  (usage 3)
Strings7Count                          1  0x00000001 (const dword)  (not used)
Strings7Size                          14  0x0000000e (const dword)  (usage 3)
Strings7StartH                         0  0x00000000 (const dword)  (usage 3)
Strings7StartL                      2048  0x00000800 (const dword)  (usage 3)
Strings8Count                          1  0x00000001 (const dword)  (not used)
Strings8Size                          13  0x0000000d (const dword)  (usage 3)
Strings8StartH                         0  0x00000000 (const dword)  (usage 3)
Strings8StartL                     13824  0x00003600 (const dword)  (usage 3)
Strings9Count                          1  0x00000001 (const dword)  (not used)
Strings9Size                           7  0x00000007 (const dword)  (usage 3)
Strings9StartH                         0  0x00000000 (const dword)  (usage 3)
Strings9StartL                      2560  0x00000a00 (const dword)  (usage 3)
stringsCV                            322  0x00000142 (mem) word[37] (global)  (usage 27)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
SWITCH1_cOff                          20  0x00000014 (const dword)  (not used)
SWITCH1_cOn                           18  0x00000012 (const dword)  (not used)
SWITCH1_dshd                          12  0x0000000c (const dword)  (not used)
SWITCH1_F_ORIENT_VERT                N/A         N/A (macro)   0x0001  /* switch orientation (0: Horizontal, 1: Vertical) */   (not used)
SWITCH1_fcOff                         32  0x00000020 (const dword)  (not used)
SWITCH1_fcOn                          30  0x0000001e (const dword)  (not used)
SWITCH1_flg                            8  0x00000008 (const dword)  (not used)
SWITCH1_fnt                           26  0x0000001a (const dword)  (not used)
SWITCH1_fsz                           28  0x0000001c (const dword)  (not used)
SWITCH1_len                            4  0x00000004 (const dword)  (not used)
SWITCH1_lshd                          10  0x0000000a (const dword)  (not used)
SWITCH1_oBz                           14  0x0000000e (const dword)  (not used)
SWITCH1_tBz                           16  0x00000010 (const dword)  (not used)
SWITCH1_thk                            6  0x00000006 (const dword)  (not used)
SWITCH1_tOff                          24  0x00000018 (const dword)  (not used)
SWITCH1_tOn                           22  0x00000016 (const dword)  (not used)
SWITCH1_x                              0  0x00000000 (const dword)  (not used)
SWITCH1_y                              2  0x00000002 (const dword)  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_Driver                          -297  0xfffffed7 (PmmC func) args[0] r=0  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_PmmC                            -296  0xfffffed8 (PmmC func) args[0] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
t4Dbutton                             30  0x0000001e (const dword)  (usage 18)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
tAngularmeter                          7  0x00000007 (const dword)  (usage 3)
tAniButton                            31  0x0000001f (const dword)  (usage 6)
tColorPicker                          32  0x00000020 (const dword)  (usage 3)
tCoolgauge                             8  0x00000008 (const dword)  (usage 3)
tCustomdigits                          9  0x00000009 (const dword)  (usage 3)
tDipSwitch                             0  0x00000000 (const dword)  (usage 3)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
tForm                                 10  0x0000000a (const dword)  (usage 15)
tGauge                                11  0x0000000b (const dword)  (usage 3)
tGSlider                               4  0x00000004 (const dword)  (usage 3)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
tiAngularMeter                        39  0x00000027 (const dword)  (usage 21)
tiButtonD                             51  0x00000033 (const dword)  (usage 3)
tiButtonE                             52  0x00000034 (const dword)  (usage 3)
tiDial                                55  0x00000037 (const dword)  (usage 3)
tiGauge                               40  0x00000028 (const dword)  (usage 3)
tiLabelB                              41  0x00000029 (const dword)  (usage 6)
tiLed                                 45  0x0000002d (const dword)  (usage 3)
tiLedDigit                            50  0x00000032 (const dword)  (usage 9)
tiLedDigits                           47  0x0000002f (const dword)  (usage 6)
tiLedDigitsH                          38  0x00000026 (const dword)  (usage 12)
tiLinearInput                         67  0x00000043 (const dword)  (usage 9)
tImage                                12  0x0000000c (const dword)  (usage 3)
tiMediaButton                         53  0x00000035 (const dword)  (usage 3)
tiMediaGauge                          43  0x0000002b (const dword)  (usage 3)
tiMediaLed                            46  0x0000002e (const dword)  (usage 3)
tiMediaRotary                         56  0x00000038 (const dword)  (usage 3)
tiMediaSlider                         61  0x0000003d (const dword)  (usage 3)
tiMediaThermometer                    44  0x0000002c (const dword)  (usage 3)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
tiNeedle                              48  0x00000030 (const dword)  (usage 3)
tiRotaryInput                         57  0x00000039 (const dword)  (usage 6)
tiRuler                               49  0x00000031 (const dword)  (usage 3)
tiSliderC                             66  0x00000042 (const dword)  (usage 3)
tiSliderD                             65  0x00000041 (const dword)  (usage 3)
tiSliderE                             60  0x0000003c (const dword)  (usage 3)
tiSliderF                             64  0x00000040 (const dword)  (usage 3)
tiSliderG                             63  0x0000003f (const dword)  (usage 3)
tiSliderH                             62  0x0000003e (const dword)  (usage 3)
tiSwitch                              58  0x0000003a (const dword)  (usage 3)
tiSwitchB                             59  0x0000003b (const dword)  (usage 6)
tiToggleInput                         54  0x00000036 (const dword)  (usage 6)
tiUserGauge                           42  0x0000002a (const dword)  (usage 3)
tKeyboard                             13  0x0000000d (const dword)  (usage 3)
tKnob                                  1  0x00000001 (const dword)  (usage 6)
tLed                                  14  0x0000000e (const dword)  (usage 3)
tLeddigits                            15  0x0000000f (const dword)  (usage 3)
tMagicObject                          34  0x00000022 (const dword)  (usage 6)
tMeter                                16  0x00000010 (const dword)  (usage 3)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 9)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 3)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 3)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 9)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 18)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
TouchState                           614  0x00000266 (mem) word (global)  (usage 24)
TouchXpos                            608  0x00000260 (mem) word (global)  (usage 12)
TouchYpos                            610  0x00000262 (mem) word (global)  (usage 9)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
tPinInput                             29  0x0000001d (const dword)  (usage 6)
tPinOutput                            28  0x0000001c (const dword)  (usage 6)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
tRockerSwitch                          2  0x00000002 (const dword)  (usage 3)
tRotarySwitch                          3  0x00000003 (const dword)  (usage 3)
tScope                                25  0x00000019 (const dword)  (not used)
tSmartGauge                           35  0x00000023 (const dword)  (usage 6)
tSmartKnob                            37  0x00000025 (const dword)  (usage 6)
tSmartSlider                          36  0x00000024 (const dword)  (usage 6)
tSounds                               22  0x00000016 (const dword)  (usage 6)
tSpectrum                             24  0x00000018 (const dword)  (usage 3)
tStaticText                           21  0x00000015 (const dword)  (usage 3)
tStrings                              17  0x00000011 (const dword)  (usage 18)
tTank                                 26  0x0000001a (const dword)  (usage 3)
tThermometer                          18  0x00000012 (const dword)  (usage 3)
tTimer                                23  0x00000017 (const dword)  (usage 6)
tTrackbar                              5  0x00000005 (const dword)  (usage 6)
TurnOffButtons                      6745  0x00001a59 (User func) args[1] r=0  (usage 6)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
tUserButton                           33  0x00000021 (const dword)  (usage 54)
tUserImages                           27  0x0000001b (const dword)  (usage 3)
tUserled                              19  0x00000013 (const dword)  (usage 3)
tVideo                                20  0x00000014 (const dword)  (usage 3)
tWinButton                             6  0x00000006 (const dword)  (usage 39)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (usage 3)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (usage 3)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (usage 3)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 3)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (usage 3)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (usage 3)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
udiv_3232                           -345  0xfffffea7 (PmmC func) args[3] r=1  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 3)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
UpdateObjects                       5446  0x00001546 (User func) args[1] r=0  (usage 3)
USD_ENABLE                            25  0x00000019 (const dword)  (not used)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
vIAngularMeter0                        2  0x00000002 (mem) word[10] (global)  (usage 3)
vIAngularMeter1                       22  0x00000016 (mem) word[10] (global)  (usage 3)
vIAngularMeter2                      134  0x00000086 (mem) word[10] (global)  (usage 3)
vIAngularMeter3                       42  0x0000002a (mem) word[10] (global)  (usage 3)
vILedDigits0                         298  0x0000012a (mem) word[12] (global)  (usage 3)
vILedDigits1                          62  0x0000003e (mem) word[12] (global)  (usage 3)
vILedDigits2                          86  0x00000056 (mem) word[12] (global)  (usage 3)
vILedDigits3                         110  0x0000006e (mem) word[12] (global)  (usage 3)
vILedDigits4                         154  0x0000009a (mem) word[12] (global)  (usage 3)
vILedDigits5                         250  0x000000fa (mem) word[12] (global)  (usage 3)
vILedDigits6                         178  0x000000b2 (mem) word[12] (global)  (usage 3)
vILedDigits7                         202  0x000000ca (mem) word[12] (global)  (usage 3)
vILedDigits8                         226  0x000000e2 (mem) word[12] (global)  (usage 3)
vILedDigits9                         274  0x00000112 (mem) word[12] (global)  (usage 3)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
vObjects                             398  0x0000018e (mem) word[28] (global)  (usage 15)
WEST                                   2  0x00000002 (const dword)  (not used)
WEST_MIRRORED                          6  0x00000006 (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (usage 81)
WHITE                              65535  0x0000ffff (const dword)  (usage 72)
WHITESMOKE                         63422  0x0000f7be (const dword)  (usage 18)
widget_Add                          -323  0xfffffebd (PmmC func) args[3] r=1  (usage 3)
widget_ClearAttributes              -334  0xfffffeb2 (PmmC func) args[3] r=1  (usage 3)
widget_Create                       -322  0xfffffebe (PmmC func) args[1] r=1  (usage 3)
WIDGET_DECIMALS                       11  0x0000000b (const dword)  (not used)
WIDGET_DELAY                          10  0x0000000a (const dword)  (not used)
widget_Delete                       -324  0xfffffebc (PmmC func) args[2] r=1  (not used)
widget_Disable                      -331  0xfffffeb5 (PmmC func) args[2] r=1  (usage 3)
widget_Enable                       -330  0xfffffeb6 (PmmC func) args[2] r=1  (usage 3)
WIDGET_F_DISABLED                   2048  0x00000800 (const dword)  (not used)
WIDGET_F_FLASH                      1024  0x00000400 (const dword)  (not used)
WIDGET_F_INITIALISED                8192  0x00002000 (const dword)  (usage 3)
WIDGET_F_INTERNAL                  16384  0x00004000 (const dword)  (not used)
WIDGET_F_RESERVED                    960  0x000003c0 (const dword)  (not used)
WIDGET_F_TOUCH_ENABLE              32768  0x00008000 (const dword)  (usage 3)
WIDGET_F_UNDRAW_ONLY                4096  0x00001000 (const dword)  (not used)
WIDGET_FLAGS                           6  0x00000006 (const dword)  (not used)
widget_FontID                       -336  0xfffffeb0 (PmmC func) args[1] r=1  (not used)
WIDGET_FRAMES                         11  0x0000000b (const dword)  (not used)
widget_GetWord                      -328  0xfffffeb8 (PmmC func) args[3] r=1  (not used)
WIDGET_HEIGHT                          3  0x00000003 (const dword)  (not used)
WIDGET_HI_WORD                         5  0x00000005 (const dword)  (not used)
WIDGET_LO_WORD                         4  0x00000004 (const dword)  (not used)
widget_LoadFlash                    -326  0xfffffeba (PmmC func) args[1] r=1  (not used)
WIDGET_RAM_SPACE                      10  0x0000000a (const dword)  (usage 42)
widget_Realloc                      -327  0xfffffeb9 (PmmC func) args[2] r=1  (not used)
widget_SetAttributes                -333  0xfffffeb3 (PmmC func) args[3] r=1  (usage 3)
widget_Setposition                  -329  0xfffffeb7 (PmmC func) args[4] r=1  (not used)
widget_SetWord                      -332  0xfffffeb4 (PmmC func) args[4] r=1  (not used)
widget_Show                         -325  0xfffffebb (PmmC func) args[2] r=1  (not used)
WIDGET_TAG                             7  0x00000007 (const dword)  (not used)
WIDGET_TAG2                            8  0x00000008 (const dword)  (not used)
widget_Touched                      -335  0xfffffeb1 (PmmC func) args[2] r=1  (usage 3)
WIDGET_VAL1                            9  0x00000009 (const dword)  (usage 9)
WIDGET_VAL2                           10  0x0000000a (const dword)  (not used)
WIDGET_WIDTH                           2  0x00000002 (const dword)  (not used)
WIDGET_XOTHER                          4  0x00000004 (const dword)  (not used)
WIDGET_XPOS                            0  0x00000000 (const dword)  (not used)
WIDGET_YOTHER                          5  0x00000005 (const dword)  (not used)
WIDGET_YPOS                            1  0x00000001 (const dword)  (not used)
wp                                   864  0x00000360 (mem) word (global)  (usage 21)
WRITE_CONTRAST                         4  0x00000004 (const dword)  (usage 3)
WRITE_LABEL                           12  0x0000000c (const dword)  (usage 6)
WRITE_MAGIC_BYTES                      8  0x00000008 (const dword)  (not used)
WRITE_MAGIC_DBYTES                     9  0x00000009 (const dword)  (not used)
WRITE_OBJ                              1  0x00000001 (const dword)  (usage 3)
WRITE_STR                              2  0x00000002 (const dword)  (usage 6)
WRITE_STRU                             3  0x00000003 (const dword)  (usage 6)
WriteCmd                               0  0x00000000 (const dword)  (not used)
WriteObject                         7008  0x00001b60 (User func) args[3] r=0  (usage 27)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
xobj2iobj                            209  0x000000d1xobj2iobj                            209  0x000000d1 (mem) word[14] (member of C:\Users\mawilkie\Documents\GitHub\HomeAutomation\Sprinter\Genie4D\SprinterGauge.4DWork\SprinterGauge.4DGenieS)  (usage 3)
XYLIN_X                                1  0x00000001 (const dword)  (not used)
XYLIN_Y                                0  0x00000000 (const dword)  (not used)
XYROT_EAST                             0  0x00000000 (const dword)  (not used)
XYROT_SOUTH                            1  0x00000001 (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
